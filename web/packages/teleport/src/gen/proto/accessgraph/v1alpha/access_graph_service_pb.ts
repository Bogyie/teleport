//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file accessgraph/v1alpha/access_graph_service.proto (package accessgraph.v1alpha, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Edge, Node } from "./graph_pb";
import { AccessListsMembers, ExcludeAccessListsMembers, ResourceHeaderList, ResourceList } from "./resources_pb";
import { AccessPathChanged } from "./events_pb";
import { AWSResourceList } from "./aws_pb";
import { GitlabResourceList, GitlabSyncOperation } from "./gitlab_pb";
import { EntraResourceList, EntraSyncOperation } from "./entra_pb";

/**
 * QueryRequest is a request to query the access graph.
 *
 * @generated from message accessgraph.v1alpha.QueryRequest
 */
export class QueryRequest extends Message<QueryRequest> {
  /**
   * query is a SQL query.
   *
   * @generated from field: string query = 1;
   */
  query = "";

  constructor(data?: PartialMessage<QueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.QueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRequest {
    return new QueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRequest | PlainMessage<QueryRequest> | undefined, b: QueryRequest | PlainMessage<QueryRequest> | undefined): boolean {
    return proto3.util.equals(QueryRequest, a, b);
  }
}

/**
 * QueryResponse is a response to a query.
 *
 * @generated from message accessgraph.v1alpha.QueryResponse
 */
export class QueryResponse extends Message<QueryResponse> {
  /**
   * nodes is a list of nodes returned by the query. The response may contain only nodes.
   *
   * @generated from field: repeated accessgraph.v1alpha.Node nodes = 1;
   */
  nodes: Node[] = [];

  /**
   * edges is a list of edges returned by the query.
   *
   * @generated from field: repeated accessgraph.v1alpha.Edge edges = 2;
   */
  edges: Edge[] = [];

  constructor(data?: PartialMessage<QueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.QueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 2, name: "edges", kind: "message", T: Edge, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse {
    return new QueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean {
    return proto3.util.equals(QueryResponse, a, b);
  }
}

/**
 * GetFileRequest is a request to get a file.
 *
 * @generated from message accessgraph.v1alpha.GetFileRequest
 */
export class GetFileRequest extends Message<GetFileRequest> {
  /**
   * filepath is a path to the file.
   *
   * @generated from field: string filepath = 1;
   */
  filepath = "";

  constructor(data?: PartialMessage<GetFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.GetFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filepath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFileRequest {
    return new GetFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFileRequest {
    return new GetFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFileRequest {
    return new GetFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetFileRequest | PlainMessage<GetFileRequest> | undefined, b: GetFileRequest | PlainMessage<GetFileRequest> | undefined): boolean {
    return proto3.util.equals(GetFileRequest, a, b);
  }
}

/**
 * GetFileResponse is a response to a file request.
 *
 * @generated from message accessgraph.v1alpha.GetFileResponse
 */
export class GetFileResponse extends Message<GetFileResponse> {
  /**
   * data is a raw file content.
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<GetFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.GetFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFileResponse {
    return new GetFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFileResponse {
    return new GetFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFileResponse {
    return new GetFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetFileResponse | PlainMessage<GetFileResponse> | undefined, b: GetFileResponse | PlainMessage<GetFileResponse> | undefined): boolean {
    return proto3.util.equals(GetFileResponse, a, b);
  }
}

/**
 * EventsStreamRequest is a request to send commands to the access graph.
 * This command is used to sync the access graph with the Teleport database state.
 *
 * @generated from message accessgraph.v1alpha.EventsStreamRequest
 */
export class EventsStreamRequest extends Message<EventsStreamRequest> {
  /**
   * operation contains the desired operation
   *
   * @generated from oneof accessgraph.v1alpha.EventsStreamRequest.operation
   */
  operation: {
    /**
     * sync is a command to sync the access graph with the Teleport database state.
     * it's issued once Teleport finishes syncing all resources with the database.
     *
     * @generated from field: accessgraph.v1alpha.SyncOperation sync = 1;
     */
    value: SyncOperation;
    case: "sync";
  } | {
    /**
     * upsert is a command to put a resource into the access graph or update it.
     *
     * @generated from field: accessgraph.v1alpha.ResourceList upsert = 2;
     */
    value: ResourceList;
    case: "upsert";
  } | {
    /**
     * delete is a command to delete a resource from the access graph when it's deleted from Teleport.
     *
     * @generated from field: accessgraph.v1alpha.ResourceHeaderList delete = 3;
     */
    value: ResourceHeaderList;
    case: "delete";
  } | {
    /**
     * access_lists_members is a command to upsert access lists members.
     * It's issued when a user is added to an access list or when their membership is updated.
     * It's also issued when a user membership expires but the user remains in the access list.
     * In that case, the state of the user reflects the expiration reason.
     *
     * @generated from field: accessgraph.v1alpha.AccessListsMembers access_lists_members = 4;
     */
    value: AccessListsMembers;
    case: "accessListsMembers";
  } | {
    /**
     * exclude_access_list_members is a command to exclude access lists members
     * when they are manually removed from the access list.
     * If their membership remains but it's expired, they are not excluded
     * from the access list but they don't receive any access - in that case,
     * the request is [access_lists_members].
     *
     * @generated from field: accessgraph.v1alpha.ExcludeAccessListsMembers exclude_access_list_members = 5;
     */
    value: ExcludeAccessListsMembers;
    case: "excludeAccessListMembers";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EventsStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EventsStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: SyncOperation, oneof: "operation" },
    { no: 2, name: "upsert", kind: "message", T: ResourceList, oneof: "operation" },
    { no: 3, name: "delete", kind: "message", T: ResourceHeaderList, oneof: "operation" },
    { no: 4, name: "access_lists_members", kind: "message", T: AccessListsMembers, oneof: "operation" },
    { no: 5, name: "exclude_access_list_members", kind: "message", T: ExcludeAccessListsMembers, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventsStreamRequest {
    return new EventsStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventsStreamRequest {
    return new EventsStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventsStreamRequest {
    return new EventsStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EventsStreamRequest | PlainMessage<EventsStreamRequest> | undefined, b: EventsStreamRequest | PlainMessage<EventsStreamRequest> | undefined): boolean {
    return proto3.util.equals(EventsStreamRequest, a, b);
  }
}

/**
 * EventsStreamV2Request is a request to send commands to the access graph.
 * This command is used to sync the access graph with the Teleport database state.
 *
 * @generated from message accessgraph.v1alpha.EventsStreamV2Request
 */
export class EventsStreamV2Request extends Message<EventsStreamV2Request> {
  /**
   * operation contains the desired operation
   *
   * @generated from oneof accessgraph.v1alpha.EventsStreamV2Request.operation
   */
  operation: {
    /**
     * sync is a command to sync the access graph with the Teleport database state.
     * it's issued once Teleport finishes syncing all resources with the database.
     *
     * @generated from field: accessgraph.v1alpha.SyncOperation sync = 1;
     */
    value: SyncOperation;
    case: "sync";
  } | {
    /**
     * upsert is a command to put a resource into the access graph or update it.
     *
     * @generated from field: accessgraph.v1alpha.ResourceList upsert = 2;
     */
    value: ResourceList;
    case: "upsert";
  } | {
    /**
     * delete is a command to delete a resource from the access graph when it's deleted from Teleport.
     *
     * @generated from field: accessgraph.v1alpha.ResourceHeaderList delete = 3;
     */
    value: ResourceHeaderList;
    case: "delete";
  } | {
    /**
     * access_lists_members is a command to upsert access lists members.
     * It's issued when a user is added to an access list or when their membership is updated.
     * It's also issued when a user membership expires but the user remains in the access list.
     * In that case, the state of the user reflects the expiration reason.
     *
     * @generated from field: accessgraph.v1alpha.AccessListsMembers access_lists_members = 4;
     */
    value: AccessListsMembers;
    case: "accessListsMembers";
  } | {
    /**
     * exclude_access_list_members is a command to exclude access lists members
     * when they are manually removed from the access list.
     * If their membership remains but it's expired, they are not excluded
     * from the access list but they don't receive any access - in that case,
     * the request is [access_lists_members].
     *
     * @generated from field: accessgraph.v1alpha.ExcludeAccessListsMembers exclude_access_list_members = 5;
     */
    value: ExcludeAccessListsMembers;
    case: "excludeAccessListMembers";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EventsStreamV2Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EventsStreamV2Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: SyncOperation, oneof: "operation" },
    { no: 2, name: "upsert", kind: "message", T: ResourceList, oneof: "operation" },
    { no: 3, name: "delete", kind: "message", T: ResourceHeaderList, oneof: "operation" },
    { no: 4, name: "access_lists_members", kind: "message", T: AccessListsMembers, oneof: "operation" },
    { no: 5, name: "exclude_access_list_members", kind: "message", T: ExcludeAccessListsMembers, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventsStreamV2Request {
    return new EventsStreamV2Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventsStreamV2Request {
    return new EventsStreamV2Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventsStreamV2Request {
    return new EventsStreamV2Request().fromJsonString(jsonString, options);
  }

  static equals(a: EventsStreamV2Request | PlainMessage<EventsStreamV2Request> | undefined, b: EventsStreamV2Request | PlainMessage<EventsStreamV2Request> | undefined): boolean {
    return proto3.util.equals(EventsStreamV2Request, a, b);
  }
}

/**
 * SyncOperation is a command that Teleport sends to the access graph service
 * at the end of the sync process.
 *
 * @generated from message accessgraph.v1alpha.SyncOperation
 */
export class SyncOperation extends Message<SyncOperation> {
  constructor(data?: PartialMessage<SyncOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.SyncOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncOperation {
    return new SyncOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncOperation {
    return new SyncOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncOperation {
    return new SyncOperation().fromJsonString(jsonString, options);
  }

  static equals(a: SyncOperation | PlainMessage<SyncOperation> | undefined, b: SyncOperation | PlainMessage<SyncOperation> | undefined): boolean {
    return proto3.util.equals(SyncOperation, a, b);
  }
}

/**
 * EventsStreamResponse is the response from EventsStream.
 *
 * @generated from message accessgraph.v1alpha.EventsStreamResponse
 */
export class EventsStreamResponse extends Message<EventsStreamResponse> {
  constructor(data?: PartialMessage<EventsStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EventsStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventsStreamResponse {
    return new EventsStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventsStreamResponse {
    return new EventsStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventsStreamResponse {
    return new EventsStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EventsStreamResponse | PlainMessage<EventsStreamResponse> | undefined, b: EventsStreamResponse | PlainMessage<EventsStreamResponse> | undefined): boolean {
    return proto3.util.equals(EventsStreamResponse, a, b);
  }
}

/**
 * EventsStreamV2Response is the response from EventsStreamV2.
 *
 * @generated from message accessgraph.v1alpha.EventsStreamV2Response
 */
export class EventsStreamV2Response extends Message<EventsStreamV2Response> {
  /**
   * action is a action that should be performed by Teleport on behalf of the access graph service.
   *
   * @generated from oneof accessgraph.v1alpha.EventsStreamV2Response.action
   */
  action: {
    /**
     * event is a audit event that should be logged by Teleport.
     *
     * @generated from field: accessgraph.v1alpha.AuditEvent event = 1;
     */
    value: AuditEvent;
    case: "event";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EventsStreamV2Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EventsStreamV2Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: AuditEvent, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventsStreamV2Response {
    return new EventsStreamV2Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventsStreamV2Response {
    return new EventsStreamV2Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventsStreamV2Response {
    return new EventsStreamV2Response().fromJsonString(jsonString, options);
  }

  static equals(a: EventsStreamV2Response | PlainMessage<EventsStreamV2Response> | undefined, b: EventsStreamV2Response | PlainMessage<EventsStreamV2Response> | undefined): boolean {
    return proto3.util.equals(EventsStreamV2Response, a, b);
  }
}

/**
 * AuditEvent is an event that should be logged by Teleport.
 *
 * @generated from message accessgraph.v1alpha.AuditEvent
 */
export class AuditEvent extends Message<AuditEvent> {
  /**
   * @generated from oneof accessgraph.v1alpha.AuditEvent.event
   */
  event: {
    /**
     * access_path_changed is an event that should be logged when the access path changes.
     *
     * @generated from field: accessgraph.v1alpha.AccessPathChanged access_path_changed = 1;
     */
    value: AccessPathChanged;
    case: "accessPathChanged";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuditEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.AuditEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_path_changed", kind: "message", T: AccessPathChanged, oneof: "event" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuditEvent {
    return new AuditEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuditEvent {
    return new AuditEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuditEvent {
    return new AuditEvent().fromJsonString(jsonString, options);
  }

  static equals(a: AuditEvent | PlainMessage<AuditEvent> | undefined, b: AuditEvent | PlainMessage<AuditEvent> | undefined): boolean {
    return proto3.util.equals(AuditEvent, a, b);
  }
}

/**
 * RegisterRequest is the request for Register.
 *
 * @generated from message accessgraph.v1alpha.RegisterRequest
 */
export class RegisterRequest extends Message<RegisterRequest> {
  /**
   * @generated from field: bytes host_ca_pem = 1;
   */
  hostCaPem = new Uint8Array(0);

  /**
   * ClusterName is the self-submitted name of the Teleport cluster (usually a FQDN).
   * This may not uniquely identify the cluster, and is only used to make identification easier for debugging purposes.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  constructor(data?: PartialMessage<RegisterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.RegisterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host_ca_pem", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterRequest {
    return new RegisterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterRequest {
    return new RegisterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterRequest {
    return new RegisterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterRequest | PlainMessage<RegisterRequest> | undefined, b: RegisterRequest | PlainMessage<RegisterRequest> | undefined): boolean {
    return proto3.util.equals(RegisterRequest, a, b);
  }
}

/**
 * RegisterResponse is the response for Register.
 *
 * @generated from message accessgraph.v1alpha.RegisterResponse
 */
export class RegisterResponse extends Message<RegisterResponse> {
  constructor(data?: PartialMessage<RegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.RegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterResponse {
    return new RegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterResponse {
    return new RegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterResponse {
    return new RegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterResponse | PlainMessage<RegisterResponse> | undefined, b: RegisterResponse | PlainMessage<RegisterResponse> | undefined): boolean {
    return proto3.util.equals(RegisterResponse, a, b);
  }
}

/**
 * ReplaceCAsRequest is the request for ReplaceCAs.
 *
 * @generated from message accessgraph.v1alpha.ReplaceCAsRequest
 */
export class ReplaceCAsRequest extends Message<ReplaceCAsRequest> {
  /**
   * @generated from field: repeated bytes host_ca_pem = 1;
   */
  hostCaPem: Uint8Array[] = [];

  constructor(data?: PartialMessage<ReplaceCAsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.ReplaceCAsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host_ca_pem", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplaceCAsRequest {
    return new ReplaceCAsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplaceCAsRequest {
    return new ReplaceCAsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplaceCAsRequest {
    return new ReplaceCAsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReplaceCAsRequest | PlainMessage<ReplaceCAsRequest> | undefined, b: ReplaceCAsRequest | PlainMessage<ReplaceCAsRequest> | undefined): boolean {
    return proto3.util.equals(ReplaceCAsRequest, a, b);
  }
}

/**
 * ReplaceCAsResponse is the response for ReplaceCAs.
 *
 * @generated from message accessgraph.v1alpha.ReplaceCAsResponse
 */
export class ReplaceCAsResponse extends Message<ReplaceCAsResponse> {
  constructor(data?: PartialMessage<ReplaceCAsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.ReplaceCAsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplaceCAsResponse {
    return new ReplaceCAsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplaceCAsResponse {
    return new ReplaceCAsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplaceCAsResponse {
    return new ReplaceCAsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReplaceCAsResponse | PlainMessage<ReplaceCAsResponse> | undefined, b: ReplaceCAsResponse | PlainMessage<ReplaceCAsResponse> | undefined): boolean {
    return proto3.util.equals(ReplaceCAsResponse, a, b);
  }
}

/**
 * AWSEventsStreamRequest is a request to send commands to the AWS importer.
 * This command is used to sync the access graph with the AWS database state.
 *
 * @generated from message accessgraph.v1alpha.AWSEventsStreamRequest
 */
export class AWSEventsStreamRequest extends Message<AWSEventsStreamRequest> {
  /**
   * operation contains the desired operation
   *
   * @generated from oneof accessgraph.v1alpha.AWSEventsStreamRequest.operation
   */
  operation: {
    /**
     * sync is a command to sync the access graph with the Teleport database state.
     * it's issued once Teleport finishes syncing all resources with the database.
     *
     * @generated from field: accessgraph.v1alpha.AWSSyncOperation sync = 1;
     */
    value: AWSSyncOperation;
    case: "sync";
  } | {
    /**
     * upsert is a command to put a resource into the access graph or update it.
     *
     * @generated from field: accessgraph.v1alpha.AWSResourceList upsert = 2;
     */
    value: AWSResourceList;
    case: "upsert";
  } | {
    /**
     * delete is a command to delete a resource from the access graph when it's deleted from Teleport.
     *
     * @generated from field: accessgraph.v1alpha.AWSResourceList delete = 3;
     */
    value: AWSResourceList;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AWSEventsStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.AWSEventsStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: AWSSyncOperation, oneof: "operation" },
    { no: 2, name: "upsert", kind: "message", T: AWSResourceList, oneof: "operation" },
    { no: 3, name: "delete", kind: "message", T: AWSResourceList, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSEventsStreamRequest {
    return new AWSEventsStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSEventsStreamRequest {
    return new AWSEventsStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSEventsStreamRequest {
    return new AWSEventsStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AWSEventsStreamRequest | PlainMessage<AWSEventsStreamRequest> | undefined, b: AWSEventsStreamRequest | PlainMessage<AWSEventsStreamRequest> | undefined): boolean {
    return proto3.util.equals(AWSEventsStreamRequest, a, b);
  }
}

/**
 * AWSSyncOperation is a command that Teleport sends to the access graph service
 * at the end of the sync process.
 *
 * @generated from message accessgraph.v1alpha.AWSSyncOperation
 */
export class AWSSyncOperation extends Message<AWSSyncOperation> {
  constructor(data?: PartialMessage<AWSSyncOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.AWSSyncOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSSyncOperation {
    return new AWSSyncOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSSyncOperation {
    return new AWSSyncOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSSyncOperation {
    return new AWSSyncOperation().fromJsonString(jsonString, options);
  }

  static equals(a: AWSSyncOperation | PlainMessage<AWSSyncOperation> | undefined, b: AWSSyncOperation | PlainMessage<AWSSyncOperation> | undefined): boolean {
    return proto3.util.equals(AWSSyncOperation, a, b);
  }
}

/**
 * AWSEventsStreamResponse is the response from AWSEventsStream.
 *
 * @generated from message accessgraph.v1alpha.AWSEventsStreamResponse
 */
export class AWSEventsStreamResponse extends Message<AWSEventsStreamResponse> {
  constructor(data?: PartialMessage<AWSEventsStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.AWSEventsStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSEventsStreamResponse {
    return new AWSEventsStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSEventsStreamResponse {
    return new AWSEventsStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSEventsStreamResponse {
    return new AWSEventsStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AWSEventsStreamResponse | PlainMessage<AWSEventsStreamResponse> | undefined, b: AWSEventsStreamResponse | PlainMessage<AWSEventsStreamResponse> | undefined): boolean {
    return proto3.util.equals(AWSEventsStreamResponse, a, b);
  }
}

/**
 * GitlabEventsStreamRequest is a request to send commands to the Gitlab importer.
 *
 * @generated from message accessgraph.v1alpha.GitlabEventsStreamRequest
 */
export class GitlabEventsStreamRequest extends Message<GitlabEventsStreamRequest> {
  /**
   * operation contains the desired operation
   *
   * @generated from oneof accessgraph.v1alpha.GitlabEventsStreamRequest.operation
   */
  operation: {
    /**
     * sync is a command to sync the access graph with the Teleport database state.
     * it's issued once Teleport finishes syncing all resources with the database.
     *
     * @generated from field: accessgraph.v1alpha.GitlabSyncOperation sync = 1;
     */
    value: GitlabSyncOperation;
    case: "sync";
  } | {
    /**
     * upsert is a command to put a resource into the access graph or update it.
     *
     * @generated from field: accessgraph.v1alpha.GitlabResourceList upsert = 2;
     */
    value: GitlabResourceList;
    case: "upsert";
  } | {
    /**
     * delete is a command to delete a resource from the access graph when it's deleted from Teleport.
     *
     * @generated from field: accessgraph.v1alpha.GitlabResourceList delete = 3;
     */
    value: GitlabResourceList;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GitlabEventsStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.GitlabEventsStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: GitlabSyncOperation, oneof: "operation" },
    { no: 2, name: "upsert", kind: "message", T: GitlabResourceList, oneof: "operation" },
    { no: 3, name: "delete", kind: "message", T: GitlabResourceList, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitlabEventsStreamRequest {
    return new GitlabEventsStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitlabEventsStreamRequest {
    return new GitlabEventsStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitlabEventsStreamRequest {
    return new GitlabEventsStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GitlabEventsStreamRequest | PlainMessage<GitlabEventsStreamRequest> | undefined, b: GitlabEventsStreamRequest | PlainMessage<GitlabEventsStreamRequest> | undefined): boolean {
    return proto3.util.equals(GitlabEventsStreamRequest, a, b);
  }
}

/**
 * GitlabEventsStreamResponse is the response from GitlabEventsStream.
 *
 * @generated from message accessgraph.v1alpha.GitlabEventsStreamResponse
 */
export class GitlabEventsStreamResponse extends Message<GitlabEventsStreamResponse> {
  constructor(data?: PartialMessage<GitlabEventsStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.GitlabEventsStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitlabEventsStreamResponse {
    return new GitlabEventsStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitlabEventsStreamResponse {
    return new GitlabEventsStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitlabEventsStreamResponse {
    return new GitlabEventsStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GitlabEventsStreamResponse | PlainMessage<GitlabEventsStreamResponse> | undefined, b: GitlabEventsStreamResponse | PlainMessage<GitlabEventsStreamResponse> | undefined): boolean {
    return proto3.util.equals(GitlabEventsStreamResponse, a, b);
  }
}

/**
 * EntraEventsStreamRequest is a request to send commands to the Gitlab importer.
 *
 * @generated from message accessgraph.v1alpha.EntraEventsStreamRequest
 */
export class EntraEventsStreamRequest extends Message<EntraEventsStreamRequest> {
  /**
   * operation contains the desired operation
   *
   * @generated from oneof accessgraph.v1alpha.EntraEventsStreamRequest.operation
   */
  operation: {
    /**
     * sync is a command to sync the access graph with the Teleport database state.
     * it's issued once Teleport finishes syncing all resources with the database.
     *
     * @generated from field: accessgraph.v1alpha.EntraSyncOperation sync = 1;
     */
    value: EntraSyncOperation;
    case: "sync";
  } | {
    /**
     * upsert is a command to put a resource into the access graph or update it.
     *
     * @generated from field: accessgraph.v1alpha.EntraResourceList upsert = 2;
     */
    value: EntraResourceList;
    case: "upsert";
  } | {
    /**
     * delete is a command to delete a resource from the access graph when it's deleted from Teleport.
     *
     * @generated from field: accessgraph.v1alpha.EntraResourceList delete = 3;
     */
    value: EntraResourceList;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EntraEventsStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EntraEventsStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync", kind: "message", T: EntraSyncOperation, oneof: "operation" },
    { no: 2, name: "upsert", kind: "message", T: EntraResourceList, oneof: "operation" },
    { no: 3, name: "delete", kind: "message", T: EntraResourceList, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntraEventsStreamRequest {
    return new EntraEventsStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntraEventsStreamRequest {
    return new EntraEventsStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntraEventsStreamRequest {
    return new EntraEventsStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EntraEventsStreamRequest | PlainMessage<EntraEventsStreamRequest> | undefined, b: EntraEventsStreamRequest | PlainMessage<EntraEventsStreamRequest> | undefined): boolean {
    return proto3.util.equals(EntraEventsStreamRequest, a, b);
  }
}

/**
 * EntraEventsStreamResponse is the response from GitlabEventsStream.
 *
 * @generated from message accessgraph.v1alpha.EntraEventsStreamResponse
 */
export class EntraEventsStreamResponse extends Message<EntraEventsStreamResponse> {
  constructor(data?: PartialMessage<EntraEventsStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "accessgraph.v1alpha.EntraEventsStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntraEventsStreamResponse {
    return new EntraEventsStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntraEventsStreamResponse {
    return new EntraEventsStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntraEventsStreamResponse {
    return new EntraEventsStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EntraEventsStreamResponse | PlainMessage<EntraEventsStreamResponse> | undefined, b: EntraEventsStreamResponse | PlainMessage<EntraEventsStreamResponse> | undefined): boolean {
    return proto3.util.equals(EntraEventsStreamResponse, a, b);
  }
}

