// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/discoveryconfig/v1/discoveryconfig.proto (package teleport.discoveryconfig.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { ResourceHeader } from "../../header/v1/resourceheader_pb";
import { AccessGraphSync, AWSMatcher, AzureMatcher, GCPMatcher, KubernetesMatcher } from "../../legacy/types/types_pb";

/**
 * DiscoveryConfigState is the state of the discovery config resource.
 *
 * @generated from enum teleport.discoveryconfig.v1.DiscoveryConfigState
 */
export enum DiscoveryConfigState {
  /**
   * @generated from enum value: DISCOVERY_CONFIG_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * DISCOVERY_CONFIG_STATE_RUNNING is used when the operation doesn't report
   * incidents.
   *
   * @generated from enum value: DISCOVERY_CONFIG_STATE_RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * DISCOVERY_CONFIG_STATE_ERROR is used when the operation reports
   * incidents.
   *
   * @generated from enum value: DISCOVERY_CONFIG_STATE_ERROR = 2;
   */
  ERROR = 2,

  /**
   * DISCOVERY_CONFIG_STATE_SYNCING is used when the discovery process has started but didn't finished yet.
   *
   * @generated from enum value: DISCOVERY_CONFIG_STATE_SYNCING = 3;
   */
  SYNCING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(DiscoveryConfigState)
proto3.util.setEnumType(DiscoveryConfigState, "teleport.discoveryconfig.v1.DiscoveryConfigState", [
  { no: 0, name: "DISCOVERY_CONFIG_STATE_UNSPECIFIED" },
  { no: 1, name: "DISCOVERY_CONFIG_STATE_RUNNING" },
  { no: 2, name: "DISCOVERY_CONFIG_STATE_ERROR" },
  { no: 3, name: "DISCOVERY_CONFIG_STATE_SYNCING" },
]);

/**
 * DiscoveryConfig is a resource that has Discovery Resource Matchers and a Discovery Group.
 *
 * Teleport Discovery Services will load the dynamic DiscoveryConfigs whose Discovery Group matches the discovery_group defined in their configuration.
 *
 * @generated from message teleport.discoveryconfig.v1.DiscoveryConfig
 */
export class DiscoveryConfig extends Message<DiscoveryConfig> {
  /**
   * Header is the resource header.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * Spec is an DiscoveryConfig specification.
   *
   * @generated from field: teleport.discoveryconfig.v1.DiscoveryConfigSpec spec = 2;
   */
  spec?: DiscoveryConfigSpec;

  /**
   * Status is the resource Status
   *
   * @generated from field: teleport.discoveryconfig.v1.DiscoveryConfigStatus status = 3;
   */
  status?: DiscoveryConfigStatus;

  constructor(data?: PartialMessage<DiscoveryConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.discoveryconfig.v1.DiscoveryConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResourceHeader },
    { no: 2, name: "spec", kind: "message", T: DiscoveryConfigSpec },
    { no: 3, name: "status", kind: "message", T: DiscoveryConfigStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfig {
    return new DiscoveryConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfig {
    return new DiscoveryConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfig {
    return new DiscoveryConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfig | PlainMessage<DiscoveryConfig> | undefined, b: DiscoveryConfig | PlainMessage<DiscoveryConfig> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfig, a, b);
  }
}

/**
 * DiscoveryConfigSpec contains properties required to create matchers to be used by discovery_service.
 * Those matchers are used by discovery_service to watch for cloud resources and create them in Teleport.
 *
 * @generated from message teleport.discoveryconfig.v1.DiscoveryConfigSpec
 */
export class DiscoveryConfigSpec extends Message<DiscoveryConfigSpec> {
  /**
   * DiscoveryGroup is used by discovery_service to add extra matchers.
   * All the discovery_services that have the same discovery_group, will load the matchers of this resource.
   *
   * @generated from field: string discovery_group = 1;
   */
  discoveryGroup = "";

  /**
   * AWS is a list of AWS Matchers.
   *
   * @generated from field: repeated types.AWSMatcher aws = 2;
   */
  aws: AWSMatcher[] = [];

  /**
   * Azure is a list of Azure Matchers.
   *
   * @generated from field: repeated types.AzureMatcher azure = 3;
   */
  azure: AzureMatcher[] = [];

  /**
   * GCP is a list of GCP Matchers.
   *
   * @generated from field: repeated types.GCPMatcher gcp = 4;
   */
  gcp: GCPMatcher[] = [];

  /**
   * Kube is a list of Kubernetes Matchers.
   *
   * @generated from field: repeated types.KubernetesMatcher kube = 5;
   */
  kube: KubernetesMatcher[] = [];

  /**
   * AccessGraph is the configurations for syncing Cloud accounts into Access Graph.
   *
   * @generated from field: types.AccessGraphSync access_graph = 6;
   */
  accessGraph?: AccessGraphSync;

  constructor(data?: PartialMessage<DiscoveryConfigSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.discoveryconfig.v1.DiscoveryConfigSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "discovery_group", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aws", kind: "message", T: AWSMatcher, repeated: true },
    { no: 3, name: "azure", kind: "message", T: AzureMatcher, repeated: true },
    { no: 4, name: "gcp", kind: "message", T: GCPMatcher, repeated: true },
    { no: 5, name: "kube", kind: "message", T: KubernetesMatcher, repeated: true },
    { no: 6, name: "access_graph", kind: "message", T: AccessGraphSync },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigSpec {
    return new DiscoveryConfigSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigSpec {
    return new DiscoveryConfigSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigSpec {
    return new DiscoveryConfigSpec().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigSpec | PlainMessage<DiscoveryConfigSpec> | undefined, b: DiscoveryConfigSpec | PlainMessage<DiscoveryConfigSpec> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigSpec, a, b);
  }
}

/**
 * DiscoveryConfigStatus holds dynamic information about the discovery configuration
 * running status such as errors, state and count of the resources.
 *
 * @generated from message teleport.discoveryconfig.v1.DiscoveryConfigStatus
 */
export class DiscoveryConfigStatus extends Message<DiscoveryConfigStatus> {
  /**
   * State reports the Discovery config state.
   *
   * @generated from field: teleport.discoveryconfig.v1.DiscoveryConfigState state = 1;
   */
  state = DiscoveryConfigState.UNSPECIFIED;

  /**
   * error_message holds the error message when state is DISCOVERY_CONFIG_STATE_ERROR.
   *
   * @generated from field: optional string error_message = 2;
   */
  errorMessage?: string;

  /**
   * discovered_resources holds the count of the discovered resources in the previous iteration.
   *
   * @generated from field: uint64 discovered_resources = 3;
   */
  discoveredResources = protoInt64.zero;

  /**
   * last_sync_time is the timestamp when the Discovery Config was last sync.
   *
   * @generated from field: google.protobuf.Timestamp last_sync_time = 4;
   */
  lastSyncTime?: Timestamp;

  /**
   * IntegrationDiscoveredResources maps an integration to discovered resources summary.
   *
   * @generated from field: map<string, teleport.discoveryconfig.v1.IntegrationDiscoveredSummary> integration_discovered_resources = 6;
   */
  integrationDiscoveredResources: { [key: string]: IntegrationDiscoveredSummary } = {};

  constructor(data?: PartialMessage<DiscoveryConfigStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.discoveryconfig.v1.DiscoveryConfigStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(DiscoveryConfigState) },
    { no: 2, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "discovered_resources", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "last_sync_time", kind: "message", T: Timestamp },
    { no: 6, name: "integration_discovered_resources", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: IntegrationDiscoveredSummary} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigStatus {
    return new DiscoveryConfigStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigStatus {
    return new DiscoveryConfigStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigStatus {
    return new DiscoveryConfigStatus().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigStatus | PlainMessage<DiscoveryConfigStatus> | undefined, b: DiscoveryConfigStatus | PlainMessage<DiscoveryConfigStatus> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigStatus, a, b);
  }
}

/**
 * IntegrationDiscoveredSummary contains the a summary for each resource type that was discovered.
 *
 * @generated from message teleport.discoveryconfig.v1.IntegrationDiscoveredSummary
 */
export class IntegrationDiscoveredSummary extends Message<IntegrationDiscoveredSummary> {
  /**
   * AWSEC2 contains the summary for the AWS EC2 discovered instances.
   *
   * @generated from field: teleport.discoveryconfig.v1.ResourcesDiscoveredSummary aws_ec2 = 1;
   */
  awsEc2?: ResourcesDiscoveredSummary;

  constructor(data?: PartialMessage<IntegrationDiscoveredSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.discoveryconfig.v1.IntegrationDiscoveredSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aws_ec2", kind: "message", T: ResourcesDiscoveredSummary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationDiscoveredSummary {
    return new IntegrationDiscoveredSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationDiscoveredSummary {
    return new IntegrationDiscoveredSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationDiscoveredSummary {
    return new IntegrationDiscoveredSummary().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationDiscoveredSummary | PlainMessage<IntegrationDiscoveredSummary> | undefined, b: IntegrationDiscoveredSummary | PlainMessage<IntegrationDiscoveredSummary> | undefined): boolean {
    return proto3.util.equals(IntegrationDiscoveredSummary, a, b);
  }
}

/**
 * ResourcesDiscoveredSummary represents the AWS resources that were discovered.
 *
 * @generated from message teleport.discoveryconfig.v1.ResourcesDiscoveredSummary
 */
export class ResourcesDiscoveredSummary extends Message<ResourcesDiscoveredSummary> {
  /**
   * Found holds the count of resources found.
   * After a resource is found, it starts the sync process and ends in either an enrolled or a failed resource.
   *
   * @generated from field: uint64 found = 1;
   */
  found = protoInt64.zero;

  /**
   * Enrolled holds the count of the resources that were successfully enrolled.
   *
   * @generated from field: uint64 enrolled = 2;
   */
  enrolled = protoInt64.zero;

  /**
   * Failed holds the count of the resources that failed to enroll.
   *
   * @generated from field: uint64 failed = 3;
   */
  failed = protoInt64.zero;

  constructor(data?: PartialMessage<ResourcesDiscoveredSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.discoveryconfig.v1.ResourcesDiscoveredSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "found", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "enrolled", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "failed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourcesDiscoveredSummary {
    return new ResourcesDiscoveredSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourcesDiscoveredSummary {
    return new ResourcesDiscoveredSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourcesDiscoveredSummary {
    return new ResourcesDiscoveredSummary().fromJsonString(jsonString, options);
  }

  static equals(a: ResourcesDiscoveredSummary | PlainMessage<ResourcesDiscoveredSummary> | undefined, b: ResourcesDiscoveredSummary | PlainMessage<ResourcesDiscoveredSummary> | undefined): boolean {
    return proto3.util.equals(ResourcesDiscoveredSummary, a, b);
  }
}

