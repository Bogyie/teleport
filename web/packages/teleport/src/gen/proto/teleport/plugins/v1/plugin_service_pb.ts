// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/plugins/v1/plugin_service.proto (package teleport.plugins.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { PluginBootstrapCredentialsV1, PluginCredentialsV1, PluginStaticCredentialsV1, PluginStatusV1, PluginV1, ResourceID } from "../../legacy/types/types_pb";

/**
 * PluginType represents a single type of hosted plugin
 * that can be onboarded.
 *
 * @generated from message teleport.plugins.v1.PluginType
 */
export class PluginType extends Message<PluginType> {
  /**
   * Type is a string corresponding to api.PluginTypeXXX constants
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * OAuthClientID contains the client ID of the OAuth application
   * that is used with this plugin's API provider.
   * For plugins that are not authenticated via OAuth,
   * this will be empty.
   *
   * @generated from field: string oauth_client_id = 2;
   */
  oauthClientId = "";

  constructor(data?: PartialMessage<PluginType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.PluginType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oauth_client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginType {
    return new PluginType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginType {
    return new PluginType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginType {
    return new PluginType().fromJsonString(jsonString, options);
  }

  static equals(a: PluginType | PlainMessage<PluginType> | undefined, b: PluginType | PlainMessage<PluginType> | undefined): boolean {
    return proto3.util.equals(PluginType, a, b);
  }
}

/**
 * CreatePluginRequest creates a new plugin from the given spec and initial
 * credentials.
 *
 * @generated from message teleport.plugins.v1.CreatePluginRequest
 */
export class CreatePluginRequest extends Message<CreatePluginRequest> {
  /**
   * Plugin is the plugin object without live credentials.
   *
   * @generated from field: types.PluginV1 plugin = 1;
   */
  plugin?: PluginV1;

  /**
   * BootstrapCredentials are the initial credentials
   * issued by e.g. OAuth2 authorization code flow.
   * In the scope of processing this request, these are exchanged for
   * short-lived renewable credentials, which are stored in the Plugin.
   *
   * @generated from field: types.PluginBootstrapCredentialsV1 bootstrap_credentials = 2;
   */
  bootstrapCredentials?: PluginBootstrapCredentialsV1;

  /**
   * StaticCredentials are an optional static credential to supply to the
   * plugin.
   *
   * @generated from field: types.PluginStaticCredentialsV1 static_credentials = 3;
   */
  staticCredentials?: PluginStaticCredentialsV1;

  /**
   * StaticCredentials are an optional collection of static credentials
   * to supply to the plugin. Ignored if `StaticCredentials` is set.
   *
   * @generated from field: repeated types.PluginStaticCredentialsV1 static_credentials_list = 4;
   */
  staticCredentialsList: PluginStaticCredentialsV1[] = [];

  /**
   * CredentialLabels are a collection of labels used to identify the
   * credentials secified in the StaticCredentialsList. Ignored if
   * StaticCredentials is used
   *
   * @generated from field: map<string, string> credential_labels = 5;
   */
  credentialLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreatePluginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.CreatePluginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugin", kind: "message", T: PluginV1 },
    { no: 2, name: "bootstrap_credentials", kind: "message", T: PluginBootstrapCredentialsV1 },
    { no: 3, name: "static_credentials", kind: "message", T: PluginStaticCredentialsV1 },
    { no: 4, name: "static_credentials_list", kind: "message", T: PluginStaticCredentialsV1, repeated: true },
    { no: 5, name: "credential_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePluginRequest {
    return new CreatePluginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePluginRequest {
    return new CreatePluginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePluginRequest {
    return new CreatePluginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreatePluginRequest | PlainMessage<CreatePluginRequest> | undefined, b: CreatePluginRequest | PlainMessage<CreatePluginRequest> | undefined): boolean {
    return proto3.util.equals(CreatePluginRequest, a, b);
  }
}

/**
 * GetPluginRequest is a request to return a plugin instance by name.
 *
 * @generated from message teleport.plugins.v1.GetPluginRequest
 */
export class GetPluginRequest extends Message<GetPluginRequest> {
  /**
   * Name is the name of the plugin instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * WithSecrets indicates whether plugin secrets (credentials) are requested
   *
   * @generated from field: bool with_secrets = 2;
   */
  withSecrets = false;

  constructor(data?: PartialMessage<GetPluginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.GetPluginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "with_secrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPluginRequest {
    return new GetPluginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPluginRequest {
    return new GetPluginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPluginRequest {
    return new GetPluginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetPluginRequest | PlainMessage<GetPluginRequest> | undefined, b: GetPluginRequest | PlainMessage<GetPluginRequest> | undefined): boolean {
    return proto3.util.equals(GetPluginRequest, a, b);
  }
}

/**
 * UpdatePluginRequest is a request to update a plugin instance.
 *
 * @generated from message teleport.plugins.v1.UpdatePluginRequest
 */
export class UpdatePluginRequest extends Message<UpdatePluginRequest> {
  /**
   * Plugin is the plugin object to update.
   *
   * @generated from field: types.PluginV1 plugin = 1;
   */
  plugin?: PluginV1;

  constructor(data?: PartialMessage<UpdatePluginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.UpdatePluginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugin", kind: "message", T: PluginV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePluginRequest {
    return new UpdatePluginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePluginRequest {
    return new UpdatePluginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePluginRequest {
    return new UpdatePluginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdatePluginRequest | PlainMessage<UpdatePluginRequest> | undefined, b: UpdatePluginRequest | PlainMessage<UpdatePluginRequest> | undefined): boolean {
    return proto3.util.equals(UpdatePluginRequest, a, b);
  }
}

/**
 * ListPluginsRequest is a paginated request to list all plugin instances.
 *
 * @generated from message teleport.plugins.v1.ListPluginsRequest
 */
export class ListPluginsRequest extends Message<ListPluginsRequest> {
  /**
   * PageSize is the maximum number of plugins to return in a single response.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * StartKey is the value of NextKey received in the last ListPluginsResponse.
   * When making the initial request, this should be left empty.
   *
   * @generated from field: string start_key = 2;
   */
  startKey = "";

  /**
   * WithSecrets indicates whether plugin secrets (credentials) are requested
   *
   * @generated from field: bool with_secrets = 3;
   */
  withSecrets = false;

  constructor(data?: PartialMessage<ListPluginsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.ListPluginsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "with_secrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPluginsRequest {
    return new ListPluginsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPluginsRequest {
    return new ListPluginsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPluginsRequest {
    return new ListPluginsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListPluginsRequest | PlainMessage<ListPluginsRequest> | undefined, b: ListPluginsRequest | PlainMessage<ListPluginsRequest> | undefined): boolean {
    return proto3.util.equals(ListPluginsRequest, a, b);
  }
}

/**
 * ListPluginsResponse is a paginated response to a ListPluginsRequest.
 *
 * @generated from message teleport.plugins.v1.ListPluginsResponse
 */
export class ListPluginsResponse extends Message<ListPluginsResponse> {
  /**
   * Plugins is the list of plugins.
   *
   * @generated from field: repeated types.PluginV1 plugins = 1;
   */
  plugins: PluginV1[] = [];

  /**
   * NextKey is a token to retrieve the next page of results, or empty
   * if there are no more results.
   *
   * @generated from field: string next_key = 2;
   */
  nextKey = "";

  constructor(data?: PartialMessage<ListPluginsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.ListPluginsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugins", kind: "message", T: PluginV1, repeated: true },
    { no: 2, name: "next_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPluginsResponse {
    return new ListPluginsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPluginsResponse {
    return new ListPluginsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPluginsResponse {
    return new ListPluginsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListPluginsResponse | PlainMessage<ListPluginsResponse> | undefined, b: ListPluginsResponse | PlainMessage<ListPluginsResponse> | undefined): boolean {
    return proto3.util.equals(ListPluginsResponse, a, b);
  }
}

/**
 * DeletePluginRequest is a request to delete a plugin instance by name.
 *
 * @generated from message teleport.plugins.v1.DeletePluginRequest
 */
export class DeletePluginRequest extends Message<DeletePluginRequest> {
  /**
   * Name is the name of the plugin instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeletePluginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.DeletePluginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePluginRequest {
    return new DeletePluginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePluginRequest {
    return new DeletePluginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePluginRequest {
    return new DeletePluginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeletePluginRequest | PlainMessage<DeletePluginRequest> | undefined, b: DeletePluginRequest | PlainMessage<DeletePluginRequest> | undefined): boolean {
    return proto3.util.equals(DeletePluginRequest, a, b);
  }
}

/**
 * SetPluginCredentialsRequest is a request to set credentials for an existing
 * plugin
 *
 * @generated from message teleport.plugins.v1.SetPluginCredentialsRequest
 */
export class SetPluginCredentialsRequest extends Message<SetPluginCredentialsRequest> {
  /**
   * Name is the name of the plugin instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Credentials are the credentials obtained after exchanging the initial
   * credentials, and after successive credential renewals.
   *
   * @generated from field: types.PluginCredentialsV1 credentials = 2;
   */
  credentials?: PluginCredentialsV1;

  constructor(data?: PartialMessage<SetPluginCredentialsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.SetPluginCredentialsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "credentials", kind: "message", T: PluginCredentialsV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPluginCredentialsRequest {
    return new SetPluginCredentialsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPluginCredentialsRequest {
    return new SetPluginCredentialsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPluginCredentialsRequest {
    return new SetPluginCredentialsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetPluginCredentialsRequest | PlainMessage<SetPluginCredentialsRequest> | undefined, b: SetPluginCredentialsRequest | PlainMessage<SetPluginCredentialsRequest> | undefined): boolean {
    return proto3.util.equals(SetPluginCredentialsRequest, a, b);
  }
}

/**
 * SetPluginStatusRequest is a request to set the status for an existing plugin
 *
 * @generated from message teleport.plugins.v1.SetPluginStatusRequest
 */
export class SetPluginStatusRequest extends Message<SetPluginStatusRequest> {
  /**
   * Name is the name of the plugin instance.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Status is the plugin status.
   *
   * @generated from field: types.PluginStatusV1 status = 2;
   */
  status?: PluginStatusV1;

  constructor(data?: PartialMessage<SetPluginStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.SetPluginStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "message", T: PluginStatusV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPluginStatusRequest {
    return new SetPluginStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPluginStatusRequest {
    return new SetPluginStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPluginStatusRequest {
    return new SetPluginStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetPluginStatusRequest | PlainMessage<SetPluginStatusRequest> | undefined, b: SetPluginStatusRequest | PlainMessage<SetPluginStatusRequest> | undefined): boolean {
    return proto3.util.equals(SetPluginStatusRequest, a, b);
  }
}

/**
 * GetAvailablePluginTypesRequest is the request type for
 * GetAvailablePluginTypes
 *
 * @generated from message teleport.plugins.v1.GetAvailablePluginTypesRequest
 */
export class GetAvailablePluginTypesRequest extends Message<GetAvailablePluginTypesRequest> {
  constructor(data?: PartialMessage<GetAvailablePluginTypesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.GetAvailablePluginTypesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAvailablePluginTypesRequest {
    return new GetAvailablePluginTypesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAvailablePluginTypesRequest {
    return new GetAvailablePluginTypesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAvailablePluginTypesRequest {
    return new GetAvailablePluginTypesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAvailablePluginTypesRequest | PlainMessage<GetAvailablePluginTypesRequest> | undefined, b: GetAvailablePluginTypesRequest | PlainMessage<GetAvailablePluginTypesRequest> | undefined): boolean {
    return proto3.util.equals(GetAvailablePluginTypesRequest, a, b);
  }
}

/**
 * GetAvailablePluginTypesResponse is a response to for GetAvailablePluginTypes
 *
 * @generated from message teleport.plugins.v1.GetAvailablePluginTypesResponse
 */
export class GetAvailablePluginTypesResponse extends Message<GetAvailablePluginTypesResponse> {
  /**
   * PluginTypes is a list of hosted plugins
   * that the auth service supports.
   *
   * @generated from field: repeated teleport.plugins.v1.PluginType plugin_types = 1;
   */
  pluginTypes: PluginType[] = [];

  constructor(data?: PartialMessage<GetAvailablePluginTypesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.GetAvailablePluginTypesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugin_types", kind: "message", T: PluginType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAvailablePluginTypesResponse {
    return new GetAvailablePluginTypesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAvailablePluginTypesResponse {
    return new GetAvailablePluginTypesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAvailablePluginTypesResponse {
    return new GetAvailablePluginTypesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAvailablePluginTypesResponse | PlainMessage<GetAvailablePluginTypesResponse> | undefined, b: GetAvailablePluginTypesResponse | PlainMessage<GetAvailablePluginTypesResponse> | undefined): boolean {
    return proto3.util.equals(GetAvailablePluginTypesResponse, a, b);
  }
}

/**
 * SearchPluginStaticCredentialsRequest is the request type for
 * SearchPluginStaticCredentials. The labels here are attached to a plugin and
 * search credential object at creation time. Labels can be provided to the
 * plugin credentials object and then, during plugin creation, a reference to
 * those labels augmented along with a uniquely identifying ID will ensure a
 * unique mapping between credentials and plugins.
 *
 * @generated from message teleport.plugins.v1.SearchPluginStaticCredentialsRequest
 */
export class SearchPluginStaticCredentialsRequest extends Message<SearchPluginStaticCredentialsRequest> {
  /**
   * Labels are matched against static credentials objects and returned.
   *
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<SearchPluginStaticCredentialsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.SearchPluginStaticCredentialsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPluginStaticCredentialsRequest {
    return new SearchPluginStaticCredentialsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPluginStaticCredentialsRequest {
    return new SearchPluginStaticCredentialsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPluginStaticCredentialsRequest {
    return new SearchPluginStaticCredentialsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchPluginStaticCredentialsRequest | PlainMessage<SearchPluginStaticCredentialsRequest> | undefined, b: SearchPluginStaticCredentialsRequest | PlainMessage<SearchPluginStaticCredentialsRequest> | undefined): boolean {
    return proto3.util.equals(SearchPluginStaticCredentialsRequest, a, b);
  }
}

/**
 * SearchPluginStaticCredentialsResponse is the response type for
 * SearchPluginStaticCredentials
 *
 * @generated from message teleport.plugins.v1.SearchPluginStaticCredentialsResponse
 */
export class SearchPluginStaticCredentialsResponse extends Message<SearchPluginStaticCredentialsResponse> {
  /**
   * Credentials are the list of credentials matching the requested labels.
   *
   * @generated from field: repeated types.PluginStaticCredentialsV1 credentials = 1;
   */
  credentials: PluginStaticCredentialsV1[] = [];

  constructor(data?: PartialMessage<SearchPluginStaticCredentialsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.SearchPluginStaticCredentialsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "credentials", kind: "message", T: PluginStaticCredentialsV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPluginStaticCredentialsResponse {
    return new SearchPluginStaticCredentialsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPluginStaticCredentialsResponse {
    return new SearchPluginStaticCredentialsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPluginStaticCredentialsResponse {
    return new SearchPluginStaticCredentialsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchPluginStaticCredentialsResponse | PlainMessage<SearchPluginStaticCredentialsResponse> | undefined, b: SearchPluginStaticCredentialsResponse | PlainMessage<SearchPluginStaticCredentialsResponse> | undefined): boolean {
    return proto3.util.equals(SearchPluginStaticCredentialsResponse, a, b);
  }
}

/**
 * NeedsCleanupRequest is the request type for NeedsCleanup.
 *
 * @generated from message teleport.plugins.v1.NeedsCleanupRequest
 */
export class NeedsCleanupRequest extends Message<NeedsCleanupRequest> {
  /**
   * Type is the plugin type. We only need the string representation of the
   * plugin type and not the PluginType message, as we don't want the oauth
   * client ID here.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  constructor(data?: PartialMessage<NeedsCleanupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.NeedsCleanupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NeedsCleanupRequest {
    return new NeedsCleanupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NeedsCleanupRequest {
    return new NeedsCleanupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NeedsCleanupRequest {
    return new NeedsCleanupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NeedsCleanupRequest | PlainMessage<NeedsCleanupRequest> | undefined, b: NeedsCleanupRequest | PlainMessage<NeedsCleanupRequest> | undefined): boolean {
    return proto3.util.equals(NeedsCleanupRequest, a, b);
  }
}

/**
 * NeedsCleanupResponse is the response type for NeedsCleanup.
 *
 * @generated from message teleport.plugins.v1.NeedsCleanupResponse
 */
export class NeedsCleanupResponse extends Message<NeedsCleanupResponse> {
  /**
   * NeedsCleanup will be set to true if the plugin needs cleanup.
   *
   * @generated from field: bool needs_cleanup = 1;
   */
  needsCleanup = false;

  /**
   * ResourcesToCleanup are the resources that need to be cleaned up.
   *
   * @generated from field: repeated types.ResourceID resources_to_cleanup = 2;
   */
  resourcesToCleanup: ResourceID[] = [];

  /**
   * PluginActive returns true if the plugin is currently active.
   *
   * @generated from field: bool plugin_active = 3;
   */
  pluginActive = false;

  constructor(data?: PartialMessage<NeedsCleanupResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.NeedsCleanupResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "needs_cleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "resources_to_cleanup", kind: "message", T: ResourceID, repeated: true },
    { no: 3, name: "plugin_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NeedsCleanupResponse {
    return new NeedsCleanupResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NeedsCleanupResponse {
    return new NeedsCleanupResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NeedsCleanupResponse {
    return new NeedsCleanupResponse().fromJsonString(jsonString, options);
  }

  static equals(a: NeedsCleanupResponse | PlainMessage<NeedsCleanupResponse> | undefined, b: NeedsCleanupResponse | PlainMessage<NeedsCleanupResponse> | undefined): boolean {
    return proto3.util.equals(NeedsCleanupResponse, a, b);
  }
}

/**
 * CleanupRequest is the request type for NeedsCleanup.
 *
 * @generated from message teleport.plugins.v1.CleanupRequest
 */
export class CleanupRequest extends Message<CleanupRequest> {
  /**
   * Type is the plugin type. We only need the string representation of the
   * plugin type and not the PluginType message, as we don't want the oauth
   * client ID here.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  constructor(data?: PartialMessage<CleanupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.plugins.v1.CleanupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CleanupRequest {
    return new CleanupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CleanupRequest {
    return new CleanupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CleanupRequest {
    return new CleanupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CleanupRequest | PlainMessage<CleanupRequest> | undefined, b: CleanupRequest | PlainMessage<CleanupRequest> | undefined): boolean {
    return proto3.util.equals(CleanupRequest, a, b);
  }
}

