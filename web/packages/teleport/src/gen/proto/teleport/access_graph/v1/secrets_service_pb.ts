// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/access_graph/v1/secrets_service.proto (package teleport.access_graph.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { AuthorizedKey } from "./authorized_key_pb";
import { AssertDeviceRequest, AssertDeviceResponse } from "../../devicetrust/v1/assert_pb";
import { PrivateKey } from "./private_key_pb";

/**
 * OperationType is an enum that indicates the operation that the client wants to perform.
 *
 * @generated from enum teleport.access_graph.v1.OperationType
 */
export enum OperationType {
  /**
   * OPERATION_TYPE_UNSPECIFIED is an unknown operation.
   *
   * @generated from enum value: OPERATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * OPERATION_TYPE_ADD is an operation that indicates that the client wants to add keys to the list.
   *
   * @generated from enum value: OPERATION_TYPE_ADD = 1;
   */
  ADD = 1,

  /**
   * OPERATION_TYPE_SYNC is an operation that indicates that the client has sent all the keys and
   * the server can proceed with the analysis.
   *
   * @generated from enum value: OPERATION_TYPE_SYNC = 2;
   */
  SYNC = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OperationType)
proto3.util.setEnumType(OperationType, "teleport.access_graph.v1.OperationType", [
  { no: 0, name: "OPERATION_TYPE_UNSPECIFIED" },
  { no: 1, name: "OPERATION_TYPE_ADD" },
  { no: 2, name: "OPERATION_TYPE_SYNC" },
]);

/**
 * ReportAuthorizedKeysRequest is used by Teleport nodes to report authorized keys
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportAuthorizedKeysRequest
 */
export class ReportAuthorizedKeysRequest extends Message<ReportAuthorizedKeysRequest> {
  /**
   * keys is a list of authorized keys that could be used to bypass Teleport.
   *
   * @generated from field: repeated teleport.access_graph.v1.AuthorizedKey keys = 1;
   */
  keys: AuthorizedKey[] = [];

  /**
   * operation indicates the operation that the client wants to perform.
   *
   * @generated from field: teleport.access_graph.v1.OperationType operation = 2;
   */
  operation = OperationType.UNSPECIFIED;

  constructor(data?: PartialMessage<ReportAuthorizedKeysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.access_graph.v1.ReportAuthorizedKeysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: AuthorizedKey, repeated: true },
    { no: 2, name: "operation", kind: "enum", T: proto3.getEnumType(OperationType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportAuthorizedKeysRequest {
    return new ReportAuthorizedKeysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportAuthorizedKeysRequest {
    return new ReportAuthorizedKeysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportAuthorizedKeysRequest {
    return new ReportAuthorizedKeysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReportAuthorizedKeysRequest | PlainMessage<ReportAuthorizedKeysRequest> | undefined, b: ReportAuthorizedKeysRequest | PlainMessage<ReportAuthorizedKeysRequest> | undefined): boolean {
    return proto3.util.equals(ReportAuthorizedKeysRequest, a, b);
  }
}

/**
 * ReportAuthorizedKeysResponse is the response from ReportAuthorizedKeys
 * RPC method.
 *
 * @generated from message teleport.access_graph.v1.ReportAuthorizedKeysResponse
 */
export class ReportAuthorizedKeysResponse extends Message<ReportAuthorizedKeysResponse> {
  constructor(data?: PartialMessage<ReportAuthorizedKeysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.access_graph.v1.ReportAuthorizedKeysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportAuthorizedKeysResponse {
    return new ReportAuthorizedKeysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportAuthorizedKeysResponse {
    return new ReportAuthorizedKeysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportAuthorizedKeysResponse {
    return new ReportAuthorizedKeysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReportAuthorizedKeysResponse | PlainMessage<ReportAuthorizedKeysResponse> | undefined, b: ReportAuthorizedKeysResponse | PlainMessage<ReportAuthorizedKeysResponse> | undefined): boolean {
    return proto3.util.equals(ReportAuthorizedKeysResponse, a, b);
  }
}

/**
 * ReportSecretsRequest is used by trusted devices to report secrets found on the host
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportSecretsRequest
 */
export class ReportSecretsRequest extends Message<ReportSecretsRequest> {
  /**
   * @generated from oneof teleport.access_graph.v1.ReportSecretsRequest.payload
   */
  payload: {
    /**
     * The device should initiate the device assertion ceremony by sending the
     * AssertDeviceRequest. Please refer to the [teleport.devicetrust.v1.AssertDeviceRequest]
     * message for more details.
     *
     * @generated from field: teleport.devicetrust.v1.AssertDeviceRequest device_assertion = 1;
     */
    value: AssertDeviceRequest;
    case: "deviceAssertion";
  } | {
    /**
     * private_keys is a list of private keys that were found on the device.
     *
     * @generated from field: teleport.access_graph.v1.ReportPrivateKeys private_keys = 4;
     */
    value: ReportPrivateKeys;
    case: "privateKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReportSecretsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.access_graph.v1.ReportSecretsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_assertion", kind: "message", T: AssertDeviceRequest, oneof: "payload" },
    { no: 4, name: "private_keys", kind: "message", T: ReportPrivateKeys, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportSecretsRequest {
    return new ReportSecretsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportSecretsRequest {
    return new ReportSecretsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportSecretsRequest {
    return new ReportSecretsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReportSecretsRequest | PlainMessage<ReportSecretsRequest> | undefined, b: ReportSecretsRequest | PlainMessage<ReportSecretsRequest> | undefined): boolean {
    return proto3.util.equals(ReportSecretsRequest, a, b);
  }
}

/**
 * ReportPrivateKeys is used by trusted devices to report private keys found on the host
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportPrivateKeys
 */
export class ReportPrivateKeys extends Message<ReportPrivateKeys> {
  /**
   * keys is a list of private keys that could be used to bypass Teleport.
   *
   * @generated from field: repeated teleport.access_graph.v1.PrivateKey keys = 1;
   */
  keys: PrivateKey[] = [];

  constructor(data?: PartialMessage<ReportPrivateKeys>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.access_graph.v1.ReportPrivateKeys";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: PrivateKey, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportPrivateKeys {
    return new ReportPrivateKeys().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportPrivateKeys {
    return new ReportPrivateKeys().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportPrivateKeys {
    return new ReportPrivateKeys().fromJsonString(jsonString, options);
  }

  static equals(a: ReportPrivateKeys | PlainMessage<ReportPrivateKeys> | undefined, b: ReportPrivateKeys | PlainMessage<ReportPrivateKeys> | undefined): boolean {
    return proto3.util.equals(ReportPrivateKeys, a, b);
  }
}

/**
 * ReportSecretsResponse is the response from the ReportSecrets
 * RPC method.
 *
 * @generated from message teleport.access_graph.v1.ReportSecretsResponse
 */
export class ReportSecretsResponse extends Message<ReportSecretsResponse> {
  /**
   * @generated from oneof teleport.access_graph.v1.ReportSecretsResponse.payload
   */
  payload: {
    /**
     * device_assertion is the response from the device assertion ceremony.
     * Please refer to the [teleport.devicetrust.v1.AssertDeviceResponse]
     * message for more details
     *
     * @generated from field: teleport.devicetrust.v1.AssertDeviceResponse device_assertion = 1;
     */
    value: AssertDeviceResponse;
    case: "deviceAssertion";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReportSecretsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.access_graph.v1.ReportSecretsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_assertion", kind: "message", T: AssertDeviceResponse, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportSecretsResponse {
    return new ReportSecretsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportSecretsResponse {
    return new ReportSecretsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportSecretsResponse {
    return new ReportSecretsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReportSecretsResponse | PlainMessage<ReportSecretsResponse> | undefined, b: ReportSecretsResponse | PlainMessage<ReportSecretsResponse> | undefined): boolean {
    return proto3.util.equals(ReportSecretsResponse, a, b);
  }
}

