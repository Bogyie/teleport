// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/legacy/types/events/events.proto (package events, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp, UInt32Value, UInt64Value } from "@bufbuild/protobuf";
import { LockTarget, SAMLConnectorV2 } from "../types_pb";
import { LabelValues } from "../wrappers/wrappers_pb";

/**
 * The kind of user a given username refers to. Usernames should always refer to
 * a valid cluster user (even if temporary, e.g. SSO), but may be Machine ID
 * bot users.
 *
 * @generated from enum events.UserKind
 */
export enum UserKind {
  /**
   * Indicates a legacy cluster emitting events without a defined user kind.
   *
   * @generated from enum value: USER_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Indicates the user associated with this event is human, either created
   * locally or via SSO.
   *
   * @generated from enum value: USER_KIND_HUMAN = 1;
   */
  HUMAN = 1,

  /**
   * Indicates the user associated with this event is a Machine ID bot user.
   *
   * @generated from enum value: USER_KIND_BOT = 2;
   */
  BOT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UserKind)
proto3.util.setEnumType(UserKind, "events.UserKind", [
  { no: 0, name: "USER_KIND_UNSPECIFIED" },
  { no: 1, name: "USER_KIND_HUMAN" },
  { no: 2, name: "USER_KIND_BOT" },
]);

/**
 * Action communicates what was done in response to the event
 *
 * @generated from enum events.EventAction
 */
export enum EventAction {
  /**
   * @generated from enum value: OBSERVED = 0;
   */
  OBSERVED = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EventAction)
proto3.util.setEnumType(EventAction, "events.EventAction", [
  { no: 0, name: "OBSERVED" },
  { no: 1, name: "DENIED" },
]);

/**
 * SFTPAction denotes what type of SFTP request was made.
 * These actions were taken from https://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-02.
 *
 * @generated from enum events.SFTPAction
 */
export enum SFTPAction {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: OPEN = 1;
   */
  OPEN = 1,

  /**
   * @generated from enum value: CLOSE = 2;
   */
  CLOSE = 2,

  /**
   * @generated from enum value: READ = 3;
   */
  READ = 3,

  /**
   * @generated from enum value: WRITE = 4;
   */
  WRITE = 4,

  /**
   * @generated from enum value: LSTAT = 5;
   */
  LSTAT = 5,

  /**
   * @generated from enum value: FSTAT = 6;
   */
  FSTAT = 6,

  /**
   * @generated from enum value: SETSTAT = 7;
   */
  SETSTAT = 7,

  /**
   * @generated from enum value: FSETSTAT = 8;
   */
  FSETSTAT = 8,

  /**
   * @generated from enum value: OPENDIR = 9;
   */
  OPENDIR = 9,

  /**
   * @generated from enum value: READDIR = 10;
   */
  READDIR = 10,

  /**
   * @generated from enum value: REMOVE = 11;
   */
  REMOVE = 11,

  /**
   * @generated from enum value: MKDIR = 12;
   */
  MKDIR = 12,

  /**
   * @generated from enum value: RMDIR = 13;
   */
  RMDIR = 13,

  /**
   * @generated from enum value: REALPATH = 14;
   */
  REALPATH = 14,

  /**
   * @generated from enum value: STAT = 15;
   */
  STAT = 15,

  /**
   * @generated from enum value: RENAME = 16;
   */
  RENAME = 16,

  /**
   * @generated from enum value: READLINK = 17;
   */
  READLINK = 17,

  /**
   * @generated from enum value: SYMLINK = 18;
   */
  SYMLINK = 18,

  /**
   * @generated from enum value: LINK = 19;
   */
  LINK = 19,
}
// Retrieve enum metadata with: proto3.getEnumType(SFTPAction)
proto3.util.setEnumType(SFTPAction, "events.SFTPAction", [
  { no: 0, name: "INVALID" },
  { no: 1, name: "OPEN" },
  { no: 2, name: "CLOSE" },
  { no: 3, name: "READ" },
  { no: 4, name: "WRITE" },
  { no: 5, name: "LSTAT" },
  { no: 6, name: "FSTAT" },
  { no: 7, name: "SETSTAT" },
  { no: 8, name: "FSETSTAT" },
  { no: 9, name: "OPENDIR" },
  { no: 10, name: "READDIR" },
  { no: 11, name: "REMOVE" },
  { no: 12, name: "MKDIR" },
  { no: 13, name: "RMDIR" },
  { no: 14, name: "REALPATH" },
  { no: 15, name: "STAT" },
  { no: 16, name: "RENAME" },
  { no: 17, name: "READLINK" },
  { no: 18, name: "SYMLINK" },
  { no: 19, name: "LINK" },
]);

/**
 * OSType is the same as teleport.devicetrust.v1.OSType.
 * Duplicated because gogo doesn't play well with protoc-gen-go.
 *
 * @generated from enum events.OSType
 */
export enum OSType {
  /**
   * @generated from enum value: OS_TYPE_UNSPECIFIED = 0;
   */
  OS_TYPE_UNSPECIFIED = 0,

  /**
   * Linux.
   *
   * @generated from enum value: OS_TYPE_LINUX = 1;
   */
  OS_TYPE_LINUX = 1,

  /**
   * macOS.
   *
   * @generated from enum value: OS_TYPE_MACOS = 2;
   */
  OS_TYPE_MACOS = 2,

  /**
   * Windows.
   *
   * @generated from enum value: OS_TYPE_WINDOWS = 3;
   */
  OS_TYPE_WINDOWS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OSType)
proto3.util.setEnumType(OSType, "events.OSType", [
  { no: 0, name: "OS_TYPE_UNSPECIFIED" },
  { no: 1, name: "OS_TYPE_LINUX" },
  { no: 2, name: "OS_TYPE_MACOS" },
  { no: 3, name: "OS_TYPE_WINDOWS" },
]);

/**
 * DeviceOrigin is the same as teleport.devicetrust.v1.DeviceOrigin.
 * Duplicated because gogo doesn't play well with protoc-gen-go.
 *
 * @generated from enum events.DeviceOrigin
 */
export enum DeviceOrigin {
  /**
   * Unspecified or absent origin.
   *
   * @generated from enum value: DEVICE_ORIGIN_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Devices originated from direct API usage.
   *
   * @generated from enum value: DEVICE_ORIGIN_API = 1;
   */
  API = 1,

  /**
   * Devices originated from Jamf sync.
   *
   * @generated from enum value: DEVICE_ORIGIN_JAMF = 2;
   */
  JAMF = 2,

  /**
   * Source originated from Microsoft Intune sync.
   *
   * @generated from enum value: DEVICE_ORIGIN_INTUNE = 3;
   */
  INTUNE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(DeviceOrigin)
proto3.util.setEnumType(DeviceOrigin, "events.DeviceOrigin", [
  { no: 0, name: "DEVICE_ORIGIN_UNSPECIFIED" },
  { no: 1, name: "DEVICE_ORIGIN_API" },
  { no: 2, name: "DEVICE_ORIGIN_JAMF" },
  { no: 3, name: "DEVICE_ORIGIN_INTUNE" },
]);

/**
 * ElasticsearchCategory specifies Elasticsearch request category.
 *
 * @generated from enum events.ElasticsearchCategory
 */
export enum ElasticsearchCategory {
  /**
   * ELASTICSEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
   *
   * @generated from enum value: ELASTICSEARCH_CATEGORY_GENERAL = 0;
   */
  GENERAL = 0,

  /**
   * ELASTICSEARCH_CATEGORY_SECURITY is for _security and _ssl APIs.
   *
   * @generated from enum value: ELASTICSEARCH_CATEGORY_SECURITY = 1;
   */
  SECURITY = 1,

  /**
   * ELASTICSEARCH_CATEGORY_SEARCH is for search-related APIs.
   *
   * @generated from enum value: ELASTICSEARCH_CATEGORY_SEARCH = 2;
   */
  SEARCH = 2,

  /**
   * ELASTICSEARCH_CATEGORY_SQL covers _sql API.
   *
   * @generated from enum value: ELASTICSEARCH_CATEGORY_SQL = 3;
   */
  SQL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ElasticsearchCategory)
proto3.util.setEnumType(ElasticsearchCategory, "events.ElasticsearchCategory", [
  { no: 0, name: "ELASTICSEARCH_CATEGORY_GENERAL" },
  { no: 1, name: "ELASTICSEARCH_CATEGORY_SECURITY" },
  { no: 2, name: "ELASTICSEARCH_CATEGORY_SEARCH" },
  { no: 3, name: "ELASTICSEARCH_CATEGORY_SQL" },
]);

/**
 * OpenSearchCategory specifies OpenSearch request category.
 *
 * @generated from enum events.OpenSearchCategory
 */
export enum OpenSearchCategory {
  /**
   * OPEN_SEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
   *
   * @generated from enum value: OPEN_SEARCH_CATEGORY_GENERAL = 0;
   */
  GENERAL = 0,

  /**
   * OPEN_SEARCH_CATEGORY_SECURITY covers /_plugins/_security API.
   *
   * @generated from enum value: OPEN_SEARCH_CATEGORY_SECURITY = 1;
   */
  SECURITY = 1,

  /**
   * OPEN_SEARCH_CATEGORY_SEARCH is for search-related APIs.
   *
   * @generated from enum value: OPEN_SEARCH_CATEGORY_SEARCH = 2;
   */
  SEARCH = 2,

  /**
   * OPEN_SEARCH_CATEGORY_SQL covers /_plugins/_sql and /_plugins/_ppl API.
   *
   * @generated from enum value: OPEN_SEARCH_CATEGORY_SQL = 3;
   */
  SQL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OpenSearchCategory)
proto3.util.setEnumType(OpenSearchCategory, "events.OpenSearchCategory", [
  { no: 0, name: "OPEN_SEARCH_CATEGORY_GENERAL" },
  { no: 1, name: "OPEN_SEARCH_CATEGORY_SECURITY" },
  { no: 2, name: "OPEN_SEARCH_CATEGORY_SEARCH" },
  { no: 3, name: "OPEN_SEARCH_CATEGORY_SQL" },
]);

/**
 * @generated from enum events.AdminActionsMFAStatus
 */
export enum AdminActionsMFAStatus {
  /**
   * @generated from enum value: ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED = 0;
   */
  ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ADMIN_ACTIONS_MFA_STATUS_UNCHANGED = 1;
   */
  ADMIN_ACTIONS_MFA_STATUS_UNCHANGED = 1,

  /**
   * @generated from enum value: ADMIN_ACTIONS_MFA_STATUS_ENABLED = 2;
   */
  ADMIN_ACTIONS_MFA_STATUS_ENABLED = 2,

  /**
   * @generated from enum value: ADMIN_ACTIONS_MFA_STATUS_DISABLED = 3;
   */
  ADMIN_ACTIONS_MFA_STATUS_DISABLED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AdminActionsMFAStatus)
proto3.util.setEnumType(AdminActionsMFAStatus, "events.AdminActionsMFAStatus", [
  { no: 0, name: "ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED" },
  { no: 1, name: "ADMIN_ACTIONS_MFA_STATUS_UNCHANGED" },
  { no: 2, name: "ADMIN_ACTIONS_MFA_STATUS_ENABLED" },
  { no: 3, name: "ADMIN_ACTIONS_MFA_STATUS_DISABLED" },
]);

/**
 * Metadata is a common event metadata
 *
 * @generated from message events.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * Index is a monotonically incremented index in the event sequence
   *
   * @generated from field: int64 Index = 1;
   */
  Index = protoInt64.zero;

  /**
   * Type is the event type
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * ID is a unique event identifier
   *
   * @generated from field: string ID = 3;
   */
  ID = "";

  /**
   * Code is a unique event code
   *
   * @generated from field: string Code = 4;
   */
  Code = "";

  /**
   * Time is event time
   *
   * @generated from field: google.protobuf.Timestamp Time = 5;
   */
  Time?: Timestamp;

  /**
   * ClusterName identifies the originating teleport cluster
   *
   * @generated from field: string ClusterName = 6;
   */
  ClusterName = "";

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Index", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Time", kind: "message", T: Timestamp },
    { no: 6, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * SessionMetadata is a common session event metadata
 *
 * @generated from message events.SessionMetadata
 */
export class SessionMetadata extends Message<SessionMetadata> {
  /**
   * SessionID is a unique UUID of the session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * WithMFA is a UUID of an MFA device used to start this session.
   *
   * @generated from field: string WithMFA = 2;
   */
  WithMFA = "";

  /**
   * PrivateKeyPolicy is the private key policy of the private key used to start this session.
   *
   * @generated from field: string PrivateKeyPolicy = 3;
   */
  PrivateKeyPolicy = "";

  constructor(data?: PartialMessage<SessionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "WithMFA", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "PrivateKeyPolicy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionMetadata {
    return new SessionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionMetadata {
    return new SessionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionMetadata {
    return new SessionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SessionMetadata | PlainMessage<SessionMetadata> | undefined, b: SessionMetadata | PlainMessage<SessionMetadata> | undefined): boolean {
    return proto3.util.equals(SessionMetadata, a, b);
  }
}

/**
 * UserMetadata is a common user event metadata
 *
 * @generated from message events.UserMetadata
 */
export class UserMetadata extends Message<UserMetadata> {
  /**
   * User is teleport user name
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Login is OS login
   *
   * @generated from field: string Login = 2;
   */
  Login = "";

  /**
   * Impersonator is a user acting on behalf of another user
   *
   * @generated from field: string Impersonator = 3;
   */
  Impersonator = "";

  /**
   * AWSRoleARN is AWS IAM role user assumes when accessing AWS console.
   *
   * @generated from field: string AWSRoleARN = 4;
   */
  AWSRoleARN = "";

  /**
   * AccessRequests are the IDs of access requests created by the user
   *
   * @generated from field: repeated string AccessRequests = 5;
   */
  AccessRequests: string[] = [];

  /**
   * AzureIdentity is the Azure identity user assumes when accessing Azure API.
   *
   * @generated from field: string AzureIdentity = 6;
   */
  AzureIdentity = "";

  /**
   * GCPServiceAccount is the GCP service account user assumes when accessing GCP API.
   *
   * @generated from field: string GCPServiceAccount = 7;
   */
  GCPServiceAccount = "";

  /**
   * TrustedDevice contains information about the users' trusted device.
   * Requires a registered and enrolled device to be used during authentication.
   *
   * @generated from field: events.DeviceMetadata TrustedDevice = 8;
   */
  TrustedDevice?: DeviceMetadata;

  /**
   * RequiredPrivateKeyPolicy is the private key policy enforced for this login.
   *
   * @generated from field: string RequiredPrivateKeyPolicy = 9;
   */
  RequiredPrivateKeyPolicy = "";

  /**
   * UserKind indicates what type of user this is, e.g. a human or Machine ID
   * bot user.
   *
   * @generated from field: events.UserKind UserKind = 10;
   */
  UserKind = UserKind.UNSPECIFIED;

  /**
   * BotName is the name of the Bot if this action is associated with one.
   *
   * @generated from field: string BotName = 11;
   */
  BotName = "";

  /**
   * BotInstanceID is the ID of the Bot Instance if this action is associated
   * with one.
   *
   * @generated from field: string BotInstanceID = 12;
   */
  BotInstanceID = "";

  constructor(data?: PartialMessage<UserMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Impersonator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AWSRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AccessRequests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "AzureIdentity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "GCPServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "TrustedDevice", kind: "message", T: DeviceMetadata },
    { no: 9, name: "RequiredPrivateKeyPolicy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "UserKind", kind: "enum", T: proto3.getEnumType(UserKind) },
    { no: 11, name: "BotName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "BotInstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserMetadata {
    return new UserMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserMetadata {
    return new UserMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserMetadata {
    return new UserMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UserMetadata | PlainMessage<UserMetadata> | undefined, b: UserMetadata | PlainMessage<UserMetadata> | undefined): boolean {
    return proto3.util.equals(UserMetadata, a, b);
  }
}

/**
 * Server is a server metadata
 *
 * @generated from message events.ServerMetadata
 */
export class ServerMetadata extends Message<ServerMetadata> {
  /**
   * ServerNamespace is a namespace of the server event
   *
   * @generated from field: string ServerNamespace = 1;
   */
  ServerNamespace = "";

  /**
   * ServerID is the UUID of the server the session occurred on.
   *
   * @generated from field: string ServerID = 2;
   */
  ServerID = "";

  /**
   * ServerHostname is the hostname of the server the session occurred on.
   *
   * @generated from field: string ServerHostname = 3;
   */
  ServerHostname = "";

  /**
   * ServerAddr is the address of the server the session occurred on.
   *
   * @generated from field: string ServerAddr = 4;
   */
  ServerAddr = "";

  /**
   * ServerLabels are the labels (static and dynamic) of the server the
   * session occurred on.
   *
   * @generated from field: map<string, string> ServerLabels = 5;
   */
  ServerLabels: { [key: string]: string } = {};

  /**
   * ForwardedBy tells us if the metadata was sent by the node itself or by another node in it's
   * place. We can't verify emit permissions fully for these events so care should be taken with
   * them.
   *
   * @generated from field: string ForwardedBy = 6;
   */
  ForwardedBy = "";

  /**
   * ServerSubKind is the sub kind of the server the session occurred on.
   *
   * @generated from field: string ServerSubKind = 7;
   */
  ServerSubKind = "";

  /**
   * ServerVersion is the component version the session occurred on.
   *
   * @generated from field: string ServerVersion = 8;
   */
  ServerVersion = "";

  constructor(data?: PartialMessage<ServerMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ServerMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ServerHostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ServerAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ServerLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "ForwardedBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ServerSubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ServerVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerMetadata {
    return new ServerMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerMetadata {
    return new ServerMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerMetadata {
    return new ServerMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ServerMetadata | PlainMessage<ServerMetadata> | undefined, b: ServerMetadata | PlainMessage<ServerMetadata> | undefined): boolean {
    return proto3.util.equals(ServerMetadata, a, b);
  }
}

/**
 * Connection contains connection info
 *
 * @generated from message events.ConnectionMetadata
 */
export class ConnectionMetadata extends Message<ConnectionMetadata> {
  /**
   * LocalAddr is a target address on the host
   *
   * @generated from field: string LocalAddr = 1;
   */
  LocalAddr = "";

  /**
   * RemoteAddr is a client (user's) address
   *
   * @generated from field: string RemoteAddr = 2;
   */
  RemoteAddr = "";

  /**
   * Protocol specifies protocol that was captured
   *
   * @generated from field: string Protocol = 3;
   */
  Protocol = "";

  constructor(data?: PartialMessage<ConnectionMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ConnectionMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "LocalAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "RemoteAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionMetadata {
    return new ConnectionMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionMetadata {
    return new ConnectionMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionMetadata {
    return new ConnectionMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionMetadata | PlainMessage<ConnectionMetadata> | undefined, b: ConnectionMetadata | PlainMessage<ConnectionMetadata> | undefined): boolean {
    return proto3.util.equals(ConnectionMetadata, a, b);
  }
}

/**
 * ClientMetadata identifies the originating client for an event.
 *
 * @generated from message events.ClientMetadata
 */
export class ClientMetadata extends Message<ClientMetadata> {
  /**
   * UserAgent identifies the type of client that attempted the event.
   *
   * @generated from field: string UserAgent = 1;
   */
  UserAgent = "";

  constructor(data?: PartialMessage<ClientMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ClientMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UserAgent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientMetadata {
    return new ClientMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientMetadata {
    return new ClientMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientMetadata {
    return new ClientMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ClientMetadata | PlainMessage<ClientMetadata> | undefined, b: ClientMetadata | PlainMessage<ClientMetadata> | undefined): boolean {
    return proto3.util.equals(ClientMetadata, a, b);
  }
}

/**
 * KubernetesClusterMetadata contains common metadata for kubernetes-related
 * events.
 *
 * @generated from message events.KubernetesClusterMetadata
 */
export class KubernetesClusterMetadata extends Message<KubernetesClusterMetadata> {
  /**
   * KubernetesCluster is a kubernetes cluster name.
   *
   * @generated from field: string KubernetesCluster = 1;
   */
  KubernetesCluster = "";

  /**
   * KubernetesUsers is a list of kubernetes usernames for the user.
   *
   * @generated from field: repeated string KubernetesUsers = 2;
   */
  KubernetesUsers: string[] = [];

  /**
   * KubernetesGroups is a list of kubernetes groups for the user.
   *
   * @generated from field: repeated string KubernetesGroups = 3;
   */
  KubernetesGroups: string[] = [];

  /**
   * KubernetesLabels are the labels (static and dynamic) of the kubernetes cluster the
   * session occurred on.
   *
   * @generated from field: map<string, string> KubernetesLabels = 4;
   */
  KubernetesLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<KubernetesClusterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubernetesClusterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "KubernetesUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "KubernetesGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "KubernetesLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterMetadata {
    return new KubernetesClusterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterMetadata {
    return new KubernetesClusterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterMetadata {
    return new KubernetesClusterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterMetadata | PlainMessage<KubernetesClusterMetadata> | undefined, b: KubernetesClusterMetadata | PlainMessage<KubernetesClusterMetadata> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterMetadata, a, b);
  }
}

/**
 * KubernetesPodMetadata contains common metadata for kubernetes pod-related
 * events.
 *
 * @generated from message events.KubernetesPodMetadata
 */
export class KubernetesPodMetadata extends Message<KubernetesPodMetadata> {
  /**
   * KubernetesPodName is the name of the pod.
   *
   * @generated from field: string KubernetesPodName = 1;
   */
  KubernetesPodName = "";

  /**
   * KubernetesPodNamespace is the namespace of the pod.
   *
   * @generated from field: string KubernetesPodNamespace = 2;
   */
  KubernetesPodNamespace = "";

  /**
   * KubernetesContainerName is the name of the container within the pod.
   *
   * @generated from field: string KubernetesContainerName = 3;
   */
  KubernetesContainerName = "";

  /**
   * KubernetesContainerImage is the image of the container within the pod.
   *
   * @generated from field: string KubernetesContainerImage = 4;
   */
  KubernetesContainerImage = "";

  /**
   * KubernetesNodeName is the node that runs the pod.
   *
   * @generated from field: string KubernetesNodeName = 5;
   */
  KubernetesNodeName = "";

  constructor(data?: PartialMessage<KubernetesPodMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubernetesPodMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KubernetesPodName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "KubernetesPodNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "KubernetesContainerName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "KubernetesContainerImage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "KubernetesNodeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesPodMetadata {
    return new KubernetesPodMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesPodMetadata {
    return new KubernetesPodMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesPodMetadata {
    return new KubernetesPodMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesPodMetadata | PlainMessage<KubernetesPodMetadata> | undefined, b: KubernetesPodMetadata | PlainMessage<KubernetesPodMetadata> | undefined): boolean {
    return proto3.util.equals(KubernetesPodMetadata, a, b);
  }
}

/**
 * SAMLIdPServiceProviderMetadata contains common metadata for SAML IdP service provider
 * events.
 *
 * @generated from message events.SAMLIdPServiceProviderMetadata
 */
export class SAMLIdPServiceProviderMetadata extends Message<SAMLIdPServiceProviderMetadata> {
  /**
   * ServiceProviderEntityID is the entity ID of the service provider.
   *
   * @generated from field: string ServiceProviderEntityID = 1;
   */
  ServiceProviderEntityID = "";

  /**
   * ServiceProviderShortcut is the shortcut name of a service provider.
   *
   * @generated from field: string ServiceProviderShortcut = 2;
   */
  ServiceProviderShortcut = "";

  /**
   * AttributeMapping is a map of attribute name and value which will be asserted in SAML response.
   *
   * @generated from field: map<string, string> AttributeMapping = 3;
   */
  AttributeMapping: { [key: string]: string } = {};

  constructor(data?: PartialMessage<SAMLIdPServiceProviderMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPServiceProviderMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceProviderEntityID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ServiceProviderShortcut", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "AttributeMapping", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderMetadata {
    return new SAMLIdPServiceProviderMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderMetadata {
    return new SAMLIdPServiceProviderMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderMetadata {
    return new SAMLIdPServiceProviderMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderMetadata | PlainMessage<SAMLIdPServiceProviderMetadata> | undefined, b: SAMLIdPServiceProviderMetadata | PlainMessage<SAMLIdPServiceProviderMetadata> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderMetadata, a, b);
  }
}

/**
 * OktaResourcesUpdatedMetadata contains common metadata for Okta resources updated events.
 *
 * @generated from message events.OktaResourcesUpdatedMetadata
 */
export class OktaResourcesUpdatedMetadata extends Message<OktaResourcesUpdatedMetadata> {
  /**
   * Added is the number of resources added.
   *
   * @generated from field: int32 Added = 1;
   */
  Added = 0;

  /**
   * Updated is the number of resources updated.
   *
   * @generated from field: int32 Updated = 2;
   */
  Updated = 0;

  /**
   * Deleted is the number of resources deleted.
   *
   * @generated from field: int32 Deleted = 3;
   */
  Deleted = 0;

  /**
   * AddedResources is a list of the actual resources that were added.
   *
   * @generated from field: repeated events.OktaResource AddedResources = 4;
   */
  AddedResources: OktaResource[] = [];

  /**
   * UpdatedResources is a list of the actual resources that were updated.
   *
   * @generated from field: repeated events.OktaResource UpdatedResources = 5;
   */
  UpdatedResources: OktaResource[] = [];

  /**
   * DeletedResources is a list of the actual resources that were deleted.
   *
   * @generated from field: repeated events.OktaResource DeletedResources = 6;
   */
  DeletedResources: OktaResource[] = [];

  constructor(data?: PartialMessage<OktaResourcesUpdatedMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaResourcesUpdatedMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Added", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "Updated", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "Deleted", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "AddedResources", kind: "message", T: OktaResource, repeated: true },
    { no: 5, name: "UpdatedResources", kind: "message", T: OktaResource, repeated: true },
    { no: 6, name: "DeletedResources", kind: "message", T: OktaResource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaResourcesUpdatedMetadata {
    return new OktaResourcesUpdatedMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaResourcesUpdatedMetadata {
    return new OktaResourcesUpdatedMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaResourcesUpdatedMetadata {
    return new OktaResourcesUpdatedMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OktaResourcesUpdatedMetadata | PlainMessage<OktaResourcesUpdatedMetadata> | undefined, b: OktaResourcesUpdatedMetadata | PlainMessage<OktaResourcesUpdatedMetadata> | undefined): boolean {
    return proto3.util.equals(OktaResourcesUpdatedMetadata, a, b);
  }
}

/**
 * OktaResource is a descriptor of an Okta resource.
 *
 * @generated from message events.OktaResource
 */
export class OktaResource extends Message<OktaResource> {
  /**
   * ID is the identifier of the Okta resource.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * Description is the description of the Okta resource.
   *
   * @generated from field: string Description = 2;
   */
  Description = "";

  constructor(data?: PartialMessage<OktaResource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaResource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaResource {
    return new OktaResource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaResource {
    return new OktaResource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaResource {
    return new OktaResource().fromJsonString(jsonString, options);
  }

  static equals(a: OktaResource | PlainMessage<OktaResource> | undefined, b: OktaResource | PlainMessage<OktaResource> | undefined): boolean {
    return proto3.util.equals(OktaResource, a, b);
  }
}

/**
 * OktaAssignmentMetadata contains common metadata for Okta assignment events.
 *
 * @generated from message events.OktaAssignmentMetadata
 */
export class OktaAssignmentMetadata extends Message<OktaAssignmentMetadata> {
  /**
   * Source is the source of the Okta assignment.
   *
   * @generated from field: string Source = 1;
   */
  Source = "";

  /**
   * User is the user the Okta assignment is for.
   *
   * @generated from field: string User = 2;
   */
  User = "";

  /**
   * StartingStatus is the starting status of the assignment.
   *
   * @generated from field: string StartingStatus = 3;
   */
  StartingStatus = "";

  /**
   * EndingStatus is the ending status of the assignment.
   *
   * @generated from field: string EndingStatus = 4;
   */
  EndingStatus = "";

  constructor(data?: PartialMessage<OktaAssignmentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaAssignmentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "StartingStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "EndingStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAssignmentMetadata {
    return new OktaAssignmentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAssignmentMetadata {
    return new OktaAssignmentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAssignmentMetadata {
    return new OktaAssignmentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAssignmentMetadata | PlainMessage<OktaAssignmentMetadata> | undefined, b: OktaAssignmentMetadata | PlainMessage<OktaAssignmentMetadata> | undefined): boolean {
    return proto3.util.equals(OktaAssignmentMetadata, a, b);
  }
}

/**
 * AccessListMemberMetadata contains common metadata for access list member resource events.
 *
 * @generated from message events.AccessListMemberMetadata
 */
export class AccessListMemberMetadata extends Message<AccessListMemberMetadata> {
  /**
   * AccessListName is the name of the access list the members are being added to or removed from.
   *
   * @generated from field: string AccessListName = 1;
   */
  AccessListName = "";

  /**
   * Members are all members affected by the access list membership change.
   *
   * @generated from field: repeated events.AccessListMember Members = 2;
   */
  Members: AccessListMember[] = [];

  constructor(data?: PartialMessage<AccessListMemberMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMemberMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AccessListName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Members", kind: "message", T: AccessListMember, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMemberMetadata {
    return new AccessListMemberMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMemberMetadata {
    return new AccessListMemberMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMemberMetadata {
    return new AccessListMemberMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMemberMetadata | PlainMessage<AccessListMemberMetadata> | undefined, b: AccessListMemberMetadata | PlainMessage<AccessListMemberMetadata> | undefined): boolean {
    return proto3.util.equals(AccessListMemberMetadata, a, b);
  }
}

/**
 * AccessListMember is metadata surrounding an individual access list member.
 *
 * @generated from message events.AccessListMember
 */
export class AccessListMember extends Message<AccessListMember> {
  /**
   * JoinedOn is the date that the member joined.
   *
   * @generated from field: google.protobuf.Timestamp JoinedOn = 1;
   */
  JoinedOn?: Timestamp;

  /**
   * RemovedOn is the date that the access list member was removed. Will only be populated for deletion.
   *
   * @generated from field: google.protobuf.Timestamp RemovedOn = 2;
   */
  RemovedOn?: Timestamp;

  /**
   * Reason is the reason that the member was added, modified, or removed.
   *
   * @generated from field: string Reason = 3;
   */
  Reason = "";

  /**
   * MemberName is the name of the member.
   *
   * @generated from field: string MemberName = 4;
   */
  MemberName = "";

  constructor(data?: PartialMessage<AccessListMember>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMember";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "JoinedOn", kind: "message", T: Timestamp },
    { no: 2, name: "RemovedOn", kind: "message", T: Timestamp },
    { no: 3, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "MemberName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMember {
    return new AccessListMember().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMember {
    return new AccessListMember().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMember {
    return new AccessListMember().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMember | PlainMessage<AccessListMember> | undefined, b: AccessListMember | PlainMessage<AccessListMember> | undefined): boolean {
    return proto3.util.equals(AccessListMember, a, b);
  }
}

/**
 * AccessListReviewMembershipRequirementsChanged contains information for when membership requirements change as part of a review.
 *
 * @generated from message events.AccessListReviewMembershipRequirementsChanged
 */
export class AccessListReviewMembershipRequirementsChanged extends Message<AccessListReviewMembershipRequirementsChanged> {
  /**
   * Roles are the roles that changed as part of a review.
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[] = [];

  /**
   * Traits are the traits that changed as part of a review.
   *
   * @generated from field: map<string, string> Traits = 2;
   */
  Traits: { [key: string]: string } = {};

  constructor(data?: PartialMessage<AccessListReviewMembershipRequirementsChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListReviewMembershipRequirementsChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Traits", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListReviewMembershipRequirementsChanged {
    return new AccessListReviewMembershipRequirementsChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListReviewMembershipRequirementsChanged {
    return new AccessListReviewMembershipRequirementsChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListReviewMembershipRequirementsChanged {
    return new AccessListReviewMembershipRequirementsChanged().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListReviewMembershipRequirementsChanged | PlainMessage<AccessListReviewMembershipRequirementsChanged> | undefined, b: AccessListReviewMembershipRequirementsChanged | PlainMessage<AccessListReviewMembershipRequirementsChanged> | undefined): boolean {
    return proto3.util.equals(AccessListReviewMembershipRequirementsChanged, a, b);
  }
}

/**
 * AccessListReviewMetadata contains metadata for access list review events.
 *
 * @generated from message events.AccessListReviewMetadata
 */
export class AccessListReviewMetadata extends Message<AccessListReviewMetadata> {
  /**
   * Message is the message that was supplied during the review.
   *
   * @generated from field: string Message = 1;
   */
  Message = "";

  /**
   * ReviewID is the ID of the review.
   *
   * @generated from field: string ReviewID = 2;
   */
  ReviewID = "";

  /**
   * MembershipRequirementsChanged is populated if the memrship requirements have changed..
   *
   * @generated from field: events.AccessListReviewMembershipRequirementsChanged MembershipRequirementsChanged = 3;
   */
  MembershipRequirementsChanged?: AccessListReviewMembershipRequirementsChanged;

  /**
   * ReviewFrequencyChanged is populated if the review frequency has changed.
   *
   * @generated from field: string ReviewFrequencyChanged = 4;
   */
  ReviewFrequencyChanged = "";

  /**
   * ReviewDayOfMonthChanged is populated if the review day of month has changed.
   *
   * @generated from field: string ReviewDayOfMonthChanged = 5;
   */
  ReviewDayOfMonthChanged = "";

  /**
   * RemovedMembers are the members that were removed as part of the review.
   *
   * @generated from field: repeated string RemovedMembers = 6;
   */
  RemovedMembers: string[] = [];

  constructor(data?: PartialMessage<AccessListReviewMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListReviewMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ReviewID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "MembershipRequirementsChanged", kind: "message", T: AccessListReviewMembershipRequirementsChanged },
    { no: 4, name: "ReviewFrequencyChanged", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ReviewDayOfMonthChanged", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RemovedMembers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListReviewMetadata {
    return new AccessListReviewMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListReviewMetadata {
    return new AccessListReviewMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListReviewMetadata {
    return new AccessListReviewMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListReviewMetadata | PlainMessage<AccessListReviewMetadata> | undefined, b: AccessListReviewMetadata | PlainMessage<AccessListReviewMetadata> | undefined): boolean {
    return proto3.util.equals(AccessListReviewMetadata, a, b);
  }
}

/**
 * LockMetadata contains common metadata for lock resource events.
 *
 * @generated from message events.LockMetadata
 */
export class LockMetadata extends Message<LockMetadata> {
  /**
   * Target describes the set of interactions that the lock applies to
   *
   * @generated from field: types.LockTarget Target = 4;
   */
  Target?: LockTarget;

  constructor(data?: PartialMessage<LockMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.LockMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "Target", kind: "message", T: LockTarget },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockMetadata {
    return new LockMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockMetadata {
    return new LockMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockMetadata {
    return new LockMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: LockMetadata | PlainMessage<LockMetadata> | undefined, b: LockMetadata | PlainMessage<LockMetadata> | undefined): boolean {
    return proto3.util.equals(LockMetadata, a, b);
  }
}

/**
 * SessionStart is a session start event
 *
 * @generated from message events.SessionStart
 */
export class SessionStart extends Message<SessionStart> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * TerminalSize is expressed as 'W:H'
   *
   * @generated from field: string TerminalSize = 6;
   */
  TerminalSize = "";

  /**
   * KubernetesCluster has information about a kubernetes cluster, if
   * applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata KubernetesCluster = 7;
   */
  KubernetesCluster?: KubernetesClusterMetadata;

  /**
   * KubernetesPod has information about a kubernetes pod, if applicable.
   *
   * @generated from field: events.KubernetesPodMetadata KubernetesPod = 8;
   */
  KubernetesPod?: KubernetesPodMetadata;

  /**
   * InitialCommand is the command used to start this session.
   *
   * @generated from field: repeated string InitialCommand = 9;
   */
  InitialCommand: string[] = [];

  /**
   * SessionRecording is the type of session recording.
   *
   * @generated from field: string SessionRecording = 10;
   */
  SessionRecording = "";

  constructor(data?: PartialMessage<SessionStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "TerminalSize", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "KubernetesCluster", kind: "message", T: KubernetesClusterMetadata },
    { no: 8, name: "KubernetesPod", kind: "message", T: KubernetesPodMetadata },
    { no: 9, name: "InitialCommand", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "SessionRecording", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionStart {
    return new SessionStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionStart {
    return new SessionStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionStart {
    return new SessionStart().fromJsonString(jsonString, options);
  }

  static equals(a: SessionStart | PlainMessage<SessionStart> | undefined, b: SessionStart | PlainMessage<SessionStart> | undefined): boolean {
    return proto3.util.equals(SessionStart, a, b);
  }
}

/**
 * SessionJoin emitted when another user joins a session
 *
 * @generated from message events.SessionJoin
 */
export class SessionJoin extends Message<SessionJoin> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * KubernetesCluster has information about a kubernetes cluster, if
   * applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata KubernetesCluster = 6;
   */
  KubernetesCluster?: KubernetesClusterMetadata;

  constructor(data?: PartialMessage<SessionJoin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionJoin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "KubernetesCluster", kind: "message", T: KubernetesClusterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionJoin {
    return new SessionJoin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionJoin {
    return new SessionJoin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionJoin {
    return new SessionJoin().fromJsonString(jsonString, options);
  }

  static equals(a: SessionJoin | PlainMessage<SessionJoin> | undefined, b: SessionJoin | PlainMessage<SessionJoin> | undefined): boolean {
    return proto3.util.equals(SessionJoin, a, b);
  }
}

/**
 * SessionPrint event happens every time a write occurs to
 * terminal I/O during a session
 *
 * @generated from message events.SessionPrint
 */
export class SessionPrint extends Message<SessionPrint> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ChunkIndex is a monotonically incremented index for ordering print events
   *
   * @generated from field: int64 ChunkIndex = 2;
   */
  ChunkIndex = protoInt64.zero;

  /**
   * Data is data transferred, it is not marshaled to JSON format
   *
   * @generated from field: bytes Data = 3;
   */
  Data = new Uint8Array(0);

  /**
   * Bytes says how many bytes have been written into the session
   * during "print" event
   *
   * @generated from field: int64 Bytes = 4;
   */
  Bytes = protoInt64.zero;

  /**
   * DelayMilliseconds is the delay in milliseconds from the start of the session
   *
   * @generated from field: int64 DelayMilliseconds = 5;
   */
  DelayMilliseconds = protoInt64.zero;

  /**
   * Offset is the offset in bytes in the session file
   *
   * @generated from field: int64 Offset = 6;
   */
  Offset = protoInt64.zero;

  constructor(data?: PartialMessage<SessionPrint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionPrint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "ChunkIndex", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "Data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "Bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "DelayMilliseconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "Offset", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionPrint {
    return new SessionPrint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionPrint {
    return new SessionPrint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionPrint {
    return new SessionPrint().fromJsonString(jsonString, options);
  }

  static equals(a: SessionPrint | PlainMessage<SessionPrint> | undefined, b: SessionPrint | PlainMessage<SessionPrint> | undefined): boolean {
    return proto3.util.equals(SessionPrint, a, b);
  }
}

/**
 * DesktopRecording happens when a Teleport Desktop Protocol message
 * is captured during a Desktop Access Session.
 *
 * @generated from message events.DesktopRecording
 */
export class DesktopRecording extends Message<DesktopRecording> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Message is the encoded TDP message.
   *
   * @generated from field: bytes Message = 2;
   */
  Message = new Uint8Array(0);

  /**
   * DelayMilliseconds is the delay in milliseconds from the start of the session
   *
   * JSON tag intentionally matches SessionPrintEvent
   *
   * @generated from field: int64 DelayMilliseconds = 3;
   */
  DelayMilliseconds = protoInt64.zero;

  constructor(data?: PartialMessage<DesktopRecording>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopRecording";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Message", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "DelayMilliseconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopRecording {
    return new DesktopRecording().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopRecording {
    return new DesktopRecording().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopRecording {
    return new DesktopRecording().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopRecording | PlainMessage<DesktopRecording> | undefined, b: DesktopRecording | PlainMessage<DesktopRecording> | undefined): boolean {
    return proto3.util.equals(DesktopRecording, a, b);
  }
}

/**
 * DesktopClipboardReceive is emitted when Teleport receives
 * clipboard data from a remote desktop.
 *
 * @generated from message events.DesktopClipboardReceive
 */
export class DesktopClipboardReceive extends Message<DesktopClipboardReceive> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 5;
   */
  DesktopAddr = "";

  /**
   * Length is the number of bytes of data received from the remote clipboard.
   *
   * @generated from field: int32 Length = 6;
   */
  Length = 0;

  constructor(data?: PartialMessage<DesktopClipboardReceive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopClipboardReceive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Length", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopClipboardReceive {
    return new DesktopClipboardReceive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopClipboardReceive {
    return new DesktopClipboardReceive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopClipboardReceive {
    return new DesktopClipboardReceive().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopClipboardReceive | PlainMessage<DesktopClipboardReceive> | undefined, b: DesktopClipboardReceive | PlainMessage<DesktopClipboardReceive> | undefined): boolean {
    return proto3.util.equals(DesktopClipboardReceive, a, b);
  }
}

/**
 * DesktopClipboardSend is emitted when clipboard data is
 * sent from a user's workstation to Teleport.
 *
 * @generated from message events.DesktopClipboardSend
 */
export class DesktopClipboardSend extends Message<DesktopClipboardSend> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 5;
   */
  DesktopAddr = "";

  /**
   * Length is the number of bytes of data sent.
   *
   * @generated from field: int32 Length = 6;
   */
  Length = 0;

  constructor(data?: PartialMessage<DesktopClipboardSend>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopClipboardSend";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Length", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopClipboardSend {
    return new DesktopClipboardSend().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopClipboardSend {
    return new DesktopClipboardSend().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopClipboardSend {
    return new DesktopClipboardSend().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopClipboardSend | PlainMessage<DesktopClipboardSend> | undefined, b: DesktopClipboardSend | PlainMessage<DesktopClipboardSend> | undefined): boolean {
    return proto3.util.equals(DesktopClipboardSend, a, b);
  }
}

/**
 * DesktopSharedDirectoryStart is emitted when Teleport
 * successfully begins sharing a new directory to a remote desktop.
 *
 * @generated from message events.DesktopSharedDirectoryStart
 */
export class DesktopSharedDirectoryStart extends Message<DesktopSharedDirectoryStart> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status indicates whether the directory sharing initialization was successful.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 6;
   */
  DesktopAddr = "";

  /**
   * DirectoryName is the name of the directory being shared.
   *
   * @generated from field: string DirectoryName = 7;
   */
  DirectoryName = "";

  /**
   * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
   *
   * @generated from field: uint32 DirectoryID = 8;
   */
  DirectoryID = 0;

  constructor(data?: PartialMessage<DesktopSharedDirectoryStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopSharedDirectoryStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "DirectoryName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DirectoryID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopSharedDirectoryStart {
    return new DesktopSharedDirectoryStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryStart {
    return new DesktopSharedDirectoryStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryStart {
    return new DesktopSharedDirectoryStart().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopSharedDirectoryStart | PlainMessage<DesktopSharedDirectoryStart> | undefined, b: DesktopSharedDirectoryStart | PlainMessage<DesktopSharedDirectoryStart> | undefined): boolean {
    return proto3.util.equals(DesktopSharedDirectoryStart, a, b);
  }
}

/**
 * DesktopSharedDirectoryRead is emitted when Teleport
 * attempts to read from a file in a shared directory at
 * the behest of the remote desktop.
 *
 * @generated from message events.DesktopSharedDirectoryRead
 */
export class DesktopSharedDirectoryRead extends Message<DesktopSharedDirectoryRead> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status indicates whether the read was successful.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 6;
   */
  DesktopAddr = "";

  /**
   * DirectoryName is the name of the directory being shared.
   *
   * @generated from field: string DirectoryName = 7;
   */
  DirectoryName = "";

  /**
   * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
   *
   * @generated from field: uint32 DirectoryID = 8;
   */
  DirectoryID = 0;

  /**
   * Path is the path within the shared directory where the file is located.
   *
   * @generated from field: string Path = 9;
   */
  Path = "";

  /**
   * Length is the number of bytes read.
   *
   * @generated from field: uint32 Length = 10;
   */
  Length = 0;

  /**
   * Offset is the offset the bytes were read from.
   *
   * @generated from field: uint64 Offset = 11;
   */
  Offset = protoInt64.zero;

  constructor(data?: PartialMessage<DesktopSharedDirectoryRead>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopSharedDirectoryRead";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "DirectoryName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DirectoryID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "Offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopSharedDirectoryRead {
    return new DesktopSharedDirectoryRead().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryRead {
    return new DesktopSharedDirectoryRead().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryRead {
    return new DesktopSharedDirectoryRead().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopSharedDirectoryRead | PlainMessage<DesktopSharedDirectoryRead> | undefined, b: DesktopSharedDirectoryRead | PlainMessage<DesktopSharedDirectoryRead> | undefined): boolean {
    return proto3.util.equals(DesktopSharedDirectoryRead, a, b);
  }
}

/**
 * DesktopSharedDirectoryWrite is emitted when Teleport
 * attempts to write to a file in a shared directory at
 * the behest of the remote desktop.
 *
 * @generated from message events.DesktopSharedDirectoryWrite
 */
export class DesktopSharedDirectoryWrite extends Message<DesktopSharedDirectoryWrite> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status indicates whether the write was successful.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 6;
   */
  DesktopAddr = "";

  /**
   * DirectoryName is the name of the directory being shared.
   *
   * @generated from field: string DirectoryName = 7;
   */
  DirectoryName = "";

  /**
   * DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
   *
   * @generated from field: uint32 DirectoryID = 8;
   */
  DirectoryID = 0;

  /**
   * Path is the path within the shared directory where the file is located.
   *
   * @generated from field: string Path = 9;
   */
  Path = "";

  /**
   * Length is the number of bytes written.
   *
   * @generated from field: uint32 Length = 10;
   */
  Length = 0;

  /**
   * Offset is the offset the bytes were written to.
   *
   * @generated from field: uint64 Offset = 11;
   */
  Offset = protoInt64.zero;

  constructor(data?: PartialMessage<DesktopSharedDirectoryWrite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DesktopSharedDirectoryWrite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "DirectoryName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DirectoryID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Length", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 11, name: "Offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopSharedDirectoryWrite {
    return new DesktopSharedDirectoryWrite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryWrite {
    return new DesktopSharedDirectoryWrite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopSharedDirectoryWrite {
    return new DesktopSharedDirectoryWrite().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopSharedDirectoryWrite | PlainMessage<DesktopSharedDirectoryWrite> | undefined, b: DesktopSharedDirectoryWrite | PlainMessage<DesktopSharedDirectoryWrite> | undefined): boolean {
    return proto3.util.equals(DesktopSharedDirectoryWrite, a, b);
  }
}

/**
 * SessionReject event happens when a user hits a session control restriction.
 *
 * @generated from message events.SessionReject
 */
export class SessionReject extends Message<SessionReject> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 3;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * Reason is a field that specifies reason for event, e.g. in disconnect
   * event it explains why server disconnected the client
   *
   * @generated from field: string Reason = 5;
   */
  Reason = "";

  /**
   * Maximum is an event field specifying a maximal value (e.g. the value
   * of `max_connections` for a `session.rejected` event).
   *
   * @generated from field: int64 Maximum = 6;
   */
  Maximum = protoInt64.zero;

  constructor(data?: PartialMessage<SessionReject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionReject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Server", kind: "message", T: ServerMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Maximum", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionReject {
    return new SessionReject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionReject {
    return new SessionReject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionReject {
    return new SessionReject().fromJsonString(jsonString, options);
  }

  static equals(a: SessionReject | PlainMessage<SessionReject> | undefined, b: SessionReject | PlainMessage<SessionReject> | undefined): boolean {
    return proto3.util.equals(SessionReject, a, b);
  }
}

/**
 * SessionConnect is emitted when a non-Teleport connection is made over net.Dial.
 *
 * @generated from message events.SessionConnect
 */
export class SessionConnect extends Message<SessionConnect> {
  /**
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * @generated from field: events.ServerMetadata Server = 2;
   */
  Server?: ServerMetadata;

  /**
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<SessionConnect>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionConnect";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Server", kind: "message", T: ServerMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionConnect {
    return new SessionConnect().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionConnect {
    return new SessionConnect().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionConnect {
    return new SessionConnect().fromJsonString(jsonString, options);
  }

  static equals(a: SessionConnect | PlainMessage<SessionConnect> | undefined, b: SessionConnect | PlainMessage<SessionConnect> | undefined): boolean {
    return proto3.util.equals(SessionConnect, a, b);
  }
}

/**
 * FileTransferRequestEvent happens when a FileTransferRequest is created, updated, approved, or denied.
 *
 * @generated from message events.FileTransferRequestEvent
 */
export class FileTransferRequestEvent extends Message<FileTransferRequestEvent> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 2;
   */
  Session?: SessionMetadata;

  /**
   * RequestID is the ID for the FileTransferRequest
   *
   * @generated from field: string RequestID = 3;
   */
  RequestID = "";

  /**
   * Approvers is a slice containing the Teleport users who have approved the request
   *
   * @generated from field: repeated string Approvers = 4;
   */
  Approvers: string[] = [];

  /**
   * Requester is the Teleport user who requested the file transfer
   *
   * @generated from field: string Requester = 5;
   */
  Requester = "";

  /**
   * Location is the location of the file to be downloaded, or the directory of the upload
   *
   * @generated from field: string Location = 6;
   */
  Location = "";

  /**
   * Download is true if the requested file transfer is a download, false if an upload
   *
   * @generated from field: bool Download = 7;
   */
  Download = false;

  /**
   * Filename is the name of the file to be uploaded to the Location. Only present in uploads.
   *
   * @generated from field: string Filename = 8;
   */
  Filename = "";

  constructor(data?: PartialMessage<FileTransferRequestEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.FileTransferRequestEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Session", kind: "message", T: SessionMetadata },
    { no: 3, name: "RequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Approvers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Requester", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Download", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "Filename", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTransferRequestEvent {
    return new FileTransferRequestEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTransferRequestEvent {
    return new FileTransferRequestEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTransferRequestEvent {
    return new FileTransferRequestEvent().fromJsonString(jsonString, options);
  }

  static equals(a: FileTransferRequestEvent | PlainMessage<FileTransferRequestEvent> | undefined, b: FileTransferRequestEvent | PlainMessage<FileTransferRequestEvent> | undefined): boolean {
    return proto3.util.equals(FileTransferRequestEvent, a, b);
  }
}

/**
 * Resize means that some user resized PTY on the client
 *
 * @generated from message events.Resize
 */
export class Resize extends Message<Resize> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 5;
   */
  Server?: ServerMetadata;

  /**
   * TerminalSize is expressed as 'W:H'
   *
   * @generated from field: string TerminalSize = 6;
   */
  TerminalSize = "";

  /**
   * KubernetesCluster has information about a kubernetes cluster, if
   * applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata KubernetesCluster = 7;
   */
  KubernetesCluster?: KubernetesClusterMetadata;

  /**
   * KubernetesPod has information about a kubernetes pod, if applicable.
   *
   * @generated from field: events.KubernetesPodMetadata KubernetesPod = 8;
   */
  KubernetesPod?: KubernetesPodMetadata;

  constructor(data?: PartialMessage<Resize>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Resize";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Server", kind: "message", T: ServerMetadata },
    { no: 6, name: "TerminalSize", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "KubernetesCluster", kind: "message", T: KubernetesClusterMetadata },
    { no: 8, name: "KubernetesPod", kind: "message", T: KubernetesPodMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Resize {
    return new Resize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Resize {
    return new Resize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Resize {
    return new Resize().fromJsonString(jsonString, options);
  }

  static equals(a: Resize | PlainMessage<Resize> | undefined, b: Resize | PlainMessage<Resize> | undefined): boolean {
    return proto3.util.equals(Resize, a, b);
  }
}

/**
 * SessionEnd is a session end event
 *
 * @generated from message events.SessionEnd
 */
export class SessionEnd extends Message<SessionEnd> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 5;
   */
  Server?: ServerMetadata;

  /**
   * EnhancedRecording is used to indicate if the recording was an
   * enhanced recording or not.
   *
   * @generated from field: bool EnhancedRecording = 6;
   */
  EnhancedRecording = false;

  /**
   * Interactive is used to indicate if the session was interactive
   * (has PTY attached) or not (exec session).
   *
   * @generated from field: bool Interactive = 7;
   */
  Interactive = false;

  /**
   * Participants is a list of participants in the session.
   *
   * @generated from field: repeated string Participants = 8;
   */
  Participants: string[] = [];

  /**
   * StartTime is the timestamp at which the session began.
   *
   * @generated from field: google.protobuf.Timestamp StartTime = 9;
   */
  StartTime?: Timestamp;

  /**
   * EndTime is the timestamp at which the session ended.
   *
   * @generated from field: google.protobuf.Timestamp EndTime = 10;
   */
  EndTime?: Timestamp;

  /**
   * KubernetesCluster has information about a kubernetes cluster, if
   * applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata KubernetesCluster = 11;
   */
  KubernetesCluster?: KubernetesClusterMetadata;

  /**
   * KubernetesPod has information about a kubernetes pod, if applicable.
   *
   * @generated from field: events.KubernetesPodMetadata KubernetesPod = 12;
   */
  KubernetesPod?: KubernetesPodMetadata;

  /**
   * InitialCommand is the command used to start this session.
   *
   * @generated from field: repeated string InitialCommand = 13;
   */
  InitialCommand: string[] = [];

  /**
   * SessionRecording is the type of session recording.
   *
   * @generated from field: string SessionRecording = 14;
   */
  SessionRecording = "";

  constructor(data?: PartialMessage<SessionEnd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionEnd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Server", kind: "message", T: ServerMetadata },
    { no: 6, name: "EnhancedRecording", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "Interactive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "Participants", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "StartTime", kind: "message", T: Timestamp },
    { no: 10, name: "EndTime", kind: "message", T: Timestamp },
    { no: 11, name: "KubernetesCluster", kind: "message", T: KubernetesClusterMetadata },
    { no: 12, name: "KubernetesPod", kind: "message", T: KubernetesPodMetadata },
    { no: 13, name: "InitialCommand", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "SessionRecording", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionEnd {
    return new SessionEnd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionEnd {
    return new SessionEnd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionEnd {
    return new SessionEnd().fromJsonString(jsonString, options);
  }

  static equals(a: SessionEnd | PlainMessage<SessionEnd> | undefined, b: SessionEnd | PlainMessage<SessionEnd> | undefined): boolean {
    return proto3.util.equals(SessionEnd, a, b);
  }
}

/**
 * BPFMetadata is a common BPF process metadata
 *
 * @generated from message events.BPFMetadata
 */
export class BPFMetadata extends Message<BPFMetadata> {
  /**
   * PID is the ID of the process.
   *
   * @generated from field: uint64 PID = 1;
   */
  PID = protoInt64.zero;

  /**
   * CgroupID is the internal cgroupv2 ID of the event.
   *
   * @generated from field: uint64 CgroupID = 2;
   */
  CgroupID = protoInt64.zero;

  /**
   * Program is name of the executable.
   *
   * @generated from field: string Program = 3;
   */
  Program = "";

  constructor(data?: PartialMessage<BPFMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BPFMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "CgroupID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "Program", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BPFMetadata {
    return new BPFMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BPFMetadata {
    return new BPFMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BPFMetadata {
    return new BPFMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: BPFMetadata | PlainMessage<BPFMetadata> | undefined, b: BPFMetadata | PlainMessage<BPFMetadata> | undefined): boolean {
    return proto3.util.equals(BPFMetadata, a, b);
  }
}

/**
 * Status contains common command or operation status fields
 *
 * @generated from message events.Status
 */
export class Status extends Message<Status> {
  /**
   * Success indicates the success or failure of the operation
   *
   * @generated from field: bool Success = 1;
   */
  Success = false;

  /**
   * Error includes system error message for the failed attempt
   *
   * @generated from field: string Error = 2;
   */
  Error = "";

  /**
   * UserMessage is a user-friendly message for successfull or unsuccessfull auth attempt
   *
   * @generated from field: string UserMessage = 3;
   */
  UserMessage = "";

  constructor(data?: PartialMessage<Status>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Status";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "UserMessage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Status {
    return new Status().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJsonString(jsonString, options);
  }

  static equals(a: Status | PlainMessage<Status> | undefined, b: Status | PlainMessage<Status> | undefined): boolean {
    return proto3.util.equals(Status, a, b);
  }
}

/**
 * SessionCommand is a session command event
 *
 * @generated from message events.SessionCommand
 */
export class SessionCommand extends Message<SessionCommand> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * BPFMetadata is a common BPF subsystem metadata
   *
   * @generated from field: events.BPFMetadata BPF = 5;
   */
  BPF?: BPFMetadata;

  /**
   * PPID is the PID of the parent process.
   *
   * @generated from field: uint64 PPID = 6;
   */
  PPID = protoInt64.zero;

  /**
   * Path is the full path to the executable.
   *
   * @generated from field: string Path = 7;
   */
  Path = "";

  /**
   * Argv is the list of arguments to the program. Note, the first element does
   * not contain the name of the process.
   *
   * @generated from field: repeated string Argv = 8;
   */
  Argv: string[] = [];

  /**
   * ReturnCode is the return code of execve.
   *
   * @generated from field: int32 ReturnCode = 9;
   */
  ReturnCode = 0;

  constructor(data?: PartialMessage<SessionCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "BPF", kind: "message", T: BPFMetadata },
    { no: 6, name: "PPID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Argv", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "ReturnCode", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionCommand {
    return new SessionCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionCommand {
    return new SessionCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionCommand {
    return new SessionCommand().fromJsonString(jsonString, options);
  }

  static equals(a: SessionCommand | PlainMessage<SessionCommand> | undefined, b: SessionCommand | PlainMessage<SessionCommand> | undefined): boolean {
    return proto3.util.equals(SessionCommand, a, b);
  }
}

/**
 * SessionDisk is a session disk access event
 *
 * @generated from message events.SessionDisk
 */
export class SessionDisk extends Message<SessionDisk> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * BPFMetadata is a common BPF subsystem metadata
   *
   * @generated from field: events.BPFMetadata BPF = 5;
   */
  BPF?: BPFMetadata;

  /**
   * Path is the full path to the executable.
   *
   * @generated from field: string Path = 6;
   */
  Path = "";

  /**
   * Flags are the flags passed to open.
   *
   * @generated from field: int32 Flags = 7;
   */
  Flags = 0;

  /**
   * ReturnCode is the return code of disk open
   *
   * @generated from field: int32 ReturnCode = 8;
   */
  ReturnCode = 0;

  constructor(data?: PartialMessage<SessionDisk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionDisk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "BPF", kind: "message", T: BPFMetadata },
    { no: 6, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Flags", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "ReturnCode", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionDisk {
    return new SessionDisk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionDisk {
    return new SessionDisk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionDisk {
    return new SessionDisk().fromJsonString(jsonString, options);
  }

  static equals(a: SessionDisk | PlainMessage<SessionDisk> | undefined, b: SessionDisk | PlainMessage<SessionDisk> | undefined): boolean {
    return proto3.util.equals(SessionDisk, a, b);
  }
}

/**
 * SessionNetwork is a network event
 *
 * @generated from message events.SessionNetwork
 */
export class SessionNetwork extends Message<SessionNetwork> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * BPFMetadata is a common BPF subsystem metadata
   *
   * @generated from field: events.BPFMetadata BPF = 5;
   */
  BPF?: BPFMetadata;

  /**
   * SrcAddr is the source IP address of the connection.
   *
   * @generated from field: string SrcAddr = 6;
   */
  SrcAddr = "";

  /**
   * DstAddr is the destination IP address of the connection.
   *
   * @generated from field: string DstAddr = 7;
   */
  DstAddr = "";

  /**
   * DstPort is the destination port of the connection.
   *
   * @generated from field: int32 DstPort = 8;
   */
  DstPort = 0;

  /**
   * TCPVersion is the version of TCP (4 or 6).
   *
   * @generated from field: int32 TCPVersion = 9;
   */
  TCPVersion = 0;

  /**
   * Operation denotes what network operation was performed (e.g. connect)
   *
   * @generated from field: events.SessionNetwork.NetworkOperation Operation = 10;
   */
  Operation = SessionNetwork_NetworkOperation.CONNECT;

  /**
   * Action denotes what happened in response to the event
   *
   * @generated from field: events.EventAction Action = 11;
   */
  Action = EventAction.OBSERVED;

  constructor(data?: PartialMessage<SessionNetwork>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionNetwork";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "BPF", kind: "message", T: BPFMetadata },
    { no: 6, name: "SrcAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "DstAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DstPort", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "TCPVersion", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 10, name: "Operation", kind: "enum", T: proto3.getEnumType(SessionNetwork_NetworkOperation) },
    { no: 11, name: "Action", kind: "enum", T: proto3.getEnumType(EventAction) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionNetwork {
    return new SessionNetwork().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionNetwork {
    return new SessionNetwork().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionNetwork {
    return new SessionNetwork().fromJsonString(jsonString, options);
  }

  static equals(a: SessionNetwork | PlainMessage<SessionNetwork> | undefined, b: SessionNetwork | PlainMessage<SessionNetwork> | undefined): boolean {
    return proto3.util.equals(SessionNetwork, a, b);
  }
}

/**
 * Operation is the network operation that was performed or attempted
 *
 * @generated from enum events.SessionNetwork.NetworkOperation
 */
export enum SessionNetwork_NetworkOperation {
  /**
   * TCP connection establishment or binding a UDP socket to a remote address
   *
   * @generated from enum value: CONNECT = 0;
   */
  CONNECT = 0,

  /**
   * Transmission of data to a remote endpoint
   *
   * @generated from enum value: SEND = 1;
   */
  SEND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SessionNetwork_NetworkOperation)
proto3.util.setEnumType(SessionNetwork_NetworkOperation, "events.SessionNetwork.NetworkOperation", [
  { no: 0, name: "CONNECT" },
  { no: 1, name: "SEND" },
]);

/**
 * SessionData is emitted to report session data usage.
 *
 * @generated from message events.SessionData
 */
export class SessionData extends Message<SessionData> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * BytesTransmitted is the amount of bytes transmitted
   *
   * @generated from field: uint64 BytesTransmitted = 6;
   */
  BytesTransmitted = protoInt64.zero;

  /**
   * BytesReceived is the amount of bytes received
   *
   * @generated from field: uint64 BytesReceived = 7;
   */
  BytesReceived = protoInt64.zero;

  constructor(data?: PartialMessage<SessionData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "BytesTransmitted", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "BytesReceived", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionData {
    return new SessionData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionData {
    return new SessionData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionData {
    return new SessionData().fromJsonString(jsonString, options);
  }

  static equals(a: SessionData | PlainMessage<SessionData> | undefined, b: SessionData | PlainMessage<SessionData> | undefined): boolean {
    return proto3.util.equals(SessionData, a, b);
  }
}

/**
 * SessionLeave is emitted to report that a user left the session
 *
 * @generated from message events.SessionLeave
 */
export class SessionLeave extends Message<SessionLeave> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<SessionLeave>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionLeave";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionLeave {
    return new SessionLeave().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionLeave {
    return new SessionLeave().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionLeave {
    return new SessionLeave().fromJsonString(jsonString, options);
  }

  static equals(a: SessionLeave | PlainMessage<SessionLeave> | undefined, b: SessionLeave | PlainMessage<SessionLeave> | undefined): boolean {
    return proto3.util.equals(SessionLeave, a, b);
  }
}

/**
 * UserLogin records a successfully or failed user login event
 *
 * @generated from message events.UserLogin
 */
export class UserLogin extends Message<UserLogin> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Status contains common command or operation status fields
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  /**
   * Method is the event field indicating how the login was performed
   *
   * @generated from field: string Method = 4;
   */
  Method = "";

  /**
   * IdentityAttributes is a map of user attributes received from identity provider
   *
   * @generated from field: google.protobuf.Struct IdentityAttributes = 5;
   */
  IdentityAttributes?: Struct;

  /**
   * MFA is the MFA device used during the login.
   *
   * @generated from field: events.MFADeviceMetadata MFADevice = 6;
   */
  MFADevice?: MFADeviceMetadata;

  /**
   * Client is the common client event metadata
   *
   * @generated from field: events.ClientMetadata Client = 7;
   */
  Client?: ClientMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 8;
   */
  Connection?: ConnectionMetadata;

  /**
   * AppliedLoginRules stores the name of each login rule that was applied
   * during the login.
   *
   * @generated from field: repeated string AppliedLoginRules = 9;
   */
  AppliedLoginRules: string[] = [];

  constructor(data?: PartialMessage<UserLogin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserLogin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
    { no: 4, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "IdentityAttributes", kind: "message", T: Struct },
    { no: 6, name: "MFADevice", kind: "message", T: MFADeviceMetadata },
    { no: 7, name: "Client", kind: "message", T: ClientMetadata },
    { no: 8, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 9, name: "AppliedLoginRules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserLogin {
    return new UserLogin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserLogin {
    return new UserLogin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserLogin {
    return new UserLogin().fromJsonString(jsonString, options);
  }

  static equals(a: UserLogin | PlainMessage<UserLogin> | undefined, b: UserLogin | PlainMessage<UserLogin> | undefined): boolean {
    return proto3.util.equals(UserLogin, a, b);
  }
}

/**
 * CreateMFAAuthChallenge records the creation of an MFA auth challenge.
 *
 * @generated from message events.CreateMFAAuthChallenge
 */
export class CreateMFAAuthChallenge extends Message<CreateMFAAuthChallenge> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Scope is the authorization scope for this MFA challenge.
   * Only applies to WebAuthn challenges.
   *
   * @generated from field: string ChallengeScope = 3;
   */
  ChallengeScope = "";

  /**
   * ChallengeAllowReuse defines whether the MFA challenge allows reuse.
   *
   * @generated from field: bool ChallengeAllowReuse = 4;
   */
  ChallengeAllowReuse = false;

  constructor(data?: PartialMessage<CreateMFAAuthChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CreateMFAAuthChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "ChallengeScope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ChallengeAllowReuse", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateMFAAuthChallenge {
    return new CreateMFAAuthChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateMFAAuthChallenge {
    return new CreateMFAAuthChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateMFAAuthChallenge {
    return new CreateMFAAuthChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: CreateMFAAuthChallenge | PlainMessage<CreateMFAAuthChallenge> | undefined, b: CreateMFAAuthChallenge | PlainMessage<CreateMFAAuthChallenge> | undefined): boolean {
    return proto3.util.equals(CreateMFAAuthChallenge, a, b);
  }
}

/**
 * ValidateMFAAuthResponse records the validation of an MFA auth callenge response.
 *
 * @generated from message events.ValidateMFAAuthResponse
 */
export class ValidateMFAAuthResponse extends Message<ValidateMFAAuthResponse> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Status contains common command or operation status fields
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  /**
   * MFADevice is the MFA device used.
   *
   * @generated from field: events.MFADeviceMetadata MFADevice = 4;
   */
  MFADevice?: MFADeviceMetadata;

  /**
   * ChallengeScope is the authorization scope of the MFA challenge used for authentication.
   * Only applies to WebAuthn challenges.
   *
   * @generated from field: string ChallengeScope = 5;
   */
  ChallengeScope = "";

  /**
   * ChallengeAllowReuse defines whether the MFA challenge used for authentication can be reused.
   *
   * @generated from field: bool ChallengeAllowReuse = 6;
   */
  ChallengeAllowReuse = false;

  constructor(data?: PartialMessage<ValidateMFAAuthResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ValidateMFAAuthResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
    { no: 4, name: "MFADevice", kind: "message", T: MFADeviceMetadata },
    { no: 5, name: "ChallengeScope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ChallengeAllowReuse", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateMFAAuthResponse {
    return new ValidateMFAAuthResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateMFAAuthResponse {
    return new ValidateMFAAuthResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateMFAAuthResponse {
    return new ValidateMFAAuthResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateMFAAuthResponse | PlainMessage<ValidateMFAAuthResponse> | undefined, b: ValidateMFAAuthResponse | PlainMessage<ValidateMFAAuthResponse> | undefined): boolean {
    return proto3.util.equals(ValidateMFAAuthResponse, a, b);
  }
}

/**
 * ResourceMetadata is a common resource metadata
 *
 * @generated from message events.ResourceMetadata
 */
export class ResourceMetadata extends Message<ResourceMetadata> {
  /**
   * ResourceName is a resource name
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Expires is set if resource expires
   *
   * @generated from field: google.protobuf.Timestamp Expires = 2;
   */
  Expires?: Timestamp;

  /**
   * UpdatedBy if set indicates the user who modified the resource
   *
   * @generated from field: string UpdatedBy = 3;
   */
  UpdatedBy = "";

  /**
   * TTL is a TTL of reset password token represented as duration, e.g. "10m"
   * used for compatibility purposes for some events, Expires should be used instead
   * as it's more useful (contains exact expiration date/time)
   *
   * @generated from field: string TTL = 4;
   */
  TTL = "";

  constructor(data?: PartialMessage<ResourceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ResourceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Expires", kind: "message", T: Timestamp },
    { no: 3, name: "UpdatedBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "TTL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMetadata {
    return new ResourceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMetadata {
    return new ResourceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMetadata {
    return new ResourceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceMetadata | PlainMessage<ResourceMetadata> | undefined, b: ResourceMetadata | PlainMessage<ResourceMetadata> | undefined): boolean {
    return proto3.util.equals(ResourceMetadata, a, b);
  }
}

/**
 * UserCreate is emitted when the user is created or upserted.
 *
 * @generated from message events.UserCreate
 */
export class UserCreate extends Message<UserCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * Roles is a list of roles for the user.
   *
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[] = [];

  /**
   * Connector is the connector used to create the user.
   *
   * @generated from field: string Connector = 5;
   */
  Connector = "";

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 6;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<UserCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserCreate {
    return new UserCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserCreate {
    return new UserCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserCreate {
    return new UserCreate().fromJsonString(jsonString, options);
  }

  static equals(a: UserCreate | PlainMessage<UserCreate> | undefined, b: UserCreate | PlainMessage<UserCreate> | undefined): boolean {
    return proto3.util.equals(UserCreate, a, b);
  }
}

/**
 * UserUpdate is emitted when the user is updated.
 *
 * @generated from message events.UserUpdate
 */
export class UserUpdate extends Message<UserUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * Roles is a list of roles for the user.
   *
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[] = [];

  /**
   * Connector is the connector used to create the user.
   *
   * @generated from field: string Connector = 5;
   */
  Connector = "";

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 6;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<UserUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserUpdate {
    return new UserUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserUpdate {
    return new UserUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserUpdate {
    return new UserUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: UserUpdate | PlainMessage<UserUpdate> | undefined, b: UserUpdate | PlainMessage<UserUpdate> | undefined): boolean {
    return proto3.util.equals(UserUpdate, a, b);
  }
}

/**
 * UserDelete is emitted when a user gets deleted
 *
 * @generated from message events.UserDelete
 */
export class UserDelete extends Message<UserDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<UserDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDelete {
    return new UserDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDelete {
    return new UserDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDelete {
    return new UserDelete().fromJsonString(jsonString, options);
  }

  static equals(a: UserDelete | PlainMessage<UserDelete> | undefined, b: UserDelete | PlainMessage<UserDelete> | undefined): boolean {
    return proto3.util.equals(UserDelete, a, b);
  }
}

/**
 * UserPasswordChange is emitted when the user changes their own password.
 *
 * @generated from message events.UserPasswordChange
 */
export class UserPasswordChange extends Message<UserPasswordChange> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<UserPasswordChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserPasswordChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPasswordChange {
    return new UserPasswordChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPasswordChange {
    return new UserPasswordChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPasswordChange {
    return new UserPasswordChange().fromJsonString(jsonString, options);
  }

  static equals(a: UserPasswordChange | PlainMessage<UserPasswordChange> | undefined, b: UserPasswordChange | PlainMessage<UserPasswordChange> | undefined): boolean {
    return proto3.util.equals(UserPasswordChange, a, b);
  }
}

/**
 * AccessRequestCreate is emitted when access request has been created or updated
 *
 * @generated from message events.AccessRequestCreate
 */
export class AccessRequestCreate extends Message<AccessRequestCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * Roles is a list of roles for the user.
   *
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[] = [];

  /**
   * RequestID is access request ID
   *
   * @generated from field: string RequestID = 5;
   */
  RequestID = "";

  /**
   * RequestState is access request state (in the access_request.review variant of
   * the event this represents the post-review state of the request).
   *
   * @generated from field: string RequestState = 6;
   */
  RequestState = "";

  /**
   * Delegator is used by teleport plugins to indicate the identity
   * which caused them to update state.
   *
   * @generated from field: string Delegator = 7;
   */
  Delegator = "";

  /**
   * Reason is an optional description of why the request is being
   * created or updated.
   *
   * @generated from field: string Reason = 8;
   */
  Reason = "";

  /**
   * Annotations is an optional set of attributes supplied by a plugin during
   * approval/denial of the request.
   *
   * @generated from field: google.protobuf.Struct Annotations = 9;
   */
  Annotations?: Struct;

  /**
   * Reviewer is the author of the review (only used in the access_request.review event variant).
   *
   * @generated from field: string Reviewer = 10;
   */
  Reviewer = "";

  /**
   * ProposedState is the state proposed by a review (only used in the access_request.review event
   * variant).
   *
   * @generated from field: string ProposedState = 11;
   */
  ProposedState = "";

  /**
   * RequestedResourceIDs is the set of resources to which access is being requested.
   *
   * @generated from field: repeated events.ResourceID RequestedResourceIDs = 12;
   */
  RequestedResourceIDs: ResourceID[] = [];

  /**
   * MaxDuration indicates how long the access should be granted for.
   *
   * @generated from field: google.protobuf.Timestamp MaxDuration = 13;
   */
  MaxDuration?: Timestamp;

  /**
   * PromotedAccessListName is the name of the access list that this request
   * was promoted to.
   * This field is only populated when the request is in the PROMOTED state.
   *
   * @generated from field: string PromotedAccessListName = 15;
   */
  PromotedAccessListName = "";

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 16;
   */
  AssumeStartTime?: Timestamp;

  constructor(data?: PartialMessage<AccessRequestCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessRequestCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "RequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RequestState", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Delegator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Annotations", kind: "message", T: Struct },
    { no: 10, name: "Reviewer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "ProposedState", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "RequestedResourceIDs", kind: "message", T: ResourceID, repeated: true },
    { no: 13, name: "MaxDuration", kind: "message", T: Timestamp },
    { no: 15, name: "PromotedAccessListName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "AssumeStartTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestCreate {
    return new AccessRequestCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestCreate {
    return new AccessRequestCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestCreate {
    return new AccessRequestCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestCreate | PlainMessage<AccessRequestCreate> | undefined, b: AccessRequestCreate | PlainMessage<AccessRequestCreate> | undefined): boolean {
    return proto3.util.equals(AccessRequestCreate, a, b);
  }
}

/**
 * ResourceID is a unique identifier for a teleport resource. This is duplicated
 * from api/types/types.proto to decouple the api and events types and because
 * neither file currently imports the other.
 *
 * @generated from message events.ResourceID
 */
export class ResourceID extends Message<ResourceID> {
  /**
   * ClusterName is the name of the cluster the resource is in.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 2;
   */
  Kind = "";

  /**
   * Name is the name of the specific resource.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * SubResourceName is the resource belonging to resource identified by "Name"
   * that the user is allowed to access to.
   * When granting access to a subresource, access to other resources is limited.
   * Currently it just supports resources of Kind=pod and the format is the following
   * "<kube_namespace>/<kube_pod>".
   *
   * @generated from field: string SubResourceName = 4;
   */
  SubResourceName = "";

  constructor(data?: PartialMessage<ResourceID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ResourceID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "SubResourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceID {
    return new ResourceID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceID {
    return new ResourceID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceID {
    return new ResourceID().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceID | PlainMessage<ResourceID> | undefined, b: ResourceID | PlainMessage<ResourceID> | undefined): boolean {
    return proto3.util.equals(ResourceID, a, b);
  }
}

/**
 * AccessRequestDelete is emitted when an access request has been deleted.
 *
 * @generated from message events.AccessRequestDelete
 */
export class AccessRequestDelete extends Message<AccessRequestDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * RequestID is access request ID
   *
   * @generated from field: string RequestID = 3;
   */
  RequestID = "";

  constructor(data?: PartialMessage<AccessRequestDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessRequestDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "RequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestDelete {
    return new AccessRequestDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestDelete {
    return new AccessRequestDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestDelete {
    return new AccessRequestDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestDelete | PlainMessage<AccessRequestDelete> | undefined, b: AccessRequestDelete | PlainMessage<AccessRequestDelete> | undefined): boolean {
    return proto3.util.equals(AccessRequestDelete, a, b);
  }
}

/**
 * PortForward is emitted when a user requests port forwarding.
 *
 * @generated from message events.PortForward
 */
export class PortForward extends Message<PortForward> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status contains operation success or failure status
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  /**
   * Addr is a target port forwarding address
   *
   * @generated from field: string Addr = 5;
   */
  Addr = "";

  constructor(data?: PartialMessage<PortForward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PortForward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
    { no: 5, name: "Addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortForward {
    return new PortForward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortForward {
    return new PortForward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortForward {
    return new PortForward().fromJsonString(jsonString, options);
  }

  static equals(a: PortForward | PlainMessage<PortForward> | undefined, b: PortForward | PlainMessage<PortForward> | undefined): boolean {
    return proto3.util.equals(PortForward, a, b);
  }
}

/**
 * X11Forward is emitted when a user requests X11 protocol forwarding
 *
 * @generated from message events.X11Forward
 */
export class X11Forward extends Message<X11Forward> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status contains operation success or failure status
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<X11Forward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.X11Forward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): X11Forward {
    return new X11Forward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): X11Forward {
    return new X11Forward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): X11Forward {
    return new X11Forward().fromJsonString(jsonString, options);
  }

  static equals(a: X11Forward | PlainMessage<X11Forward> | undefined, b: X11Forward | PlainMessage<X11Forward> | undefined): boolean {
    return proto3.util.equals(X11Forward, a, b);
  }
}

/**
 * CommandMetadata specifies common command fields
 *
 * @generated from message events.CommandMetadata
 */
export class CommandMetadata extends Message<CommandMetadata> {
  /**
   * Command is the executed command name
   *
   * @generated from field: string Command = 1;
   */
  Command = "";

  /**
   * ExitCode specifies command exit code
   *
   * @generated from field: string ExitCode = 2;
   */
  ExitCode = "";

  /**
   * Error is an optional exit error, set if command has failed
   *
   * @generated from field: string Error = 3;
   */
  Error = "";

  constructor(data?: PartialMessage<CommandMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CommandMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ExitCode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommandMetadata {
    return new CommandMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommandMetadata {
    return new CommandMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommandMetadata {
    return new CommandMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CommandMetadata | PlainMessage<CommandMetadata> | undefined, b: CommandMetadata | PlainMessage<CommandMetadata> | undefined): boolean {
    return proto3.util.equals(CommandMetadata, a, b);
  }
}

/**
 * Exec specifies command exec event
 *
 * @generated from message events.Exec
 */
export class Exec extends Message<Exec> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 4;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 5;
   */
  Server?: ServerMetadata;

  /**
   * CommandMetadata is a common command metadata
   *
   * @generated from field: events.CommandMetadata Command = 6;
   */
  Command?: CommandMetadata;

  /**
   * KubernetesCluster has information about a kubernetes cluster, if
   * applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata KubernetesCluster = 7;
   */
  KubernetesCluster?: KubernetesClusterMetadata;

  /**
   * KubernetesPod has information about a kubernetes pod, if applicable.
   *
   * @generated from field: events.KubernetesPodMetadata KubernetesPod = 8;
   */
  KubernetesPod?: KubernetesPodMetadata;

  constructor(data?: PartialMessage<Exec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Exec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Session", kind: "message", T: SessionMetadata },
    { no: 5, name: "Server", kind: "message", T: ServerMetadata },
    { no: 6, name: "Command", kind: "message", T: CommandMetadata },
    { no: 7, name: "KubernetesCluster", kind: "message", T: KubernetesClusterMetadata },
    { no: 8, name: "KubernetesPod", kind: "message", T: KubernetesPodMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exec {
    return new Exec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exec {
    return new Exec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exec {
    return new Exec().fromJsonString(jsonString, options);
  }

  static equals(a: Exec | PlainMessage<Exec> | undefined, b: Exec | PlainMessage<Exec> | undefined): boolean {
    return proto3.util.equals(Exec, a, b);
  }
}

/**
 * SCP is emitted when data transfer has occurred between server and client
 *
 * @generated from message events.SCP
 */
export class SCP extends Message<SCP> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 4;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 5;
   */
  Server?: ServerMetadata;

  /**
   * CommandMetadata is a common command metadata
   *
   * @generated from field: events.CommandMetadata Command = 6;
   */
  Command?: CommandMetadata;

  /**
   * Path is a copy path
   *
   * @generated from field: string Path = 7;
   */
  Path = "";

  /**
   * Action is upload or download
   *
   * @generated from field: string Action = 8;
   */
  Action = "";

  constructor(data?: PartialMessage<SCP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SCP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Session", kind: "message", T: SessionMetadata },
    { no: 5, name: "Server", kind: "message", T: ServerMetadata },
    { no: 6, name: "Command", kind: "message", T: CommandMetadata },
    { no: 7, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SCP {
    return new SCP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SCP {
    return new SCP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SCP {
    return new SCP().fromJsonString(jsonString, options);
  }

  static equals(a: SCP | PlainMessage<SCP> | undefined, b: SCP | PlainMessage<SCP> | undefined): boolean {
    return proto3.util.equals(SCP, a, b);
  }
}

/**
 * SFTPAttributes are file metadata sent over SFTP
 *
 * @generated from message events.SFTPAttributes
 */
export class SFTPAttributes extends Message<SFTPAttributes> {
  /**
   * FileSize is file size
   *
   * @generated from field: google.protobuf.UInt64Value FileSize = 1;
   */
  FileSize?: bigint;

  /**
   * UID is the user owner of a file
   *
   * @generated from field: google.protobuf.UInt32Value UID = 2;
   */
  UID?: number;

  /**
   * GID is the group owner of the file
   *
   * @generated from field: google.protobuf.UInt32Value GID = 3;
   */
  GID?: number;

  /**
   * Permissions is the file permissions
   *
   * @generated from field: google.protobuf.UInt32Value Permissions = 4;
   */
  Permissions?: number;

  /**
   * AccessTime is when the file was last read
   *
   * @generated from field: google.protobuf.Timestamp AccessTime = 5;
   */
  AccessTime?: Timestamp;

  /**
   * ModificationTime was when the file was last changed
   *
   * @generated from field: google.protobuf.Timestamp ModificationTime = 6;
   */
  ModificationTime?: Timestamp;

  constructor(data?: PartialMessage<SFTPAttributes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SFTPAttributes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "FileSize", kind: "message", T: UInt64Value },
    { no: 2, name: "UID", kind: "message", T: UInt32Value },
    { no: 3, name: "GID", kind: "message", T: UInt32Value },
    { no: 4, name: "Permissions", kind: "message", T: UInt32Value },
    { no: 5, name: "AccessTime", kind: "message", T: Timestamp },
    { no: 6, name: "ModificationTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFTPAttributes {
    return new SFTPAttributes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFTPAttributes {
    return new SFTPAttributes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFTPAttributes {
    return new SFTPAttributes().fromJsonString(jsonString, options);
  }

  static equals(a: SFTPAttributes | PlainMessage<SFTPAttributes> | undefined, b: SFTPAttributes | PlainMessage<SFTPAttributes> | undefined): boolean {
    return proto3.util.equals(SFTPAttributes, a, b);
  }
}

/**
 * SFTP is emitted when file operations have occurred between server and client
 *
 * @generated from message events.SFTP
 */
export class SFTP extends Message<SFTP> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 4;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 5;
   */
  Server?: ServerMetadata;

  /**
   * WorkingDirectory is the current directory the SFTP server is in
   *
   * @generated from field: string WorkingDirectory = 6;
   */
  WorkingDirectory = "";

  /**
   * Path is the filepath that was operated on. It is the exact path that
   * was sent by the client, so it may be relative or absolute.
   *
   * @generated from field: string Path = 7;
   */
  Path = "";

  /**
   * TargetPath is the new path in file renames, or the path of the symlink
   * when creating symlinks. It is the exact path that wassent by the client,
   * so it may be relative or absolute.
   *
   * @generated from field: string TargetPath = 8;
   */
  TargetPath = "";

  /**
   * Flags is options that were passed that affect file creation events
   *
   * @generated from field: uint32 Flags = 9;
   */
  Flags = 0;

  /**
   * Attributes is file metadata that the user requested to be changed
   *
   * @generated from field: events.SFTPAttributes Attributes = 10;
   */
  Attributes?: SFTPAttributes;

  /**
   * Action is what kind of file operation
   *
   * @generated from field: events.SFTPAction Action = 11;
   */
  Action = SFTPAction.INVALID;

  /**
   * Error is the optional error that may have occurred
   *
   * @generated from field: string Error = 12;
   */
  Error = "";

  constructor(data?: PartialMessage<SFTP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SFTP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Session", kind: "message", T: SessionMetadata },
    { no: 5, name: "Server", kind: "message", T: ServerMetadata },
    { no: 6, name: "WorkingDirectory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "TargetPath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "Attributes", kind: "message", T: SFTPAttributes },
    { no: 11, name: "Action", kind: "enum", T: proto3.getEnumType(SFTPAction) },
    { no: 12, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SFTP {
    return new SFTP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SFTP {
    return new SFTP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SFTP {
    return new SFTP().fromJsonString(jsonString, options);
  }

  static equals(a: SFTP | PlainMessage<SFTP> | undefined, b: SFTP | PlainMessage<SFTP> | undefined): boolean {
    return proto3.util.equals(SFTP, a, b);
  }
}

/**
 * Subsystem is emitted when a user requests a new subsystem.
 *
 * @generated from message events.Subsystem
 */
export class Subsystem extends Message<Subsystem> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * Name is a subsystem name
   *
   * @generated from field: string Name = 4;
   */
  Name = "";

  /**
   * Error contains error in case of unsucessfull attempt
   *
   * @generated from field: string Error = 5;
   */
  Error = "";

  constructor(data?: PartialMessage<Subsystem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Subsystem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subsystem {
    return new Subsystem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subsystem {
    return new Subsystem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subsystem {
    return new Subsystem().fromJsonString(jsonString, options);
  }

  static equals(a: Subsystem | PlainMessage<Subsystem> | undefined, b: Subsystem | PlainMessage<Subsystem> | undefined): boolean {
    return proto3.util.equals(Subsystem, a, b);
  }
}

/**
 * ClientDisconnect is emitted when client is disconnected
 * by the server due to inactivity or any other reason
 *
 * @generated from message events.ClientDisconnect
 */
export class ClientDisconnect extends Message<ClientDisconnect> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * Reason is a field that specifies reason for event, e.g. in disconnect
   * event it explains why server disconnected the client
   *
   * @generated from field: string Reason = 5;
   */
  Reason = "";

  constructor(data?: PartialMessage<ClientDisconnect>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ClientDisconnect";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientDisconnect {
    return new ClientDisconnect().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientDisconnect {
    return new ClientDisconnect().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientDisconnect {
    return new ClientDisconnect().fromJsonString(jsonString, options);
  }

  static equals(a: ClientDisconnect | PlainMessage<ClientDisconnect> | undefined, b: ClientDisconnect | PlainMessage<ClientDisconnect> | undefined): boolean {
    return proto3.util.equals(ClientDisconnect, a, b);
  }
}

/**
 * AuthAttempt is emitted upon a failed or successfull authentication attempt.
 *
 * @generated from message events.AuthAttempt
 */
export class AuthAttempt extends Message<AuthAttempt> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status contains common command or operation status fields
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AuthAttempt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AuthAttempt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthAttempt {
    return new AuthAttempt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthAttempt {
    return new AuthAttempt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthAttempt {
    return new AuthAttempt().fromJsonString(jsonString, options);
  }

  static equals(a: AuthAttempt | PlainMessage<AuthAttempt> | undefined, b: AuthAttempt | PlainMessage<AuthAttempt> | undefined): boolean {
    return proto3.util.equals(AuthAttempt, a, b);
  }
}

/**
 * UserTokenCreate is emitted when a user token is created.
 *
 * @generated from message events.UserTokenCreate
 */
export class UserTokenCreate extends Message<UserTokenCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<UserTokenCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UserTokenCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserTokenCreate {
    return new UserTokenCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserTokenCreate {
    return new UserTokenCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserTokenCreate {
    return new UserTokenCreate().fromJsonString(jsonString, options);
  }

  static equals(a: UserTokenCreate | PlainMessage<UserTokenCreate> | undefined, b: UserTokenCreate | PlainMessage<UserTokenCreate> | undefined): boolean {
    return proto3.util.equals(UserTokenCreate, a, b);
  }
}

/**
 * RoleCreate is emitted when a role is created/updated.
 *
 * @generated from message events.RoleCreate
 */
export class RoleCreate extends Message<RoleCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<RoleCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RoleCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleCreate {
    return new RoleCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleCreate {
    return new RoleCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleCreate {
    return new RoleCreate().fromJsonString(jsonString, options);
  }

  static equals(a: RoleCreate | PlainMessage<RoleCreate> | undefined, b: RoleCreate | PlainMessage<RoleCreate> | undefined): boolean {
    return proto3.util.equals(RoleCreate, a, b);
  }
}

/**
 * RoleUpdate is emitted when a role is updated.
 *
 * @generated from message events.RoleUpdate
 */
export class RoleUpdate extends Message<RoleUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<RoleUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RoleUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleUpdate {
    return new RoleUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleUpdate {
    return new RoleUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleUpdate {
    return new RoleUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: RoleUpdate | PlainMessage<RoleUpdate> | undefined, b: RoleUpdate | PlainMessage<RoleUpdate> | undefined): boolean {
    return proto3.util.equals(RoleUpdate, a, b);
  }
}

/**
 * RoleDelete is emitted when a role is deleted
 *
 * @generated from message events.RoleDelete
 */
export class RoleDelete extends Message<RoleDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<RoleDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RoleDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleDelete {
    return new RoleDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleDelete {
    return new RoleDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleDelete {
    return new RoleDelete().fromJsonString(jsonString, options);
  }

  static equals(a: RoleDelete | PlainMessage<RoleDelete> | undefined, b: RoleDelete | PlainMessage<RoleDelete> | undefined): boolean {
    return proto3.util.equals(RoleDelete, a, b);
  }
}

/**
 * BotCreate is emitted when a bot is created/upserted.
 *
 * @generated from message events.BotCreate
 */
export class BotCreate extends Message<BotCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BotCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BotCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotCreate {
    return new BotCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotCreate {
    return new BotCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotCreate {
    return new BotCreate().fromJsonString(jsonString, options);
  }

  static equals(a: BotCreate | PlainMessage<BotCreate> | undefined, b: BotCreate | PlainMessage<BotCreate> | undefined): boolean {
    return proto3.util.equals(BotCreate, a, b);
  }
}

/**
 * BotCreate is emitted when a bot is created/updated.
 *
 * @generated from message events.BotUpdate
 */
export class BotUpdate extends Message<BotUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BotUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BotUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotUpdate {
    return new BotUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotUpdate {
    return new BotUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotUpdate {
    return new BotUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: BotUpdate | PlainMessage<BotUpdate> | undefined, b: BotUpdate | PlainMessage<BotUpdate> | undefined): boolean {
    return proto3.util.equals(BotUpdate, a, b);
  }
}

/**
 * BotDelete is emitted when a bot is deleted.
 *
 * @generated from message events.BotDelete
 */
export class BotDelete extends Message<BotDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BotDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BotDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotDelete {
    return new BotDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotDelete {
    return new BotDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotDelete {
    return new BotDelete().fromJsonString(jsonString, options);
  }

  static equals(a: BotDelete | PlainMessage<BotDelete> | undefined, b: BotDelete | PlainMessage<BotDelete> | undefined): boolean {
    return proto3.util.equals(BotDelete, a, b);
  }
}

/**
 * TrustedClusterCreate is the event for creating a trusted cluster.
 *
 * @generated from message events.TrustedClusterCreate
 */
export class TrustedClusterCreate extends Message<TrustedClusterCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<TrustedClusterCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.TrustedClusterCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterCreate {
    return new TrustedClusterCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterCreate {
    return new TrustedClusterCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterCreate {
    return new TrustedClusterCreate().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterCreate | PlainMessage<TrustedClusterCreate> | undefined, b: TrustedClusterCreate | PlainMessage<TrustedClusterCreate> | undefined): boolean {
    return proto3.util.equals(TrustedClusterCreate, a, b);
  }
}

/**
 * TrustedClusterDelete is the event for removing a trusted cluster.
 *
 * @generated from message events.TrustedClusterDelete
 */
export class TrustedClusterDelete extends Message<TrustedClusterDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<TrustedClusterDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.TrustedClusterDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterDelete {
    return new TrustedClusterDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterDelete {
    return new TrustedClusterDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterDelete {
    return new TrustedClusterDelete().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterDelete | PlainMessage<TrustedClusterDelete> | undefined, b: TrustedClusterDelete | PlainMessage<TrustedClusterDelete> | undefined): boolean {
    return proto3.util.equals(TrustedClusterDelete, a, b);
  }
}

/**
 * ProvisionTokenCreate event is emitted when a provisioning token (a.k.a. join
 * token) of any role is created.
 *
 * @generated from message events.ProvisionTokenCreate
 */
export class ProvisionTokenCreate extends Message<ProvisionTokenCreate> {
  /**
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[] = [];

  /**
   * @generated from field: string JoinMethod = 5;
   */
  JoinMethod = "";

  constructor(data?: PartialMessage<ProvisionTokenCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ProvisionTokenCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "JoinMethod", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenCreate {
    return new ProvisionTokenCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenCreate {
    return new ProvisionTokenCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenCreate {
    return new ProvisionTokenCreate().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenCreate | PlainMessage<ProvisionTokenCreate> | undefined, b: ProvisionTokenCreate | PlainMessage<ProvisionTokenCreate> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenCreate, a, b);
  }
}

/**
 * TrustedClusterTokenCreate event is emitted (in addition to
 * ProvisionTokenCreate) when a token of a "Trusted_cluster" role is created.
 *
 * Deprecated: redundant, since we also emit ProvisionTokenCreate.
 *
 * @generated from message events.TrustedClusterTokenCreate
 */
export class TrustedClusterTokenCreate extends Message<TrustedClusterTokenCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<TrustedClusterTokenCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.TrustedClusterTokenCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterTokenCreate {
    return new TrustedClusterTokenCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterTokenCreate {
    return new TrustedClusterTokenCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterTokenCreate {
    return new TrustedClusterTokenCreate().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterTokenCreate | PlainMessage<TrustedClusterTokenCreate> | undefined, b: TrustedClusterTokenCreate | PlainMessage<TrustedClusterTokenCreate> | undefined): boolean {
    return proto3.util.equals(TrustedClusterTokenCreate, a, b);
  }
}

/**
 * GithubConnectorCreate fires when a Github connector is created.
 *
 * @generated from message events.GithubConnectorCreate
 */
export class GithubConnectorCreate extends Message<GithubConnectorCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<GithubConnectorCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.GithubConnectorCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorCreate {
    return new GithubConnectorCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorCreate {
    return new GithubConnectorCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorCreate {
    return new GithubConnectorCreate().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorCreate | PlainMessage<GithubConnectorCreate> | undefined, b: GithubConnectorCreate | PlainMessage<GithubConnectorCreate> | undefined): boolean {
    return proto3.util.equals(GithubConnectorCreate, a, b);
  }
}

/**
 * GithubConnectorUpdate fires when a Github connector is updated.
 *
 * @generated from message events.GithubConnectorUpdate
 */
export class GithubConnectorUpdate extends Message<GithubConnectorUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<GithubConnectorUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.GithubConnectorUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorUpdate {
    return new GithubConnectorUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorUpdate {
    return new GithubConnectorUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorUpdate {
    return new GithubConnectorUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorUpdate | PlainMessage<GithubConnectorUpdate> | undefined, b: GithubConnectorUpdate | PlainMessage<GithubConnectorUpdate> | undefined): boolean {
    return proto3.util.equals(GithubConnectorUpdate, a, b);
  }
}

/**
 * GithubConnectorDelete fires when a Github connector is deleted.
 *
 * @generated from message events.GithubConnectorDelete
 */
export class GithubConnectorDelete extends Message<GithubConnectorDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<GithubConnectorDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.GithubConnectorDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorDelete {
    return new GithubConnectorDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorDelete {
    return new GithubConnectorDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorDelete {
    return new GithubConnectorDelete().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorDelete | PlainMessage<GithubConnectorDelete> | undefined, b: GithubConnectorDelete | PlainMessage<GithubConnectorDelete> | undefined): boolean {
    return proto3.util.equals(GithubConnectorDelete, a, b);
  }
}

/**
 * OIDCConnectorCreate fires when OIDC connector is created.
 *
 * @generated from message events.OIDCConnectorCreate
 */
export class OIDCConnectorCreate extends Message<OIDCConnectorCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<OIDCConnectorCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OIDCConnectorCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorCreate {
    return new OIDCConnectorCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorCreate {
    return new OIDCConnectorCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorCreate {
    return new OIDCConnectorCreate().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorCreate | PlainMessage<OIDCConnectorCreate> | undefined, b: OIDCConnectorCreate | PlainMessage<OIDCConnectorCreate> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorCreate, a, b);
  }
}

/**
 * OIDCConnectorUpdate fires when OIDC connector is updated.
 *
 * @generated from message events.OIDCConnectorUpdate
 */
export class OIDCConnectorUpdate extends Message<OIDCConnectorUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<OIDCConnectorUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OIDCConnectorUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorUpdate {
    return new OIDCConnectorUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorUpdate {
    return new OIDCConnectorUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorUpdate {
    return new OIDCConnectorUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorUpdate | PlainMessage<OIDCConnectorUpdate> | undefined, b: OIDCConnectorUpdate | PlainMessage<OIDCConnectorUpdate> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorUpdate, a, b);
  }
}

/**
 * OIDCConnectorDelete fires when OIDC connector is deleted.
 *
 * @generated from message events.OIDCConnectorDelete
 */
export class OIDCConnectorDelete extends Message<OIDCConnectorDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<OIDCConnectorDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OIDCConnectorDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorDelete {
    return new OIDCConnectorDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorDelete {
    return new OIDCConnectorDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorDelete {
    return new OIDCConnectorDelete().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorDelete | PlainMessage<OIDCConnectorDelete> | undefined, b: OIDCConnectorDelete | PlainMessage<OIDCConnectorDelete> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorDelete, a, b);
  }
}

/**
 * SAMLConnectorCreate fires when SAML connector is created/updated.
 *
 * @generated from message events.SAMLConnectorCreate
 */
export class SAMLConnectorCreate extends Message<SAMLConnectorCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * Connector is the new SAML connector
   *
   * @generated from field: types.SAMLConnectorV2 Connector = 4;
   */
  Connector?: SAMLConnectorV2;

  constructor(data?: PartialMessage<SAMLConnectorCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLConnectorCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connector", kind: "message", T: SAMLConnectorV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorCreate {
    return new SAMLConnectorCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorCreate {
    return new SAMLConnectorCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorCreate {
    return new SAMLConnectorCreate().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorCreate | PlainMessage<SAMLConnectorCreate> | undefined, b: SAMLConnectorCreate | PlainMessage<SAMLConnectorCreate> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorCreate, a, b);
  }
}

/**
 * SAMLConnectorUpdate fires when SAML connector is updated.
 *
 * @generated from message events.SAMLConnectorUpdate
 */
export class SAMLConnectorUpdate extends Message<SAMLConnectorUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * Connector is the updated SAML connector
   *
   * @generated from field: types.SAMLConnectorV2 Connector = 4;
   */
  Connector?: SAMLConnectorV2;

  constructor(data?: PartialMessage<SAMLConnectorUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLConnectorUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connector", kind: "message", T: SAMLConnectorV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorUpdate {
    return new SAMLConnectorUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorUpdate {
    return new SAMLConnectorUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorUpdate {
    return new SAMLConnectorUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorUpdate | PlainMessage<SAMLConnectorUpdate> | undefined, b: SAMLConnectorUpdate | PlainMessage<SAMLConnectorUpdate> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorUpdate, a, b);
  }
}

/**
 * SAMLConnectorDelete fires when SAML connector is deleted.
 *
 * @generated from message events.SAMLConnectorDelete
 */
export class SAMLConnectorDelete extends Message<SAMLConnectorDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<SAMLConnectorDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLConnectorDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorDelete {
    return new SAMLConnectorDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorDelete {
    return new SAMLConnectorDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorDelete {
    return new SAMLConnectorDelete().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorDelete | PlainMessage<SAMLConnectorDelete> | undefined, b: SAMLConnectorDelete | PlainMessage<SAMLConnectorDelete> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorDelete, a, b);
  }
}

/**
 * KubeRequest specifies a Kubernetes API request event.
 *
 * @generated from message events.KubeRequest
 */
export class KubeRequest extends Message<KubeRequest> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * RequestPath is the raw request URL path.
   *
   * @generated from field: string RequestPath = 5;
   */
  RequestPath = "";

  /**
   * Verb is the HTTP verb used for this request (e.g. GET, POST, etc)
   *
   * @generated from field: string Verb = 6;
   */
  Verb = "";

  /**
   * ResourceAPIGroup is the resource API group.
   *
   * @generated from field: string ResourceAPIGroup = 7;
   */
  ResourceAPIGroup = "";

  /**
   * ResourceNamespace is the resource namespace.
   *
   * @generated from field: string ResourceNamespace = 8;
   */
  ResourceNamespace = "";

  /**
   * ResourceKind is the API resource kind (e.g. "pod", "service", etc).
   *
   * @generated from field: string ResourceKind = 9;
   */
  ResourceKind = "";

  /**
   * ResourceName is the API resource name.
   *
   * @generated from field: string ResourceName = 10;
   */
  ResourceName = "";

  /**
   * ResponseCode is the HTTP response code for this request.
   *
   * @generated from field: int32 ResponseCode = 11;
   */
  ResponseCode = 0;

  /**
   * Kubernetes has information about a kubernetes cluster, if applicable.
   *
   * @generated from field: events.KubernetesClusterMetadata Kubernetes = 12;
   */
  Kubernetes?: KubernetesClusterMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 13;
   */
  Session?: SessionMetadata;

  constructor(data?: PartialMessage<KubeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "RequestPath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Verb", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ResourceAPIGroup", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ResourceNamespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ResourceKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "ResourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "ResponseCode", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 12, name: "Kubernetes", kind: "message", T: KubernetesClusterMetadata },
    { no: 13, name: "Session", kind: "message", T: SessionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubeRequest {
    return new KubeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubeRequest {
    return new KubeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubeRequest {
    return new KubeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: KubeRequest | PlainMessage<KubeRequest> | undefined, b: KubeRequest | PlainMessage<KubeRequest> | undefined): boolean {
    return proto3.util.equals(KubeRequest, a, b);
  }
}

/**
 * AppMetadata contains common application information.
 *
 * @generated from message events.AppMetadata
 */
export class AppMetadata extends Message<AppMetadata> {
  /**
   * AppURI is the application endpoint.
   *
   * @generated from field: string AppURI = 1;
   */
  AppURI = "";

  /**
   * AppPublicAddr is the configured application public address.
   *
   * @generated from field: string AppPublicAddr = 2;
   */
  AppPublicAddr = "";

  /**
   * AppLabels are the configured application labels.
   *
   * @generated from field: map<string, string> AppLabels = 3;
   */
  AppLabels: { [key: string]: string } = {};

  /**
   * AppName is the configured application name.
   *
   * @generated from field: string AppName = 4;
   */
  AppName = "";

  constructor(data?: PartialMessage<AppMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AppURI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AppPublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "AppLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "AppName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppMetadata {
    return new AppMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppMetadata {
    return new AppMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppMetadata {
    return new AppMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AppMetadata | PlainMessage<AppMetadata> | undefined, b: AppMetadata | PlainMessage<AppMetadata> | undefined): boolean {
    return proto3.util.equals(AppMetadata, a, b);
  }
}

/**
 * AppCreate is emitted when a new application resource is created.
 *
 * @generated from message events.AppCreate
 */
export class AppCreate extends Message<AppCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * AppMetadata is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 4;
   */
  App?: AppMetadata;

  constructor(data?: PartialMessage<AppCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "App", kind: "message", T: AppMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppCreate {
    return new AppCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppCreate {
    return new AppCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppCreate {
    return new AppCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AppCreate | PlainMessage<AppCreate> | undefined, b: AppCreate | PlainMessage<AppCreate> | undefined): boolean {
    return proto3.util.equals(AppCreate, a, b);
  }
}

/**
 * AppUpdate is emitted when an existing application resource is updated.
 *
 * @generated from message events.AppUpdate
 */
export class AppUpdate extends Message<AppUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * AppMetadata is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 4;
   */
  App?: AppMetadata;

  constructor(data?: PartialMessage<AppUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "App", kind: "message", T: AppMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppUpdate {
    return new AppUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppUpdate {
    return new AppUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppUpdate {
    return new AppUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AppUpdate | PlainMessage<AppUpdate> | undefined, b: AppUpdate | PlainMessage<AppUpdate> | undefined): boolean {
    return proto3.util.equals(AppUpdate, a, b);
  }
}

/**
 * AppDelete is emitted when an application resource is deleted.
 *
 * @generated from message events.AppDelete
 */
export class AppDelete extends Message<AppDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  constructor(data?: PartialMessage<AppDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDelete {
    return new AppDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDelete {
    return new AppDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDelete {
    return new AppDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AppDelete | PlainMessage<AppDelete> | undefined, b: AppDelete | PlainMessage<AppDelete> | undefined): boolean {
    return proto3.util.equals(AppDelete, a, b);
  }
}

/**
 * AppSessionStart is emitted when a user is issued an application certificate.
 *
 * @generated from message events.AppSessionStart
 */
export class AppSessionStart extends Message<AppSessionStart> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * PublicAddr is the public address of the application being requested.
   * DELETE IN 10.0: this information is also present on the AppMetadata.
   *
   * @generated from field: string PublicAddr = 7 [deprecated = true];
   * @deprecated
   */
  PublicAddr = "";

  /**
   * App is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 8;
   */
  App?: AppMetadata;

  constructor(data?: PartialMessage<AppSessionStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppSessionStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 7, name: "PublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "App", kind: "message", T: AppMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSessionStart {
    return new AppSessionStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSessionStart {
    return new AppSessionStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSessionStart {
    return new AppSessionStart().fromJsonString(jsonString, options);
  }

  static equals(a: AppSessionStart | PlainMessage<AppSessionStart> | undefined, b: AppSessionStart | PlainMessage<AppSessionStart> | undefined): boolean {
    return proto3.util.equals(AppSessionStart, a, b);
  }
}

/**
 * AppSessionEnd is emitted when an application session ends.
 *
 * @generated from message events.AppSessionEnd
 */
export class AppSessionEnd extends Message<AppSessionEnd> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * App is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 6;
   */
  App?: AppMetadata;

  constructor(data?: PartialMessage<AppSessionEnd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppSessionEnd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "App", kind: "message", T: AppMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSessionEnd {
    return new AppSessionEnd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSessionEnd {
    return new AppSessionEnd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSessionEnd {
    return new AppSessionEnd().fromJsonString(jsonString, options);
  }

  static equals(a: AppSessionEnd | PlainMessage<AppSessionEnd> | undefined, b: AppSessionEnd | PlainMessage<AppSessionEnd> | undefined): boolean {
    return proto3.util.equals(AppSessionEnd, a, b);
  }
}

/**
 * AppSessionChunk is emitted at the start of a 5 minute chunk on each
 * proxy. This chunk is used to buffer 5 minutes of audit events at a time
 * for applications.
 *
 * @generated from message events.AppSessionChunk
 */
export class AppSessionChunk extends Message<AppSessionChunk> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * ServerMetadata is a common server metadata
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * SessionChunkID is the ID of the session that was created for this 5 minute
   * application log chunk.
   *
   * @generated from field: string SessionChunkID = 6;
   */
  SessionChunkID = "";

  /**
   * App is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 7;
   */
  App?: AppMetadata;

  constructor(data?: PartialMessage<AppSessionChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppSessionChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "SessionChunkID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "App", kind: "message", T: AppMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSessionChunk {
    return new AppSessionChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSessionChunk {
    return new AppSessionChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSessionChunk {
    return new AppSessionChunk().fromJsonString(jsonString, options);
  }

  static equals(a: AppSessionChunk | PlainMessage<AppSessionChunk> | undefined, b: AppSessionChunk | PlainMessage<AppSessionChunk> | undefined): boolean {
    return proto3.util.equals(AppSessionChunk, a, b);
  }
}

/**
 * AppSessionRequest is an HTTP request and response.
 *
 * @generated from message events.AppSessionRequest
 */
export class AppSessionRequest extends Message<AppSessionRequest> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * StatusCode the HTTP response code for the request.
   *
   * @generated from field: uint32 StatusCode = 2;
   */
  StatusCode = 0;

  /**
   * Path is relative path in the URL.
   *
   * @generated from field: string Path = 3;
   */
  Path = "";

  /**
   * RawQuery are the encoded query values.
   *
   * @generated from field: string RawQuery = 4;
   */
  RawQuery = "";

  /**
   * Method is the request HTTP method, like GET/POST/DELETE/etc.
   *
   * @generated from field: string Method = 5;
   */
  Method = "";

  /**
   * App is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 6;
   */
  App?: AppMetadata;

  /**
   * AWS contains extra AWS metadata of the request.
   *
   * @generated from field: events.AWSRequestMetadata AWS = 7;
   */
  AWS?: AWSRequestMetadata;

  constructor(data?: PartialMessage<AppSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "StatusCode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "RawQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "App", kind: "message", T: AppMetadata },
    { no: 7, name: "AWS", kind: "message", T: AWSRequestMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSessionRequest {
    return new AppSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSessionRequest {
    return new AppSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSessionRequest {
    return new AppSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppSessionRequest | PlainMessage<AppSessionRequest> | undefined, b: AppSessionRequest | PlainMessage<AppSessionRequest> | undefined): boolean {
    return proto3.util.equals(AppSessionRequest, a, b);
  }
}

/**
 * AWSRequestMetadata contains extra AWS metadata of an AppSessionRequest.
 *
 * @generated from message events.AWSRequestMetadata
 */
export class AWSRequestMetadata extends Message<AWSRequestMetadata> {
  /**
   * AWSRegion is the requested AWS region.
   *
   * @generated from field: string AWSRegion = 1;
   */
  AWSRegion = "";

  /**
   * AWSService is the requested AWS service name.
   *
   * @generated from field: string AWSService = 2;
   */
  AWSService = "";

  /**
   * AWSHost is the requested host of the AWS service.
   *
   * @generated from field: string AWSHost = 3;
   */
  AWSHost = "";

  /**
   * AWSAssumedRole is the assumed role that signed this request.
   *
   * @generated from field: string AWSAssumedRole = 4;
   */
  AWSAssumedRole = "";

  constructor(data?: PartialMessage<AWSRequestMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AWSRequestMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AWSRegion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AWSService", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "AWSHost", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AWSAssumedRole", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSRequestMetadata {
    return new AWSRequestMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSRequestMetadata {
    return new AWSRequestMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSRequestMetadata {
    return new AWSRequestMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AWSRequestMetadata | PlainMessage<AWSRequestMetadata> | undefined, b: AWSRequestMetadata | PlainMessage<AWSRequestMetadata> | undefined): boolean {
    return proto3.util.equals(AWSRequestMetadata, a, b);
  }
}

/**
 * DatabaseMetadata contains common database information.
 *
 * @generated from message events.DatabaseMetadata
 */
export class DatabaseMetadata extends Message<DatabaseMetadata> {
  /**
   * DatabaseService is the name of the database service proxying the database.
   *
   * @generated from field: string DatabaseService = 1;
   */
  DatabaseService = "";

  /**
   * DatabaseProtocol is the database type, e.g. postgres or mysql.
   *
   * @generated from field: string DatabaseProtocol = 2;
   */
  DatabaseProtocol = "";

  /**
   * DatabaseURI is the database URI to connect to.
   *
   * @generated from field: string DatabaseURI = 3;
   */
  DatabaseURI = "";

  /**
   * DatabaseName is the name of the database a user is connecting to.
   *
   * @generated from field: string DatabaseName = 4;
   */
  DatabaseName = "";

  /**
   * DatabaseUser is the database username used to connect.
   *
   * @generated from field: string DatabaseUser = 5;
   */
  DatabaseUser = "";

  /**
   * DatabaseLabels is the database resource labels.
   *
   * @generated from field: map<string, string> DatabaseLabels = 6;
   */
  DatabaseLabels: { [key: string]: string } = {};

  /**
   * DatabaseAWSRegion is AWS regions for AWS hosted databases.
   *
   * @generated from field: string DatabaseAWSRegion = 7;
   */
  DatabaseAWSRegion = "";

  /**
   * DatabaseAWSRegion is cluster ID for Redshift databases.
   *
   * @generated from field: string DatabaseAWSRedshiftClusterID = 8;
   */
  DatabaseAWSRedshiftClusterID = "";

  /**
   * DatabaseGCPProjectID is project ID for GCP hosted databases.
   *
   * @generated from field: string DatabaseGCPProjectID = 9;
   */
  DatabaseGCPProjectID = "";

  /**
   * DatabaseGCPInstanceID is instance ID for GCP hosted databases.
   *
   * @generated from field: string DatabaseGCPInstanceID = 10;
   */
  DatabaseGCPInstanceID = "";

  /**
   * DatabaseRoles is a list of database roles for auto-provisioned users.
   *
   * @generated from field: repeated string DatabaseRoles = 11;
   */
  DatabaseRoles: string[] = [];

  /**
   * DatabaseType is the database type.
   *
   * @generated from field: string DatabaseType = 12;
   */
  DatabaseType = "";

  /**
   * DatabaseOrigin is the database origin source.
   *
   * @generated from field: string DatabaseOrigin = 13;
   */
  DatabaseOrigin = "";

  constructor(data?: PartialMessage<DatabaseMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DatabaseService", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DatabaseProtocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "DatabaseURI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "DatabaseName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "DatabaseUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "DatabaseLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "DatabaseAWSRegion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DatabaseAWSRedshiftClusterID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "DatabaseGCPProjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "DatabaseGCPInstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "DatabaseRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "DatabaseType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "DatabaseOrigin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseMetadata {
    return new DatabaseMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseMetadata {
    return new DatabaseMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseMetadata {
    return new DatabaseMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseMetadata | PlainMessage<DatabaseMetadata> | undefined, b: DatabaseMetadata | PlainMessage<DatabaseMetadata> | undefined): boolean {
    return proto3.util.equals(DatabaseMetadata, a, b);
  }
}

/**
 * DatabaseCreate is emitted when a new database resource is created.
 *
 * @generated from message events.DatabaseCreate
 */
export class DatabaseCreate extends Message<DatabaseCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * DatabaseMetadata is a common database resource metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  constructor(data?: PartialMessage<DatabaseCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseCreate {
    return new DatabaseCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseCreate {
    return new DatabaseCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseCreate {
    return new DatabaseCreate().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseCreate | PlainMessage<DatabaseCreate> | undefined, b: DatabaseCreate | PlainMessage<DatabaseCreate> | undefined): boolean {
    return proto3.util.equals(DatabaseCreate, a, b);
  }
}

/**
 * DatabaseUpdate is emitted when an existing database resource is updated.
 *
 * @generated from message events.DatabaseUpdate
 */
export class DatabaseUpdate extends Message<DatabaseUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * DatabaseMetadata is a common database resource metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  constructor(data?: PartialMessage<DatabaseUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseUpdate {
    return new DatabaseUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseUpdate {
    return new DatabaseUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseUpdate {
    return new DatabaseUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseUpdate | PlainMessage<DatabaseUpdate> | undefined, b: DatabaseUpdate | PlainMessage<DatabaseUpdate> | undefined): boolean {
    return proto3.util.equals(DatabaseUpdate, a, b);
  }
}

/**
 * DatabaseDelete is emitted when a database resource is deleted.
 *
 * @generated from message events.DatabaseDelete
 */
export class DatabaseDelete extends Message<DatabaseDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  constructor(data?: PartialMessage<DatabaseDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseDelete {
    return new DatabaseDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseDelete {
    return new DatabaseDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseDelete {
    return new DatabaseDelete().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseDelete | PlainMessage<DatabaseDelete> | undefined, b: DatabaseDelete | PlainMessage<DatabaseDelete> | undefined): boolean {
    return proto3.util.equals(DatabaseDelete, a, b);
  }
}

/**
 * DatabaseSessionStart is emitted when a user connects to a database.
 *
 * @generated from message events.DatabaseSessionStart
 */
export class DatabaseSessionStart extends Message<DatabaseSessionStart> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Server is a common server metadata.
   *
   * @generated from field: events.ServerMetadata Server = 4;
   */
  Server?: ServerMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status indicates whether the connection was successful or denied.
   *
   * @generated from field: events.Status Status = 6;
   */
  Status?: Status;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 7;
   */
  Database?: DatabaseMetadata;

  constructor(data?: PartialMessage<DatabaseSessionStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseSessionStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Server", kind: "message", T: ServerMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 6, name: "Status", kind: "message", T: Status },
    { no: 7, name: "Database", kind: "message", T: DatabaseMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSessionStart {
    return new DatabaseSessionStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSessionStart {
    return new DatabaseSessionStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSessionStart {
    return new DatabaseSessionStart().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSessionStart | PlainMessage<DatabaseSessionStart> | undefined, b: DatabaseSessionStart | PlainMessage<DatabaseSessionStart> | undefined): boolean {
    return proto3.util.equals(DatabaseSessionStart, a, b);
  }
}

/**
 * DatabaseSessionQuery is emitted when a user executes a database query.
 *
 * @generated from message events.DatabaseSessionQuery
 */
export class DatabaseSessionQuery extends Message<DatabaseSessionQuery> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * DatabaseQuery is the executed query string.
   *
   * @generated from field: string DatabaseQuery = 5;
   */
  DatabaseQuery = "";

  /**
   * DatabaseQueryParameters are the query parameters for prepared statements.
   *
   * @generated from field: repeated string DatabaseQueryParameters = 6;
   */
  DatabaseQueryParameters: string[] = [];

  /**
   * Status indicates whether the query was successfully sent to the database.
   *
   * @generated from field: events.Status Status = 7;
   */
  Status?: Status;

  constructor(data?: PartialMessage<DatabaseSessionQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseSessionQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "DatabaseQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "DatabaseQueryParameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSessionQuery {
    return new DatabaseSessionQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSessionQuery {
    return new DatabaseSessionQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSessionQuery {
    return new DatabaseSessionQuery().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSessionQuery | PlainMessage<DatabaseSessionQuery> | undefined, b: DatabaseSessionQuery | PlainMessage<DatabaseSessionQuery> | undefined): boolean {
    return proto3.util.equals(DatabaseSessionQuery, a, b);
  }
}

/**
 * DatabaseSessionCommandResult represents the result of a user command. It is
 * expected that for each user command/query there will be a corresponding
 * result.
 *
 * @generated from message events.DatabaseSessionCommandResult
 */
export class DatabaseSessionCommandResult extends Message<DatabaseSessionCommandResult> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Status indicates if the command was successful or not.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * AfftectedRecords represents the number of records that were affected by the
   * command.
   *
   * @generated from field: uint64 AffectedRecords = 6;
   */
  AffectedRecords = protoInt64.zero;

  constructor(data?: PartialMessage<DatabaseSessionCommandResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseSessionCommandResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "AffectedRecords", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSessionCommandResult {
    return new DatabaseSessionCommandResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSessionCommandResult {
    return new DatabaseSessionCommandResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSessionCommandResult {
    return new DatabaseSessionCommandResult().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSessionCommandResult | PlainMessage<DatabaseSessionCommandResult> | undefined, b: DatabaseSessionCommandResult | PlainMessage<DatabaseSessionCommandResult> | undefined): boolean {
    return proto3.util.equals(DatabaseSessionCommandResult, a, b);
  }
}

/**
 * DatabasePermissionUpdate is emitted when a user database permissions are updated.
 *
 * @generated from message events.DatabasePermissionUpdate
 */
export class DatabasePermissionUpdate extends Message<DatabasePermissionUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * PermissionSummary is a summary of applied permissions.
   *
   * @generated from field: repeated events.DatabasePermissionEntry PermissionSummary = 5;
   */
  PermissionSummary: DatabasePermissionEntry[] = [];

  /**
   * AffectedObjectCounts counts how many distinct objects of each kind were affected.
   *
   * @generated from field: map<string, int32> AffectedObjectCounts = 6;
   */
  AffectedObjectCounts: { [key: string]: number } = {};

  constructor(data?: PartialMessage<DatabasePermissionUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabasePermissionUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "PermissionSummary", kind: "message", T: DatabasePermissionEntry, repeated: true },
    { no: 6, name: "AffectedObjectCounts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabasePermissionUpdate {
    return new DatabasePermissionUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabasePermissionUpdate {
    return new DatabasePermissionUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabasePermissionUpdate {
    return new DatabasePermissionUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DatabasePermissionUpdate | PlainMessage<DatabasePermissionUpdate> | undefined, b: DatabasePermissionUpdate | PlainMessage<DatabasePermissionUpdate> | undefined): boolean {
    return proto3.util.equals(DatabasePermissionUpdate, a, b);
  }
}

/**
 * DatabasePermissionEntry is a summary of permissions, scoped to a particular permission.
 *
 * @generated from message events.DatabasePermissionEntry
 */
export class DatabasePermissionEntry extends Message<DatabasePermissionEntry> {
  /**
   * Permission is a particular database-level permission, e.g. "SELECT".
   *
   * @generated from field: string Permission = 1;
   */
  Permission = "";

  /**
   * Counts stores information how many objects of particular kind (e.g. "table") were affected.
   *
   * @generated from field: map<string, int32> Counts = 2;
   */
  Counts: { [key: string]: number } = {};

  constructor(data?: PartialMessage<DatabasePermissionEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabasePermissionEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Counts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabasePermissionEntry {
    return new DatabasePermissionEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabasePermissionEntry {
    return new DatabasePermissionEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabasePermissionEntry {
    return new DatabasePermissionEntry().fromJsonString(jsonString, options);
  }

  static equals(a: DatabasePermissionEntry | PlainMessage<DatabasePermissionEntry> | undefined, b: DatabasePermissionEntry | PlainMessage<DatabasePermissionEntry> | undefined): boolean {
    return proto3.util.equals(DatabasePermissionEntry, a, b);
  }
}

/**
 * DatabaseUserCreate is emitted when a database user is provisioned.
 *
 * @generated from message events.DatabaseUserCreate
 */
export class DatabaseUserCreate extends Message<DatabaseUserCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Status indicates whether the operation was successful.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * Username is the username chosen for the database user. Due to database limitations (e.g. username length, allowed charset)
   * it may differ from Teleport username.
   *
   * @generated from field: string Username = 6;
   */
  Username = "";

  /**
   * Roles is an optional list of granted database roles.
   *
   * @generated from field: repeated string Roles = 7;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<DatabaseUserCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseUserCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseUserCreate {
    return new DatabaseUserCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseUserCreate {
    return new DatabaseUserCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseUserCreate {
    return new DatabaseUserCreate().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseUserCreate | PlainMessage<DatabaseUserCreate> | undefined, b: DatabaseUserCreate | PlainMessage<DatabaseUserCreate> | undefined): boolean {
    return proto3.util.equals(DatabaseUserCreate, a, b);
  }
}

/**
 * DatabaseUserDeactivate is emitted when a database user is disabled or deleted.
 *
 * @generated from message events.DatabaseUserDeactivate
 */
export class DatabaseUserDeactivate extends Message<DatabaseUserDeactivate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Status indicates whether the operation was successful.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * Username is the username chosen for the database user. Due to database limitations (e.g. username length, allowed charset)
   * it may differ from Teleport username.
   *
   * @generated from field: string Username = 6;
   */
  Username = "";

  /**
   * Delete indicates if the user was deleted entirely or merely disabled.
   *
   * @generated from field: bool Delete = 7;
   */
  Delete = false;

  constructor(data?: PartialMessage<DatabaseUserDeactivate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseUserDeactivate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Delete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseUserDeactivate {
    return new DatabaseUserDeactivate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseUserDeactivate {
    return new DatabaseUserDeactivate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseUserDeactivate {
    return new DatabaseUserDeactivate().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseUserDeactivate | PlainMessage<DatabaseUserDeactivate> | undefined, b: DatabaseUserDeactivate | PlainMessage<DatabaseUserDeactivate> | undefined): boolean {
    return proto3.util.equals(DatabaseUserDeactivate, a, b);
  }
}

/**
 * PostgresParse is emitted when a Postgres client creates a prepared statement
 * using extended query protocol.
 *
 * @generated from message events.PostgresParse
 */
export class PostgresParse extends Message<PostgresParse> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementName is the prepared statement name.
   *
   * @generated from field: string StatementName = 5;
   */
  StatementName = "";

  /**
   * Query is the prepared statement query.
   *
   * @generated from field: string Query = 6;
   */
  Query = "";

  constructor(data?: PartialMessage<PostgresParse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PostgresParse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresParse {
    return new PostgresParse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresParse {
    return new PostgresParse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresParse {
    return new PostgresParse().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresParse | PlainMessage<PostgresParse> | undefined, b: PostgresParse | PlainMessage<PostgresParse> | undefined): boolean {
    return proto3.util.equals(PostgresParse, a, b);
  }
}

/**
 * PostgresBind is emitted when a Postgres client readies a prepared statement
 * for execution and binds it to parameters.
 *
 * @generated from message events.PostgresBind
 */
export class PostgresBind extends Message<PostgresBind> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementName is the name of prepared statement that's being bound to parameters.
   *
   * @generated from field: string StatementName = 5;
   */
  StatementName = "";

  /**
   * PortalName is the destination portal name that binds statement to parameters.
   *
   * @generated from field: string PortalName = 6;
   */
  PortalName = "";

  /**
   * Parameters are the query bind parameters.
   *
   * @generated from field: repeated string Parameters = 7;
   */
  Parameters: string[] = [];

  constructor(data?: PartialMessage<PostgresBind>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PostgresBind";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "PortalName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Parameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresBind {
    return new PostgresBind().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresBind {
    return new PostgresBind().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresBind {
    return new PostgresBind().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresBind | PlainMessage<PostgresBind> | undefined, b: PostgresBind | PlainMessage<PostgresBind> | undefined): boolean {
    return proto3.util.equals(PostgresBind, a, b);
  }
}

/**
 * PostgresExecute is emitted when a Postgres client executes a previously
 * bound prepared statement.
 *
 * @generated from message events.PostgresExecute
 */
export class PostgresExecute extends Message<PostgresExecute> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * PortalName is the name of destination portal that's being executed.
   *
   * @generated from field: string PortalName = 5;
   */
  PortalName = "";

  constructor(data?: PartialMessage<PostgresExecute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PostgresExecute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "PortalName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresExecute {
    return new PostgresExecute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresExecute {
    return new PostgresExecute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresExecute {
    return new PostgresExecute().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresExecute | PlainMessage<PostgresExecute> | undefined, b: PostgresExecute | PlainMessage<PostgresExecute> | undefined): boolean {
    return proto3.util.equals(PostgresExecute, a, b);
  }
}

/**
 * PostgresClose is emitted when a Postgres client closes an existing prepared
 * statement.
 *
 * @generated from message events.PostgresClose
 */
export class PostgresClose extends Message<PostgresClose> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementName is the name of prepared statement that's being closed.
   *
   * @generated from field: string StatementName = 5;
   */
  StatementName = "";

  /**
   * PortalName is the name of destination portal that's being closed.
   *
   * @generated from field: string PortalName = 6;
   */
  PortalName = "";

  constructor(data?: PartialMessage<PostgresClose>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PostgresClose";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "PortalName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresClose {
    return new PostgresClose().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresClose {
    return new PostgresClose().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresClose {
    return new PostgresClose().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresClose | PlainMessage<PostgresClose> | undefined, b: PostgresClose | PlainMessage<PostgresClose> | undefined): boolean {
    return proto3.util.equals(PostgresClose, a, b);
  }
}

/**
 * PostgresFunctionCall is emitted when a Postgres client calls internal
 * database function.
 *
 * @generated from message events.PostgresFunctionCall
 */
export class PostgresFunctionCall extends Message<PostgresFunctionCall> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * FunctionOID is the Postgres object ID of the called function.
   *
   * @generated from field: uint32 FunctionOID = 5;
   */
  FunctionOID = 0;

  /**
   * FunctionArgs contains formatted function arguments.
   *
   * @generated from field: repeated string FunctionArgs = 6;
   */
  FunctionArgs: string[] = [];

  constructor(data?: PartialMessage<PostgresFunctionCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PostgresFunctionCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "FunctionOID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "FunctionArgs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresFunctionCall {
    return new PostgresFunctionCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresFunctionCall {
    return new PostgresFunctionCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresFunctionCall {
    return new PostgresFunctionCall().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresFunctionCall | PlainMessage<PostgresFunctionCall> | undefined, b: PostgresFunctionCall | PlainMessage<PostgresFunctionCall> | undefined): boolean {
    return proto3.util.equals(PostgresFunctionCall, a, b);
  }
}

/**
 * WindowsDesktopSessionStart is emitted when a user connects to a desktop.
 *
 * @generated from message events.WindowsDesktopSessionStart
 */
export class WindowsDesktopSessionStart extends Message<WindowsDesktopSessionStart> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Connection holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * Status indicates whether the connection was successful or denied.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * WindowsDesktopService is the name of the service proxying the RDP session.
   *
   * @generated from field: string WindowsDesktopService = 6;
   */
  WindowsDesktopService = "";

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 7;
   */
  DesktopAddr = "";

  /**
   * Domain is the Active Directory domain of the desktop being accessed.
   *
   * @generated from field: string Domain = 8;
   */
  Domain = "";

  /**
   * WindowsUser is the Windows username used to connect.
   *
   * @generated from field: string WindowsUser = 9;
   */
  WindowsUser = "";

  /**
   * DesktopLabels are the labels on the desktop resource.
   *
   * @generated from field: map<string, string> DesktopLabels = 10;
   */
  DesktopLabels: { [key: string]: string } = {};

  /**
   * DesktopName is the name of the desktop resource.
   *
   * @generated from field: string DesktopName = 11;
   */
  DesktopName = "";

  /**
   * AllowUserCreation indicates whether automatic local user creation
   * is allowed for this session.
   *
   * @generated from field: bool AllowUserCreation = 12;
   */
  AllowUserCreation = false;

  /**
   * NLA indicates whether Teleport performed Network Level Authentication (NLA)
   * when initiating this session.
   *
   * @generated from field: bool NLA = 13;
   */
  NLA = false;

  constructor(data?: PartialMessage<WindowsDesktopSessionStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.WindowsDesktopSessionStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "WindowsDesktopService", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "WindowsUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "DesktopLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 11, name: "DesktopName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "AllowUserCreation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "NLA", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopSessionStart {
    return new WindowsDesktopSessionStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopSessionStart {
    return new WindowsDesktopSessionStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopSessionStart {
    return new WindowsDesktopSessionStart().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopSessionStart | PlainMessage<WindowsDesktopSessionStart> | undefined, b: WindowsDesktopSessionStart | PlainMessage<WindowsDesktopSessionStart> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopSessionStart, a, b);
  }
}

/**
 * DatabaseSessionEnd is emitted when a user ends the database session.
 *
 * @generated from message events.DatabaseSessionEnd
 */
export class DatabaseSessionEnd extends Message<DatabaseSessionEnd> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StartTime is the timestamp at which the session began.
   *
   * @generated from field: google.protobuf.Timestamp StartTime = 5;
   */
  StartTime?: Timestamp;

  /**
   * EndTime is the timestamp at which the session ended.
   *
   * @generated from field: google.protobuf.Timestamp EndTime = 6;
   */
  EndTime?: Timestamp;

  constructor(data?: PartialMessage<DatabaseSessionEnd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseSessionEnd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StartTime", kind: "message", T: Timestamp },
    { no: 6, name: "EndTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSessionEnd {
    return new DatabaseSessionEnd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSessionEnd {
    return new DatabaseSessionEnd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSessionEnd {
    return new DatabaseSessionEnd().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSessionEnd | PlainMessage<DatabaseSessionEnd> | undefined, b: DatabaseSessionEnd | PlainMessage<DatabaseSessionEnd> | undefined): boolean {
    return proto3.util.equals(DatabaseSessionEnd, a, b);
  }
}

/**
 * MFADeviceMetadata is a common MFA device metadata.
 *
 * @generated from message events.MFADeviceMetadata
 */
export class MFADeviceMetadata extends Message<MFADeviceMetadata> {
  /**
   * Name is the user-specified name of the MFA device.
   *
   * @generated from field: string DeviceName = 1;
   */
  DeviceName = "";

  /**
   * ID is the UUID of the MFA device generated by Teleport.
   *
   * @generated from field: string DeviceID = 2;
   */
  DeviceID = "";

  /**
   * Type is the type of this MFA device.
   *
   * @generated from field: string DeviceType = 3;
   */
  DeviceType = "";

  constructor(data?: PartialMessage<MFADeviceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MFADeviceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DeviceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DeviceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "DeviceType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFADeviceMetadata {
    return new MFADeviceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFADeviceMetadata {
    return new MFADeviceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFADeviceMetadata {
    return new MFADeviceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MFADeviceMetadata | PlainMessage<MFADeviceMetadata> | undefined, b: MFADeviceMetadata | PlainMessage<MFADeviceMetadata> | undefined): boolean {
    return proto3.util.equals(MFADeviceMetadata, a, b);
  }
}

/**
 * MFADeviceAdd is emitted when a user adds an MFA device.
 *
 * @generated from message events.MFADeviceAdd
 */
export class MFADeviceAdd extends Message<MFADeviceAdd> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Device is the new MFA device added by the user.
   *
   * @generated from field: events.MFADeviceMetadata Device = 3;
   */
  Device?: MFADeviceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<MFADeviceAdd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MFADeviceAdd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Device", kind: "message", T: MFADeviceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFADeviceAdd {
    return new MFADeviceAdd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFADeviceAdd {
    return new MFADeviceAdd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFADeviceAdd {
    return new MFADeviceAdd().fromJsonString(jsonString, options);
  }

  static equals(a: MFADeviceAdd | PlainMessage<MFADeviceAdd> | undefined, b: MFADeviceAdd | PlainMessage<MFADeviceAdd> | undefined): boolean {
    return proto3.util.equals(MFADeviceAdd, a, b);
  }
}

/**
 * MFADeviceDelete is emitted when a user deletes an MFA device.
 *
 * @generated from message events.MFADeviceDelete
 */
export class MFADeviceDelete extends Message<MFADeviceDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Device is the MFA device deleted by the user.
   *
   * @generated from field: events.MFADeviceMetadata Device = 3;
   */
  Device?: MFADeviceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<MFADeviceDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MFADeviceDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Device", kind: "message", T: MFADeviceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFADeviceDelete {
    return new MFADeviceDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFADeviceDelete {
    return new MFADeviceDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFADeviceDelete {
    return new MFADeviceDelete().fromJsonString(jsonString, options);
  }

  static equals(a: MFADeviceDelete | PlainMessage<MFADeviceDelete> | undefined, b: MFADeviceDelete | PlainMessage<MFADeviceDelete> | undefined): boolean {
    return proto3.util.equals(MFADeviceDelete, a, b);
  }
}

/**
 * BillingInformationUpdate is emitted when a user updates the billing information.
 *
 * @generated from message events.BillingInformationUpdate
 */
export class BillingInformationUpdate extends Message<BillingInformationUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BillingInformationUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BillingInformationUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BillingInformationUpdate {
    return new BillingInformationUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BillingInformationUpdate {
    return new BillingInformationUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BillingInformationUpdate {
    return new BillingInformationUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: BillingInformationUpdate | PlainMessage<BillingInformationUpdate> | undefined, b: BillingInformationUpdate | PlainMessage<BillingInformationUpdate> | undefined): boolean {
    return proto3.util.equals(BillingInformationUpdate, a, b);
  }
}

/**
 * BillingCardCreate is emitted when a user creates or updates a credit card.
 *
 * @generated from message events.BillingCardCreate
 */
export class BillingCardCreate extends Message<BillingCardCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BillingCardCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BillingCardCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BillingCardCreate {
    return new BillingCardCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BillingCardCreate {
    return new BillingCardCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BillingCardCreate {
    return new BillingCardCreate().fromJsonString(jsonString, options);
  }

  static equals(a: BillingCardCreate | PlainMessage<BillingCardCreate> | undefined, b: BillingCardCreate | PlainMessage<BillingCardCreate> | undefined): boolean {
    return proto3.util.equals(BillingCardCreate, a, b);
  }
}

/**
 * BillingCardDelete is emitted when a user deletes a credit card.
 *
 * @generated from message events.BillingCardDelete
 */
export class BillingCardDelete extends Message<BillingCardDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<BillingCardDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BillingCardDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BillingCardDelete {
    return new BillingCardDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BillingCardDelete {
    return new BillingCardDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BillingCardDelete {
    return new BillingCardDelete().fromJsonString(jsonString, options);
  }

  static equals(a: BillingCardDelete | PlainMessage<BillingCardDelete> | undefined, b: BillingCardDelete | PlainMessage<BillingCardDelete> | undefined): boolean {
    return proto3.util.equals(BillingCardDelete, a, b);
  }
}

/**
 * LockCreate is emitted when a lock is created/updated.
 * Locks are used to restrict access to a Teleport environment by disabling
 * interactions involving a user, an RBAC role, a node, etc.
 * See rfd/0009-locking.md for more details.
 *
 * @generated from message events.LockCreate
 */
export class LockCreate extends Message<LockCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * Target describes the set of interactions that the lock applies to
   * Deprecated: use Lock instead.
   *
   * @generated from field: types.LockTarget Target = 4 [deprecated = true];
   * @deprecated
   */
  Target?: LockTarget;

  /**
   * Lock is a common lock event metadata
   *
   * @generated from field: events.LockMetadata Lock = 5;
   */
  Lock?: LockMetadata;

  constructor(data?: PartialMessage<LockCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.LockCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Target", kind: "message", T: LockTarget },
    { no: 5, name: "Lock", kind: "message", T: LockMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockCreate {
    return new LockCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockCreate {
    return new LockCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockCreate {
    return new LockCreate().fromJsonString(jsonString, options);
  }

  static equals(a: LockCreate | PlainMessage<LockCreate> | undefined, b: LockCreate | PlainMessage<LockCreate> | undefined): boolean {
    return proto3.util.equals(LockCreate, a, b);
  }
}

/**
 * LockDelete is emitted when a lock is deleted
 *
 * @generated from message events.LockDelete
 */
export class LockDelete extends Message<LockDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * Lock is a common lock event metadata
   *
   * @generated from field: events.LockMetadata Lock = 4;
   */
  Lock?: LockMetadata;

  constructor(data?: PartialMessage<LockDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.LockDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Lock", kind: "message", T: LockMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockDelete {
    return new LockDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockDelete {
    return new LockDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockDelete {
    return new LockDelete().fromJsonString(jsonString, options);
  }

  static equals(a: LockDelete | PlainMessage<LockDelete> | undefined, b: LockDelete | PlainMessage<LockDelete> | undefined): boolean {
    return proto3.util.equals(LockDelete, a, b);
  }
}

/**
 * RecoveryCodeGenerate is emitted when a user's new recovery codes are generated and updated.
 *
 * @generated from message events.RecoveryCodeGenerate
 */
export class RecoveryCodeGenerate extends Message<RecoveryCodeGenerate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<RecoveryCodeGenerate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RecoveryCodeGenerate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCodeGenerate {
    return new RecoveryCodeGenerate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCodeGenerate {
    return new RecoveryCodeGenerate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCodeGenerate {
    return new RecoveryCodeGenerate().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCodeGenerate | PlainMessage<RecoveryCodeGenerate> | undefined, b: RecoveryCodeGenerate | PlainMessage<RecoveryCodeGenerate> | undefined): boolean {
    return proto3.util.equals(RecoveryCodeGenerate, a, b);
  }
}

/**
 * RecoveryCodeUsed is emitted when a user's recovery code was used successfully or
 * unsuccessfully.
 *
 * @generated from message events.RecoveryCodeUsed
 */
export class RecoveryCodeUsed extends Message<RecoveryCodeUsed> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Status contains fields to indicate whether attempt was successful or not.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  constructor(data?: PartialMessage<RecoveryCodeUsed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RecoveryCodeUsed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCodeUsed {
    return new RecoveryCodeUsed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCodeUsed {
    return new RecoveryCodeUsed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCodeUsed {
    return new RecoveryCodeUsed().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCodeUsed | PlainMessage<RecoveryCodeUsed> | undefined, b: RecoveryCodeUsed | PlainMessage<RecoveryCodeUsed> | undefined): boolean {
    return proto3.util.equals(RecoveryCodeUsed, a, b);
  }
}

/**
 * WindowsDesktopSessionEnd is emitted when a user ends a Windows desktop session.
 *
 * @generated from message events.WindowsDesktopSessionEnd
 */
export class WindowsDesktopSessionEnd extends Message<WindowsDesktopSessionEnd> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Session is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * WindowsDesktopService is the name of the service proxying the RDP session.
   *
   * @generated from field: string WindowsDesktopService = 4;
   */
  WindowsDesktopService = "";

  /**
   * DesktopAddr is the address of the desktop being accessed.
   *
   * @generated from field: string DesktopAddr = 5;
   */
  DesktopAddr = "";

  /**
   * Domain is the Active Directory domain of the desktop being accessed.
   *
   * @generated from field: string Domain = 6;
   */
  Domain = "";

  /**
   * WindowsUser is the Windows username used to connect.
   *
   * @generated from field: string WindowsUser = 7;
   */
  WindowsUser = "";

  /**
   * DesktopLabels are the labels on the desktop resource.
   *
   * @generated from field: map<string, string> DesktopLabels = 8;
   */
  DesktopLabels: { [key: string]: string } = {};

  /**
   * StartTime is the timestamp at which the session began.
   *
   * @generated from field: google.protobuf.Timestamp StartTime = 9;
   */
  StartTime?: Timestamp;

  /**
   * EndTime is the timestamp at which the session ended.
   *
   * @generated from field: google.protobuf.Timestamp EndTime = 10;
   */
  EndTime?: Timestamp;

  /**
   * DesktopName is the name of the desktop resource.
   *
   * @generated from field: string DesktopName = 11;
   */
  DesktopName = "";

  /**
   * Recorded is true if the session was recorded, false otherwise.
   *
   * @generated from field: bool Recorded = 12;
   */
  Recorded = false;

  /**
   * Participants is a list of participants in the session.
   *
   * @generated from field: repeated string Participants = 13;
   */
  Participants: string[] = [];

  constructor(data?: PartialMessage<WindowsDesktopSessionEnd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.WindowsDesktopSessionEnd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "WindowsDesktopService", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "DesktopAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "WindowsUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "DesktopLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 9, name: "StartTime", kind: "message", T: Timestamp },
    { no: 10, name: "EndTime", kind: "message", T: Timestamp },
    { no: 11, name: "DesktopName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "Recorded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "Participants", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopSessionEnd {
    return new WindowsDesktopSessionEnd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopSessionEnd {
    return new WindowsDesktopSessionEnd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopSessionEnd {
    return new WindowsDesktopSessionEnd().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopSessionEnd | PlainMessage<WindowsDesktopSessionEnd> | undefined, b: WindowsDesktopSessionEnd | PlainMessage<WindowsDesktopSessionEnd> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopSessionEnd, a, b);
  }
}

/**
 * CertificateCreate is emitted when a certificate is issued.
 *
 * @generated from message events.CertificateCreate
 */
export class CertificateCreate extends Message<CertificateCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * CertificateType is the type of certificate that was just issued.
   *
   * @generated from field: string CertificateType = 2;
   */
  CertificateType = "";

  /**
   * Identity is the identity associated with the certificate, as interpreted by Teleport.
   *
   * @generated from field: events.Identity Identity = 3;
   */
  Identity?: Identity;

  /**
   * Client is the common client event metadata
   *
   * @generated from field: events.ClientMetadata Client = 4;
   */
  Client?: ClientMetadata;

  constructor(data?: PartialMessage<CertificateCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CertificateCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "CertificateType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Identity", kind: "message", T: Identity },
    { no: 4, name: "Client", kind: "message", T: ClientMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertificateCreate {
    return new CertificateCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertificateCreate {
    return new CertificateCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertificateCreate {
    return new CertificateCreate().fromJsonString(jsonString, options);
  }

  static equals(a: CertificateCreate | PlainMessage<CertificateCreate> | undefined, b: CertificateCreate | PlainMessage<CertificateCreate> | undefined): boolean {
    return proto3.util.equals(CertificateCreate, a, b);
  }
}

/**
 * RenewableCertificateGenerationMismatch is emitted when a renewable
 * certificate's generation counter fails to validate, possibly indicating a
 * stolen certificate and an invalid renewal attempt.
 *
 * @generated from message events.RenewableCertificateGenerationMismatch
 */
export class RenewableCertificateGenerationMismatch extends Message<RenewableCertificateGenerationMismatch> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * UserMetadata is a common user event metadata.
   *
   * @generated from field: events.UserMetadata UserMetadata = 2;
   */
  UserMetadata?: UserMetadata;

  constructor(data?: PartialMessage<RenewableCertificateGenerationMismatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RenewableCertificateGenerationMismatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "UserMetadata", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenewableCertificateGenerationMismatch {
    return new RenewableCertificateGenerationMismatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenewableCertificateGenerationMismatch {
    return new RenewableCertificateGenerationMismatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenewableCertificateGenerationMismatch {
    return new RenewableCertificateGenerationMismatch().fromJsonString(jsonString, options);
  }

  static equals(a: RenewableCertificateGenerationMismatch | PlainMessage<RenewableCertificateGenerationMismatch> | undefined, b: RenewableCertificateGenerationMismatch | PlainMessage<RenewableCertificateGenerationMismatch> | undefined): boolean {
    return proto3.util.equals(RenewableCertificateGenerationMismatch, a, b);
  }
}

/**
 * BotJoin records a bot join event.
 *
 * @generated from message events.BotJoin
 */
export class BotJoin extends Message<BotJoin> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status contains common command or operation status fields.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * BotName is the name of the bot which has joined.
   *
   * @generated from field: string BotName = 3;
   */
  BotName = "";

  /**
   * Method is the event field indicating what join method was used.
   *
   * @generated from field: string Method = 4;
   */
  Method = "";

  /**
   * TokenName is the name of the provision token used to join.
   *
   * @generated from field: string TokenName = 5;
   */
  TokenName = "";

  /**
   * Attributes is a map of attributes received from the join method provider.
   *
   * @generated from field: google.protobuf.Struct Attributes = 6;
   */
  Attributes?: Struct;

  /**
   * UserName is the name of the user associated with the bot which has joined.
   *
   * @generated from field: string UserName = 7;
   */
  UserName = "";

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 8;
   */
  Connection?: ConnectionMetadata;

  /**
   * BotInstanceID is the ID of the bot instance which has joined or renewed.
   *
   * @generated from field: string BotInstanceID = 9;
   */
  BotInstanceID = "";

  constructor(data?: PartialMessage<BotJoin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.BotJoin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "BotName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "TokenName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Attributes", kind: "message", T: Struct },
    { no: 7, name: "UserName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 9, name: "BotInstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotJoin {
    return new BotJoin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotJoin {
    return new BotJoin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotJoin {
    return new BotJoin().fromJsonString(jsonString, options);
  }

  static equals(a: BotJoin | PlainMessage<BotJoin> | undefined, b: BotJoin | PlainMessage<BotJoin> | undefined): boolean {
    return proto3.util.equals(BotJoin, a, b);
  }
}

/**
 * InstanceJoin records an instance join event.
 *
 * @generated from message events.InstanceJoin
 */
export class InstanceJoin extends Message<InstanceJoin> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status contains common command or operation status fields.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * HostID is the unique host ID of the instance which attempted to join.
   *
   * @generated from field: string HostID = 3;
   */
  HostID = "";

  /**
   * NodeName is the name of the instance which attempted to join.
   *
   * @generated from field: string NodeName = 4;
   */
  NodeName = "";

  /**
   * Role is the role that the node requested when attempting to join.
   *
   * @generated from field: string Role = 5;
   */
  Role = "";

  /**
   * Method is the event field indicating what join method was used.
   *
   * @generated from field: string Method = 6;
   */
  Method = "";

  /**
   * TokenName is the name of the token used to join. This will be omitted
   * for the 'token' join method where the token name is a secret value.
   *
   * @generated from field: string TokenName = 7;
   */
  TokenName = "";

  /**
   * Attributes is a map of attributes received from the join method provider.
   *
   * @generated from field: google.protobuf.Struct Attributes = 8;
   */
  Attributes?: Struct;

  /**
   * TokenExpires contain information about token expiration time.
   * In case of static token the TokenExpiration time is to the Unix epoch start time.
   *
   * @generated from field: google.protobuf.Timestamp TokenExpires = 9;
   */
  TokenExpires?: Timestamp;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 10;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<InstanceJoin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.InstanceJoin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "NodeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "TokenName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Attributes", kind: "message", T: Struct },
    { no: 9, name: "TokenExpires", kind: "message", T: Timestamp },
    { no: 10, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceJoin {
    return new InstanceJoin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceJoin {
    return new InstanceJoin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceJoin {
    return new InstanceJoin().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceJoin | PlainMessage<InstanceJoin> | undefined, b: InstanceJoin | PlainMessage<InstanceJoin> | undefined): boolean {
    return proto3.util.equals(InstanceJoin, a, b);
  }
}

/**
 * Unknown is a fallback event used when we don't recognize an event from the backend.
 *
 * @generated from message events.Unknown
 */
export class Unknown extends Message<Unknown> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * UnknownType is the event type extracted from the unknown event.
   *
   * @generated from field: string UnknownType = 2;
   */
  UnknownType = "";

  /**
   * UnknownCode is the event code extracted from the unknown event.
   *
   * @generated from field: string UnknownCode = 3;
   */
  UnknownCode = "";

  /**
   * Data is the serialized JSON data of the unknown event.
   *
   * @generated from field: string Data = 4;
   */
  Data = "";

  constructor(data?: PartialMessage<Unknown>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Unknown";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "UnknownType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "UnknownCode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Unknown {
    return new Unknown().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Unknown {
    return new Unknown().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Unknown {
    return new Unknown().fromJsonString(jsonString, options);
  }

  static equals(a: Unknown | PlainMessage<Unknown> | undefined, b: Unknown | PlainMessage<Unknown> | undefined): boolean {
    return proto3.util.equals(Unknown, a, b);
  }
}

/**
 * DeviceMetadata groups device information for events.
 *
 * @generated from message events.DeviceMetadata
 */
export class DeviceMetadata extends Message<DeviceMetadata> {
  /**
   * ID of the device.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = "";

  /**
   * OS of the device.
   *
   * @generated from field: events.OSType os_type = 2;
   */
  osType = OSType.OS_TYPE_UNSPECIFIED;

  /**
   * Device inventory identifier.
   *
   * @generated from field: string asset_tag = 3;
   */
  assetTag = "";

  /**
   * Device credential identifier.
   *
   * @generated from field: string credential_id = 4;
   */
  credentialId = "";

  /**
   * Device origin.
   *
   * @generated from field: events.DeviceOrigin device_origin = 5;
   */
  deviceOrigin = DeviceOrigin.UNSPECIFIED;

  /**
   * True if web authentication, aka on-behalf-of device authentication, was
   * performed.
   * Only present in "device.authenticate" type events.
   *
   * @generated from field: bool web_authentication = 6;
   */
  webAuthentication = false;

  /**
   * Device web authentication attempt ID.
   * Present in events related to device web authentication.
   *
   * @generated from field: string web_authentication_id = 8;
   */
  webAuthenticationId = "";

  constructor(data?: PartialMessage<DeviceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DeviceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "os_type", kind: "enum", T: proto3.getEnumType(OSType) },
    { no: 3, name: "asset_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "credential_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "device_origin", kind: "enum", T: proto3.getEnumType(DeviceOrigin) },
    { no: 6, name: "web_authentication", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "web_authentication_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceMetadata | PlainMessage<DeviceMetadata> | undefined, b: DeviceMetadata | PlainMessage<DeviceMetadata> | undefined): boolean {
    return proto3.util.equals(DeviceMetadata, a, b);
  }
}

/**
 * DeviceEvent is a device-related event.
 * The event type (Metadata.Type) for device events is always "device". See the
 * event code (Metadata.Code) for its meaning.
 * Deprecated: Use DeviceEvent2 instead.
 *
 * @generated from message events.DeviceEvent
 */
export class DeviceEvent extends Message<DeviceEvent> {
  /**
   * Metadata holds common event metadata.
   *
   * @generated from field: events.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * Status indicates the outcome of the event.
   *
   * @generated from field: events.Status status = 2;
   */
  status?: Status;

  /**
   * DeviceMetadata holds metadata about the user device.
   *
   * @generated from field: events.DeviceMetadata device = 3;
   */
  device?: DeviceMetadata;

  /**
   * UserMetadata holds metadata about the user behind the event.
   *
   * @generated from field: events.UserMetadata user = 4;
   */
  user?: UserMetadata;

  constructor(data?: PartialMessage<DeviceEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DeviceEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 2, name: "status", kind: "message", T: Status },
    { no: 3, name: "device", kind: "message", T: DeviceMetadata },
    { no: 4, name: "user", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceEvent {
    return new DeviceEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceEvent {
    return new DeviceEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceEvent {
    return new DeviceEvent().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceEvent | PlainMessage<DeviceEvent> | undefined, b: DeviceEvent | PlainMessage<DeviceEvent> | undefined): boolean {
    return proto3.util.equals(DeviceEvent, a, b);
  }
}

/**
 * DeviceEvent2 is a device-related event.
 * See the "lib/events.Device*Event" and "lib/events.Device*Code" for the
 * various event types and codes, respectively.
 * Replaces the previous [DeviceEvent] proto, presenting a more standard event
 * interface with various embeds.
 *
 * @generated from message events.DeviceEvent2
 */
export class DeviceEvent2 extends Message<DeviceEvent2> {
  /**
   * Metadata holds common event metadata.
   *
   * @generated from field: events.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * DeviceMetadata holds metadata about the user device.
   *
   * @generated from field: events.DeviceMetadata device = 3;
   */
  device?: DeviceMetadata;

  /**
   * Status indicates the outcome of the event.
   *
   * @generated from field: events.Status status = 5;
   */
  status?: Status;

  /**
   * UserMetadata holds metadata about the user behind the event.
   *
   * @generated from field: events.UserMetadata user = 6;
   */
  user?: UserMetadata;

  constructor(data?: PartialMessage<DeviceEvent2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DeviceEvent2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 3, name: "device", kind: "message", T: DeviceMetadata },
    { no: 5, name: "status", kind: "message", T: Status },
    { no: 6, name: "user", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceEvent2 {
    return new DeviceEvent2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceEvent2 {
    return new DeviceEvent2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceEvent2 {
    return new DeviceEvent2().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceEvent2 | PlainMessage<DeviceEvent2> | undefined, b: DeviceEvent2 | PlainMessage<DeviceEvent2> | undefined): boolean {
    return proto3.util.equals(DeviceEvent2, a, b);
  }
}

/**
 * DiscoveryConfigCreate is emitted when a discovery config is created.
 *
 * @generated from message events.DiscoveryConfigCreate
 */
export class DiscoveryConfigCreate extends Message<DiscoveryConfigCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<DiscoveryConfigCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DiscoveryConfigCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigCreate {
    return new DiscoveryConfigCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigCreate {
    return new DiscoveryConfigCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigCreate {
    return new DiscoveryConfigCreate().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigCreate | PlainMessage<DiscoveryConfigCreate> | undefined, b: DiscoveryConfigCreate | PlainMessage<DiscoveryConfigCreate> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigCreate, a, b);
  }
}

/**
 * DiscoveryConfigUpdate is emitted when a discovery config is updated.
 *
 * @generated from message events.DiscoveryConfigUpdate
 */
export class DiscoveryConfigUpdate extends Message<DiscoveryConfigUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<DiscoveryConfigUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DiscoveryConfigUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigUpdate {
    return new DiscoveryConfigUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigUpdate {
    return new DiscoveryConfigUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigUpdate {
    return new DiscoveryConfigUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigUpdate | PlainMessage<DiscoveryConfigUpdate> | undefined, b: DiscoveryConfigUpdate | PlainMessage<DiscoveryConfigUpdate> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigUpdate, a, b);
  }
}

/**
 * DiscoveryConfigDelete is emitted when a discovery config is deleted.
 *
 * @generated from message events.DiscoveryConfigDelete
 */
export class DiscoveryConfigDelete extends Message<DiscoveryConfigDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<DiscoveryConfigDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DiscoveryConfigDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigDelete {
    return new DiscoveryConfigDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigDelete {
    return new DiscoveryConfigDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigDelete {
    return new DiscoveryConfigDelete().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigDelete | PlainMessage<DiscoveryConfigDelete> | undefined, b: DiscoveryConfigDelete | PlainMessage<DiscoveryConfigDelete> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigDelete, a, b);
  }
}

/**
 * DiscoveryConfigDeleteAll is emitted when all discovery configs are deleted.
 *
 * @generated from message events.DiscoveryConfigDeleteAll
 */
export class DiscoveryConfigDeleteAll extends Message<DiscoveryConfigDeleteAll> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<DiscoveryConfigDeleteAll>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DiscoveryConfigDeleteAll";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoveryConfigDeleteAll {
    return new DiscoveryConfigDeleteAll().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoveryConfigDeleteAll {
    return new DiscoveryConfigDeleteAll().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoveryConfigDeleteAll {
    return new DiscoveryConfigDeleteAll().fromJsonString(jsonString, options);
  }

  static equals(a: DiscoveryConfigDeleteAll | PlainMessage<DiscoveryConfigDeleteAll> | undefined, b: DiscoveryConfigDeleteAll | PlainMessage<DiscoveryConfigDeleteAll> | undefined): boolean {
    return proto3.util.equals(DiscoveryConfigDeleteAll, a, b);
  }
}

/**
 * IntegrationCreate is emitted when an integration resource is created.
 *
 * @generated from message events.IntegrationCreate
 */
export class IntegrationCreate extends Message<IntegrationCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * @generated from field: events.IntegrationMetadata Integration = 4;
   */
  Integration?: IntegrationMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<IntegrationCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.IntegrationCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Integration", kind: "message", T: IntegrationMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationCreate {
    return new IntegrationCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationCreate {
    return new IntegrationCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationCreate {
    return new IntegrationCreate().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationCreate | PlainMessage<IntegrationCreate> | undefined, b: IntegrationCreate | PlainMessage<IntegrationCreate> | undefined): boolean {
    return proto3.util.equals(IntegrationCreate, a, b);
  }
}

/**
 * IntegrationUpdate is emitted when an integration resource is updated.
 *
 * @generated from message events.IntegrationUpdate
 */
export class IntegrationUpdate extends Message<IntegrationUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * @generated from field: events.IntegrationMetadata Integration = 4;
   */
  Integration?: IntegrationMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<IntegrationUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.IntegrationUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Integration", kind: "message", T: IntegrationMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationUpdate {
    return new IntegrationUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationUpdate {
    return new IntegrationUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationUpdate {
    return new IntegrationUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationUpdate | PlainMessage<IntegrationUpdate> | undefined, b: IntegrationUpdate | PlainMessage<IntegrationUpdate> | undefined): boolean {
    return proto3.util.equals(IntegrationUpdate, a, b);
  }
}

/**
 * IntegrationDelete is emitted when an integration is deleted.
 *
 * @generated from message events.IntegrationDelete
 */
export class IntegrationDelete extends Message<IntegrationDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * @generated from field: events.IntegrationMetadata Integration = 4;
   */
  Integration?: IntegrationMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<IntegrationDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.IntegrationDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Integration", kind: "message", T: IntegrationMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationDelete {
    return new IntegrationDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationDelete {
    return new IntegrationDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationDelete {
    return new IntegrationDelete().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationDelete | PlainMessage<IntegrationDelete> | undefined, b: IntegrationDelete | PlainMessage<IntegrationDelete> | undefined): boolean {
    return proto3.util.equals(IntegrationDelete, a, b);
  }
}

/**
 * IntegrationMetadata contains information about integration resources.
 *
 * @generated from message events.IntegrationMetadata
 */
export class IntegrationMetadata extends Message<IntegrationMetadata> {
  /**
   * SubKind is the sub kind of the integration resource.
   *
   * @generated from field: string SubKind = 1;
   */
  SubKind = "";

  /**
   * AWSOIDC contains metadata for AWS OIDC integrations.
   *
   * @generated from field: events.AWSOIDCIntegrationMetadata AWSOIDC = 2;
   */
  AWSOIDC?: AWSOIDCIntegrationMetadata;

  /**
   * AzureOIDC contains metadata for Azure OIDC integrations.
   *
   * @generated from field: events.AzureOIDCIntegrationMetadata AzureOIDC = 3;
   */
  AzureOIDC?: AzureOIDCIntegrationMetadata;

  constructor(data?: PartialMessage<IntegrationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.IntegrationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AWSOIDC", kind: "message", T: AWSOIDCIntegrationMetadata },
    { no: 3, name: "AzureOIDC", kind: "message", T: AzureOIDCIntegrationMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationMetadata {
    return new IntegrationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationMetadata {
    return new IntegrationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationMetadata {
    return new IntegrationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationMetadata | PlainMessage<IntegrationMetadata> | undefined, b: IntegrationMetadata | PlainMessage<IntegrationMetadata> | undefined): boolean {
    return proto3.util.equals(IntegrationMetadata, a, b);
  }
}

/**
 * AWSOIDCIntegrationMetadata contains metadata for AWS OIDC integrations.
 *
 * @generated from message events.AWSOIDCIntegrationMetadata
 */
export class AWSOIDCIntegrationMetadata extends Message<AWSOIDCIntegrationMetadata> {
  /**
   * RoleARN contains the Role ARN used to set up the Integration.
   * This is the AWS Role that Teleport will use to issue tokens for API Calls.
   *
   * @generated from field: string RoleARN = 1;
   */
  RoleARN = "";

  /**
   * IssuerS3URI is the Identity Provider that was configured in AWS.
   *
   * @generated from field: string IssuerS3URI = 2;
   */
  IssuerS3URI = "";

  constructor(data?: PartialMessage<AWSOIDCIntegrationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AWSOIDCIntegrationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "IssuerS3URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSOIDCIntegrationMetadata {
    return new AWSOIDCIntegrationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSOIDCIntegrationMetadata {
    return new AWSOIDCIntegrationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSOIDCIntegrationMetadata {
    return new AWSOIDCIntegrationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AWSOIDCIntegrationMetadata | PlainMessage<AWSOIDCIntegrationMetadata> | undefined, b: AWSOIDCIntegrationMetadata | PlainMessage<AWSOIDCIntegrationMetadata> | undefined): boolean {
    return proto3.util.equals(AWSOIDCIntegrationMetadata, a, b);
  }
}

/**
 * AzureOIDCIntegrationMetadata contains metadata for Azure OIDC integrations.
 *
 * @generated from message events.AzureOIDCIntegrationMetadata
 */
export class AzureOIDCIntegrationMetadata extends Message<AzureOIDCIntegrationMetadata> {
  /**
   * TenantID specifies the ID of Entra Tenant (Directory).
   *
   * @generated from field: string TenantID = 1;
   */
  TenantID = "";

  /**
   * ClientID specifies the ID of Azure enterprise application (client).
   *
   * @generated from field: string ClientID = 2;
   */
  ClientID = "";

  constructor(data?: PartialMessage<AzureOIDCIntegrationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AzureOIDCIntegrationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TenantID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureOIDCIntegrationMetadata {
    return new AzureOIDCIntegrationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureOIDCIntegrationMetadata {
    return new AzureOIDCIntegrationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureOIDCIntegrationMetadata {
    return new AzureOIDCIntegrationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AzureOIDCIntegrationMetadata | PlainMessage<AzureOIDCIntegrationMetadata> | undefined, b: AzureOIDCIntegrationMetadata | PlainMessage<AzureOIDCIntegrationMetadata> | undefined): boolean {
    return proto3.util.equals(AzureOIDCIntegrationMetadata, a, b);
  }
}

/**
 * PluginCreate is emitted when a plugin resource is created.
 *
 * @generated from message events.PluginCreate
 */
export class PluginCreate extends Message<PluginCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata user = 2;
   */
  user?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 3;
   */
  resource?: ResourceMetadata;

  /**
   * @generated from field: events.PluginMetadata plugin = 4;
   */
  plugin?: PluginMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata connection = 5;
   */
  connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<PluginCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PluginCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 2, name: "user", kind: "message", T: UserMetadata },
    { no: 3, name: "resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "plugin", kind: "message", T: PluginMetadata },
    { no: 5, name: "connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginCreate {
    return new PluginCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginCreate {
    return new PluginCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginCreate {
    return new PluginCreate().fromJsonString(jsonString, options);
  }

  static equals(a: PluginCreate | PlainMessage<PluginCreate> | undefined, b: PluginCreate | PlainMessage<PluginCreate> | undefined): boolean {
    return proto3.util.equals(PluginCreate, a, b);
  }
}

/**
 * PluginUpdate is emitted when a plugin resource is updated.
 *
 * @generated from message events.PluginUpdate
 */
export class PluginUpdate extends Message<PluginUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata user = 2;
   */
  user?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 3;
   */
  resource?: ResourceMetadata;

  /**
   * @generated from field: events.PluginMetadata plugin = 4;
   */
  plugin?: PluginMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata connection = 5;
   */
  connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<PluginUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PluginUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 2, name: "user", kind: "message", T: UserMetadata },
    { no: 3, name: "resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "plugin", kind: "message", T: PluginMetadata },
    { no: 5, name: "connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginUpdate {
    return new PluginUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginUpdate {
    return new PluginUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginUpdate {
    return new PluginUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: PluginUpdate | PlainMessage<PluginUpdate> | undefined, b: PluginUpdate | PlainMessage<PluginUpdate> | undefined): boolean {
    return proto3.util.equals(PluginUpdate, a, b);
  }
}

/**
 * PluginDelete is emitted when a plugin is deleted.
 *
 * @generated from message events.PluginDelete
 */
export class PluginDelete extends Message<PluginDelete> {
  /**
   * metadata is a common event metadata.
   *
   * @generated from field: events.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata user = 2;
   */
  user?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 3;
   */
  resource?: ResourceMetadata;

  /**
   * @generated from field: events.PluginMetadata plugin = 4;
   */
  plugin?: PluginMetadata;

  /**
   * ConnectionMetadata holds information about the connection.
   *
   * @generated from field: events.ConnectionMetadata connection = 5;
   */
  connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<PluginDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PluginDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 2, name: "user", kind: "message", T: UserMetadata },
    { no: 3, name: "resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "plugin", kind: "message", T: PluginMetadata },
    { no: 5, name: "connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDelete {
    return new PluginDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDelete {
    return new PluginDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDelete {
    return new PluginDelete().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDelete | PlainMessage<PluginDelete> | undefined, b: PluginDelete | PlainMessage<PluginDelete> | undefined): boolean {
    return proto3.util.equals(PluginDelete, a, b);
  }
}

/**
 * PluginMetadata contains information about plugin resources.
 *
 * @generated from message events.PluginMetadata
 */
export class PluginMetadata extends Message<PluginMetadata> {
  /**
   * plugin_type is the plugin type of the plugin resource.
   * The value matches the types.PluginV1.Spec.Type field.
   *
   * @generated from field: string plugin_type = 1;
   */
  pluginType = "";

  /**
   * has_credentials indicates whether the plugin has credentials.
   *
   * @generated from field: bool has_credentials = 3;
   */
  hasCredentials = false;

  /**
   * reuses_credentials indicates whether the plugin reuses credentials.
   *
   * @generated from field: bool reuses_credentials = 4;
   */
  reusesCredentials = false;

  /**
   * plugin_data is the plugin data of the plugin resource.
   *
   * @generated from field: google.protobuf.Struct plugin_data = 5;
   */
  pluginData?: Struct;

  constructor(data?: PartialMessage<PluginMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.PluginMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugin_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "has_credentials", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "reuses_credentials", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "plugin_data", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginMetadata {
    return new PluginMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginMetadata {
    return new PluginMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginMetadata {
    return new PluginMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PluginMetadata | PlainMessage<PluginMetadata> | undefined, b: PluginMetadata | PlainMessage<PluginMetadata> | undefined): boolean {
    return proto3.util.equals(PluginMetadata, a, b);
  }
}

/**
 * OneOf is a union of one of audit events submitted to the auth service
 *
 * @generated from message events.OneOf
 */
export class OneOf extends Message<OneOf> {
  /**
   * Event is one of the audit events
   *
   * @generated from oneof events.OneOf.Event
   */
  Event: {
    /**
     * @generated from field: events.UserLogin UserLogin = 1;
     */
    value: UserLogin;
    case: "UserLogin";
  } | {
    /**
     * @generated from field: events.UserCreate UserCreate = 2;
     */
    value: UserCreate;
    case: "UserCreate";
  } | {
    /**
     * @generated from field: events.UserDelete UserDelete = 3;
     */
    value: UserDelete;
    case: "UserDelete";
  } | {
    /**
     * @generated from field: events.UserPasswordChange UserPasswordChange = 4;
     */
    value: UserPasswordChange;
    case: "UserPasswordChange";
  } | {
    /**
     * @generated from field: events.SessionStart SessionStart = 5;
     */
    value: SessionStart;
    case: "SessionStart";
  } | {
    /**
     * @generated from field: events.SessionJoin SessionJoin = 6;
     */
    value: SessionJoin;
    case: "SessionJoin";
  } | {
    /**
     * @generated from field: events.SessionPrint SessionPrint = 7;
     */
    value: SessionPrint;
    case: "SessionPrint";
  } | {
    /**
     * @generated from field: events.SessionReject SessionReject = 8;
     */
    value: SessionReject;
    case: "SessionReject";
  } | {
    /**
     * @generated from field: events.Resize Resize = 9;
     */
    value: Resize;
    case: "Resize";
  } | {
    /**
     * @generated from field: events.SessionEnd SessionEnd = 10;
     */
    value: SessionEnd;
    case: "SessionEnd";
  } | {
    /**
     * @generated from field: events.SessionCommand SessionCommand = 11;
     */
    value: SessionCommand;
    case: "SessionCommand";
  } | {
    /**
     * @generated from field: events.SessionDisk SessionDisk = 12;
     */
    value: SessionDisk;
    case: "SessionDisk";
  } | {
    /**
     * @generated from field: events.SessionNetwork SessionNetwork = 13;
     */
    value: SessionNetwork;
    case: "SessionNetwork";
  } | {
    /**
     * @generated from field: events.SessionData SessionData = 14;
     */
    value: SessionData;
    case: "SessionData";
  } | {
    /**
     * @generated from field: events.SessionLeave SessionLeave = 15;
     */
    value: SessionLeave;
    case: "SessionLeave";
  } | {
    /**
     * @generated from field: events.PortForward PortForward = 16;
     */
    value: PortForward;
    case: "PortForward";
  } | {
    /**
     * @generated from field: events.X11Forward X11Forward = 17;
     */
    value: X11Forward;
    case: "X11Forward";
  } | {
    /**
     * @generated from field: events.SCP SCP = 18;
     */
    value: SCP;
    case: "SCP";
  } | {
    /**
     * @generated from field: events.Exec Exec = 19;
     */
    value: Exec;
    case: "Exec";
  } | {
    /**
     * @generated from field: events.Subsystem Subsystem = 20;
     */
    value: Subsystem;
    case: "Subsystem";
  } | {
    /**
     * @generated from field: events.ClientDisconnect ClientDisconnect = 21;
     */
    value: ClientDisconnect;
    case: "ClientDisconnect";
  } | {
    /**
     * @generated from field: events.AuthAttempt AuthAttempt = 22;
     */
    value: AuthAttempt;
    case: "AuthAttempt";
  } | {
    /**
     * @generated from field: events.AccessRequestCreate AccessRequestCreate = 23;
     */
    value: AccessRequestCreate;
    case: "AccessRequestCreate";
  } | {
    /**
     * @generated from field: events.UserTokenCreate UserTokenCreate = 24;
     */
    value: UserTokenCreate;
    case: "UserTokenCreate";
  } | {
    /**
     * @generated from field: events.RoleCreate RoleCreate = 25;
     */
    value: RoleCreate;
    case: "RoleCreate";
  } | {
    /**
     * @generated from field: events.RoleDelete RoleDelete = 26;
     */
    value: RoleDelete;
    case: "RoleDelete";
  } | {
    /**
     * @generated from field: events.TrustedClusterCreate TrustedClusterCreate = 27;
     */
    value: TrustedClusterCreate;
    case: "TrustedClusterCreate";
  } | {
    /**
     * @generated from field: events.TrustedClusterDelete TrustedClusterDelete = 28;
     */
    value: TrustedClusterDelete;
    case: "TrustedClusterDelete";
  } | {
    /**
     * @generated from field: events.TrustedClusterTokenCreate TrustedClusterTokenCreate = 29;
     */
    value: TrustedClusterTokenCreate;
    case: "TrustedClusterTokenCreate";
  } | {
    /**
     * @generated from field: events.GithubConnectorCreate GithubConnectorCreate = 30;
     */
    value: GithubConnectorCreate;
    case: "GithubConnectorCreate";
  } | {
    /**
     * @generated from field: events.GithubConnectorDelete GithubConnectorDelete = 31;
     */
    value: GithubConnectorDelete;
    case: "GithubConnectorDelete";
  } | {
    /**
     * @generated from field: events.OIDCConnectorCreate OIDCConnectorCreate = 32;
     */
    value: OIDCConnectorCreate;
    case: "OIDCConnectorCreate";
  } | {
    /**
     * @generated from field: events.OIDCConnectorDelete OIDCConnectorDelete = 33;
     */
    value: OIDCConnectorDelete;
    case: "OIDCConnectorDelete";
  } | {
    /**
     * @generated from field: events.SAMLConnectorCreate SAMLConnectorCreate = 34;
     */
    value: SAMLConnectorCreate;
    case: "SAMLConnectorCreate";
  } | {
    /**
     * @generated from field: events.SAMLConnectorDelete SAMLConnectorDelete = 35;
     */
    value: SAMLConnectorDelete;
    case: "SAMLConnectorDelete";
  } | {
    /**
     * @generated from field: events.KubeRequest KubeRequest = 36;
     */
    value: KubeRequest;
    case: "KubeRequest";
  } | {
    /**
     * @generated from field: events.AppSessionStart AppSessionStart = 37;
     */
    value: AppSessionStart;
    case: "AppSessionStart";
  } | {
    /**
     * @generated from field: events.AppSessionChunk AppSessionChunk = 38;
     */
    value: AppSessionChunk;
    case: "AppSessionChunk";
  } | {
    /**
     * @generated from field: events.AppSessionRequest AppSessionRequest = 39;
     */
    value: AppSessionRequest;
    case: "AppSessionRequest";
  } | {
    /**
     * @generated from field: events.DatabaseSessionStart DatabaseSessionStart = 40;
     */
    value: DatabaseSessionStart;
    case: "DatabaseSessionStart";
  } | {
    /**
     * @generated from field: events.DatabaseSessionEnd DatabaseSessionEnd = 41;
     */
    value: DatabaseSessionEnd;
    case: "DatabaseSessionEnd";
  } | {
    /**
     * @generated from field: events.DatabaseSessionQuery DatabaseSessionQuery = 42;
     */
    value: DatabaseSessionQuery;
    case: "DatabaseSessionQuery";
  } | {
    /**
     * @generated from field: events.SessionUpload SessionUpload = 43;
     */
    value: SessionUpload;
    case: "SessionUpload";
  } | {
    /**
     * @generated from field: events.MFADeviceAdd MFADeviceAdd = 44;
     */
    value: MFADeviceAdd;
    case: "MFADeviceAdd";
  } | {
    /**
     * @generated from field: events.MFADeviceDelete MFADeviceDelete = 45;
     */
    value: MFADeviceDelete;
    case: "MFADeviceDelete";
  } | {
    /**
     * @generated from field: events.BillingInformationUpdate BillingInformationUpdate = 46;
     */
    value: BillingInformationUpdate;
    case: "BillingInformationUpdate";
  } | {
    /**
     * @generated from field: events.BillingCardCreate BillingCardCreate = 47;
     */
    value: BillingCardCreate;
    case: "BillingCardCreate";
  } | {
    /**
     * @generated from field: events.BillingCardDelete BillingCardDelete = 48;
     */
    value: BillingCardDelete;
    case: "BillingCardDelete";
  } | {
    /**
     * @generated from field: events.LockCreate LockCreate = 49;
     */
    value: LockCreate;
    case: "LockCreate";
  } | {
    /**
     * @generated from field: events.LockDelete LockDelete = 50;
     */
    value: LockDelete;
    case: "LockDelete";
  } | {
    /**
     * @generated from field: events.RecoveryCodeGenerate RecoveryCodeGenerate = 51;
     */
    value: RecoveryCodeGenerate;
    case: "RecoveryCodeGenerate";
  } | {
    /**
     * @generated from field: events.RecoveryCodeUsed RecoveryCodeUsed = 52;
     */
    value: RecoveryCodeUsed;
    case: "RecoveryCodeUsed";
  } | {
    /**
     * @generated from field: events.DatabaseCreate DatabaseCreate = 53;
     */
    value: DatabaseCreate;
    case: "DatabaseCreate";
  } | {
    /**
     * @generated from field: events.DatabaseUpdate DatabaseUpdate = 54;
     */
    value: DatabaseUpdate;
    case: "DatabaseUpdate";
  } | {
    /**
     * @generated from field: events.DatabaseDelete DatabaseDelete = 55;
     */
    value: DatabaseDelete;
    case: "DatabaseDelete";
  } | {
    /**
     * @generated from field: events.AppCreate AppCreate = 56;
     */
    value: AppCreate;
    case: "AppCreate";
  } | {
    /**
     * @generated from field: events.AppUpdate AppUpdate = 57;
     */
    value: AppUpdate;
    case: "AppUpdate";
  } | {
    /**
     * @generated from field: events.AppDelete AppDelete = 58;
     */
    value: AppDelete;
    case: "AppDelete";
  } | {
    /**
     * @generated from field: events.WindowsDesktopSessionStart WindowsDesktopSessionStart = 59;
     */
    value: WindowsDesktopSessionStart;
    case: "WindowsDesktopSessionStart";
  } | {
    /**
     * @generated from field: events.WindowsDesktopSessionEnd WindowsDesktopSessionEnd = 60;
     */
    value: WindowsDesktopSessionEnd;
    case: "WindowsDesktopSessionEnd";
  } | {
    /**
     * @generated from field: events.PostgresParse PostgresParse = 61;
     */
    value: PostgresParse;
    case: "PostgresParse";
  } | {
    /**
     * @generated from field: events.PostgresBind PostgresBind = 62;
     */
    value: PostgresBind;
    case: "PostgresBind";
  } | {
    /**
     * @generated from field: events.PostgresExecute PostgresExecute = 63;
     */
    value: PostgresExecute;
    case: "PostgresExecute";
  } | {
    /**
     * @generated from field: events.PostgresClose PostgresClose = 64;
     */
    value: PostgresClose;
    case: "PostgresClose";
  } | {
    /**
     * @generated from field: events.PostgresFunctionCall PostgresFunctionCall = 65;
     */
    value: PostgresFunctionCall;
    case: "PostgresFunctionCall";
  } | {
    /**
     * @generated from field: events.AccessRequestDelete AccessRequestDelete = 66;
     */
    value: AccessRequestDelete;
    case: "AccessRequestDelete";
  } | {
    /**
     * @generated from field: events.SessionConnect SessionConnect = 67;
     */
    value: SessionConnect;
    case: "SessionConnect";
  } | {
    /**
     * @generated from field: events.CertificateCreate CertificateCreate = 68;
     */
    value: CertificateCreate;
    case: "CertificateCreate";
  } | {
    /**
     * @generated from field: events.DesktopRecording DesktopRecording = 69;
     */
    value: DesktopRecording;
    case: "DesktopRecording";
  } | {
    /**
     * @generated from field: events.DesktopClipboardSend DesktopClipboardSend = 70;
     */
    value: DesktopClipboardSend;
    case: "DesktopClipboardSend";
  } | {
    /**
     * @generated from field: events.DesktopClipboardReceive DesktopClipboardReceive = 71;
     */
    value: DesktopClipboardReceive;
    case: "DesktopClipboardReceive";
  } | {
    /**
     * @generated from field: events.MySQLStatementPrepare MySQLStatementPrepare = 72;
     */
    value: MySQLStatementPrepare;
    case: "MySQLStatementPrepare";
  } | {
    /**
     * @generated from field: events.MySQLStatementExecute MySQLStatementExecute = 73;
     */
    value: MySQLStatementExecute;
    case: "MySQLStatementExecute";
  } | {
    /**
     * @generated from field: events.MySQLStatementSendLongData MySQLStatementSendLongData = 74;
     */
    value: MySQLStatementSendLongData;
    case: "MySQLStatementSendLongData";
  } | {
    /**
     * @generated from field: events.MySQLStatementClose MySQLStatementClose = 75;
     */
    value: MySQLStatementClose;
    case: "MySQLStatementClose";
  } | {
    /**
     * @generated from field: events.MySQLStatementReset MySQLStatementReset = 76;
     */
    value: MySQLStatementReset;
    case: "MySQLStatementReset";
  } | {
    /**
     * @generated from field: events.MySQLStatementFetch MySQLStatementFetch = 77;
     */
    value: MySQLStatementFetch;
    case: "MySQLStatementFetch";
  } | {
    /**
     * @generated from field: events.MySQLStatementBulkExecute MySQLStatementBulkExecute = 78;
     */
    value: MySQLStatementBulkExecute;
    case: "MySQLStatementBulkExecute";
  } | {
    /**
     * @generated from field: events.RenewableCertificateGenerationMismatch RenewableCertificateGenerationMismatch = 79;
     */
    value: RenewableCertificateGenerationMismatch;
    case: "RenewableCertificateGenerationMismatch";
  } | {
    /**
     * @generated from field: events.Unknown Unknown = 80;
     */
    value: Unknown;
    case: "Unknown";
  } | {
    /**
     * @generated from field: events.MySQLInitDB MySQLInitDB = 81;
     */
    value: MySQLInitDB;
    case: "MySQLInitDB";
  } | {
    /**
     * @generated from field: events.MySQLCreateDB MySQLCreateDB = 82;
     */
    value: MySQLCreateDB;
    case: "MySQLCreateDB";
  } | {
    /**
     * @generated from field: events.MySQLDropDB MySQLDropDB = 83;
     */
    value: MySQLDropDB;
    case: "MySQLDropDB";
  } | {
    /**
     * @generated from field: events.MySQLShutDown MySQLShutDown = 84;
     */
    value: MySQLShutDown;
    case: "MySQLShutDown";
  } | {
    /**
     * @generated from field: events.MySQLProcessKill MySQLProcessKill = 85;
     */
    value: MySQLProcessKill;
    case: "MySQLProcessKill";
  } | {
    /**
     * @generated from field: events.MySQLDebug MySQLDebug = 86;
     */
    value: MySQLDebug;
    case: "MySQLDebug";
  } | {
    /**
     * @generated from field: events.MySQLRefresh MySQLRefresh = 87;
     */
    value: MySQLRefresh;
    case: "MySQLRefresh";
  } | {
    /**
     * @generated from field: events.AccessRequestResourceSearch AccessRequestResourceSearch = 88;
     */
    value: AccessRequestResourceSearch;
    case: "AccessRequestResourceSearch";
  } | {
    /**
     * @generated from field: events.SQLServerRPCRequest SQLServerRPCRequest = 89;
     */
    value: SQLServerRPCRequest;
    case: "SQLServerRPCRequest";
  } | {
    /**
     * @generated from field: events.DatabaseSessionMalformedPacket DatabaseSessionMalformedPacket = 90;
     */
    value: DatabaseSessionMalformedPacket;
    case: "DatabaseSessionMalformedPacket";
  } | {
    /**
     * @generated from field: events.SFTP SFTP = 91;
     */
    value: SFTP;
    case: "SFTP";
  } | {
    /**
     * @generated from field: events.UpgradeWindowStartUpdate UpgradeWindowStartUpdate = 92;
     */
    value: UpgradeWindowStartUpdate;
    case: "UpgradeWindowStartUpdate";
  } | {
    /**
     * @generated from field: events.AppSessionEnd AppSessionEnd = 93;
     */
    value: AppSessionEnd;
    case: "AppSessionEnd";
  } | {
    /**
     * @generated from field: events.SessionRecordingAccess SessionRecordingAccess = 94;
     */
    value: SessionRecordingAccess;
    case: "SessionRecordingAccess";
  } | {
    /**
     * @generated from field: events.KubernetesClusterCreate KubernetesClusterCreate = 96;
     */
    value: KubernetesClusterCreate;
    case: "KubernetesClusterCreate";
  } | {
    /**
     * @generated from field: events.KubernetesClusterUpdate KubernetesClusterUpdate = 97;
     */
    value: KubernetesClusterUpdate;
    case: "KubernetesClusterUpdate";
  } | {
    /**
     * @generated from field: events.KubernetesClusterDelete KubernetesClusterDelete = 98;
     */
    value: KubernetesClusterDelete;
    case: "KubernetesClusterDelete";
  } | {
    /**
     * @generated from field: events.SSMRun SSMRun = 99;
     */
    value: SSMRun;
    case: "SSMRun";
  } | {
    /**
     * @generated from field: events.ElasticsearchRequest ElasticsearchRequest = 100;
     */
    value: ElasticsearchRequest;
    case: "ElasticsearchRequest";
  } | {
    /**
     * @generated from field: events.CassandraBatch CassandraBatch = 101;
     */
    value: CassandraBatch;
    case: "CassandraBatch";
  } | {
    /**
     * @generated from field: events.CassandraPrepare CassandraPrepare = 102;
     */
    value: CassandraPrepare;
    case: "CassandraPrepare";
  } | {
    /**
     * @generated from field: events.CassandraRegister CassandraRegister = 103;
     */
    value: CassandraRegister;
    case: "CassandraRegister";
  } | {
    /**
     * @generated from field: events.CassandraExecute CassandraExecute = 104;
     */
    value: CassandraExecute;
    case: "CassandraExecute";
  } | {
    /**
     * @generated from field: events.AppSessionDynamoDBRequest AppSessionDynamoDBRequest = 105;
     */
    value: AppSessionDynamoDBRequest;
    case: "AppSessionDynamoDBRequest";
  } | {
    /**
     * @generated from field: events.DesktopSharedDirectoryStart DesktopSharedDirectoryStart = 106;
     */
    value: DesktopSharedDirectoryStart;
    case: "DesktopSharedDirectoryStart";
  } | {
    /**
     * @generated from field: events.DesktopSharedDirectoryRead DesktopSharedDirectoryRead = 107;
     */
    value: DesktopSharedDirectoryRead;
    case: "DesktopSharedDirectoryRead";
  } | {
    /**
     * @generated from field: events.DesktopSharedDirectoryWrite DesktopSharedDirectoryWrite = 108;
     */
    value: DesktopSharedDirectoryWrite;
    case: "DesktopSharedDirectoryWrite";
  } | {
    /**
     * @generated from field: events.DynamoDBRequest DynamoDBRequest = 109;
     */
    value: DynamoDBRequest;
    case: "DynamoDBRequest";
  } | {
    /**
     * @generated from field: events.BotJoin BotJoin = 110;
     */
    value: BotJoin;
    case: "BotJoin";
  } | {
    /**
     * @generated from field: events.InstanceJoin InstanceJoin = 111;
     */
    value: InstanceJoin;
    case: "InstanceJoin";
  } | {
    /**
     * @generated from field: events.DeviceEvent DeviceEvent = 112;
     */
    value: DeviceEvent;
    case: "DeviceEvent";
  } | {
    /**
     * @generated from field: events.LoginRuleCreate LoginRuleCreate = 113;
     */
    value: LoginRuleCreate;
    case: "LoginRuleCreate";
  } | {
    /**
     * @generated from field: events.LoginRuleDelete LoginRuleDelete = 114;
     */
    value: LoginRuleDelete;
    case: "LoginRuleDelete";
  } | {
    /**
     * @generated from field: events.SAMLIdPAuthAttempt SAMLIdPAuthAttempt = 115;
     */
    value: SAMLIdPAuthAttempt;
    case: "SAMLIdPAuthAttempt";
  } | {
    /**
     * @generated from field: events.SAMLIdPServiceProviderCreate SAMLIdPServiceProviderCreate = 116;
     */
    value: SAMLIdPServiceProviderCreate;
    case: "SAMLIdPServiceProviderCreate";
  } | {
    /**
     * @generated from field: events.SAMLIdPServiceProviderUpdate SAMLIdPServiceProviderUpdate = 117;
     */
    value: SAMLIdPServiceProviderUpdate;
    case: "SAMLIdPServiceProviderUpdate";
  } | {
    /**
     * @generated from field: events.SAMLIdPServiceProviderDelete SAMLIdPServiceProviderDelete = 118;
     */
    value: SAMLIdPServiceProviderDelete;
    case: "SAMLIdPServiceProviderDelete";
  } | {
    /**
     * @generated from field: events.SAMLIdPServiceProviderDeleteAll SAMLIdPServiceProviderDeleteAll = 119;
     */
    value: SAMLIdPServiceProviderDeleteAll;
    case: "SAMLIdPServiceProviderDeleteAll";
  } | {
    /**
     * @generated from field: events.OpenSearchRequest OpenSearchRequest = 120;
     */
    value: OpenSearchRequest;
    case: "OpenSearchRequest";
  } | {
    /**
     * @generated from field: events.DeviceEvent2 DeviceEvent2 = 121;
     */
    value: DeviceEvent2;
    case: "DeviceEvent2";
  } | {
    /**
     * @generated from field: events.OktaResourcesUpdate OktaResourcesUpdate = 122;
     */
    value: OktaResourcesUpdate;
    case: "OktaResourcesUpdate";
  } | {
    /**
     * @generated from field: events.OktaSyncFailure OktaSyncFailure = 123;
     */
    value: OktaSyncFailure;
    case: "OktaSyncFailure";
  } | {
    /**
     * @generated from field: events.OktaAssignmentResult OktaAssignmentResult = 124;
     */
    value: OktaAssignmentResult;
    case: "OktaAssignmentResult";
  } | {
    /**
     * @generated from field: events.ProvisionTokenCreate ProvisionTokenCreate = 125;
     */
    value: ProvisionTokenCreate;
    case: "ProvisionTokenCreate";
  } | {
    /**
     * @generated from field: events.AccessListCreate AccessListCreate = 126;
     */
    value: AccessListCreate;
    case: "AccessListCreate";
  } | {
    /**
     * @generated from field: events.AccessListUpdate AccessListUpdate = 127;
     */
    value: AccessListUpdate;
    case: "AccessListUpdate";
  } | {
    /**
     * @generated from field: events.AccessListDelete AccessListDelete = 128;
     */
    value: AccessListDelete;
    case: "AccessListDelete";
  } | {
    /**
     * @generated from field: events.AccessListReview AccessListReview = 129;
     */
    value: AccessListReview;
    case: "AccessListReview";
  } | {
    /**
     * @generated from field: events.AccessListMemberCreate AccessListMemberCreate = 130;
     */
    value: AccessListMemberCreate;
    case: "AccessListMemberCreate";
  } | {
    /**
     * @generated from field: events.AccessListMemberUpdate AccessListMemberUpdate = 131;
     */
    value: AccessListMemberUpdate;
    case: "AccessListMemberUpdate";
  } | {
    /**
     * @generated from field: events.AccessListMemberDelete AccessListMemberDelete = 132;
     */
    value: AccessListMemberDelete;
    case: "AccessListMemberDelete";
  } | {
    /**
     * @generated from field: events.AccessListMemberDeleteAllForAccessList AccessListMemberDeleteAllForAccessList = 133;
     */
    value: AccessListMemberDeleteAllForAccessList;
    case: "AccessListMemberDeleteAllForAccessList";
  } | {
    /**
     * @generated from field: events.AuditQueryRun AuditQueryRun = 134;
     */
    value: AuditQueryRun;
    case: "AuditQueryRun";
  } | {
    /**
     * @generated from field: events.SecurityReportRun SecurityReportRun = 135;
     */
    value: SecurityReportRun;
    case: "SecurityReportRun";
  } | {
    /**
     * @generated from field: events.GithubConnectorUpdate GithubConnectorUpdate = 136;
     */
    value: GithubConnectorUpdate;
    case: "GithubConnectorUpdate";
  } | {
    /**
     * @generated from field: events.OIDCConnectorUpdate OIDCConnectorUpdate = 137;
     */
    value: OIDCConnectorUpdate;
    case: "OIDCConnectorUpdate";
  } | {
    /**
     * @generated from field: events.SAMLConnectorUpdate SAMLConnectorUpdate = 138;
     */
    value: SAMLConnectorUpdate;
    case: "SAMLConnectorUpdate";
  } | {
    /**
     * @generated from field: events.RoleUpdate RoleUpdate = 139;
     */
    value: RoleUpdate;
    case: "RoleUpdate";
  } | {
    /**
     * @generated from field: events.UserUpdate UserUpdate = 140;
     */
    value: UserUpdate;
    case: "UserUpdate";
  } | {
    /**
     * @generated from field: events.ExternalAuditStorageEnable ExternalAuditStorageEnable = 141;
     */
    value: ExternalAuditStorageEnable;
    case: "ExternalAuditStorageEnable";
  } | {
    /**
     * @generated from field: events.ExternalAuditStorageDisable ExternalAuditStorageDisable = 142;
     */
    value: ExternalAuditStorageDisable;
    case: "ExternalAuditStorageDisable";
  } | {
    /**
     * @generated from field: events.BotCreate BotCreate = 143;
     */
    value: BotCreate;
    case: "BotCreate";
  } | {
    /**
     * @generated from field: events.BotDelete BotDelete = 144;
     */
    value: BotDelete;
    case: "BotDelete";
  } | {
    /**
     * @generated from field: events.BotUpdate BotUpdate = 145;
     */
    value: BotUpdate;
    case: "BotUpdate";
  } | {
    /**
     * @generated from field: events.CreateMFAAuthChallenge CreateMFAAuthChallenge = 146;
     */
    value: CreateMFAAuthChallenge;
    case: "CreateMFAAuthChallenge";
  } | {
    /**
     * @generated from field: events.ValidateMFAAuthResponse ValidateMFAAuthResponse = 147;
     */
    value: ValidateMFAAuthResponse;
    case: "ValidateMFAAuthResponse";
  } | {
    /**
     * @generated from field: events.OktaAccessListSync OktaAccessListSync = 148;
     */
    value: OktaAccessListSync;
    case: "OktaAccessListSync";
  } | {
    /**
     * @generated from field: events.DatabasePermissionUpdate DatabasePermissionUpdate = 149;
     */
    value: DatabasePermissionUpdate;
    case: "DatabasePermissionUpdate";
  } | {
    /**
     * @generated from field: events.SPIFFESVIDIssued SPIFFESVIDIssued = 150;
     */
    value: SPIFFESVIDIssued;
    case: "SPIFFESVIDIssued";
  } | {
    /**
     * @generated from field: events.OktaUserSync OktaUserSync = 151;
     */
    value: OktaUserSync;
    case: "OktaUserSync";
  } | {
    /**
     * @generated from field: events.AuthPreferenceUpdate AuthPreferenceUpdate = 152;
     */
    value: AuthPreferenceUpdate;
    case: "AuthPreferenceUpdate";
  } | {
    /**
     * @generated from field: events.SessionRecordingConfigUpdate SessionRecordingConfigUpdate = 153;
     */
    value: SessionRecordingConfigUpdate;
    case: "SessionRecordingConfigUpdate";
  } | {
    /**
     * @generated from field: events.ClusterNetworkingConfigUpdate ClusterNetworkingConfigUpdate = 154;
     */
    value: ClusterNetworkingConfigUpdate;
    case: "ClusterNetworkingConfigUpdate";
  } | {
    /**
     * @generated from field: events.DatabaseUserCreate DatabaseUserCreate = 155;
     */
    value: DatabaseUserCreate;
    case: "DatabaseUserCreate";
  } | {
    /**
     * @generated from field: events.DatabaseUserDeactivate DatabaseUserDeactivate = 156;
     */
    value: DatabaseUserDeactivate;
    case: "DatabaseUserDeactivate";
  } | {
    /**
     * @generated from field: events.AccessPathChanged AccessPathChanged = 157;
     */
    value: AccessPathChanged;
    case: "AccessPathChanged";
  } | {
    /**
     * @generated from field: events.SpannerRPC SpannerRPC = 158;
     */
    value: SpannerRPC;
    case: "SpannerRPC";
  } | {
    /**
     * @generated from field: events.DatabaseSessionCommandResult DatabaseSessionCommandResult = 159;
     */
    value: DatabaseSessionCommandResult;
    case: "DatabaseSessionCommandResult";
  } | {
    /**
     * @generated from field: events.DiscoveryConfigCreate DiscoveryConfigCreate = 160;
     */
    value: DiscoveryConfigCreate;
    case: "DiscoveryConfigCreate";
  } | {
    /**
     * @generated from field: events.DiscoveryConfigUpdate DiscoveryConfigUpdate = 161;
     */
    value: DiscoveryConfigUpdate;
    case: "DiscoveryConfigUpdate";
  } | {
    /**
     * @generated from field: events.DiscoveryConfigDelete DiscoveryConfigDelete = 162;
     */
    value: DiscoveryConfigDelete;
    case: "DiscoveryConfigDelete";
  } | {
    /**
     * @generated from field: events.DiscoveryConfigDeleteAll DiscoveryConfigDeleteAll = 163;
     */
    value: DiscoveryConfigDeleteAll;
    case: "DiscoveryConfigDeleteAll";
  } | {
    /**
     * @generated from field: events.AccessGraphSettingsUpdate AccessGraphSettingsUpdate = 164;
     */
    value: AccessGraphSettingsUpdate;
    case: "AccessGraphSettingsUpdate";
  } | {
    /**
     * @generated from field: events.IntegrationCreate IntegrationCreate = 165;
     */
    value: IntegrationCreate;
    case: "IntegrationCreate";
  } | {
    /**
     * @generated from field: events.IntegrationUpdate IntegrationUpdate = 166;
     */
    value: IntegrationUpdate;
    case: "IntegrationUpdate";
  } | {
    /**
     * @generated from field: events.IntegrationDelete IntegrationDelete = 167;
     */
    value: IntegrationDelete;
    case: "IntegrationDelete";
  } | {
    /**
     * @generated from field: events.SPIFFEFederationCreate SPIFFEFederationCreate = 168;
     */
    value: SPIFFEFederationCreate;
    case: "SPIFFEFederationCreate";
  } | {
    /**
     * @generated from field: events.SPIFFEFederationDelete SPIFFEFederationDelete = 169;
     */
    value: SPIFFEFederationDelete;
    case: "SPIFFEFederationDelete";
  } | {
    /**
     * @generated from field: events.PluginCreate PluginCreate = 170;
     */
    value: PluginCreate;
    case: "PluginCreate";
  } | {
    /**
     * @generated from field: events.PluginUpdate PluginUpdate = 171;
     */
    value: PluginUpdate;
    case: "PluginUpdate";
  } | {
    /**
     * @generated from field: events.PluginDelete PluginDelete = 172;
     */
    value: PluginDelete;
    case: "PluginDelete";
  } | {
    /**
     * @generated from field: events.AutoUpdateConfigCreate AutoUpdateConfigCreate = 173;
     */
    value: AutoUpdateConfigCreate;
    case: "AutoUpdateConfigCreate";
  } | {
    /**
     * @generated from field: events.AutoUpdateConfigUpdate AutoUpdateConfigUpdate = 174;
     */
    value: AutoUpdateConfigUpdate;
    case: "AutoUpdateConfigUpdate";
  } | {
    /**
     * @generated from field: events.AutoUpdateConfigDelete AutoUpdateConfigDelete = 175;
     */
    value: AutoUpdateConfigDelete;
    case: "AutoUpdateConfigDelete";
  } | {
    /**
     * @generated from field: events.AutoUpdateVersionCreate AutoUpdateVersionCreate = 176;
     */
    value: AutoUpdateVersionCreate;
    case: "AutoUpdateVersionCreate";
  } | {
    /**
     * @generated from field: events.AutoUpdateVersionUpdate AutoUpdateVersionUpdate = 177;
     */
    value: AutoUpdateVersionUpdate;
    case: "AutoUpdateVersionUpdate";
  } | {
    /**
     * @generated from field: events.AutoUpdateVersionDelete AutoUpdateVersionDelete = 178;
     */
    value: AutoUpdateVersionDelete;
    case: "AutoUpdateVersionDelete";
  } | {
    /**
     * @generated from field: events.StaticHostUserCreate StaticHostUserCreate = 179;
     */
    value: StaticHostUserCreate;
    case: "StaticHostUserCreate";
  } | {
    /**
     * @generated from field: events.StaticHostUserUpdate StaticHostUserUpdate = 180;
     */
    value: StaticHostUserUpdate;
    case: "StaticHostUserUpdate";
  } | {
    /**
     * @generated from field: events.StaticHostUserDelete StaticHostUserDelete = 181;
     */
    value: StaticHostUserDelete;
    case: "StaticHostUserDelete";
  } | {
    /**
     * @generated from field: events.CrownJewelCreate CrownJewelCreate = 182;
     */
    value: CrownJewelCreate;
    case: "CrownJewelCreate";
  } | {
    /**
     * @generated from field: events.CrownJewelUpdate CrownJewelUpdate = 183;
     */
    value: CrownJewelUpdate;
    case: "CrownJewelUpdate";
  } | {
    /**
     * @generated from field: events.CrownJewelDelete CrownJewelDelete = 184;
     */
    value: CrownJewelDelete;
    case: "CrownJewelDelete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OneOf>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OneOf";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UserLogin", kind: "message", T: UserLogin, oneof: "Event" },
    { no: 2, name: "UserCreate", kind: "message", T: UserCreate, oneof: "Event" },
    { no: 3, name: "UserDelete", kind: "message", T: UserDelete, oneof: "Event" },
    { no: 4, name: "UserPasswordChange", kind: "message", T: UserPasswordChange, oneof: "Event" },
    { no: 5, name: "SessionStart", kind: "message", T: SessionStart, oneof: "Event" },
    { no: 6, name: "SessionJoin", kind: "message", T: SessionJoin, oneof: "Event" },
    { no: 7, name: "SessionPrint", kind: "message", T: SessionPrint, oneof: "Event" },
    { no: 8, name: "SessionReject", kind: "message", T: SessionReject, oneof: "Event" },
    { no: 9, name: "Resize", kind: "message", T: Resize, oneof: "Event" },
    { no: 10, name: "SessionEnd", kind: "message", T: SessionEnd, oneof: "Event" },
    { no: 11, name: "SessionCommand", kind: "message", T: SessionCommand, oneof: "Event" },
    { no: 12, name: "SessionDisk", kind: "message", T: SessionDisk, oneof: "Event" },
    { no: 13, name: "SessionNetwork", kind: "message", T: SessionNetwork, oneof: "Event" },
    { no: 14, name: "SessionData", kind: "message", T: SessionData, oneof: "Event" },
    { no: 15, name: "SessionLeave", kind: "message", T: SessionLeave, oneof: "Event" },
    { no: 16, name: "PortForward", kind: "message", T: PortForward, oneof: "Event" },
    { no: 17, name: "X11Forward", kind: "message", T: X11Forward, oneof: "Event" },
    { no: 18, name: "SCP", kind: "message", T: SCP, oneof: "Event" },
    { no: 19, name: "Exec", kind: "message", T: Exec, oneof: "Event" },
    { no: 20, name: "Subsystem", kind: "message", T: Subsystem, oneof: "Event" },
    { no: 21, name: "ClientDisconnect", kind: "message", T: ClientDisconnect, oneof: "Event" },
    { no: 22, name: "AuthAttempt", kind: "message", T: AuthAttempt, oneof: "Event" },
    { no: 23, name: "AccessRequestCreate", kind: "message", T: AccessRequestCreate, oneof: "Event" },
    { no: 24, name: "UserTokenCreate", kind: "message", T: UserTokenCreate, oneof: "Event" },
    { no: 25, name: "RoleCreate", kind: "message", T: RoleCreate, oneof: "Event" },
    { no: 26, name: "RoleDelete", kind: "message", T: RoleDelete, oneof: "Event" },
    { no: 27, name: "TrustedClusterCreate", kind: "message", T: TrustedClusterCreate, oneof: "Event" },
    { no: 28, name: "TrustedClusterDelete", kind: "message", T: TrustedClusterDelete, oneof: "Event" },
    { no: 29, name: "TrustedClusterTokenCreate", kind: "message", T: TrustedClusterTokenCreate, oneof: "Event" },
    { no: 30, name: "GithubConnectorCreate", kind: "message", T: GithubConnectorCreate, oneof: "Event" },
    { no: 31, name: "GithubConnectorDelete", kind: "message", T: GithubConnectorDelete, oneof: "Event" },
    { no: 32, name: "OIDCConnectorCreate", kind: "message", T: OIDCConnectorCreate, oneof: "Event" },
    { no: 33, name: "OIDCConnectorDelete", kind: "message", T: OIDCConnectorDelete, oneof: "Event" },
    { no: 34, name: "SAMLConnectorCreate", kind: "message", T: SAMLConnectorCreate, oneof: "Event" },
    { no: 35, name: "SAMLConnectorDelete", kind: "message", T: SAMLConnectorDelete, oneof: "Event" },
    { no: 36, name: "KubeRequest", kind: "message", T: KubeRequest, oneof: "Event" },
    { no: 37, name: "AppSessionStart", kind: "message", T: AppSessionStart, oneof: "Event" },
    { no: 38, name: "AppSessionChunk", kind: "message", T: AppSessionChunk, oneof: "Event" },
    { no: 39, name: "AppSessionRequest", kind: "message", T: AppSessionRequest, oneof: "Event" },
    { no: 40, name: "DatabaseSessionStart", kind: "message", T: DatabaseSessionStart, oneof: "Event" },
    { no: 41, name: "DatabaseSessionEnd", kind: "message", T: DatabaseSessionEnd, oneof: "Event" },
    { no: 42, name: "DatabaseSessionQuery", kind: "message", T: DatabaseSessionQuery, oneof: "Event" },
    { no: 43, name: "SessionUpload", kind: "message", T: SessionUpload, oneof: "Event" },
    { no: 44, name: "MFADeviceAdd", kind: "message", T: MFADeviceAdd, oneof: "Event" },
    { no: 45, name: "MFADeviceDelete", kind: "message", T: MFADeviceDelete, oneof: "Event" },
    { no: 46, name: "BillingInformationUpdate", kind: "message", T: BillingInformationUpdate, oneof: "Event" },
    { no: 47, name: "BillingCardCreate", kind: "message", T: BillingCardCreate, oneof: "Event" },
    { no: 48, name: "BillingCardDelete", kind: "message", T: BillingCardDelete, oneof: "Event" },
    { no: 49, name: "LockCreate", kind: "message", T: LockCreate, oneof: "Event" },
    { no: 50, name: "LockDelete", kind: "message", T: LockDelete, oneof: "Event" },
    { no: 51, name: "RecoveryCodeGenerate", kind: "message", T: RecoveryCodeGenerate, oneof: "Event" },
    { no: 52, name: "RecoveryCodeUsed", kind: "message", T: RecoveryCodeUsed, oneof: "Event" },
    { no: 53, name: "DatabaseCreate", kind: "message", T: DatabaseCreate, oneof: "Event" },
    { no: 54, name: "DatabaseUpdate", kind: "message", T: DatabaseUpdate, oneof: "Event" },
    { no: 55, name: "DatabaseDelete", kind: "message", T: DatabaseDelete, oneof: "Event" },
    { no: 56, name: "AppCreate", kind: "message", T: AppCreate, oneof: "Event" },
    { no: 57, name: "AppUpdate", kind: "message", T: AppUpdate, oneof: "Event" },
    { no: 58, name: "AppDelete", kind: "message", T: AppDelete, oneof: "Event" },
    { no: 59, name: "WindowsDesktopSessionStart", kind: "message", T: WindowsDesktopSessionStart, oneof: "Event" },
    { no: 60, name: "WindowsDesktopSessionEnd", kind: "message", T: WindowsDesktopSessionEnd, oneof: "Event" },
    { no: 61, name: "PostgresParse", kind: "message", T: PostgresParse, oneof: "Event" },
    { no: 62, name: "PostgresBind", kind: "message", T: PostgresBind, oneof: "Event" },
    { no: 63, name: "PostgresExecute", kind: "message", T: PostgresExecute, oneof: "Event" },
    { no: 64, name: "PostgresClose", kind: "message", T: PostgresClose, oneof: "Event" },
    { no: 65, name: "PostgresFunctionCall", kind: "message", T: PostgresFunctionCall, oneof: "Event" },
    { no: 66, name: "AccessRequestDelete", kind: "message", T: AccessRequestDelete, oneof: "Event" },
    { no: 67, name: "SessionConnect", kind: "message", T: SessionConnect, oneof: "Event" },
    { no: 68, name: "CertificateCreate", kind: "message", T: CertificateCreate, oneof: "Event" },
    { no: 69, name: "DesktopRecording", kind: "message", T: DesktopRecording, oneof: "Event" },
    { no: 70, name: "DesktopClipboardSend", kind: "message", T: DesktopClipboardSend, oneof: "Event" },
    { no: 71, name: "DesktopClipboardReceive", kind: "message", T: DesktopClipboardReceive, oneof: "Event" },
    { no: 72, name: "MySQLStatementPrepare", kind: "message", T: MySQLStatementPrepare, oneof: "Event" },
    { no: 73, name: "MySQLStatementExecute", kind: "message", T: MySQLStatementExecute, oneof: "Event" },
    { no: 74, name: "MySQLStatementSendLongData", kind: "message", T: MySQLStatementSendLongData, oneof: "Event" },
    { no: 75, name: "MySQLStatementClose", kind: "message", T: MySQLStatementClose, oneof: "Event" },
    { no: 76, name: "MySQLStatementReset", kind: "message", T: MySQLStatementReset, oneof: "Event" },
    { no: 77, name: "MySQLStatementFetch", kind: "message", T: MySQLStatementFetch, oneof: "Event" },
    { no: 78, name: "MySQLStatementBulkExecute", kind: "message", T: MySQLStatementBulkExecute, oneof: "Event" },
    { no: 79, name: "RenewableCertificateGenerationMismatch", kind: "message", T: RenewableCertificateGenerationMismatch, oneof: "Event" },
    { no: 80, name: "Unknown", kind: "message", T: Unknown, oneof: "Event" },
    { no: 81, name: "MySQLInitDB", kind: "message", T: MySQLInitDB, oneof: "Event" },
    { no: 82, name: "MySQLCreateDB", kind: "message", T: MySQLCreateDB, oneof: "Event" },
    { no: 83, name: "MySQLDropDB", kind: "message", T: MySQLDropDB, oneof: "Event" },
    { no: 84, name: "MySQLShutDown", kind: "message", T: MySQLShutDown, oneof: "Event" },
    { no: 85, name: "MySQLProcessKill", kind: "message", T: MySQLProcessKill, oneof: "Event" },
    { no: 86, name: "MySQLDebug", kind: "message", T: MySQLDebug, oneof: "Event" },
    { no: 87, name: "MySQLRefresh", kind: "message", T: MySQLRefresh, oneof: "Event" },
    { no: 88, name: "AccessRequestResourceSearch", kind: "message", T: AccessRequestResourceSearch, oneof: "Event" },
    { no: 89, name: "SQLServerRPCRequest", kind: "message", T: SQLServerRPCRequest, oneof: "Event" },
    { no: 90, name: "DatabaseSessionMalformedPacket", kind: "message", T: DatabaseSessionMalformedPacket, oneof: "Event" },
    { no: 91, name: "SFTP", kind: "message", T: SFTP, oneof: "Event" },
    { no: 92, name: "UpgradeWindowStartUpdate", kind: "message", T: UpgradeWindowStartUpdate, oneof: "Event" },
    { no: 93, name: "AppSessionEnd", kind: "message", T: AppSessionEnd, oneof: "Event" },
    { no: 94, name: "SessionRecordingAccess", kind: "message", T: SessionRecordingAccess, oneof: "Event" },
    { no: 96, name: "KubernetesClusterCreate", kind: "message", T: KubernetesClusterCreate, oneof: "Event" },
    { no: 97, name: "KubernetesClusterUpdate", kind: "message", T: KubernetesClusterUpdate, oneof: "Event" },
    { no: 98, name: "KubernetesClusterDelete", kind: "message", T: KubernetesClusterDelete, oneof: "Event" },
    { no: 99, name: "SSMRun", kind: "message", T: SSMRun, oneof: "Event" },
    { no: 100, name: "ElasticsearchRequest", kind: "message", T: ElasticsearchRequest, oneof: "Event" },
    { no: 101, name: "CassandraBatch", kind: "message", T: CassandraBatch, oneof: "Event" },
    { no: 102, name: "CassandraPrepare", kind: "message", T: CassandraPrepare, oneof: "Event" },
    { no: 103, name: "CassandraRegister", kind: "message", T: CassandraRegister, oneof: "Event" },
    { no: 104, name: "CassandraExecute", kind: "message", T: CassandraExecute, oneof: "Event" },
    { no: 105, name: "AppSessionDynamoDBRequest", kind: "message", T: AppSessionDynamoDBRequest, oneof: "Event" },
    { no: 106, name: "DesktopSharedDirectoryStart", kind: "message", T: DesktopSharedDirectoryStart, oneof: "Event" },
    { no: 107, name: "DesktopSharedDirectoryRead", kind: "message", T: DesktopSharedDirectoryRead, oneof: "Event" },
    { no: 108, name: "DesktopSharedDirectoryWrite", kind: "message", T: DesktopSharedDirectoryWrite, oneof: "Event" },
    { no: 109, name: "DynamoDBRequest", kind: "message", T: DynamoDBRequest, oneof: "Event" },
    { no: 110, name: "BotJoin", kind: "message", T: BotJoin, oneof: "Event" },
    { no: 111, name: "InstanceJoin", kind: "message", T: InstanceJoin, oneof: "Event" },
    { no: 112, name: "DeviceEvent", kind: "message", T: DeviceEvent, oneof: "Event" },
    { no: 113, name: "LoginRuleCreate", kind: "message", T: LoginRuleCreate, oneof: "Event" },
    { no: 114, name: "LoginRuleDelete", kind: "message", T: LoginRuleDelete, oneof: "Event" },
    { no: 115, name: "SAMLIdPAuthAttempt", kind: "message", T: SAMLIdPAuthAttempt, oneof: "Event" },
    { no: 116, name: "SAMLIdPServiceProviderCreate", kind: "message", T: SAMLIdPServiceProviderCreate, oneof: "Event" },
    { no: 117, name: "SAMLIdPServiceProviderUpdate", kind: "message", T: SAMLIdPServiceProviderUpdate, oneof: "Event" },
    { no: 118, name: "SAMLIdPServiceProviderDelete", kind: "message", T: SAMLIdPServiceProviderDelete, oneof: "Event" },
    { no: 119, name: "SAMLIdPServiceProviderDeleteAll", kind: "message", T: SAMLIdPServiceProviderDeleteAll, oneof: "Event" },
    { no: 120, name: "OpenSearchRequest", kind: "message", T: OpenSearchRequest, oneof: "Event" },
    { no: 121, name: "DeviceEvent2", kind: "message", T: DeviceEvent2, oneof: "Event" },
    { no: 122, name: "OktaResourcesUpdate", kind: "message", T: OktaResourcesUpdate, oneof: "Event" },
    { no: 123, name: "OktaSyncFailure", kind: "message", T: OktaSyncFailure, oneof: "Event" },
    { no: 124, name: "OktaAssignmentResult", kind: "message", T: OktaAssignmentResult, oneof: "Event" },
    { no: 125, name: "ProvisionTokenCreate", kind: "message", T: ProvisionTokenCreate, oneof: "Event" },
    { no: 126, name: "AccessListCreate", kind: "message", T: AccessListCreate, oneof: "Event" },
    { no: 127, name: "AccessListUpdate", kind: "message", T: AccessListUpdate, oneof: "Event" },
    { no: 128, name: "AccessListDelete", kind: "message", T: AccessListDelete, oneof: "Event" },
    { no: 129, name: "AccessListReview", kind: "message", T: AccessListReview, oneof: "Event" },
    { no: 130, name: "AccessListMemberCreate", kind: "message", T: AccessListMemberCreate, oneof: "Event" },
    { no: 131, name: "AccessListMemberUpdate", kind: "message", T: AccessListMemberUpdate, oneof: "Event" },
    { no: 132, name: "AccessListMemberDelete", kind: "message", T: AccessListMemberDelete, oneof: "Event" },
    { no: 133, name: "AccessListMemberDeleteAllForAccessList", kind: "message", T: AccessListMemberDeleteAllForAccessList, oneof: "Event" },
    { no: 134, name: "AuditQueryRun", kind: "message", T: AuditQueryRun, oneof: "Event" },
    { no: 135, name: "SecurityReportRun", kind: "message", T: SecurityReportRun, oneof: "Event" },
    { no: 136, name: "GithubConnectorUpdate", kind: "message", T: GithubConnectorUpdate, oneof: "Event" },
    { no: 137, name: "OIDCConnectorUpdate", kind: "message", T: OIDCConnectorUpdate, oneof: "Event" },
    { no: 138, name: "SAMLConnectorUpdate", kind: "message", T: SAMLConnectorUpdate, oneof: "Event" },
    { no: 139, name: "RoleUpdate", kind: "message", T: RoleUpdate, oneof: "Event" },
    { no: 140, name: "UserUpdate", kind: "message", T: UserUpdate, oneof: "Event" },
    { no: 141, name: "ExternalAuditStorageEnable", kind: "message", T: ExternalAuditStorageEnable, oneof: "Event" },
    { no: 142, name: "ExternalAuditStorageDisable", kind: "message", T: ExternalAuditStorageDisable, oneof: "Event" },
    { no: 143, name: "BotCreate", kind: "message", T: BotCreate, oneof: "Event" },
    { no: 144, name: "BotDelete", kind: "message", T: BotDelete, oneof: "Event" },
    { no: 145, name: "BotUpdate", kind: "message", T: BotUpdate, oneof: "Event" },
    { no: 146, name: "CreateMFAAuthChallenge", kind: "message", T: CreateMFAAuthChallenge, oneof: "Event" },
    { no: 147, name: "ValidateMFAAuthResponse", kind: "message", T: ValidateMFAAuthResponse, oneof: "Event" },
    { no: 148, name: "OktaAccessListSync", kind: "message", T: OktaAccessListSync, oneof: "Event" },
    { no: 149, name: "DatabasePermissionUpdate", kind: "message", T: DatabasePermissionUpdate, oneof: "Event" },
    { no: 150, name: "SPIFFESVIDIssued", kind: "message", T: SPIFFESVIDIssued, oneof: "Event" },
    { no: 151, name: "OktaUserSync", kind: "message", T: OktaUserSync, oneof: "Event" },
    { no: 152, name: "AuthPreferenceUpdate", kind: "message", T: AuthPreferenceUpdate, oneof: "Event" },
    { no: 153, name: "SessionRecordingConfigUpdate", kind: "message", T: SessionRecordingConfigUpdate, oneof: "Event" },
    { no: 154, name: "ClusterNetworkingConfigUpdate", kind: "message", T: ClusterNetworkingConfigUpdate, oneof: "Event" },
    { no: 155, name: "DatabaseUserCreate", kind: "message", T: DatabaseUserCreate, oneof: "Event" },
    { no: 156, name: "DatabaseUserDeactivate", kind: "message", T: DatabaseUserDeactivate, oneof: "Event" },
    { no: 157, name: "AccessPathChanged", kind: "message", T: AccessPathChanged, oneof: "Event" },
    { no: 158, name: "SpannerRPC", kind: "message", T: SpannerRPC, oneof: "Event" },
    { no: 159, name: "DatabaseSessionCommandResult", kind: "message", T: DatabaseSessionCommandResult, oneof: "Event" },
    { no: 160, name: "DiscoveryConfigCreate", kind: "message", T: DiscoveryConfigCreate, oneof: "Event" },
    { no: 161, name: "DiscoveryConfigUpdate", kind: "message", T: DiscoveryConfigUpdate, oneof: "Event" },
    { no: 162, name: "DiscoveryConfigDelete", kind: "message", T: DiscoveryConfigDelete, oneof: "Event" },
    { no: 163, name: "DiscoveryConfigDeleteAll", kind: "message", T: DiscoveryConfigDeleteAll, oneof: "Event" },
    { no: 164, name: "AccessGraphSettingsUpdate", kind: "message", T: AccessGraphSettingsUpdate, oneof: "Event" },
    { no: 165, name: "IntegrationCreate", kind: "message", T: IntegrationCreate, oneof: "Event" },
    { no: 166, name: "IntegrationUpdate", kind: "message", T: IntegrationUpdate, oneof: "Event" },
    { no: 167, name: "IntegrationDelete", kind: "message", T: IntegrationDelete, oneof: "Event" },
    { no: 168, name: "SPIFFEFederationCreate", kind: "message", T: SPIFFEFederationCreate, oneof: "Event" },
    { no: 169, name: "SPIFFEFederationDelete", kind: "message", T: SPIFFEFederationDelete, oneof: "Event" },
    { no: 170, name: "PluginCreate", kind: "message", T: PluginCreate, oneof: "Event" },
    { no: 171, name: "PluginUpdate", kind: "message", T: PluginUpdate, oneof: "Event" },
    { no: 172, name: "PluginDelete", kind: "message", T: PluginDelete, oneof: "Event" },
    { no: 173, name: "AutoUpdateConfigCreate", kind: "message", T: AutoUpdateConfigCreate, oneof: "Event" },
    { no: 174, name: "AutoUpdateConfigUpdate", kind: "message", T: AutoUpdateConfigUpdate, oneof: "Event" },
    { no: 175, name: "AutoUpdateConfigDelete", kind: "message", T: AutoUpdateConfigDelete, oneof: "Event" },
    { no: 176, name: "AutoUpdateVersionCreate", kind: "message", T: AutoUpdateVersionCreate, oneof: "Event" },
    { no: 177, name: "AutoUpdateVersionUpdate", kind: "message", T: AutoUpdateVersionUpdate, oneof: "Event" },
    { no: 178, name: "AutoUpdateVersionDelete", kind: "message", T: AutoUpdateVersionDelete, oneof: "Event" },
    { no: 179, name: "StaticHostUserCreate", kind: "message", T: StaticHostUserCreate, oneof: "Event" },
    { no: 180, name: "StaticHostUserUpdate", kind: "message", T: StaticHostUserUpdate, oneof: "Event" },
    { no: 181, name: "StaticHostUserDelete", kind: "message", T: StaticHostUserDelete, oneof: "Event" },
    { no: 182, name: "CrownJewelCreate", kind: "message", T: CrownJewelCreate, oneof: "Event" },
    { no: 183, name: "CrownJewelUpdate", kind: "message", T: CrownJewelUpdate, oneof: "Event" },
    { no: 184, name: "CrownJewelDelete", kind: "message", T: CrownJewelDelete, oneof: "Event" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OneOf {
    return new OneOf().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OneOf {
    return new OneOf().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OneOf {
    return new OneOf().fromJsonString(jsonString, options);
  }

  static equals(a: OneOf | PlainMessage<OneOf> | undefined, b: OneOf | PlainMessage<OneOf> | undefined): boolean {
    return proto3.util.equals(OneOf, a, b);
  }
}

/**
 * StreamStatus reflects stream status
 *
 * @generated from message events.StreamStatus
 */
export class StreamStatus extends Message<StreamStatus> {
  /**
   * UploadID represents upload ID
   *
   * @generated from field: string UploadID = 1;
   */
  UploadID = "";

  /**
   * LastEventIndex updates last event index
   *
   * @generated from field: int64 LastEventIndex = 2;
   */
  LastEventIndex = protoInt64.zero;

  /**
   * LastUploadTime is the time of the last upload
   *
   * @generated from field: google.protobuf.Timestamp LastUploadTime = 3;
   */
  LastUploadTime?: Timestamp;

  constructor(data?: PartialMessage<StreamStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.StreamStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UploadID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "LastEventIndex", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "LastUploadTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamStatus {
    return new StreamStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamStatus {
    return new StreamStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamStatus {
    return new StreamStatus().fromJsonString(jsonString, options);
  }

  static equals(a: StreamStatus | PlainMessage<StreamStatus> | undefined, b: StreamStatus | PlainMessage<StreamStatus> | undefined): boolean {
    return proto3.util.equals(StreamStatus, a, b);
  }
}

/**
 * SessionUpload is a session upload
 *
 * @generated from message events.SessionUpload
 */
export class SessionUpload extends Message<SessionUpload> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * SessionMetadata is a common event session metadata
   *
   * @generated from field: events.SessionMetadata SessionMetadata = 2;
   */
  SessionMetadata?: SessionMetadata;

  /**
   * URL is where the url the session event data upload is at
   *
   * @generated from field: string SessionURL = 5;
   */
  SessionURL = "";

  constructor(data?: PartialMessage<SessionUpload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionUpload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "SessionMetadata", kind: "message", T: SessionMetadata },
    { no: 5, name: "SessionURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionUpload {
    return new SessionUpload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionUpload {
    return new SessionUpload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionUpload {
    return new SessionUpload().fromJsonString(jsonString, options);
  }

  static equals(a: SessionUpload | PlainMessage<SessionUpload> | undefined, b: SessionUpload | PlainMessage<SessionUpload> | undefined): boolean {
    return proto3.util.equals(SessionUpload, a, b);
  }
}

/**
 * Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except
 * for RouteToApp and RouteToDatabase which are nullable and Traits which is
 * represented as a google.protobuf.Struct (still containing a map from string
 * to strings). Field names match other names already used in other events
 * rather than the field names in tlsca.Identity.
 *
 * @generated from message events.Identity
 */
export class Identity extends Message<Identity> {
  /**
   * User is a username or name of the node connection
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Impersonator is a username of a user impersonating this user
   *
   * @generated from field: string Impersonator = 2;
   */
  Impersonator = "";

  /**
   * Roles is a list of groups (Teleport roles) encoded in the identity
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[] = [];

  /**
   * Usage is a list of usage restrictions encoded in the identity
   *
   * @generated from field: repeated string Usage = 4;
   */
  Usage: string[] = [];

  /**
   * Logins is a list of Unix logins allowed.
   *
   * @generated from field: repeated string Logins = 5;
   */
  Logins: string[] = [];

  /**
   * KubernetesGroups is a list of Kubernetes groups allowed
   *
   * @generated from field: repeated string KubernetesGroups = 6;
   */
  KubernetesGroups: string[] = [];

  /**
   * KubernetesUsers is a list of Kubernetes users allowed
   *
   * @generated from field: repeated string KubernetesUsers = 7;
   */
  KubernetesUsers: string[] = [];

  /**
   * Expires specifies whenever the session will expire
   *
   * @generated from field: google.protobuf.Timestamp Expires = 8;
   */
  Expires?: Timestamp;

  /**
   * RouteToCluster specifies the target cluster
   * if present in the session
   *
   * @generated from field: string RouteToCluster = 9;
   */
  RouteToCluster = "";

  /**
   * KubernetesCluster specifies the target kubernetes cluster for TLS
   * identities. This can be empty on older Teleport clients.
   *
   * @generated from field: string KubernetesCluster = 10;
   */
  KubernetesCluster = "";

  /**
   * Traits hold claim data used to populate a role at runtime.
   *
   * @generated from field: wrappers.LabelValues Traits = 11;
   */
  Traits?: LabelValues;

  /**
   * RouteToApp holds routing information for applications. Routing metadata
   * allows Teleport web proxy to route HTTP requests to the appropriate
   * cluster and Teleport application proxy within the cluster.
   *
   * @generated from field: events.RouteToApp RouteToApp = 12;
   */
  RouteToApp?: RouteToApp;

  /**
   * TeleportCluster is the name of the teleport cluster that this identity
   * originated from. For TLS certs this may not be the same as cert issuer,
   * in case of multi-hop requests that originate from a remote cluster.
   *
   * @generated from field: string TeleportCluster = 13;
   */
  TeleportCluster = "";

  /**
   * RouteToDatabase contains routing information for databases.
   *
   * @generated from field: events.RouteToDatabase RouteToDatabase = 14;
   */
  RouteToDatabase?: RouteToDatabase;

  /**
   * DatabaseNames is a list of allowed database names.
   *
   * @generated from field: repeated string DatabaseNames = 15;
   */
  DatabaseNames: string[] = [];

  /**
   * DatabaseUsers is a list of allowed database users.
   *
   * @generated from field: repeated string DatabaseUsers = 16;
   */
  DatabaseUsers: string[] = [];

  /**
   * MFADeviceUUID is the UUID of an MFA device when this Identity was
   * confirmed immediately after an MFA check.
   *
   * @generated from field: string MFADeviceUUID = 17;
   */
  MFADeviceUUID = "";

  /**
   * ClientIP is an observed IP of the client that this Identity represents.
   *
   * @generated from field: string ClientIP = 18;
   */
  ClientIP = "";

  /**
   * AWSRoleARNs is a list of allowed AWS role ARNs user can assume.
   *
   * @generated from field: repeated string AWSRoleARNs = 19;
   */
  AWSRoleARNs: string[] = [];

  /**
   * AccessRequests is a list of UUIDs of active requests for this Identity.
   *
   * @generated from field: repeated string AccessRequests = 20;
   */
  AccessRequests: string[] = [];

  /**
   * DisallowReissue is a flag that, if set, instructs the auth server to
   * deny any attempts to reissue new certificates while authenticated with
   * this certificate.
   *
   * @generated from field: bool DisallowReissue = 21;
   */
  DisallowReissue = false;

  /**
   * AllowedResourceIds is the list of resources which the identity will be
   * allowed to access. An empty list indicates that no resource-specific
   * restrictions will be applied.
   *
   * @generated from field: repeated events.ResourceID AllowedResourceIDs = 22;
   */
  AllowedResourceIDs: ResourceID[] = [];

  /**
   * PreviousIdentityExpires is the expiry time of the identity/cert that this
   * identity/cert was derived from. It is used to determine a session's hard
   * deadline in cases where both require_session_mfa and disconnect_expired_cert
   * are enabled. See https://github.com/gravitational/teleport/issues/18544.
   *
   * @generated from field: google.protobuf.Timestamp PreviousIdentityExpires = 23;
   */
  PreviousIdentityExpires?: Timestamp;

  /**
   * AzureIdentities is a list of allowed Azure identities user can assume.
   *
   * @generated from field: repeated string AzureIdentities = 24;
   */
  AzureIdentities: string[] = [];

  /**
   * GCPServiceAccounts is a list of allowed GCP service accounts user can assume.
   *
   * @generated from field: repeated string GCPServiceAccounts = 25;
   */
  GCPServiceAccounts: string[] = [];

  /**
   * PrivateKeyPolicy is the private key policy of the user's private key.
   *
   * @generated from field: string PrivateKeyPolicy = 26;
   */
  PrivateKeyPolicy = "";

  /**
   * BotName indicates the name of the Machine ID bot this identity was issued
   * to, if any.
   *
   * @generated from field: string BotName = 27;
   */
  BotName = "";

  /**
   * DeviceExtensions holds the device trust device extensions for the identity,
   * if any.
   *
   * @generated from field: events.DeviceExtensions DeviceExtensions = 28;
   */
  DeviceExtensions?: DeviceExtensions;

  /**
   * BotInstanceID indicates the name of the Machine ID bot instance this
   * identity was issued to, if any.
   *
   * @generated from field: string BotInstanceID = 29;
   */
  BotInstanceID = "";

  constructor(data?: PartialMessage<Identity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.Identity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Impersonator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "Usage", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "KubernetesGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "KubernetesUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "Expires", kind: "message", T: Timestamp },
    { no: 9, name: "RouteToCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "Traits", kind: "message", T: LabelValues },
    { no: 12, name: "RouteToApp", kind: "message", T: RouteToApp },
    { no: 13, name: "TeleportCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "RouteToDatabase", kind: "message", T: RouteToDatabase },
    { no: 15, name: "DatabaseNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 16, name: "DatabaseUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 17, name: "MFADeviceUUID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "ClientIP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "AWSRoleARNs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 20, name: "AccessRequests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 21, name: "DisallowReissue", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "AllowedResourceIDs", kind: "message", T: ResourceID, repeated: true },
    { no: 23, name: "PreviousIdentityExpires", kind: "message", T: Timestamp },
    { no: 24, name: "AzureIdentities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 25, name: "GCPServiceAccounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 26, name: "PrivateKeyPolicy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 27, name: "BotName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 28, name: "DeviceExtensions", kind: "message", T: DeviceExtensions },
    { no: 29, name: "BotInstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identity {
    return new Identity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identity {
    return new Identity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identity {
    return new Identity().fromJsonString(jsonString, options);
  }

  static equals(a: Identity | PlainMessage<Identity> | undefined, b: Identity | PlainMessage<Identity> | undefined): boolean {
    return proto3.util.equals(Identity, a, b);
  }
}

/**
 * RouteToApp contains parameters for application access certificate requests.
 *
 * @generated from message events.RouteToApp
 */
export class RouteToApp extends Message<RouteToApp> {
  /**
   * Name is the application name certificate is being requested for.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * SessionID is the ID of the application session.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID = "";

  /**
   * PublicAddr is the application public address.
   *
   * @generated from field: string PublicAddr = 3;
   */
  PublicAddr = "";

  /**
   * ClusterName is the cluster where the application resides.
   *
   * @generated from field: string ClusterName = 4;
   */
  ClusterName = "";

  /**
   * AWSRoleARN is the AWS role to assume when accessing AWS API.
   *
   * @generated from field: string AWSRoleARN = 5;
   */
  AWSRoleARN = "";

  /**
   * AzureIdentity is the Azure identity ot assume when accessing Azure API.
   *
   * @generated from field: string AzureIdentity = 6;
   */
  AzureIdentity = "";

  /**
   * GCPServiceAccount is the GCP service account to assume when accessing GCP API.
   *
   * @generated from field: string GCPServiceAccount = 7;
   */
  GCPServiceAccount = "";

  /**
   * URI is the application URI.
   *
   * @generated from field: string URI = 8;
   */
  URI = "";

  constructor(data?: PartialMessage<RouteToApp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RouteToApp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "PublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AWSRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AzureIdentity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "GCPServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteToApp {
    return new RouteToApp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteToApp {
    return new RouteToApp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteToApp {
    return new RouteToApp().fromJsonString(jsonString, options);
  }

  static equals(a: RouteToApp | PlainMessage<RouteToApp> | undefined, b: RouteToApp | PlainMessage<RouteToApp> | undefined): boolean {
    return proto3.util.equals(RouteToApp, a, b);
  }
}

/**
 * RouteToDatabase combines parameters for database service routing information.
 *
 * @generated from message events.RouteToDatabase
 */
export class RouteToDatabase extends Message<RouteToDatabase> {
  /**
   * ServiceName is the Teleport database proxy service name the cert is for.
   *
   * @generated from field: string ServiceName = 1;
   */
  ServiceName = "";

  /**
   * Protocol is the type of the database the cert is for.
   *
   * @generated from field: string Protocol = 2;
   */
  Protocol = "";

  /**
   * Username is an optional database username to embed.
   *
   * @generated from field: string Username = 3;
   */
  Username = "";

  /**
   * Database is an optional database name to embed.
   *
   * @generated from field: string Database = 4;
   */
  Database = "";

  /**
   * Roles is an optional list of database roles to embed.
   *
   * @generated from field: repeated string Roles = 5;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<RouteToDatabase>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.RouteToDatabase";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromJsonString(jsonString, options);
  }

  static equals(a: RouteToDatabase | PlainMessage<RouteToDatabase> | undefined, b: RouteToDatabase | PlainMessage<RouteToDatabase> | undefined): boolean {
    return proto3.util.equals(RouteToDatabase, a, b);
  }
}

/**
 * DeviceExtensions holds certificate extensions (X.509 and SSH) for device
 * trust.
 *
 * Mimics tlsca.DeviceExtensions.
 *
 * @generated from message events.DeviceExtensions
 */
export class DeviceExtensions extends Message<DeviceExtensions> {
  /**
   * DeviceID is the trusted device identifier.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = "";

  /**
   * AssetTag is the device inventory identifier.
   *
   * @generated from field: string asset_tag = 2;
   */
  assetTag = "";

  /**
   * CredentialID is the identifier for the credential used by the device to
   * authenticate itself.
   *
   * @generated from field: string credential_id = 3;
   */
  credentialId = "";

  constructor(data?: PartialMessage<DeviceExtensions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DeviceExtensions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "asset_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "credential_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceExtensions {
    return new DeviceExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceExtensions {
    return new DeviceExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceExtensions {
    return new DeviceExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceExtensions | PlainMessage<DeviceExtensions> | undefined, b: DeviceExtensions | PlainMessage<DeviceExtensions> | undefined): boolean {
    return proto3.util.equals(DeviceExtensions, a, b);
  }
}

/**
 * AccessRequestResourceSearch is emitted when a user searches for resources as
 * part of a search-based access request
 *
 * @generated from message events.AccessRequestResourceSearch
 */
export class AccessRequestResourceSearch extends Message<AccessRequestResourceSearch> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SearchAsRoles is the list of roles the search was performed as.
   *
   * @generated from field: repeated string SearchAsRoles = 3;
   */
  SearchAsRoles: string[] = [];

  /**
   * ResourceType is the type of resource being searched for.
   *
   * @generated from field: string ResourceType = 4;
   */
  ResourceType = "";

  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 5;
   */
  Namespace = "";

  /**
   * Labels is the label-based matcher used for the search.
   *
   * @generated from field: map<string, string> Labels = 6;
   */
  Labels: { [key: string]: string } = {};

  /**
   * PredicateExpression is the list of boolean conditions that were used for the search.
   *
   * @generated from field: string PredicateExpression = 7;
   */
  PredicateExpression = "";

  /**
   * SearchKeywords is the list of search keywords used to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 8;
   */
  SearchKeywords: string[] = [];

  constructor(data?: PartialMessage<AccessRequestResourceSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessRequestResourceSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "SearchAsRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ResourceType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "PredicateExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestResourceSearch {
    return new AccessRequestResourceSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestResourceSearch {
    return new AccessRequestResourceSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestResourceSearch {
    return new AccessRequestResourceSearch().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestResourceSearch | PlainMessage<AccessRequestResourceSearch> | undefined, b: AccessRequestResourceSearch | PlainMessage<AccessRequestResourceSearch> | undefined): boolean {
    return proto3.util.equals(AccessRequestResourceSearch, a, b);
  }
}

/**
 * MySQLStatementPrepare is emitted when a MySQL client creates a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementPrepare
 */
export class MySQLStatementPrepare extends Message<MySQLStatementPrepare> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Query is the prepared statement query.
   *
   * @generated from field: string Query = 5;
   */
  Query = "";

  constructor(data?: PartialMessage<MySQLStatementPrepare>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementPrepare";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementPrepare {
    return new MySQLStatementPrepare().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementPrepare {
    return new MySQLStatementPrepare().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementPrepare {
    return new MySQLStatementPrepare().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementPrepare | PlainMessage<MySQLStatementPrepare> | undefined, b: MySQLStatementPrepare | PlainMessage<MySQLStatementPrepare> | undefined): boolean {
    return proto3.util.equals(MySQLStatementPrepare, a, b);
  }
}

/**
 * MySQLStatementExecute is emitted when a MySQL client executes a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementExecute
 */
export class MySQLStatementExecute extends Message<MySQLStatementExecute> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  /**
   * Parameters are the parameters used to execute the prepared statement.
   *
   * @generated from field: repeated string Parameters = 6;
   */
  Parameters: string[] = [];

  constructor(data?: PartialMessage<MySQLStatementExecute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementExecute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "Parameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementExecute {
    return new MySQLStatementExecute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementExecute {
    return new MySQLStatementExecute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementExecute {
    return new MySQLStatementExecute().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementExecute | PlainMessage<MySQLStatementExecute> | undefined, b: MySQLStatementExecute | PlainMessage<MySQLStatementExecute> | undefined): boolean {
    return proto3.util.equals(MySQLStatementExecute, a, b);
  }
}

/**
 * MySQLStatementSendLongData is emitted when a MySQL client sends long bytes
 * stream using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementSendLongData
 */
export class MySQLStatementSendLongData extends Message<MySQLStatementSendLongData> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  /**
   * ParameterID is the identifier of the parameter.
   *
   * @generated from field: uint32 ParameterID = 6;
   */
  ParameterID = 0;

  /**
   * DataSize is the size of the data.
   *
   * @generated from field: uint32 DataSize = 7;
   */
  DataSize = 0;

  constructor(data?: PartialMessage<MySQLStatementSendLongData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementSendLongData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "ParameterID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "DataSize", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementSendLongData {
    return new MySQLStatementSendLongData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementSendLongData {
    return new MySQLStatementSendLongData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementSendLongData {
    return new MySQLStatementSendLongData().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementSendLongData | PlainMessage<MySQLStatementSendLongData> | undefined, b: MySQLStatementSendLongData | PlainMessage<MySQLStatementSendLongData> | undefined): boolean {
    return proto3.util.equals(MySQLStatementSendLongData, a, b);
  }
}

/**
 * MySQLStatementClose is emitted when a MySQL client deallocates a prepared
 * statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementClose
 */
export class MySQLStatementClose extends Message<MySQLStatementClose> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  constructor(data?: PartialMessage<MySQLStatementClose>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementClose";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementClose {
    return new MySQLStatementClose().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementClose {
    return new MySQLStatementClose().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementClose {
    return new MySQLStatementClose().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementClose | PlainMessage<MySQLStatementClose> | undefined, b: MySQLStatementClose | PlainMessage<MySQLStatementClose> | undefined): boolean {
    return proto3.util.equals(MySQLStatementClose, a, b);
  }
}

/**
 * MySQLStatementReset is emitted when a MySQL client resets the data of a
 * prepared statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementReset
 */
export class MySQLStatementReset extends Message<MySQLStatementReset> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  constructor(data?: PartialMessage<MySQLStatementReset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementReset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementReset {
    return new MySQLStatementReset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementReset {
    return new MySQLStatementReset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementReset {
    return new MySQLStatementReset().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementReset | PlainMessage<MySQLStatementReset> | undefined, b: MySQLStatementReset | PlainMessage<MySQLStatementReset> | undefined): boolean {
    return proto3.util.equals(MySQLStatementReset, a, b);
  }
}

/**
 * MySQLStatementFetch is emitted when a MySQL client fetches rows from a
 * prepared statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementFetch
 */
export class MySQLStatementFetch extends Message<MySQLStatementFetch> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  /**
   * RowsCount is the number of rows to fetch.
   *
   * @generated from field: uint32 RowsCount = 6;
   */
  RowsCount = 0;

  constructor(data?: PartialMessage<MySQLStatementFetch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementFetch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "RowsCount", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementFetch {
    return new MySQLStatementFetch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementFetch {
    return new MySQLStatementFetch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementFetch {
    return new MySQLStatementFetch().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementFetch | PlainMessage<MySQLStatementFetch> | undefined, b: MySQLStatementFetch | PlainMessage<MySQLStatementFetch> | undefined): boolean {
    return proto3.util.equals(MySQLStatementFetch, a, b);
  }
}

/**
 * MySQLStatementBulkExecute is emitted when a MySQL client executes a bulk
 * insert of a prepared statement using the prepared statement protocol.
 *
 * @generated from message events.MySQLStatementBulkExecute
 */
export class MySQLStatementBulkExecute extends Message<MySQLStatementBulkExecute> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * StatementID is the identifier of the prepared statement.
   *
   * @generated from field: uint32 StatementID = 5;
   */
  StatementID = 0;

  /**
   * Parameters are the parameters used to execute the prepared statement.
   *
   * @generated from field: repeated string Parameters = 6;
   */
  Parameters: string[] = [];

  constructor(data?: PartialMessage<MySQLStatementBulkExecute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLStatementBulkExecute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatementID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "Parameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLStatementBulkExecute {
    return new MySQLStatementBulkExecute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLStatementBulkExecute {
    return new MySQLStatementBulkExecute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLStatementBulkExecute {
    return new MySQLStatementBulkExecute().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLStatementBulkExecute | PlainMessage<MySQLStatementBulkExecute> | undefined, b: MySQLStatementBulkExecute | PlainMessage<MySQLStatementBulkExecute> | undefined): boolean {
    return proto3.util.equals(MySQLStatementBulkExecute, a, b);
  }
}

/**
 * MySQLInitDB is emitted when a MySQL client changes the default schema for
 * the connection.
 *
 * @generated from message events.MySQLInitDB
 */
export class MySQLInitDB extends Message<MySQLInitDB> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * SchemaName is the name of the schema to use.
   *
   * @generated from field: string SchemaName = 5;
   */
  SchemaName = "";

  constructor(data?: PartialMessage<MySQLInitDB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLInitDB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "SchemaName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLInitDB {
    return new MySQLInitDB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLInitDB {
    return new MySQLInitDB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLInitDB {
    return new MySQLInitDB().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLInitDB | PlainMessage<MySQLInitDB> | undefined, b: MySQLInitDB | PlainMessage<MySQLInitDB> | undefined): boolean {
    return proto3.util.equals(MySQLInitDB, a, b);
  }
}

/**
 * MySQLCreateDB is emitted when a MySQL client creates a schema.
 *
 * @generated from message events.MySQLCreateDB
 */
export class MySQLCreateDB extends Message<MySQLCreateDB> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * SchemaName is the name of the schema to create.
   *
   * @generated from field: string SchemaName = 5;
   */
  SchemaName = "";

  constructor(data?: PartialMessage<MySQLCreateDB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLCreateDB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "SchemaName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLCreateDB {
    return new MySQLCreateDB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLCreateDB {
    return new MySQLCreateDB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLCreateDB {
    return new MySQLCreateDB().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLCreateDB | PlainMessage<MySQLCreateDB> | undefined, b: MySQLCreateDB | PlainMessage<MySQLCreateDB> | undefined): boolean {
    return proto3.util.equals(MySQLCreateDB, a, b);
  }
}

/**
 * MySQLDropDB is emitted when a MySQL client drops a schema.
 *
 * @generated from message events.MySQLDropDB
 */
export class MySQLDropDB extends Message<MySQLDropDB> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * SchemaName is the name of the schema to drop.
   *
   * @generated from field: string SchemaName = 5;
   */
  SchemaName = "";

  constructor(data?: PartialMessage<MySQLDropDB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLDropDB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "SchemaName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLDropDB {
    return new MySQLDropDB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLDropDB {
    return new MySQLDropDB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLDropDB {
    return new MySQLDropDB().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLDropDB | PlainMessage<MySQLDropDB> | undefined, b: MySQLDropDB | PlainMessage<MySQLDropDB> | undefined): boolean {
    return proto3.util.equals(MySQLDropDB, a, b);
  }
}

/**
 * MySQLShutDown is emitted when a MySQL client asks the server to shut down.
 *
 * @generated from message events.MySQLShutDown
 */
export class MySQLShutDown extends Message<MySQLShutDown> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  constructor(data?: PartialMessage<MySQLShutDown>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLShutDown";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLShutDown {
    return new MySQLShutDown().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLShutDown {
    return new MySQLShutDown().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLShutDown {
    return new MySQLShutDown().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLShutDown | PlainMessage<MySQLShutDown> | undefined, b: MySQLShutDown | PlainMessage<MySQLShutDown> | undefined): boolean {
    return proto3.util.equals(MySQLShutDown, a, b);
  }
}

/**
 * MySQLProcessKill is emitted when a MySQL client asks the server to terminate
 * a connection.
 *
 * @generated from message events.MySQLProcessKill
 */
export class MySQLProcessKill extends Message<MySQLProcessKill> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * ProcessID is the process ID of a connection.
   *
   * @generated from field: uint32 ProcessID = 5;
   */
  ProcessID = 0;

  constructor(data?: PartialMessage<MySQLProcessKill>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLProcessKill";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "ProcessID", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLProcessKill {
    return new MySQLProcessKill().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLProcessKill {
    return new MySQLProcessKill().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLProcessKill {
    return new MySQLProcessKill().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLProcessKill | PlainMessage<MySQLProcessKill> | undefined, b: MySQLProcessKill | PlainMessage<MySQLProcessKill> | undefined): boolean {
    return proto3.util.equals(MySQLProcessKill, a, b);
  }
}

/**
 * MySQLDebug is emitted when a MySQL client asks the server to dump internal
 * debug info to stdout.
 *
 * @generated from message events.MySQLDebug
 */
export class MySQLDebug extends Message<MySQLDebug> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  constructor(data?: PartialMessage<MySQLDebug>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLDebug";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLDebug {
    return new MySQLDebug().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLDebug {
    return new MySQLDebug().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLDebug {
    return new MySQLDebug().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLDebug | PlainMessage<MySQLDebug> | undefined, b: MySQLDebug | PlainMessage<MySQLDebug> | undefined): boolean {
    return proto3.util.equals(MySQLDebug, a, b);
  }
}

/**
 * MySQLRefresh is emitted when a MySQL client sends refresh commands.
 *
 * @generated from message events.MySQLRefresh
 */
export class MySQLRefresh extends Message<MySQLRefresh> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Subcommand is the string representation of the subcommand.
   *
   * @generated from field: string Subcommand = 5;
   */
  Subcommand = "";

  constructor(data?: PartialMessage<MySQLRefresh>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.MySQLRefresh";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Subcommand", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLRefresh {
    return new MySQLRefresh().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLRefresh {
    return new MySQLRefresh().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLRefresh {
    return new MySQLRefresh().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLRefresh | PlainMessage<MySQLRefresh> | undefined, b: MySQLRefresh | PlainMessage<MySQLRefresh> | undefined): boolean {
    return proto3.util.equals(MySQLRefresh, a, b);
  }
}

/**
 * SQLServerRPCRequest is emitted when a user executes a MSSQL Server RPC command.
 *
 * @generated from message events.SQLServerRPCRequest
 */
export class SQLServerRPCRequest extends Message<SQLServerRPCRequest> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Procname is the RPC SQL Server procedure name.
   *
   * @generated from field: string Procname = 5;
   */
  Procname = "";

  /**
   * Parameters are the RPC parameters used to execute RPC Procedure..
   *
   * @generated from field: repeated string Parameters = 6;
   */
  Parameters: string[] = [];

  constructor(data?: PartialMessage<SQLServerRPCRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SQLServerRPCRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Procname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Parameters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SQLServerRPCRequest {
    return new SQLServerRPCRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SQLServerRPCRequest {
    return new SQLServerRPCRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SQLServerRPCRequest {
    return new SQLServerRPCRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SQLServerRPCRequest | PlainMessage<SQLServerRPCRequest> | undefined, b: SQLServerRPCRequest | PlainMessage<SQLServerRPCRequest> | undefined): boolean {
    return proto3.util.equals(SQLServerRPCRequest, a, b);
  }
}

/**
 * DatabaseSessionMalformedPacket is emitted when a database sends a malformed packet.
 *
 * @generated from message events.DatabaseSessionMalformedPacket
 */
export class DatabaseSessionMalformedPacket extends Message<DatabaseSessionMalformedPacket> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Payload is the malformed packet payload.
   *
   * @generated from field: bytes Payload = 5;
   */
  Payload = new Uint8Array(0);

  constructor(data?: PartialMessage<DatabaseSessionMalformedPacket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DatabaseSessionMalformedPacket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSessionMalformedPacket {
    return new DatabaseSessionMalformedPacket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSessionMalformedPacket {
    return new DatabaseSessionMalformedPacket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSessionMalformedPacket {
    return new DatabaseSessionMalformedPacket().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSessionMalformedPacket | PlainMessage<DatabaseSessionMalformedPacket> | undefined, b: DatabaseSessionMalformedPacket | PlainMessage<DatabaseSessionMalformedPacket> | undefined): boolean {
    return proto3.util.equals(DatabaseSessionMalformedPacket, a, b);
  }
}

/**
 * ElasticsearchRequest is emitted when user executes an Elasticsearch request, which isn't
 * covered by API-specific events.
 *
 * @generated from message events.ElasticsearchRequest
 */
export class ElasticsearchRequest extends Message<ElasticsearchRequest> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Path is relative path in the URL.
   *
   * @generated from field: string Path = 5;
   */
  Path = "";

  /**
   * RawQuery are the encoded query values.
   *
   * @generated from field: string RawQuery = 6;
   */
  RawQuery = "";

  /**
   * Method is the request HTTP method, like GET/POST/DELETE/etc.
   *
   * @generated from field: string Method = 7;
   */
  Method = "";

  /**
   * Body is the request HTTP body.
   *
   * @generated from field: bytes Body = 8;
   */
  Body = new Uint8Array(0);

  /**
   * Headers are the HTTP request headers.
   *
   * @generated from field: wrappers.LabelValues Headers = 9;
   */
  Headers?: LabelValues;

  /**
   * Category represents the category if API being accessed in a given request.
   *
   * @generated from field: events.ElasticsearchCategory Category = 10;
   */
  Category = ElasticsearchCategory.GENERAL;

  /**
   * Target is an optional field indicating the target index or set of indices used as a subject of request.
   *
   * @generated from field: string Target = 11;
   */
  Target = "";

  /**
   * Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
   *
   * @generated from field: string Query = 12;
   */
  Query = "";

  /**
   * StatusCode is optional status code returned from the call to database.
   *
   * @generated from field: uint32 StatusCode = 13;
   */
  StatusCode = 0;

  constructor(data?: PartialMessage<ElasticsearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ElasticsearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RawQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "Headers", kind: "message", T: LabelValues },
    { no: 10, name: "Category", kind: "enum", T: proto3.getEnumType(ElasticsearchCategory) },
    { no: 11, name: "Target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "StatusCode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElasticsearchRequest {
    return new ElasticsearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElasticsearchRequest {
    return new ElasticsearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElasticsearchRequest {
    return new ElasticsearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ElasticsearchRequest | PlainMessage<ElasticsearchRequest> | undefined, b: ElasticsearchRequest | PlainMessage<ElasticsearchRequest> | undefined): boolean {
    return proto3.util.equals(ElasticsearchRequest, a, b);
  }
}

/**
 * OpenSearchRequest is emitted when a user executes a OpenSearch request via database-access.
 *
 * @generated from message events.OpenSearchRequest
 */
export class OpenSearchRequest extends Message<OpenSearchRequest> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Path is relative path in the URL.
   *
   * @generated from field: string Path = 5;
   */
  Path = "";

  /**
   * RawQuery are the encoded query values.
   *
   * @generated from field: string RawQuery = 6;
   */
  RawQuery = "";

  /**
   * Method is the request HTTP method, like GET/POST/DELETE/etc.
   *
   * @generated from field: string Method = 7;
   */
  Method = "";

  /**
   * Body is the request HTTP body.
   *
   * @generated from field: bytes Body = 8;
   */
  Body = new Uint8Array(0);

  /**
   * Headers are the HTTP request headers.
   *
   * @generated from field: wrappers.LabelValues Headers = 9;
   */
  Headers?: LabelValues;

  /**
   * Category represents the category if API being accessed in a given request.
   *
   * @generated from field: events.OpenSearchCategory Category = 10;
   */
  Category = OpenSearchCategory.GENERAL;

  /**
   * Target is an optional field indicating the target index or set of indices used as a subject of request.
   *
   * @generated from field: string Target = 11;
   */
  Target = "";

  /**
   * Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
   *
   * @generated from field: string Query = 12;
   */
  Query = "";

  /**
   * StatusCode is optional status code returned from the call to database.
   *
   * @generated from field: uint32 StatusCode = 13;
   */
  StatusCode = 0;

  constructor(data?: PartialMessage<OpenSearchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OpenSearchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RawQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "Headers", kind: "message", T: LabelValues },
    { no: 10, name: "Category", kind: "enum", T: proto3.getEnumType(OpenSearchCategory) },
    { no: 11, name: "Target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "StatusCode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenSearchRequest {
    return new OpenSearchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenSearchRequest {
    return new OpenSearchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenSearchRequest {
    return new OpenSearchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OpenSearchRequest | PlainMessage<OpenSearchRequest> | undefined, b: OpenSearchRequest | PlainMessage<OpenSearchRequest> | undefined): boolean {
    return proto3.util.equals(OpenSearchRequest, a, b);
  }
}

/**
 * DynamoDBRequest is emitted when a user executes a DynamoDB request via database-access.
 *
 * @generated from message events.DynamoDBRequest
 */
export class DynamoDBRequest extends Message<DynamoDBRequest> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * @generated from field: uint32 StatusCode = 5;
   */
  StatusCode = 0;

  /**
   * Path is relative path in the URL.
   *
   * @generated from field: string Path = 6;
   */
  Path = "";

  /**
   * RawQuery are the encoded query values.
   *
   * @generated from field: string RawQuery = 7;
   */
  RawQuery = "";

  /**
   * Method is the request HTTP method, like GET/POST/DELETE/etc.
   *
   * @generated from field: string Method = 8;
   */
  Method = "";

  /**
   * Target is the API target in the X-Amz-Target header.
   *
   * @generated from field: string Target = 9;
   */
  Target = "";

  /**
   * Body is the HTTP request json body.
   * The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
   *
   * @generated from field: google.protobuf.Struct Body = 10;
   */
  Body?: Struct;

  constructor(data?: PartialMessage<DynamoDBRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.DynamoDBRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "StatusCode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "RawQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Body", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBRequest {
    return new DynamoDBRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBRequest {
    return new DynamoDBRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBRequest {
    return new DynamoDBRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBRequest | PlainMessage<DynamoDBRequest> | undefined, b: DynamoDBRequest | PlainMessage<DynamoDBRequest> | undefined): boolean {
    return proto3.util.equals(DynamoDBRequest, a, b);
  }
}

/**
 * AppSessionDynamoDBRequest is emitted when a user executes a DynamoDB request via app access.
 *
 * @generated from message events.AppSessionDynamoDBRequest
 */
export class AppSessionDynamoDBRequest extends Message<AppSessionDynamoDBRequest> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * App is a common application resource metadata.
   *
   * @generated from field: events.AppMetadata App = 3;
   */
  App?: AppMetadata;

  /**
   * AWS contains extra AWS metadata of the request.
   *
   * @generated from field: events.AWSRequestMetadata AWS = 4;
   */
  AWS?: AWSRequestMetadata;

  /**
   * SessionChunkID is the ID of the app session chunk that this request belongs to.
   * This is more appropriate to include than the app session id, since it is the chunk
   * id that is needed to play back the session chunk with tsh. The session chunk event
   * already includes the app session id.
   *
   * @generated from field: string SessionChunkID = 5;
   */
  SessionChunkID = "";

  /**
   * StatusCode the HTTP response code for the request.
   *
   * @generated from field: uint32 StatusCode = 6;
   */
  StatusCode = 0;

  /**
   * Path is relative path in the URL.
   *
   * @generated from field: string Path = 7;
   */
  Path = "";

  /**
   * RawQuery are the encoded query values.
   *
   * @generated from field: string RawQuery = 8;
   */
  RawQuery = "";

  /**
   * Method is the request HTTP method, like GET/POST/DELETE/etc.
   *
   * @generated from field: string Method = 9;
   */
  Method = "";

  /**
   * Target is the API target in the X-Amz-Target header.
   *
   * @generated from field: string Target = 10;
   */
  Target = "";

  /**
   * Body is the HTTP request json body.
   * The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
   *
   * @generated from field: google.protobuf.Struct Body = 11;
   */
  Body?: Struct;

  constructor(data?: PartialMessage<AppSessionDynamoDBRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AppSessionDynamoDBRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "App", kind: "message", T: AppMetadata },
    { no: 4, name: "AWS", kind: "message", T: AWSRequestMetadata },
    { no: 5, name: "SessionChunkID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "StatusCode", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "RawQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "Body", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSessionDynamoDBRequest {
    return new AppSessionDynamoDBRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSessionDynamoDBRequest {
    return new AppSessionDynamoDBRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSessionDynamoDBRequest {
    return new AppSessionDynamoDBRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppSessionDynamoDBRequest | PlainMessage<AppSessionDynamoDBRequest> | undefined, b: AppSessionDynamoDBRequest | PlainMessage<AppSessionDynamoDBRequest> | undefined): boolean {
    return proto3.util.equals(AppSessionDynamoDBRequest, a, b);
  }
}

/**
 * UpgradeWindowStartMetadata contains common upgrade window information.
 *
 * @generated from message events.UpgradeWindowStartMetadata
 */
export class UpgradeWindowStartMetadata extends Message<UpgradeWindowStartMetadata> {
  /**
   * UpgradeWindowStart is the upgrade window time.
   *
   * @generated from field: string UpgradeWindowStart = 1;
   */
  UpgradeWindowStart = "";

  constructor(data?: PartialMessage<UpgradeWindowStartMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UpgradeWindowStartMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UpgradeWindowStart", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeWindowStartMetadata {
    return new UpgradeWindowStartMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeWindowStartMetadata {
    return new UpgradeWindowStartMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeWindowStartMetadata {
    return new UpgradeWindowStartMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeWindowStartMetadata | PlainMessage<UpgradeWindowStartMetadata> | undefined, b: UpgradeWindowStartMetadata | PlainMessage<UpgradeWindowStartMetadata> | undefined): boolean {
    return proto3.util.equals(UpgradeWindowStartMetadata, a, b);
  }
}

/**
 * UpgradeWindowStartUpdate is emitted when a user updates the cloud upgrade window start time.
 *
 * @generated from message events.UpgradeWindowStartUpdate
 */
export class UpgradeWindowStartUpdate extends Message<UpgradeWindowStartUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * UpgradeWindowStartMetadata contains upgrade window related metadata.
   *
   * @generated from field: events.UpgradeWindowStartMetadata UpgradeWindowStart = 4;
   */
  UpgradeWindowStart?: UpgradeWindowStartMetadata;

  constructor(data?: PartialMessage<UpgradeWindowStartUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.UpgradeWindowStartUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "UpgradeWindowStart", kind: "message", T: UpgradeWindowStartMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeWindowStartUpdate {
    return new UpgradeWindowStartUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeWindowStartUpdate {
    return new UpgradeWindowStartUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeWindowStartUpdate {
    return new UpgradeWindowStartUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeWindowStartUpdate | PlainMessage<UpgradeWindowStartUpdate> | undefined, b: UpgradeWindowStartUpdate | PlainMessage<UpgradeWindowStartUpdate> | undefined): boolean {
    return proto3.util.equals(UpgradeWindowStartUpdate, a, b);
  }
}

/**
 * SessionRecordingAccess is emitted when a session recording is accessed, allowing
 * session views to be included in the audit log
 *
 * @generated from message events.SessionRecordingAccess
 */
export class SessionRecordingAccess extends Message<SessionRecordingAccess> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * SessionID is the ID of the session.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID = "";

  /**
   * UserMetadata is a common user event metadata.
   *
   * @generated from field: events.UserMetadata UserMetadata = 3;
   */
  UserMetadata?: UserMetadata;

  constructor(data?: PartialMessage<SessionRecordingAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionRecordingAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "UserMetadata", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionRecordingAccess {
    return new SessionRecordingAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionRecordingAccess {
    return new SessionRecordingAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionRecordingAccess {
    return new SessionRecordingAccess().fromJsonString(jsonString, options);
  }

  static equals(a: SessionRecordingAccess | PlainMessage<SessionRecordingAccess> | undefined, b: SessionRecordingAccess | PlainMessage<SessionRecordingAccess> | undefined): boolean {
    return proto3.util.equals(SessionRecordingAccess, a, b);
  }
}

/**
 * KubeClusterMetadata contains common kubernetes cluster information.
 *
 * @generated from message events.KubeClusterMetadata
 */
export class KubeClusterMetadata extends Message<KubeClusterMetadata> {
  /**
   * KubeLabels are the configured cluster labels.
   *
   * @generated from field: map<string, string> KubeLabels = 1;
   */
  KubeLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<KubeClusterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubeClusterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KubeLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubeClusterMetadata {
    return new KubeClusterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubeClusterMetadata {
    return new KubeClusterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubeClusterMetadata {
    return new KubeClusterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: KubeClusterMetadata | PlainMessage<KubeClusterMetadata> | undefined, b: KubeClusterMetadata | PlainMessage<KubeClusterMetadata> | undefined): boolean {
    return proto3.util.equals(KubeClusterMetadata, a, b);
  }
}

/**
 * KubernetesClusterCreate is emitted when a new kubernetes cluster resource is created.
 *
 * @generated from message events.KubernetesClusterCreate
 */
export class KubernetesClusterCreate extends Message<KubernetesClusterCreate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * KubeClusterMetadata is a common kubernetes resource metadata.
   *
   * @generated from field: events.KubeClusterMetadata KubeClusterMetadata = 4;
   */
  KubeClusterMetadata?: KubeClusterMetadata;

  constructor(data?: PartialMessage<KubernetesClusterCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubernetesClusterCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "KubeClusterMetadata", kind: "message", T: KubeClusterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterCreate {
    return new KubernetesClusterCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterCreate {
    return new KubernetesClusterCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterCreate {
    return new KubernetesClusterCreate().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterCreate | PlainMessage<KubernetesClusterCreate> | undefined, b: KubernetesClusterCreate | PlainMessage<KubernetesClusterCreate> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterCreate, a, b);
  }
}

/**
 * KubernetesClusterUpdate is emitted when an existing kubernetes cluster resource is updated.
 *
 * @generated from message events.KubernetesClusterUpdate
 */
export class KubernetesClusterUpdate extends Message<KubernetesClusterUpdate> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * KubeClusterMetadata is a common kubernetes resource metadata.
   *
   * @generated from field: events.KubeClusterMetadata KubeClusterMetadata = 4;
   */
  KubeClusterMetadata?: KubeClusterMetadata;

  constructor(data?: PartialMessage<KubernetesClusterUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubernetesClusterUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "KubeClusterMetadata", kind: "message", T: KubeClusterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterUpdate {
    return new KubernetesClusterUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterUpdate {
    return new KubernetesClusterUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterUpdate {
    return new KubernetesClusterUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterUpdate | PlainMessage<KubernetesClusterUpdate> | undefined, b: KubernetesClusterUpdate | PlainMessage<KubernetesClusterUpdate> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterUpdate, a, b);
  }
}

/**
 * KubernetesClusterDelete is emitted when a kubernetes cluster resource is deleted.
 *
 * @generated from message events.KubernetesClusterDelete
 */
export class KubernetesClusterDelete extends Message<KubernetesClusterDelete> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  constructor(data?: PartialMessage<KubernetesClusterDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.KubernetesClusterDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterDelete {
    return new KubernetesClusterDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterDelete {
    return new KubernetesClusterDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterDelete {
    return new KubernetesClusterDelete().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterDelete | PlainMessage<KubernetesClusterDelete> | undefined, b: KubernetesClusterDelete | PlainMessage<KubernetesClusterDelete> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterDelete, a, b);
  }
}

/**
 * SSMRun is emitted after an AWS SSM document completes execution.
 *
 * @generated from message events.SSMRun
 */
export class SSMRun extends Message<SSMRun> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * CommandID is the id of the SSM command that was run.
   *
   * @generated from field: string CommandID = 2;
   */
  CommandID = "";

  /**
   * InstanceID is the id of the EC2 instance the command was run on.
   *
   * @generated from field: string InstanceID = 3;
   */
  InstanceID = "";

  /**
   * ExitCode is the exit code resulting from the script run.
   *
   * @generated from field: int64 ExitCode = 4;
   */
  ExitCode = protoInt64.zero;

  /**
   * Status represents the success or failure status of a script run.
   *
   * @generated from field: string Status = 5;
   */
  Status = "";

  /**
   * AccountID is the id of the AWS account that ran the command.
   *
   * @generated from field: string AccountID = 6;
   */
  AccountID = "";

  /**
   * Region is the AWS region the command was ran in.
   *
   * @generated from field: string Region = 7;
   */
  Region = "";

  /**
   * StandardOutput contains the stdout of the executed command.
   * Only the first 24000 chars are returned.
   *
   * @generated from field: string StandardOutput = 8;
   */
  StandardOutput = "";

  /**
   * StandardError contains the stderr of the executed command.
   * Only the first 24000 chars are returned.
   *
   * @generated from field: string StandardError = 9;
   */
  StandardError = "";

  /**
   * InvocationURL is a link to AWS Web Console for this invocation.
   * An invocation is the execution of a Command in an Instance.
   *
   * @generated from field: string InvocationURL = 10;
   */
  InvocationURL = "";

  constructor(data?: PartialMessage<SSMRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SSMRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "CommandID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "InstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ExitCode", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "Status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AccountID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "StandardOutput", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "StandardError", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "InvocationURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSMRun {
    return new SSMRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSMRun {
    return new SSMRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSMRun {
    return new SSMRun().fromJsonString(jsonString, options);
  }

  static equals(a: SSMRun | PlainMessage<SSMRun> | undefined, b: SSMRun | PlainMessage<SSMRun> | undefined): boolean {
    return proto3.util.equals(SSMRun, a, b);
  }
}

/**
 * CassandraSession is emitted when a Cassandra client sends
 * the prepare a CQL statement.
 *
 * @generated from message events.CassandraPrepare
 */
export class CassandraPrepare extends Message<CassandraPrepare> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Query is the CQL statement.
   *
   * @generated from field: string Query = 5;
   */
  Query = "";

  /**
   * Keyspace is the keyspace the statement is in.
   *
   * @generated from field: string Keyspace = 6;
   */
  Keyspace = "";

  constructor(data?: PartialMessage<CassandraPrepare>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraPrepare";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Keyspace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraPrepare {
    return new CassandraPrepare().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraPrepare {
    return new CassandraPrepare().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraPrepare {
    return new CassandraPrepare().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraPrepare | PlainMessage<CassandraPrepare> | undefined, b: CassandraPrepare | PlainMessage<CassandraPrepare> | undefined): boolean {
    return proto3.util.equals(CassandraPrepare, a, b);
  }
}

/**
 * CassandraExecute is emitted when a Cassandra client executes a CQL statement.
 *
 * @generated from message events.CassandraExecute
 */
export class CassandraExecute extends Message<CassandraExecute> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * QueryId is the prepared query id to execute.
   *
   * @generated from field: string QueryId = 5;
   */
  QueryId = "";

  constructor(data?: PartialMessage<CassandraExecute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraExecute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "QueryId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraExecute {
    return new CassandraExecute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraExecute {
    return new CassandraExecute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraExecute {
    return new CassandraExecute().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraExecute | PlainMessage<CassandraExecute> | undefined, b: CassandraExecute | PlainMessage<CassandraExecute> | undefined): boolean {
    return proto3.util.equals(CassandraExecute, a, b);
  }
}

/**
 * CassandraBatch is emitted when a Cassandra client executes a batch of CQL statements.
 *
 * @generated from message events.CassandraBatch
 */
export class CassandraBatch extends Message<CassandraBatch> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Consistency is the consistency level to use.
   *
   * @generated from field: string Consistency = 5;
   */
  Consistency = "";

  /**
   * Keyspace is the keyspace the statement is in.
   *
   * @generated from field: string Keyspace = 6;
   */
  Keyspace = "";

  /**
   * BatchType is the type of batch.
   *
   * @generated from field: string BatchType = 7;
   */
  BatchType = "";

  /**
   * Children is batch children statements.
   *
   * @generated from field: repeated events.CassandraBatch.BatchChild Children = 8;
   */
  Children: CassandraBatch_BatchChild[] = [];

  constructor(data?: PartialMessage<CassandraBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Consistency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Keyspace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "BatchType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Children", kind: "message", T: CassandraBatch_BatchChild, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraBatch {
    return new CassandraBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraBatch {
    return new CassandraBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraBatch {
    return new CassandraBatch().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraBatch | PlainMessage<CassandraBatch> | undefined, b: CassandraBatch | PlainMessage<CassandraBatch> | undefined): boolean {
    return proto3.util.equals(CassandraBatch, a, b);
  }
}

/**
 * BatchChild represents a single child batch statement.
 *
 * @generated from message events.CassandraBatch.BatchChild
 */
export class CassandraBatch_BatchChild extends Message<CassandraBatch_BatchChild> {
  /**
   * ID is the id of the statement.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * Query the CQL statement to execute.
   *
   * @generated from field: string Query = 2;
   */
  Query = "";

  /**
   * Values is the values to bind to the query.
   *
   * @generated from field: repeated events.CassandraBatch.BatchChild.Value Values = 3;
   */
  Values: CassandraBatch_BatchChild_Value[] = [];

  constructor(data?: PartialMessage<CassandraBatch_BatchChild>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraBatch.BatchChild";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Values", kind: "message", T: CassandraBatch_BatchChild_Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraBatch_BatchChild {
    return new CassandraBatch_BatchChild().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraBatch_BatchChild {
    return new CassandraBatch_BatchChild().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraBatch_BatchChild {
    return new CassandraBatch_BatchChild().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraBatch_BatchChild | PlainMessage<CassandraBatch_BatchChild> | undefined, b: CassandraBatch_BatchChild | PlainMessage<CassandraBatch_BatchChild> | undefined): boolean {
    return proto3.util.equals(CassandraBatch_BatchChild, a, b);
  }
}

/**
 * Value is a single value to bind to the query.
 *
 * @generated from message events.CassandraBatch.BatchChild.Value
 */
export class CassandraBatch_BatchChild_Value extends Message<CassandraBatch_BatchChild_Value> {
  /**
   * Type is the type of the value.
   *
   * @generated from field: uint32 Type = 1;
   */
  Type = 0;

  /**
   * Contents is the value contents.
   *
   * @generated from field: bytes Contents = 2;
   */
  Contents = new Uint8Array(0);

  constructor(data?: PartialMessage<CassandraBatch_BatchChild_Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraBatch.BatchChild.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "Contents", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraBatch_BatchChild_Value {
    return new CassandraBatch_BatchChild_Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraBatch_BatchChild_Value {
    return new CassandraBatch_BatchChild_Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraBatch_BatchChild_Value {
    return new CassandraBatch_BatchChild_Value().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraBatch_BatchChild_Value | PlainMessage<CassandraBatch_BatchChild_Value> | undefined, b: CassandraBatch_BatchChild_Value | PlainMessage<CassandraBatch_BatchChild_Value> | undefined): boolean {
    return proto3.util.equals(CassandraBatch_BatchChild_Value, a, b);
  }
}

/**
 * CassandraRegister is emitted when a Cassandra client
 * request to register for the specified event types.
 *
 * @generated from message events.CassandraRegister
 */
export class CassandraRegister extends Message<CassandraRegister> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * EventTypes is the list of event types to register for.
   *
   * @generated from field: repeated string EventTypes = 5;
   */
  EventTypes: string[] = [];

  constructor(data?: PartialMessage<CassandraRegister>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CassandraRegister";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "EventTypes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CassandraRegister {
    return new CassandraRegister().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CassandraRegister {
    return new CassandraRegister().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CassandraRegister {
    return new CassandraRegister().fromJsonString(jsonString, options);
  }

  static equals(a: CassandraRegister | PlainMessage<CassandraRegister> | undefined, b: CassandraRegister | PlainMessage<CassandraRegister> | undefined): boolean {
    return proto3.util.equals(CassandraRegister, a, b);
  }
}

/**
 * LoginRuleCreate is emitted when a login rule is created or updated.
 *
 * @generated from message events.LoginRuleCreate
 */
export class LoginRuleCreate extends Message<LoginRuleCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<LoginRuleCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.LoginRuleCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRuleCreate {
    return new LoginRuleCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRuleCreate {
    return new LoginRuleCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRuleCreate {
    return new LoginRuleCreate().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRuleCreate | PlainMessage<LoginRuleCreate> | undefined, b: LoginRuleCreate | PlainMessage<LoginRuleCreate> | undefined): boolean {
    return proto3.util.equals(LoginRuleCreate, a, b);
  }
}

/**
 * LoginRuleDelete is emitted when a login rule is deleted
 *
 * @generated from message events.LoginRuleDelete
 */
export class LoginRuleDelete extends Message<LoginRuleDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  constructor(data?: PartialMessage<LoginRuleDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.LoginRuleDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRuleDelete {
    return new LoginRuleDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRuleDelete {
    return new LoginRuleDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRuleDelete {
    return new LoginRuleDelete().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRuleDelete | PlainMessage<LoginRuleDelete> | undefined, b: LoginRuleDelete | PlainMessage<LoginRuleDelete> | undefined): boolean {
    return proto3.util.equals(LoginRuleDelete, a, b);
  }
}

/**
 * SAMLIdPAuthAttempt is emitted when a user has attempted to authorize against the SAML IdP.
 *
 * @generated from message events.SAMLIdPAuthAttempt
 */
export class SAMLIdPAuthAttempt extends Message<SAMLIdPAuthAttempt> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is common event session metadata
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Status indicates whether the SAML IdP authentication was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  /**
   * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
   *
   * @generated from field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 5;
   */
  ServiceProvider?: SAMLIdPServiceProviderMetadata;

  constructor(data?: PartialMessage<SAMLIdPAuthAttempt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPAuthAttempt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
    { no: 5, name: "ServiceProvider", kind: "message", T: SAMLIdPServiceProviderMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPAuthAttempt {
    return new SAMLIdPAuthAttempt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPAuthAttempt {
    return new SAMLIdPAuthAttempt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPAuthAttempt {
    return new SAMLIdPAuthAttempt().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPAuthAttempt | PlainMessage<SAMLIdPAuthAttempt> | undefined, b: SAMLIdPAuthAttempt | PlainMessage<SAMLIdPAuthAttempt> | undefined): boolean {
    return proto3.util.equals(SAMLIdPAuthAttempt, a, b);
  }
}

/**
 * SAMLIdPServiceProviderCreate is emitted when a service provider has been added.
 *
 * @generated from message events.SAMLIdPServiceProviderCreate
 */
export class SAMLIdPServiceProviderCreate extends Message<SAMLIdPServiceProviderCreate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
   *
   * @generated from field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3;
   */
  ServiceProvider?: SAMLIdPServiceProviderMetadata;

  constructor(data?: PartialMessage<SAMLIdPServiceProviderCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPServiceProviderCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "ServiceProvider", kind: "message", T: SAMLIdPServiceProviderMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderCreate {
    return new SAMLIdPServiceProviderCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderCreate {
    return new SAMLIdPServiceProviderCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderCreate {
    return new SAMLIdPServiceProviderCreate().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderCreate | PlainMessage<SAMLIdPServiceProviderCreate> | undefined, b: SAMLIdPServiceProviderCreate | PlainMessage<SAMLIdPServiceProviderCreate> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderCreate, a, b);
  }
}

/**
 * SAMLIdPServiceProviderUpdate is emitted when a service provider has been updated.
 *
 * @generated from message events.SAMLIdPServiceProviderUpdate
 */
export class SAMLIdPServiceProviderUpdate extends Message<SAMLIdPServiceProviderUpdate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
   *
   * @generated from field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3;
   */
  ServiceProvider?: SAMLIdPServiceProviderMetadata;

  constructor(data?: PartialMessage<SAMLIdPServiceProviderUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPServiceProviderUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "ServiceProvider", kind: "message", T: SAMLIdPServiceProviderMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderUpdate {
    return new SAMLIdPServiceProviderUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderUpdate {
    return new SAMLIdPServiceProviderUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderUpdate {
    return new SAMLIdPServiceProviderUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderUpdate | PlainMessage<SAMLIdPServiceProviderUpdate> | undefined, b: SAMLIdPServiceProviderUpdate | PlainMessage<SAMLIdPServiceProviderUpdate> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderUpdate, a, b);
  }
}

/**
 * SAMLIdPServiceProviderDelete is emitted when a service provider has been deleted.
 *
 * @generated from message events.SAMLIdPServiceProviderDelete
 */
export class SAMLIdPServiceProviderDelete extends Message<SAMLIdPServiceProviderDelete> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
   *
   * @generated from field: events.SAMLIdPServiceProviderMetadata ServiceProvider = 3;
   */
  ServiceProvider?: SAMLIdPServiceProviderMetadata;

  constructor(data?: PartialMessage<SAMLIdPServiceProviderDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPServiceProviderDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "ServiceProvider", kind: "message", T: SAMLIdPServiceProviderMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderDelete {
    return new SAMLIdPServiceProviderDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderDelete {
    return new SAMLIdPServiceProviderDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderDelete {
    return new SAMLIdPServiceProviderDelete().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderDelete | PlainMessage<SAMLIdPServiceProviderDelete> | undefined, b: SAMLIdPServiceProviderDelete | PlainMessage<SAMLIdPServiceProviderDelete> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderDelete, a, b);
  }
}

/**
 * SAMLIdPServiceProviderDeleteAll is emitted when all service providers have been deleted.
 *
 * @generated from message events.SAMLIdPServiceProviderDeleteAll
 */
export class SAMLIdPServiceProviderDeleteAll extends Message<SAMLIdPServiceProviderDeleteAll> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  constructor(data?: PartialMessage<SAMLIdPServiceProviderDeleteAll>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SAMLIdPServiceProviderDeleteAll";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderDeleteAll {
    return new SAMLIdPServiceProviderDeleteAll().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderDeleteAll {
    return new SAMLIdPServiceProviderDeleteAll().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderDeleteAll {
    return new SAMLIdPServiceProviderDeleteAll().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderDeleteAll | PlainMessage<SAMLIdPServiceProviderDeleteAll> | undefined, b: SAMLIdPServiceProviderDeleteAll | PlainMessage<SAMLIdPServiceProviderDeleteAll> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderDeleteAll, a, b);
  }
}

/**
 * OktaResourcesUpdate is emitted when Okta related resources have been updated.
 *
 * @generated from message events.OktaResourcesUpdate
 */
export class OktaResourcesUpdate extends Message<OktaResourcesUpdate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Server is a common server metadata.
   *
   * @generated from field: events.ServerMetadata Server = 2;
   */
  Server?: ServerMetadata;

  /**
   * Updated is common metadata related to Okta resources being updated.
   *
   * @generated from field: events.OktaResourcesUpdatedMetadata Updated = 3;
   */
  Updated?: OktaResourcesUpdatedMetadata;

  constructor(data?: PartialMessage<OktaResourcesUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaResourcesUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Server", kind: "message", T: ServerMetadata },
    { no: 3, name: "Updated", kind: "message", T: OktaResourcesUpdatedMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaResourcesUpdate {
    return new OktaResourcesUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaResourcesUpdate {
    return new OktaResourcesUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaResourcesUpdate {
    return new OktaResourcesUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: OktaResourcesUpdate | PlainMessage<OktaResourcesUpdate> | undefined, b: OktaResourcesUpdate | PlainMessage<OktaResourcesUpdate> | undefined): boolean {
    return proto3.util.equals(OktaResourcesUpdate, a, b);
  }
}

/**
 * OktaSyncFailure is emitted when an Okta synchronization attempt has failed.
 *
 * @generated from message events.OktaSyncFailure
 */
export class OktaSyncFailure extends Message<OktaSyncFailure> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Server is a common server metadata.
   *
   * @generated from field: events.ServerMetadata Server = 2;
   */
  Server?: ServerMetadata;

  /**
   * Status contains error information for the synchronization failure.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  constructor(data?: PartialMessage<OktaSyncFailure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaSyncFailure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Server", kind: "message", T: ServerMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaSyncFailure {
    return new OktaSyncFailure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaSyncFailure {
    return new OktaSyncFailure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaSyncFailure {
    return new OktaSyncFailure().fromJsonString(jsonString, options);
  }

  static equals(a: OktaSyncFailure | PlainMessage<OktaSyncFailure> | undefined, b: OktaSyncFailure | PlainMessage<OktaSyncFailure> | undefined): boolean {
    return proto3.util.equals(OktaSyncFailure, a, b);
  }
}

/**
 * OktaAssignmentResult is emitted when an Okta assignment processing or cleanup was attempted.
 *
 * @generated from message events.OktaAssignmentResult
 */
export class OktaAssignmentResult extends Message<OktaAssignmentResult> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Server is a common server metadata.
   *
   * @generated from field: events.ServerMetadata Server = 2;
   */
  Server?: ServerMetadata;

  /**
   * ResourceMetadata is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * Status indicates whether the assignment processing was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  /**
   * OktaAssignmentMetadata is common Okta assignment metadata.
   *
   * @generated from field: events.OktaAssignmentMetadata OktaAssignment = 5;
   */
  OktaAssignment?: OktaAssignmentMetadata;

  constructor(data?: PartialMessage<OktaAssignmentResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaAssignmentResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Server", kind: "message", T: ServerMetadata },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
    { no: 5, name: "OktaAssignment", kind: "message", T: OktaAssignmentMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAssignmentResult {
    return new OktaAssignmentResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAssignmentResult {
    return new OktaAssignmentResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAssignmentResult {
    return new OktaAssignmentResult().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAssignmentResult | PlainMessage<OktaAssignmentResult> | undefined, b: OktaAssignmentResult | PlainMessage<OktaAssignmentResult> | undefined): boolean {
    return proto3.util.equals(OktaAssignmentResult, a, b);
  }
}

/**
 * AccessListCreate is emitted when an access list is created.
 *
 * @generated from message events.AccessListCreate
 */
export class AccessListCreate extends Message<AccessListCreate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListCreate {
    return new AccessListCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListCreate {
    return new AccessListCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListCreate {
    return new AccessListCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListCreate | PlainMessage<AccessListCreate> | undefined, b: AccessListCreate | PlainMessage<AccessListCreate> | undefined): boolean {
    return proto3.util.equals(AccessListCreate, a, b);
  }
}

/**
 * AccessListUpdate is emitted when an access list is updated.
 *
 * @generated from message events.AccessListUpdate
 */
export class AccessListUpdate extends Message<AccessListUpdate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListUpdate {
    return new AccessListUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListUpdate {
    return new AccessListUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListUpdate {
    return new AccessListUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListUpdate | PlainMessage<AccessListUpdate> | undefined, b: AccessListUpdate | PlainMessage<AccessListUpdate> | undefined): boolean {
    return proto3.util.equals(AccessListUpdate, a, b);
  }
}

/**
 * AccessListDelete is emitted when an access list is deleted.
 *
 * @generated from message events.AccessListDelete
 */
export class AccessListDelete extends Message<AccessListDelete> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListDelete {
    return new AccessListDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListDelete {
    return new AccessListDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListDelete {
    return new AccessListDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListDelete | PlainMessage<AccessListDelete> | undefined, b: AccessListDelete | PlainMessage<AccessListDelete> | undefined): boolean {
    return proto3.util.equals(AccessListDelete, a, b);
  }
}

/**
 * AccessListMemberCreate is emitted when an access list member is created.
 *
 * @generated from message events.AccessListMemberCreate
 */
export class AccessListMemberCreate extends Message<AccessListMemberCreate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * AccessListMember is common access list member metadata.
   *
   * @generated from field: events.AccessListMemberMetadata AccessListMember = 3;
   */
  AccessListMember?: AccessListMemberMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListMemberCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMemberCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "AccessListMember", kind: "message", T: AccessListMemberMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMemberCreate {
    return new AccessListMemberCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMemberCreate {
    return new AccessListMemberCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMemberCreate {
    return new AccessListMemberCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMemberCreate | PlainMessage<AccessListMemberCreate> | undefined, b: AccessListMemberCreate | PlainMessage<AccessListMemberCreate> | undefined): boolean {
    return proto3.util.equals(AccessListMemberCreate, a, b);
  }
}

/**
 * AccessListMemberUpdate is emitted when an access list member is updated.
 *
 * @generated from message events.AccessListMemberUpdate
 */
export class AccessListMemberUpdate extends Message<AccessListMemberUpdate> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * AccessListMember is common access list member metadata.
   *
   * @generated from field: events.AccessListMemberMetadata AccessListMember = 3;
   */
  AccessListMember?: AccessListMemberMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListMemberUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMemberUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "AccessListMember", kind: "message", T: AccessListMemberMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMemberUpdate {
    return new AccessListMemberUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMemberUpdate {
    return new AccessListMemberUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMemberUpdate {
    return new AccessListMemberUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMemberUpdate | PlainMessage<AccessListMemberUpdate> | undefined, b: AccessListMemberUpdate | PlainMessage<AccessListMemberUpdate> | undefined): boolean {
    return proto3.util.equals(AccessListMemberUpdate, a, b);
  }
}

/**
 * AccessListMemberDelete is emitted when an access list member is deleted.
 *
 * @generated from message events.AccessListMemberDelete
 */
export class AccessListMemberDelete extends Message<AccessListMemberDelete> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * AccessListMember is common access list member metadata.
   *
   * @generated from field: events.AccessListMemberMetadata AccessListMember = 3;
   */
  AccessListMember?: AccessListMemberMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListMemberDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMemberDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "AccessListMember", kind: "message", T: AccessListMemberMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMemberDelete {
    return new AccessListMemberDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMemberDelete {
    return new AccessListMemberDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMemberDelete {
    return new AccessListMemberDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMemberDelete | PlainMessage<AccessListMemberDelete> | undefined, b: AccessListMemberDelete | PlainMessage<AccessListMemberDelete> | undefined): boolean {
    return proto3.util.equals(AccessListMemberDelete, a, b);
  }
}

/**
 * AccessListMemberDeleteAllForAccessList is emitted when all members are deleted for an access list.
 *
 * @generated from message events.AccessListMemberDeleteAllForAccessList
 */
export class AccessListMemberDeleteAllForAccessList extends Message<AccessListMemberDeleteAllForAccessList> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * AccessListMember is common access list member metadata.
   *
   * @generated from field: events.AccessListMemberMetadata AccessListMember = 3;
   */
  AccessListMember?: AccessListMemberMetadata;

  /**
   * Status indicates whether the resource operation was successful.
   *
   * @generated from field: events.Status Status = 4;
   */
  Status?: Status;

  constructor(data?: PartialMessage<AccessListMemberDeleteAllForAccessList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListMemberDeleteAllForAccessList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "AccessListMember", kind: "message", T: AccessListMemberMetadata },
    { no: 4, name: "Status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListMemberDeleteAllForAccessList {
    return new AccessListMemberDeleteAllForAccessList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListMemberDeleteAllForAccessList {
    return new AccessListMemberDeleteAllForAccessList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListMemberDeleteAllForAccessList {
    return new AccessListMemberDeleteAllForAccessList().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListMemberDeleteAllForAccessList | PlainMessage<AccessListMemberDeleteAllForAccessList> | undefined, b: AccessListMemberDeleteAllForAccessList | PlainMessage<AccessListMemberDeleteAllForAccessList> | undefined): boolean {
    return proto3.util.equals(AccessListMemberDeleteAllForAccessList, a, b);
  }
}

/**
 * AccessListReview is emitted when an access list is reviewed.
 *
 * @generated from message events.AccessListReview
 */
export class AccessListReview extends Message<AccessListReview> {
  /**
   * Metadata is common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Review is metadata for the access list review.
   *
   * @generated from field: events.AccessListReviewMetadata Review = 3;
   */
  Review?: AccessListReviewMetadata;

  /**
   * Status indicates whether the review operation was successful.
   *
   * @generated from field: events.Status status = 4;
   */
  status?: Status;

  constructor(data?: PartialMessage<AccessListReview>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessListReview";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "Review", kind: "message", T: AccessListReviewMetadata },
    { no: 4, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListReview {
    return new AccessListReview().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListReview {
    return new AccessListReview().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListReview {
    return new AccessListReview().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListReview | PlainMessage<AccessListReview> | undefined, b: AccessListReview | PlainMessage<AccessListReview> | undefined): boolean {
    return proto3.util.equals(AccessListReview, a, b);
  }
}

/**
 * AuditQueryRun is emitted when a user runs an audit query.
 *
 * @generated from message events.AuditQueryRun
 */
export class AuditQueryRun extends Message<AuditQueryRun> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Status indicates whether the read was successful.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  /**
   * Query contains additional query information.
   *
   * @generated from field: events.AuditQueryDetails Query = 4;
   */
  Query?: AuditQueryDetails;

  constructor(data?: PartialMessage<AuditQueryRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AuditQueryRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
    { no: 4, name: "Query", kind: "message", T: AuditQueryDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuditQueryRun {
    return new AuditQueryRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuditQueryRun {
    return new AuditQueryRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuditQueryRun {
    return new AuditQueryRun().fromJsonString(jsonString, options);
  }

  static equals(a: AuditQueryRun | PlainMessage<AuditQueryRun> | undefined, b: AuditQueryRun | PlainMessage<AuditQueryRun> | undefined): boolean {
    return proto3.util.equals(AuditQueryRun, a, b);
  }
}

/**
 * AuditQueryDetails contains additional query information.
 *
 * @generated from message events.AuditQueryDetails
 */
export class AuditQueryDetails extends Message<AuditQueryDetails> {
  /**
   * Name is the name of the query.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Query is the query that was run.
   *
   * @generated from field: string Query = 2;
   */
  Query = "";

  /**
   * Days is the number of days time range for the query.
   *
   * @generated from field: int32 Days = 3;
   */
  Days = 0;

  /**
   * ExecutionTimeInMillis is the total execution time of the query.
   *
   * @generated from field: int64 ExecutionTimeInMillis = 4;
   */
  ExecutionTimeInMillis = protoInt64.zero;

  /**
   * DataScannedInBytes is the amount of data scanned by the query.
   *
   * @generated from field: int64 DataScannedInBytes = 5;
   */
  DataScannedInBytes = protoInt64.zero;

  constructor(data?: PartialMessage<AuditQueryDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AuditQueryDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "ExecutionTimeInMillis", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "DataScannedInBytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuditQueryDetails {
    return new AuditQueryDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuditQueryDetails {
    return new AuditQueryDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuditQueryDetails {
    return new AuditQueryDetails().fromJsonString(jsonString, options);
  }

  static equals(a: AuditQueryDetails | PlainMessage<AuditQueryDetails> | undefined, b: AuditQueryDetails | PlainMessage<AuditQueryDetails> | undefined): boolean {
    return proto3.util.equals(AuditQueryDetails, a, b);
  }
}

/**
 * SecurityReportRun is emitted when a user runs an audit query.
 *
 * @generated from message events.SecurityReportRun
 */
export class SecurityReportRun extends Message<SecurityReportRun> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * Status indicates whether the read was successful.
   *
   * @generated from field: events.Status Status = 3;
   */
  Status?: Status;

  /**
   * Query is the query that was run.
   *
   * @generated from field: string Name = 4;
   */
  Name = "";

  /**
   * Version is the version of security report.
   *
   * @generated from field: string Version = 5;
   */
  Version = "";

  /**
   * TotalExecutionTimeInMillis is the total execution time of the query.
   *
   * @generated from field: int64 TotalExecutionTimeInMillis = 6;
   */
  TotalExecutionTimeInMillis = protoInt64.zero;

  /**
   * TotalDataScannedInBytes is the amount of data scanned by the query.
   *
   * @generated from field: int64 TotalDataScannedInBytes = 7;
   */
  TotalDataScannedInBytes = protoInt64.zero;

  /**
   * AuditQueries is the list of audit queries that were run.
   *
   * @generated from field: repeated events.AuditQueryDetails AuditQueries = 8;
   */
  AuditQueries: AuditQueryDetails[] = [];

  constructor(data?: PartialMessage<SecurityReportRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SecurityReportRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Status", kind: "message", T: Status },
    { no: 4, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "TotalExecutionTimeInMillis", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "TotalDataScannedInBytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "AuditQueries", kind: "message", T: AuditQueryDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityReportRun {
    return new SecurityReportRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityReportRun {
    return new SecurityReportRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityReportRun {
    return new SecurityReportRun().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityReportRun | PlainMessage<SecurityReportRun> | undefined, b: SecurityReportRun | PlainMessage<SecurityReportRun> | undefined): boolean {
    return proto3.util.equals(SecurityReportRun, a, b);
  }
}

/**
 * ExternalAuditStorageEnableEvent is emitted when External Audit Storage is
 * enabled.
 *
 * @generated from message events.ExternalAuditStorageEnable
 */
export class ExternalAuditStorageEnable extends Message<ExternalAuditStorageEnable> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Details holds details about the External Audit Storage configuration that
   * was enabled.
   *
   * @generated from field: events.ExternalAuditStorageDetails details = 3;
   */
  details?: ExternalAuditStorageDetails;

  constructor(data?: PartialMessage<ExternalAuditStorageEnable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ExternalAuditStorageEnable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "details", kind: "message", T: ExternalAuditStorageDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalAuditStorageEnable {
    return new ExternalAuditStorageEnable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalAuditStorageEnable {
    return new ExternalAuditStorageEnable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalAuditStorageEnable {
    return new ExternalAuditStorageEnable().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalAuditStorageEnable | PlainMessage<ExternalAuditStorageEnable> | undefined, b: ExternalAuditStorageEnable | PlainMessage<ExternalAuditStorageEnable> | undefined): boolean {
    return proto3.util.equals(ExternalAuditStorageEnable, a, b);
  }
}

/**
 * ExternalAuditStorageDisableEvent is emitted when External Audit Storage is
 * disabled.
 *
 * @generated from message events.ExternalAuditStorageDisable
 */
export class ExternalAuditStorageDisable extends Message<ExternalAuditStorageDisable> {
  /**
   * Metadata is common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Resource is common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * Details holds details about the External Audit Storage configuration that
   * was disabled.
   *
   * @generated from field: events.ExternalAuditStorageDetails details = 3;
   */
  details?: ExternalAuditStorageDetails;

  constructor(data?: PartialMessage<ExternalAuditStorageDisable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ExternalAuditStorageDisable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "details", kind: "message", T: ExternalAuditStorageDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalAuditStorageDisable {
    return new ExternalAuditStorageDisable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalAuditStorageDisable {
    return new ExternalAuditStorageDisable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalAuditStorageDisable {
    return new ExternalAuditStorageDisable().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalAuditStorageDisable | PlainMessage<ExternalAuditStorageDisable> | undefined, b: ExternalAuditStorageDisable | PlainMessage<ExternalAuditStorageDisable> | undefined): boolean {
    return proto3.util.equals(ExternalAuditStorageDisable, a, b);
  }
}

/**
 * Details holds details about the External Audit Storage configuration.
 *
 * @generated from message events.ExternalAuditStorageDetails
 */
export class ExternalAuditStorageDetails extends Message<ExternalAuditStorageDetails> {
  /**
   * IntegrationName is the name of the AWS OIDC integration used.
   *
   * @generated from field: string integration_name = 3;
   */
  integrationName = "";

  /**
   * SessionsRecordingsURI is the S3 path used to store session recordings.
   *
   * @generated from field: string session_recordings_uri = 4;
   */
  sessionRecordingsUri = "";

  /**
   * AthenaWorkgroup is the workgroup used for Athena audit log queries.
   *
   * @generated from field: string athena_workgroup = 5;
   */
  athenaWorkgroup = "";

  /**
   * GlueDatabase is the database used for Athena audit log queries.
   *
   * @generated from field: string glue_database = 6;
   */
  glueDatabase = "";

  /**
   * GlueTable is the table used for Athena audit log queries.
   *
   * @generated from field: string glue_table = 7;
   */
  glueTable = "";

  /**
   * AuditEventsLongTermURI is the S3 path used to store batched parquet files
   * with audit events, partitioned by event date.
   *
   * @generated from field: string audit_events_long_term_uri = 8;
   */
  auditEventsLongTermUri = "";

  /**
   * AthenaResultsURI is the S3 path used to store temporary results generated
   * by Athena.
   *
   * @generated from field: string athena_results_uri = 9;
   */
  athenaResultsUri = "";

  /**
   * PolicyName is the name of the IAM policy attached to the OIDC integration
   * role.
   *
   * @generated from field: string policy_name = 10;
   */
  policyName = "";

  /**
   * Region is the AWS region where the infrastructure is hosted.
   *
   * @generated from field: string region = 11;
   */
  region = "";

  constructor(data?: PartialMessage<ExternalAuditStorageDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ExternalAuditStorageDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "integration_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "session_recordings_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "athena_workgroup", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "glue_database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "glue_table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "audit_events_long_term_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "athena_results_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "policy_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalAuditStorageDetails {
    return new ExternalAuditStorageDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalAuditStorageDetails {
    return new ExternalAuditStorageDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalAuditStorageDetails {
    return new ExternalAuditStorageDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalAuditStorageDetails | PlainMessage<ExternalAuditStorageDetails> | undefined, b: ExternalAuditStorageDetails | PlainMessage<ExternalAuditStorageDetails> | undefined): boolean {
    return proto3.util.equals(ExternalAuditStorageDetails, a, b);
  }
}

/**
 * OktaAccessListSync records an access list sync event.
 *
 * @generated from message events.OktaAccessListSync
 */
export class OktaAccessListSync extends Message<OktaAccessListSync> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status contains common command or operation status fields.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * NumAppFilters is the number of application filters used for this sync.
   *
   * @generated from field: int32 num_app_filters = 3;
   */
  numAppFilters = 0;

  /**
   * NumGroupFilters is the number of group filters used for this sync.
   *
   * @generated from field: int32 num_group_filters = 4;
   */
  numGroupFilters = 0;

  /**
   * NumApps is the number of apps that were synchronized from this sync event.
   *
   * @generated from field: int32 num_apps = 5;
   */
  numApps = 0;

  /**
   * NumGroups is the number of groups that were synchronized from this sync event.
   *
   * @generated from field: int32 num_groups = 6;
   */
  numGroups = 0;

  /**
   * NumRoles are the number of roles that were created/updated.
   *
   * @generated from field: int32 numRoles = 7;
   */
  numRoles = 0;

  /**
   * NumAccessLists are the number of access lists that were created/updated.
   *
   * @generated from field: int32 numAccessLists = 8;
   */
  numAccessLists = 0;

  /**
   * NumAccessListMembers are the number of access list members that were created/updated.
   *
   * @generated from field: int32 numAccessListMembers = 9;
   */
  numAccessListMembers = 0;

  constructor(data?: PartialMessage<OktaAccessListSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaAccessListSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "num_app_filters", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "num_group_filters", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "num_apps", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "num_groups", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "numRoles", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "numAccessLists", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "numAccessListMembers", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAccessListSync {
    return new OktaAccessListSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAccessListSync {
    return new OktaAccessListSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAccessListSync {
    return new OktaAccessListSync().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAccessListSync | PlainMessage<OktaAccessListSync> | undefined, b: OktaAccessListSync | PlainMessage<OktaAccessListSync> | undefined): boolean {
    return proto3.util.equals(OktaAccessListSync, a, b);
  }
}

/**
 * OktaUserSync records an Okta user sync event.
 *
 * @generated from message events.OktaUserSync
 */
export class OktaUserSync extends Message<OktaUserSync> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status contains common command or operation status fields.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * OrgUrl is the URL of the Okta organization being synced to
   *
   * @generated from field: string org_url = 3;
   */
  orgUrl = "";

  /**
   * AppId is the optional ID of an Okta Application that Teleport is using as
   * its gateway into Okta. The list of potential Teleport users are drawn from
   * the list of Okta users assigned to this app - either directly or via a group
   * assignement. If not set, the Okta sync service is drawing its user list from
   * the whole organization.
   *
   * @generated from field: string app_id = 4;
   */
  appId = "";

  /**
   * NumUsersCreated is the number of Teleport users created in this
   * synchronization pass.
   *
   * @generated from field: int32 num_users_created = 5;
   */
  numUsersCreated = 0;

  /**
   * NumUsersDeleted is the number of Teleport users deleted in this
   * synchronization pass.
   *
   * @generated from field: int32 num_users_deleted = 6;
   */
  numUsersDeleted = 0;

  /**
   * NumUserModified is the number of Teleport users modified in this
   * synchronization pass.
   *
   * @generated from field: int32 num_users_modified = 7;
   */
  numUsersModified = 0;

  /**
   * NumUsersTotal is the total number of Teleport users managed by the Okta
   * integration at the end of the synchronzaton pass.
   *
   * @generated from field: int32 num_users_total = 8;
   */
  numUsersTotal = 0;

  constructor(data?: PartialMessage<OktaUserSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.OktaUserSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "org_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "num_users_created", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "num_users_deleted", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "num_users_modified", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "num_users_total", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaUserSync {
    return new OktaUserSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaUserSync {
    return new OktaUserSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaUserSync {
    return new OktaUserSync().fromJsonString(jsonString, options);
  }

  static equals(a: OktaUserSync | PlainMessage<OktaUserSync> | undefined, b: OktaUserSync | PlainMessage<OktaUserSync> | undefined): boolean {
    return proto3.util.equals(OktaUserSync, a, b);
  }
}

/**
 * SPIFFESVIDIssued is an event recorded when a SPIFFE SVID is issued.
 *
 * @generated from message events.SPIFFESVIDIssued
 */
export class SPIFFESVIDIssued extends Message<SPIFFESVIDIssued> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 3;
   */
  Connection?: ConnectionMetadata;

  /**
   * SPIFFEID is the SPIFFE ID of the issued SVID
   *
   * @generated from field: string SPIFFEID = 4;
   */
  SPIFFEID = "";

  /**
   * DNSSANs is the list of DNS SANs in the issued SVID
   *
   * @generated from field: repeated string DNSSANs = 5;
   */
  DNSSANs: string[] = [];

  /**
   * IPSANs is the list of IP SANs in the issued SVID
   *
   * @generated from field: repeated string IPSANs = 6;
   */
  IPSANs: string[] = [];

  /**
   * SVIDType is `jwt` or `x509
   *
   * @generated from field: string SVIDType = 7;
   */
  SVIDType = "";

  /**
   * SerialNumber is the serial number of the issued SVID
   *
   * @generated from field: string SerialNumber = 8;
   */
  SerialNumber = "";

  /**
   * Hint is the hint of the issued SVID
   *
   * @generated from field: string Hint = 9;
   */
  Hint = "";

  constructor(data?: PartialMessage<SPIFFESVIDIssued>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SPIFFESVIDIssued";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 4, name: "SPIFFEID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "DNSSANs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "IPSANs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "SVIDType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "SerialNumber", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Hint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SPIFFESVIDIssued {
    return new SPIFFESVIDIssued().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SPIFFESVIDIssued {
    return new SPIFFESVIDIssued().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SPIFFESVIDIssued {
    return new SPIFFESVIDIssued().fromJsonString(jsonString, options);
  }

  static equals(a: SPIFFESVIDIssued | PlainMessage<SPIFFESVIDIssued> | undefined, b: SPIFFESVIDIssued | PlainMessage<SPIFFESVIDIssued> | undefined): boolean {
    return proto3.util.equals(SPIFFESVIDIssued, a, b);
  }
}

/**
 * AuthPreferenceUpdate is emitted when the auth preference is updated.
 *
 * @generated from message events.AuthPreferenceUpdate
 */
export class AuthPreferenceUpdate extends Message<AuthPreferenceUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * AdminActionsMFA indicates whether MFA for admin actions was altered
   * while updating the authentication preference.
   *
   * @generated from field: events.AdminActionsMFAStatus AdminActionsMFA = 5;
   */
  AdminActionsMFA = AdminActionsMFAStatus.ADMIN_ACTIONS_MFA_STATUS_UNSPECIFIED;

  constructor(data?: PartialMessage<AuthPreferenceUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AuthPreferenceUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "AdminActionsMFA", kind: "enum", T: proto3.getEnumType(AdminActionsMFAStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthPreferenceUpdate {
    return new AuthPreferenceUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthPreferenceUpdate {
    return new AuthPreferenceUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthPreferenceUpdate {
    return new AuthPreferenceUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AuthPreferenceUpdate | PlainMessage<AuthPreferenceUpdate> | undefined, b: AuthPreferenceUpdate | PlainMessage<AuthPreferenceUpdate> | undefined): boolean {
    return proto3.util.equals(AuthPreferenceUpdate, a, b);
  }
}

/**
 * ClusterNetworkingConfigUpdate is emitted when the cluster networking config is updated.
 *
 * @generated from message events.ClusterNetworkingConfigUpdate
 */
export class ClusterNetworkingConfigUpdate extends Message<ClusterNetworkingConfigUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<ClusterNetworkingConfigUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.ClusterNetworkingConfigUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterNetworkingConfigUpdate {
    return new ClusterNetworkingConfigUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigUpdate {
    return new ClusterNetworkingConfigUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigUpdate {
    return new ClusterNetworkingConfigUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterNetworkingConfigUpdate | PlainMessage<ClusterNetworkingConfigUpdate> | undefined, b: ClusterNetworkingConfigUpdate | PlainMessage<ClusterNetworkingConfigUpdate> | undefined): boolean {
    return proto3.util.equals(ClusterNetworkingConfigUpdate, a, b);
  }
}

/**
 * SessionRecordingConfigUpdate is emitted when the session recording config is updated.
 *
 * @generated from message events.SessionRecordingConfigUpdate
 */
export class SessionRecordingConfigUpdate extends Message<SessionRecordingConfigUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<SessionRecordingConfigUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SessionRecordingConfigUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionRecordingConfigUpdate {
    return new SessionRecordingConfigUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionRecordingConfigUpdate {
    return new SessionRecordingConfigUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionRecordingConfigUpdate {
    return new SessionRecordingConfigUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: SessionRecordingConfigUpdate | PlainMessage<SessionRecordingConfigUpdate> | undefined, b: SessionRecordingConfigUpdate | PlainMessage<SessionRecordingConfigUpdate> | undefined): boolean {
    return proto3.util.equals(SessionRecordingConfigUpdate, a, b);
  }
}

/**
 * AccessPathChanged is emitted when access graph detects a change in a access path.
 *
 * @generated from message events.AccessPathChanged
 */
export class AccessPathChanged extends Message<AccessPathChanged> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ChangeID is the id of the change.
   *
   * @generated from field: string ChangeID = 2;
   */
  ChangeID = "";

  /**
   * AffectedResourceID is the name of the affected resource.
   *
   * @generated from field: string AffectedResourceName = 3;
   */
  AffectedResourceName = "";

  /**
   * AffectedResourceSource is the source of the affected resource, ex: Teleport, AWS, GitLab, etc.
   *
   * @generated from field: string AffectedResourceSource = 4;
   */
  AffectedResourceSource = "";

  /**
   * AffectedResourceType is the type of the affected resource, ex: user, role, etc.
   *
   * @generated from field: string AffectedResourceType = 5;
   */
  AffectedResourceType = "";

  constructor(data?: PartialMessage<AccessPathChanged>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessPathChanged";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "ChangeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "AffectedResourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AffectedResourceSource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AffectedResourceType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessPathChanged {
    return new AccessPathChanged().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessPathChanged {
    return new AccessPathChanged().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessPathChanged {
    return new AccessPathChanged().fromJsonString(jsonString, options);
  }

  static equals(a: AccessPathChanged | PlainMessage<AccessPathChanged> | undefined, b: AccessPathChanged | PlainMessage<AccessPathChanged> | undefined): boolean {
    return proto3.util.equals(AccessPathChanged, a, b);
  }
}

/**
 * SpannerRPC is an event emitted when a Spanner client calls a Spanner RPC.
 *
 * @generated from message events.SpannerRPC
 */
export class SpannerRPC extends Message<SpannerRPC> {
  /**
   * Metadata is a common event metadata.
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * User is a common user event metadata.
   *
   * @generated from field: events.UserMetadata User = 2;
   */
  User?: UserMetadata;

  /**
   * SessionMetadata is a common event session metadata.
   *
   * @generated from field: events.SessionMetadata Session = 3;
   */
  Session?: SessionMetadata;

  /**
   * Database contains database related metadata.
   *
   * @generated from field: events.DatabaseMetadata Database = 4;
   */
  Database?: DatabaseMetadata;

  /**
   * Status indicates whether the RPC was successfully sent to the database.
   *
   * @generated from field: events.Status Status = 5;
   */
  Status?: Status;

  /**
   * Procedure is the name of the remote procedure.
   *
   * @generated from field: string Procedure = 6;
   */
  Procedure = "";

  /**
   * Args are the RPC arguments.
   *
   * @generated from field: google.protobuf.Struct Args = 7;
   */
  Args?: Struct;

  constructor(data?: PartialMessage<SpannerRPC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SpannerRPC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "User", kind: "message", T: UserMetadata },
    { no: 3, name: "Session", kind: "message", T: SessionMetadata },
    { no: 4, name: "Database", kind: "message", T: DatabaseMetadata },
    { no: 5, name: "Status", kind: "message", T: Status },
    { no: 6, name: "Procedure", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Args", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpannerRPC {
    return new SpannerRPC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpannerRPC {
    return new SpannerRPC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpannerRPC {
    return new SpannerRPC().fromJsonString(jsonString, options);
  }

  static equals(a: SpannerRPC | PlainMessage<SpannerRPC> | undefined, b: SpannerRPC | PlainMessage<SpannerRPC> | undefined): boolean {
    return proto3.util.equals(SpannerRPC, a, b);
  }
}

/**
 * AccessGraphSettingsUpdate is emitted when the Access Graph Settings config is updated.
 *
 * @generated from message events.AccessGraphSettingsUpdate
 */
export class AccessGraphSettingsUpdate extends Message<AccessGraphSettingsUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AccessGraphSettingsUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AccessGraphSettingsUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessGraphSettingsUpdate {
    return new AccessGraphSettingsUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessGraphSettingsUpdate {
    return new AccessGraphSettingsUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessGraphSettingsUpdate {
    return new AccessGraphSettingsUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AccessGraphSettingsUpdate | PlainMessage<AccessGraphSettingsUpdate> | undefined, b: AccessGraphSettingsUpdate | PlainMessage<AccessGraphSettingsUpdate> | undefined): boolean {
    return proto3.util.equals(AccessGraphSettingsUpdate, a, b);
  }
}

/**
 * SPIFFEFederationCreate is emitted when a SPIFFE federation is created.
 *
 * @generated from message events.SPIFFEFederationCreate
 */
export class SPIFFEFederationCreate extends Message<SPIFFEFederationCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<SPIFFEFederationCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SPIFFEFederationCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SPIFFEFederationCreate {
    return new SPIFFEFederationCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SPIFFEFederationCreate {
    return new SPIFFEFederationCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SPIFFEFederationCreate {
    return new SPIFFEFederationCreate().fromJsonString(jsonString, options);
  }

  static equals(a: SPIFFEFederationCreate | PlainMessage<SPIFFEFederationCreate> | undefined, b: SPIFFEFederationCreate | PlainMessage<SPIFFEFederationCreate> | undefined): boolean {
    return proto3.util.equals(SPIFFEFederationCreate, a, b);
  }
}

/**
 * SPIFFEFederationDelete is emitted when a SPIFFE federation is deleted.
 *
 * @generated from message events.SPIFFEFederationDelete
 */
export class SPIFFEFederationDelete extends Message<SPIFFEFederationDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<SPIFFEFederationDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.SPIFFEFederationDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SPIFFEFederationDelete {
    return new SPIFFEFederationDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SPIFFEFederationDelete {
    return new SPIFFEFederationDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SPIFFEFederationDelete {
    return new SPIFFEFederationDelete().fromJsonString(jsonString, options);
  }

  static equals(a: SPIFFEFederationDelete | PlainMessage<SPIFFEFederationDelete> | undefined, b: SPIFFEFederationDelete | PlainMessage<SPIFFEFederationDelete> | undefined): boolean {
    return proto3.util.equals(SPIFFEFederationDelete, a, b);
  }
}

/**
 * AutoUpdateConfigCreate is emitted when an auto update config is created.
 *
 * @generated from message events.AutoUpdateConfigCreate
 */
export class AutoUpdateConfigCreate extends Message<AutoUpdateConfigCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateConfigCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateConfigCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateConfigCreate {
    return new AutoUpdateConfigCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateConfigCreate {
    return new AutoUpdateConfigCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateConfigCreate {
    return new AutoUpdateConfigCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateConfigCreate | PlainMessage<AutoUpdateConfigCreate> | undefined, b: AutoUpdateConfigCreate | PlainMessage<AutoUpdateConfigCreate> | undefined): boolean {
    return proto3.util.equals(AutoUpdateConfigCreate, a, b);
  }
}

/**
 * AutoUpdateConfigUpdate is emitted when an auto update config is updated.
 *
 * @generated from message events.AutoUpdateConfigUpdate
 */
export class AutoUpdateConfigUpdate extends Message<AutoUpdateConfigUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateConfigUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateConfigUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateConfigUpdate {
    return new AutoUpdateConfigUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateConfigUpdate {
    return new AutoUpdateConfigUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateConfigUpdate {
    return new AutoUpdateConfigUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateConfigUpdate | PlainMessage<AutoUpdateConfigUpdate> | undefined, b: AutoUpdateConfigUpdate | PlainMessage<AutoUpdateConfigUpdate> | undefined): boolean {
    return proto3.util.equals(AutoUpdateConfigUpdate, a, b);
  }
}

/**
 * AutoUpdateConfigDelete is emitted when an auto update config is deleted.
 *
 * @generated from message events.AutoUpdateConfigDelete
 */
export class AutoUpdateConfigDelete extends Message<AutoUpdateConfigDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateConfigDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateConfigDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateConfigDelete {
    return new AutoUpdateConfigDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateConfigDelete {
    return new AutoUpdateConfigDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateConfigDelete {
    return new AutoUpdateConfigDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateConfigDelete | PlainMessage<AutoUpdateConfigDelete> | undefined, b: AutoUpdateConfigDelete | PlainMessage<AutoUpdateConfigDelete> | undefined): boolean {
    return proto3.util.equals(AutoUpdateConfigDelete, a, b);
  }
}

/**
 * AutoUpdateVersionCreate is emitted when an auto update version is created.
 *
 * @generated from message events.AutoUpdateVersionCreate
 */
export class AutoUpdateVersionCreate extends Message<AutoUpdateVersionCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateVersionCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateVersionCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateVersionCreate {
    return new AutoUpdateVersionCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateVersionCreate {
    return new AutoUpdateVersionCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateVersionCreate {
    return new AutoUpdateVersionCreate().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateVersionCreate | PlainMessage<AutoUpdateVersionCreate> | undefined, b: AutoUpdateVersionCreate | PlainMessage<AutoUpdateVersionCreate> | undefined): boolean {
    return proto3.util.equals(AutoUpdateVersionCreate, a, b);
  }
}

/**
 * AutoUpdateVersionUpdate is emitted when an auto update version is updated.
 *
 * @generated from message events.AutoUpdateVersionUpdate
 */
export class AutoUpdateVersionUpdate extends Message<AutoUpdateVersionUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateVersionUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateVersionUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateVersionUpdate {
    return new AutoUpdateVersionUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateVersionUpdate {
    return new AutoUpdateVersionUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateVersionUpdate {
    return new AutoUpdateVersionUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateVersionUpdate | PlainMessage<AutoUpdateVersionUpdate> | undefined, b: AutoUpdateVersionUpdate | PlainMessage<AutoUpdateVersionUpdate> | undefined): boolean {
    return proto3.util.equals(AutoUpdateVersionUpdate, a, b);
  }
}

/**
 * AutoUpdateVersionDelete is emitted when an auto update version is deleted.
 *
 * @generated from message events.AutoUpdateVersionDelete
 */
export class AutoUpdateVersionDelete extends Message<AutoUpdateVersionDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 2;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<AutoUpdateVersionDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.AutoUpdateVersionDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpdateVersionDelete {
    return new AutoUpdateVersionDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpdateVersionDelete {
    return new AutoUpdateVersionDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpdateVersionDelete {
    return new AutoUpdateVersionDelete().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpdateVersionDelete | PlainMessage<AutoUpdateVersionDelete> | undefined, b: AutoUpdateVersionDelete | PlainMessage<AutoUpdateVersionDelete> | undefined): boolean {
    return proto3.util.equals(AutoUpdateVersionDelete, a, b);
  }
}

/**
 * StaticHostUserCreate is emitted when a static host user is created.
 *
 * @generated from message events.StaticHostUserCreate
 */
export class StaticHostUserCreate extends Message<StaticHostUserCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the creation was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 4;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<StaticHostUserCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.StaticHostUserCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "User", kind: "message", T: UserMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StaticHostUserCreate {
    return new StaticHostUserCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StaticHostUserCreate {
    return new StaticHostUserCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StaticHostUserCreate {
    return new StaticHostUserCreate().fromJsonString(jsonString, options);
  }

  static equals(a: StaticHostUserCreate | PlainMessage<StaticHostUserCreate> | undefined, b: StaticHostUserCreate | PlainMessage<StaticHostUserCreate> | undefined): boolean {
    return proto3.util.equals(StaticHostUserCreate, a, b);
  }
}

/**
 * StaticHostUserUpdate is emitted when a static host user is updated.
 *
 * @generated from message events.StaticHostUserUpdate
 */
export class StaticHostUserUpdate extends Message<StaticHostUserUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 4;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<StaticHostUserUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.StaticHostUserUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "User", kind: "message", T: UserMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StaticHostUserUpdate {
    return new StaticHostUserUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StaticHostUserUpdate {
    return new StaticHostUserUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StaticHostUserUpdate {
    return new StaticHostUserUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: StaticHostUserUpdate | PlainMessage<StaticHostUserUpdate> | undefined, b: StaticHostUserUpdate | PlainMessage<StaticHostUserUpdate> | undefined): boolean {
    return proto3.util.equals(StaticHostUserUpdate, a, b);
  }
}

/**
 * StaticHostUserDelete is emitted when a static host user is deleted.
 *
 * @generated from message events.StaticHostUserDelete
 */
export class StaticHostUserDelete extends Message<StaticHostUserDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the deletion was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * ResourceMetadata is a common resource event metadata
   *
   * @generated from field: events.ResourceMetadata Resource = 3;
   */
  Resource?: ResourceMetadata;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 4;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 5;
   */
  Connection?: ConnectionMetadata;

  constructor(data?: PartialMessage<StaticHostUserDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.StaticHostUserDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "Resource", kind: "message", T: ResourceMetadata },
    { no: 4, name: "User", kind: "message", T: UserMetadata },
    { no: 5, name: "Connection", kind: "message", T: ConnectionMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StaticHostUserDelete {
    return new StaticHostUserDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StaticHostUserDelete {
    return new StaticHostUserDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StaticHostUserDelete {
    return new StaticHostUserDelete().fromJsonString(jsonString, options);
  }

  static equals(a: StaticHostUserDelete | PlainMessage<StaticHostUserDelete> | undefined, b: StaticHostUserDelete | PlainMessage<StaticHostUserDelete> | undefined): boolean {
    return proto3.util.equals(StaticHostUserDelete, a, b);
  }
}

/**
 * CrownJewelCreate is emitted when a Access Graph CrownJewel is created.
 *
 * @generated from message events.CrownJewelCreate
 */
export class CrownJewelCreate extends Message<CrownJewelCreate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 5;
   */
  resource?: ResourceMetadata;

  /**
   * CrownJewelQuery is the query used to track the crown jewel.
   *
   * @generated from field: string CrownJewelQuery = 6;
   */
  CrownJewelQuery = "";

  constructor(data?: PartialMessage<CrownJewelCreate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CrownJewelCreate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "resource", kind: "message", T: ResourceMetadata },
    { no: 6, name: "CrownJewelQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrownJewelCreate {
    return new CrownJewelCreate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrownJewelCreate {
    return new CrownJewelCreate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrownJewelCreate {
    return new CrownJewelCreate().fromJsonString(jsonString, options);
  }

  static equals(a: CrownJewelCreate | PlainMessage<CrownJewelCreate> | undefined, b: CrownJewelCreate | PlainMessage<CrownJewelCreate> | undefined): boolean {
    return proto3.util.equals(CrownJewelCreate, a, b);
  }
}

/**
 * CrownJewelUpdate is emitted when a Access Graph CrownJewel is updated.
 *
 * @generated from message events.CrownJewelUpdate
 */
export class CrownJewelUpdate extends Message<CrownJewelUpdate> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 5;
   */
  resource?: ResourceMetadata;

  /**
   * CurrentCrownJewelQuery is the current query used to track the crown jewel.
   *
   * @generated from field: string CurrentCrownJewelQuery = 6;
   */
  CurrentCrownJewelQuery = "";

  /**
   * UpdatedCrownJewelQuery is the new query used to track the crown jewel.
   *
   * @generated from field: string UpdatedCrownJewelQuery = 7;
   */
  UpdatedCrownJewelQuery = "";

  constructor(data?: PartialMessage<CrownJewelUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CrownJewelUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "resource", kind: "message", T: ResourceMetadata },
    { no: 6, name: "CurrentCrownJewelQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "UpdatedCrownJewelQuery", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrownJewelUpdate {
    return new CrownJewelUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrownJewelUpdate {
    return new CrownJewelUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrownJewelUpdate {
    return new CrownJewelUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: CrownJewelUpdate | PlainMessage<CrownJewelUpdate> | undefined, b: CrownJewelUpdate | PlainMessage<CrownJewelUpdate> | undefined): boolean {
    return proto3.util.equals(CrownJewelUpdate, a, b);
  }
}

/**
 * CrownJewelDelete is emitted when a Access Graph CrownJewel is deleted.
 *
 * @generated from message events.CrownJewelDelete
 */
export class CrownJewelDelete extends Message<CrownJewelDelete> {
  /**
   * Metadata is a common event metadata
   *
   * @generated from field: events.Metadata Metadata = 1;
   */
  Metadata?: Metadata;

  /**
   * Status indicates whether the update was successful.
   *
   * @generated from field: events.Status Status = 2;
   */
  Status?: Status;

  /**
   * User is a common user event metadata
   *
   * @generated from field: events.UserMetadata User = 3;
   */
  User?: UserMetadata;

  /**
   * ConnectionMetadata holds information about the connection
   *
   * @generated from field: events.ConnectionMetadata Connection = 4;
   */
  Connection?: ConnectionMetadata;

  /**
   * ResourceMetadata is a common resource event metadata.
   *
   * @generated from field: events.ResourceMetadata resource = 5;
   */
  resource?: ResourceMetadata;

  constructor(data?: PartialMessage<CrownJewelDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "events.CrownJewelDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Metadata", kind: "message", T: Metadata },
    { no: 2, name: "Status", kind: "message", T: Status },
    { no: 3, name: "User", kind: "message", T: UserMetadata },
    { no: 4, name: "Connection", kind: "message", T: ConnectionMetadata },
    { no: 5, name: "resource", kind: "message", T: ResourceMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrownJewelDelete {
    return new CrownJewelDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrownJewelDelete {
    return new CrownJewelDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrownJewelDelete {
    return new CrownJewelDelete().fromJsonString(jsonString, options);
  }

  static equals(a: CrownJewelDelete | PlainMessage<CrownJewelDelete> | undefined, b: CrownJewelDelete | PlainMessage<CrownJewelDelete> | undefined): boolean {
    return proto3.util.equals(CrownJewelDelete, a, b);
  }
}

