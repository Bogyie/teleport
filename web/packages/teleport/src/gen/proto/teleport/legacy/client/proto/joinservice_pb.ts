// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/legacy/client/proto/joinservice.proto (package proto, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { RegisterUsingTokenRequest } from "../../types/types_pb";
import { Certs } from "./certs_pb";

/**
 * TODO(nklaassen): Document me.
 *
 * @generated from message proto.RegisterUsingIAMMethodRequest
 */
export class RegisterUsingIAMMethodRequest extends Message<RegisterUsingIAMMethodRequest> {
  /**
   * RegisterUsingTokenRequest holds registration parameters common to all
   * join methods.
   *
   * @generated from field: types.RegisterUsingTokenRequest register_using_token_request = 1;
   */
  registerUsingTokenRequest?: RegisterUsingTokenRequest;

  /**
   * StsIdentityRequest is a signed HTTP request to the AWS
   * sts:GetCallerIdentity API endpoint used to prove the AWS identity of a
   * joining node. It must include the challenge string as a signed header.
   *
   * @generated from field: bytes sts_identity_request = 2;
   */
  stsIdentityRequest = new Uint8Array(0);

  constructor(data?: PartialMessage<RegisterUsingIAMMethodRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingIAMMethodRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "register_using_token_request", kind: "message", T: RegisterUsingTokenRequest },
    { no: 2, name: "sts_identity_request", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingIAMMethodRequest {
    return new RegisterUsingIAMMethodRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingIAMMethodRequest {
    return new RegisterUsingIAMMethodRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingIAMMethodRequest {
    return new RegisterUsingIAMMethodRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingIAMMethodRequest | PlainMessage<RegisterUsingIAMMethodRequest> | undefined, b: RegisterUsingIAMMethodRequest | PlainMessage<RegisterUsingIAMMethodRequest> | undefined): boolean {
    return proto3.util.equals(RegisterUsingIAMMethodRequest, a, b);
  }
}

/**
 * RegisterUsingIAMMethodResponse is a stream response and will contain either a
 * Challenge or signed Certs to join the cluster.
 *
 * @generated from message proto.RegisterUsingIAMMethodResponse
 */
export class RegisterUsingIAMMethodResponse extends Message<RegisterUsingIAMMethodResponse> {
  /**
   * Challenge is a crypto-random string that should be included in the signed
   * sts:GetCallerIdentity request.
   *
   * @generated from field: string challenge = 1;
   */
  challenge = "";

  /**
   * Certs is the returned signed certs.
   *
   * @generated from field: proto.Certs certs = 2;
   */
  certs?: Certs;

  constructor(data?: PartialMessage<RegisterUsingIAMMethodResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingIAMMethodResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenge", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "certs", kind: "message", T: Certs },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingIAMMethodResponse {
    return new RegisterUsingIAMMethodResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingIAMMethodResponse {
    return new RegisterUsingIAMMethodResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingIAMMethodResponse {
    return new RegisterUsingIAMMethodResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingIAMMethodResponse | PlainMessage<RegisterUsingIAMMethodResponse> | undefined, b: RegisterUsingIAMMethodResponse | PlainMessage<RegisterUsingIAMMethodResponse> | undefined): boolean {
    return proto3.util.equals(RegisterUsingIAMMethodResponse, a, b);
  }
}

/**
 * RegisterUsingAzureMethodRequest is the request for registration via the Azure
 * join method.
 *
 * @generated from message proto.RegisterUsingAzureMethodRequest
 */
export class RegisterUsingAzureMethodRequest extends Message<RegisterUsingAzureMethodRequest> {
  /**
   * RegisterUsingTokenRequest holds registration parameters common to all
   * join methods.
   *
   * @generated from field: types.RegisterUsingTokenRequest register_using_token_request = 1;
   */
  registerUsingTokenRequest?: RegisterUsingTokenRequest;

  /**
   * AttestedData is a signed JSON document from an Azure VM's attested data
   * metadata endpoint used to prove the identity of a joining node. It must
   * include the challenge string as the nonce.
   *
   * @generated from field: bytes attested_data = 2;
   */
  attestedData = new Uint8Array(0);

  /**
   * AccessToken is a JWT signed by Azure, used to prove the identity of a
   * joining node.
   *
   * @generated from field: string access_token = 3;
   */
  accessToken = "";

  constructor(data?: PartialMessage<RegisterUsingAzureMethodRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingAzureMethodRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "register_using_token_request", kind: "message", T: RegisterUsingTokenRequest },
    { no: 2, name: "attested_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingAzureMethodRequest {
    return new RegisterUsingAzureMethodRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingAzureMethodRequest {
    return new RegisterUsingAzureMethodRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingAzureMethodRequest {
    return new RegisterUsingAzureMethodRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingAzureMethodRequest | PlainMessage<RegisterUsingAzureMethodRequest> | undefined, b: RegisterUsingAzureMethodRequest | PlainMessage<RegisterUsingAzureMethodRequest> | undefined): boolean {
    return proto3.util.equals(RegisterUsingAzureMethodRequest, a, b);
  }
}

/**
 * RegisterUsingAzureMethodResponse is a stream response and will contain either
 * a Challenge or signed Certs to join the cluster.
 *
 * @generated from message proto.RegisterUsingAzureMethodResponse
 */
export class RegisterUsingAzureMethodResponse extends Message<RegisterUsingAzureMethodResponse> {
  /**
   * Challenge is a crypto-random string that should be included in the signed
   * attested data.
   *
   * @generated from field: string challenge = 1;
   */
  challenge = "";

  /**
   * Certs is the returned signed certs.
   *
   * @generated from field: proto.Certs certs = 2;
   */
  certs?: Certs;

  constructor(data?: PartialMessage<RegisterUsingAzureMethodResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingAzureMethodResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenge", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "certs", kind: "message", T: Certs },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingAzureMethodResponse {
    return new RegisterUsingAzureMethodResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingAzureMethodResponse {
    return new RegisterUsingAzureMethodResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingAzureMethodResponse {
    return new RegisterUsingAzureMethodResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingAzureMethodResponse | PlainMessage<RegisterUsingAzureMethodResponse> | undefined, b: RegisterUsingAzureMethodResponse | PlainMessage<RegisterUsingAzureMethodResponse> | undefined): boolean {
    return proto3.util.equals(RegisterUsingAzureMethodResponse, a, b);
  }
}

/**
 * The enrollment challenge response containing the solution returned by
 * calling the TPM2.0 `ActivateCredential` command on the client with the
 * parameters provided in `TPMEncryptedCredential`.
 *
 * @generated from message proto.RegisterUsingTPMMethodChallengeResponse
 */
export class RegisterUsingTPMMethodChallengeResponse extends Message<RegisterUsingTPMMethodChallengeResponse> {
  /**
   * The client's solution to `TPMEncryptedCredential` included in
   * `TPMEncryptedCredential` using ActivateCredential.
   *
   * @generated from field: bytes solution = 1;
   */
  solution = new Uint8Array(0);

  constructor(data?: PartialMessage<RegisterUsingTPMMethodChallengeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingTPMMethodChallengeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "solution", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingTPMMethodChallengeResponse {
    return new RegisterUsingTPMMethodChallengeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodChallengeResponse {
    return new RegisterUsingTPMMethodChallengeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodChallengeResponse {
    return new RegisterUsingTPMMethodChallengeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingTPMMethodChallengeResponse | PlainMessage<RegisterUsingTPMMethodChallengeResponse> | undefined, b: RegisterUsingTPMMethodChallengeResponse | PlainMessage<RegisterUsingTPMMethodChallengeResponse> | undefined): boolean {
    return proto3.util.equals(RegisterUsingTPMMethodChallengeResponse, a, b);
  }
}

/**
 * The initial payload sent from the client to the server during a TPM join
 * request.
 *
 * @generated from message proto.RegisterUsingTPMMethodInitialRequest
 */
export class RegisterUsingTPMMethodInitialRequest extends Message<RegisterUsingTPMMethodInitialRequest> {
  /**
   * Holds the registration parameters shared by all join methods.
   *
   * @generated from field: types.RegisterUsingTokenRequest join_request = 1;
   */
  joinRequest?: RegisterUsingTokenRequest;

  /**
   * @generated from oneof proto.RegisterUsingTPMMethodInitialRequest.ek
   */
  ek: {
    /**
     * The device's endorsement certificate in X509, ASN.1 DER form. This
     * certificate contains the public key of the endorsement key. This is
     * preferred to ek_key.
     *
     * @generated from field: bytes ek_cert = 2;
     */
    value: Uint8Array;
    case: "ekCert";
  } | {
    /**
     * The device's public endorsement key in PKIX, ASN.1 DER form. This is
     * used when a TPM does not contain any endorsement certificates.
     *
     * @generated from field: bytes ek_key = 3;
     */
    value: Uint8Array;
    case: "ekKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The attestation key and the parameters necessary to remotely verify it as
   * related to the endorsement key.
   *
   * @generated from field: proto.TPMAttestationParameters attestation_params = 4;
   */
  attestationParams?: TPMAttestationParameters;

  constructor(data?: PartialMessage<RegisterUsingTPMMethodInitialRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingTPMMethodInitialRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "join_request", kind: "message", T: RegisterUsingTokenRequest },
    { no: 2, name: "ek_cert", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "ek" },
    { no: 3, name: "ek_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "ek" },
    { no: 4, name: "attestation_params", kind: "message", T: TPMAttestationParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingTPMMethodInitialRequest {
    return new RegisterUsingTPMMethodInitialRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodInitialRequest {
    return new RegisterUsingTPMMethodInitialRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodInitialRequest {
    return new RegisterUsingTPMMethodInitialRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingTPMMethodInitialRequest | PlainMessage<RegisterUsingTPMMethodInitialRequest> | undefined, b: RegisterUsingTPMMethodInitialRequest | PlainMessage<RegisterUsingTPMMethodInitialRequest> | undefined): boolean {
    return proto3.util.equals(RegisterUsingTPMMethodInitialRequest, a, b);
  }
}

/**
 * RegisterUsingTPMMethodRequest is the streaming request type for the
 * RegisterUsingTPMMethod RPC.
 *
 * @generated from message proto.RegisterUsingTPMMethodRequest
 */
export class RegisterUsingTPMMethodRequest extends Message<RegisterUsingTPMMethodRequest> {
  /**
   * @generated from oneof proto.RegisterUsingTPMMethodRequest.payload
   */
  payload: {
    /**
     * Initial information sent from the client to the server.
     *
     * @generated from field: proto.RegisterUsingTPMMethodInitialRequest init = 1;
     */
    value: RegisterUsingTPMMethodInitialRequest;
    case: "init";
  } | {
    /**
     * The challenge response required to complete the TPM join process. This is
     * sent in response to the servers challenge.
     *
     * @generated from field: proto.RegisterUsingTPMMethodChallengeResponse challenge_response = 2;
     */
    value: RegisterUsingTPMMethodChallengeResponse;
    case: "challengeResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RegisterUsingTPMMethodRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingTPMMethodRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init", kind: "message", T: RegisterUsingTPMMethodInitialRequest, oneof: "payload" },
    { no: 2, name: "challenge_response", kind: "message", T: RegisterUsingTPMMethodChallengeResponse, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingTPMMethodRequest {
    return new RegisterUsingTPMMethodRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodRequest {
    return new RegisterUsingTPMMethodRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodRequest {
    return new RegisterUsingTPMMethodRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingTPMMethodRequest | PlainMessage<RegisterUsingTPMMethodRequest> | undefined, b: RegisterUsingTPMMethodRequest | PlainMessage<RegisterUsingTPMMethodRequest> | undefined): boolean {
    return proto3.util.equals(RegisterUsingTPMMethodRequest, a, b);
  }
}

/**
 * RegisterUsingTPMMethodResponse is the streaming response type for the
 * RegisterUsingTPMMethod RPC.
 *
 * @generated from message proto.RegisterUsingTPMMethodResponse
 */
export class RegisterUsingTPMMethodResponse extends Message<RegisterUsingTPMMethodResponse> {
  /**
   * @generated from oneof proto.RegisterUsingTPMMethodResponse.payload
   */
  payload: {
    /**
     * The challenge required to complete the TPM join process. This is sent to
     * the client in response to the initial request.
     *
     * @generated from field: proto.TPMEncryptedCredential challenge_request = 1;
     */
    value: TPMEncryptedCredential;
    case: "challengeRequest";
  } | {
    /**
     * The signed certificates resulting from the join process.
     *
     * @generated from field: proto.Certs certs = 2;
     */
    value: Certs;
    case: "certs";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RegisterUsingTPMMethodResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RegisterUsingTPMMethodResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenge_request", kind: "message", T: TPMEncryptedCredential, oneof: "payload" },
    { no: 2, name: "certs", kind: "message", T: Certs, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingTPMMethodResponse {
    return new RegisterUsingTPMMethodResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodResponse {
    return new RegisterUsingTPMMethodResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingTPMMethodResponse {
    return new RegisterUsingTPMMethodResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingTPMMethodResponse | PlainMessage<RegisterUsingTPMMethodResponse> | undefined, b: RegisterUsingTPMMethodResponse | PlainMessage<RegisterUsingTPMMethodResponse> | undefined): boolean {
    return proto3.util.equals(RegisterUsingTPMMethodResponse, a, b);
  }
}

/**
 * The attestation key and the parameters necessary to remotely verify it as
 * related to the endorsement key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
 * This message excludes the `UseTCSDActivationFormat` field from the link above
 * as it is TMP 1.x specific and always false.
 *
 * @generated from message proto.TPMAttestationParameters
 */
export class TPMAttestationParameters extends Message<TPMAttestationParameters> {
  /**
   * The encoded TPMT_PUBLIC structure containing the attestation public key
   * and signing parameters.
   *
   * @generated from field: bytes public = 1;
   */
  public = new Uint8Array(0);

  /**
   * The properties of the attestation key, encoded as a TPMS_CREATION_DATA
   * structure.
   *
   * @generated from field: bytes create_data = 2;
   */
  createData = new Uint8Array(0);

  /**
   * An assertion as to the details of the key, encoded as a TPMS_ATTEST
   * structure.
   *
   * @generated from field: bytes create_attestation = 3;
   */
  createAttestation = new Uint8Array(0);

  /**
   * A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
   *
   * @generated from field: bytes create_signature = 4;
   */
  createSignature = new Uint8Array(0);

  constructor(data?: PartialMessage<TPMAttestationParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TPMAttestationParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "public", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "create_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "create_attestation", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "create_signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromJsonString(jsonString, options);
  }

  static equals(a: TPMAttestationParameters | PlainMessage<TPMAttestationParameters> | undefined, b: TPMAttestationParameters | PlainMessage<TPMAttestationParameters> | undefined): boolean {
    return proto3.util.equals(TPMAttestationParameters, a, b);
  }
}

/**
 * These values are used by the TPM2.0 `ActivateCredential` command to produce
 * the solution which proves possession of the EK and AK.
 *
 * For a more in-depth description see:
 * - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
 * - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
 * - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
 * - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
 *
 * @generated from message proto.TPMEncryptedCredential
 */
export class TPMEncryptedCredential extends Message<TPMEncryptedCredential> {
  /**
   * The `credential_blob` parameter to be used with the `ActivateCredential`
   * command. This is used with the decrypted value of `secret` in a
   * cryptographic process to decrypt the solution.
   *
   * @generated from field: bytes credential_blob = 1;
   */
  credentialBlob = new Uint8Array(0);

  /**
   * The `secret` parameter to be used with `ActivateCredential`. This is a
   * seed which can be decrypted with the EK. The decrypted seed is then used
   * when decrypting `credential_blob`.
   *
   * @generated from field: bytes secret = 2;
   */
  secret = new Uint8Array(0);

  constructor(data?: PartialMessage<TPMEncryptedCredential>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TPMEncryptedCredential";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "credential_blob", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "secret", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromJsonString(jsonString, options);
  }

  static equals(a: TPMEncryptedCredential | PlainMessage<TPMEncryptedCredential> | undefined, b: TPMEncryptedCredential | PlainMessage<TPMEncryptedCredential> | undefined): boolean {
    return proto3.util.equals(TPMEncryptedCredential, a, b);
  }
}

