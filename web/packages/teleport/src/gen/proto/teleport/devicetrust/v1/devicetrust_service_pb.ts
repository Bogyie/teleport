// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/devicetrust/v1/devicetrust_service.proto (package teleport.devicetrust.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Device } from "./device_pb";
import { Status } from "../../../google/rpc/status_pb";
import { DeviceCollectedData } from "./device_collected_data_pb";
import { TPMPlatformParameters } from "./tpm_pb";
import { AuthenticateDeviceChallenge, AuthenticateDeviceChallengeResponse, TPMAuthenticateDeviceChallenge, TPMAuthenticateDeviceChallengeResponse } from "./authenticate_challenge_pb";
import { UserCertificates } from "./user_certificates_pb";
import { DeviceConfirmationToken } from "./device_confirmation_token_pb";
import { DeviceWebToken } from "./device_web_token_pb";
import { DeviceSource } from "./device_source_pb";

/**
 * DeviceView specifies which fields of returned devices should be present.
 *
 * @generated from enum teleport.devicetrust.v1.DeviceView
 */
export enum DeviceView {
  /**
   * @generated from enum value: DEVICE_VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * View for general device listings, like `tctl devices ls`.
   * Contains only basic information, such as IDs and enrollment status.
   *
   * @generated from enum value: DEVICE_VIEW_LIST = 1;
   */
  LIST = 1,

  /**
   * View for detailed device queries, like `tctl get devices`.
   * Presents a complete view of the device.
   *
   * @generated from enum value: DEVICE_VIEW_RESOURCE = 2;
   */
  RESOURCE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DeviceView)
proto3.util.setEnumType(DeviceView, "teleport.devicetrust.v1.DeviceView", [
  { no: 0, name: "DEVICE_VIEW_UNSPECIFIED" },
  { no: 1, name: "DEVICE_VIEW_LIST" },
  { no: 2, name: "DEVICE_VIEW_RESOURCE" },
]);

/**
 * Request for CreateDevice.
 *
 * @generated from message teleport.devicetrust.v1.CreateDeviceRequest
 */
export class CreateDeviceRequest extends Message<CreateDeviceRequest> {
  /**
   * Device to create.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * If true, a DeviceEnrollToken is created along with the Device.
   *
   * @generated from field: bool create_enroll_token = 2;
   */
  createEnrollToken = false;

  /**
   * If true, create the device as a Teleport resource, meaning that fields that
   * are usually considered read-only or system managed are copied as provided
   * to storage.
   * Prefer using non-resource creation semantics if possible.
   *
   * @generated from field: bool create_as_resource = 3;
   */
  createAsResource = false;

  /**
   * Custom expiration time for enrollment tokens.
   * A short (for humans) server default is used if unset.
   *
   * @generated from field: google.protobuf.Timestamp enroll_token_expire_time = 4;
   */
  enrollTokenExpireTime?: Timestamp;

  constructor(data?: PartialMessage<CreateDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.CreateDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device", kind: "message", T: Device },
    { no: 2, name: "create_enroll_token", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "create_as_resource", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "enroll_token_expire_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDeviceRequest {
    return new CreateDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDeviceRequest {
    return new CreateDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDeviceRequest {
    return new CreateDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDeviceRequest | PlainMessage<CreateDeviceRequest> | undefined, b: CreateDeviceRequest | PlainMessage<CreateDeviceRequest> | undefined): boolean {
    return proto3.util.equals(CreateDeviceRequest, a, b);
  }
}

/**
 * Request for UpdateDevice.
 *
 * @generated from message teleport.devicetrust.v1.UpdateDeviceRequest
 */
export class UpdateDeviceRequest extends Message<UpdateDeviceRequest> {
  /**
   * Device to update.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * Update mask applied to the resource.
   * Fields are masked according to their proto name.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.UpdateDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device", kind: "message", T: Device },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDeviceRequest {
    return new UpdateDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDeviceRequest {
    return new UpdateDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDeviceRequest {
    return new UpdateDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDeviceRequest | PlainMessage<UpdateDeviceRequest> | undefined, b: UpdateDeviceRequest | PlainMessage<UpdateDeviceRequest> | undefined): boolean {
    return proto3.util.equals(UpdateDeviceRequest, a, b);
  }
}

/**
 * Request for UpsertDevice.
 *
 * @generated from message teleport.devicetrust.v1.UpsertDeviceRequest
 */
export class UpsertDeviceRequest extends Message<UpsertDeviceRequest> {
  /**
   * Device to create or update.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * If true, creates the device using resource semantics.
   * Has no effect on device updates.
   * See create_as_resource in CreateDeviceRequest.
   *
   * @generated from field: bool create_as_resource = 2;
   */
  createAsResource = false;

  constructor(data?: PartialMessage<UpsertDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.UpsertDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device", kind: "message", T: Device },
    { no: 2, name: "create_as_resource", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertDeviceRequest {
    return new UpsertDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertDeviceRequest {
    return new UpsertDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertDeviceRequest {
    return new UpsertDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertDeviceRequest | PlainMessage<UpsertDeviceRequest> | undefined, b: UpsertDeviceRequest | PlainMessage<UpsertDeviceRequest> | undefined): boolean {
    return proto3.util.equals(UpsertDeviceRequest, a, b);
  }
}

/**
 * Request for DeleteDevice.
 *
 * @generated from message teleport.devicetrust.v1.DeleteDeviceRequest
 */
export class DeleteDeviceRequest extends Message<DeleteDeviceRequest> {
  /**
   * ID of the Device to delete.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = "";

  constructor(data?: PartialMessage<DeleteDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.DeleteDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDeviceRequest {
    return new DeleteDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDeviceRequest {
    return new DeleteDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDeviceRequest {
    return new DeleteDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDeviceRequest | PlainMessage<DeleteDeviceRequest> | undefined, b: DeleteDeviceRequest | PlainMessage<DeleteDeviceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDeviceRequest, a, b);
  }
}

/**
 * Request for FindDevices.
 *
 * Inspect the returned devices to determine whether the match was by ID or
 * asset tag.
 *
 * @generated from message teleport.devicetrust.v1.FindDevicesRequest
 */
export class FindDevicesRequest extends Message<FindDevicesRequest> {
  /**
   * Device ID or asset tag.
   *
   * @generated from field: string id_or_tag = 1;
   */
  idOrTag = "";

  constructor(data?: PartialMessage<FindDevicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.FindDevicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id_or_tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindDevicesRequest {
    return new FindDevicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindDevicesRequest {
    return new FindDevicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindDevicesRequest {
    return new FindDevicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FindDevicesRequest | PlainMessage<FindDevicesRequest> | undefined, b: FindDevicesRequest | PlainMessage<FindDevicesRequest> | undefined): boolean {
    return proto3.util.equals(FindDevicesRequest, a, b);
  }
}

/**
 * Response for FindDevices.
 *
 * @generated from message teleport.devicetrust.v1.FindDevicesResponse
 */
export class FindDevicesResponse extends Message<FindDevicesResponse> {
  /**
   * Devices that matched the search.
   * The number of resulting devices is expected to be low and may be
   * artificially capped by the server otherwise.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[] = [];

  constructor(data?: PartialMessage<FindDevicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.FindDevicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: Device, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindDevicesResponse {
    return new FindDevicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindDevicesResponse {
    return new FindDevicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindDevicesResponse {
    return new FindDevicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FindDevicesResponse | PlainMessage<FindDevicesResponse> | undefined, b: FindDevicesResponse | PlainMessage<FindDevicesResponse> | undefined): boolean {
    return proto3.util.equals(FindDevicesResponse, a, b);
  }
}

/**
 * Request for GetDevice.
 *
 * @generated from message teleport.devicetrust.v1.GetDeviceRequest
 */
export class GetDeviceRequest extends Message<GetDeviceRequest> {
  /**
   * ID of the device.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = "";

  constructor(data?: PartialMessage<GetDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.GetDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDeviceRequest {
    return new GetDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDeviceRequest {
    return new GetDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDeviceRequest {
    return new GetDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDeviceRequest | PlainMessage<GetDeviceRequest> | undefined, b: GetDeviceRequest | PlainMessage<GetDeviceRequest> | undefined): boolean {
    return proto3.util.equals(GetDeviceRequest, a, b);
  }
}

/**
 * Request for ListDevices.
 *
 * Follows the pagination semantics of
 * https://cloud.google.com/apis/design/standard_methods#list.
 *
 * @generated from message teleport.devicetrust.v1.ListDevicesRequest
 */
export class ListDevicesRequest extends Message<ListDevicesRequest> {
  /**
   * The maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * The next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Specifies which fields of the resource should be returned in the response.
   * Defaults to DEVICE_VIEW_LIST.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceView view = 3;
   */
  view = DeviceView.UNSPECIFIED;

  constructor(data?: PartialMessage<ListDevicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.ListDevicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "view", kind: "enum", T: proto3.getEnumType(DeviceView) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDevicesRequest {
    return new ListDevicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDevicesRequest {
    return new ListDevicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDevicesRequest {
    return new ListDevicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDevicesRequest | PlainMessage<ListDevicesRequest> | undefined, b: ListDevicesRequest | PlainMessage<ListDevicesRequest> | undefined): boolean {
    return proto3.util.equals(ListDevicesRequest, a, b);
  }
}

/**
 * Response for ListDevices.
 *
 * @generated from message teleport.devicetrust.v1.ListDevicesResponse
 */
export class ListDevicesResponse extends Message<ListDevicesResponse> {
  /**
   * Devices that matched the search.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[] = [];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListDevicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.ListDevicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: Device, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDevicesResponse {
    return new ListDevicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDevicesResponse {
    return new ListDevicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDevicesResponse {
    return new ListDevicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDevicesResponse | PlainMessage<ListDevicesResponse> | undefined, b: ListDevicesResponse | PlainMessage<ListDevicesResponse> | undefined): boolean {
    return proto3.util.equals(ListDevicesResponse, a, b);
  }
}

/**
 * Request for BulkCreateDevices.
 *
 * @generated from message teleport.devicetrust.v1.BulkCreateDevicesRequest
 */
export class BulkCreateDevicesRequest extends Message<BulkCreateDevicesRequest> {
  /**
   * Devices to create.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[] = [];

  /**
   * If true, create the device as a Teleport resource, meaning that fields that
   * are usually considered read-only or system managed are copied as provided
   * to storage.
   * Prefer using non-resource creation semantics if possible.
   *
   * @generated from field: bool create_as_resource = 2;
   */
  createAsResource = false;

  constructor(data?: PartialMessage<BulkCreateDevicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.BulkCreateDevicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: Device, repeated: true },
    { no: 2, name: "create_as_resource", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCreateDevicesRequest {
    return new BulkCreateDevicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCreateDevicesRequest {
    return new BulkCreateDevicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCreateDevicesRequest {
    return new BulkCreateDevicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCreateDevicesRequest | PlainMessage<BulkCreateDevicesRequest> | undefined, b: BulkCreateDevicesRequest | PlainMessage<BulkCreateDevicesRequest> | undefined): boolean {
    return proto3.util.equals(BulkCreateDevicesRequest, a, b);
  }
}

/**
 * Response for BulkCreateDevices.
 *
 * @generated from message teleport.devicetrust.v1.BulkCreateDevicesResponse
 */
export class BulkCreateDevicesResponse extends Message<BulkCreateDevicesResponse> {
  /**
   * Created devices or a failure reason.
   * Responses are sorted according to the request.
   *
   * @generated from field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
   */
  devices: DeviceOrStatus[] = [];

  constructor(data?: PartialMessage<BulkCreateDevicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.BulkCreateDevicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: DeviceOrStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCreateDevicesResponse {
    return new BulkCreateDevicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCreateDevicesResponse {
    return new BulkCreateDevicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCreateDevicesResponse {
    return new BulkCreateDevicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCreateDevicesResponse | PlainMessage<BulkCreateDevicesResponse> | undefined, b: BulkCreateDevicesResponse | PlainMessage<BulkCreateDevicesResponse> | undefined): boolean {
    return proto3.util.equals(BulkCreateDevicesResponse, a, b);
  }
}

/**
 * DeviceOrStatus contains either a device ID, in case of success, or a status
 * in case of failures.
 *
 * @generated from message teleport.devicetrust.v1.DeviceOrStatus
 */
export class DeviceOrStatus extends Message<DeviceOrStatus> {
  /**
   * Status of the operation.
   * May either be absent or contain the OK code for successes, at the
   * implementation's discretion.
   *
   * @generated from field: google.rpc.Status status = 1;
   */
  status?: Status;

  /**
   * ID of the created device.
   * Only present if the status is OK.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * If true the action attempted against the device was a delete, instead of a
   * create or update.
   *
   * @generated from field: bool deleted = 3;
   */
  deleted = false;

  constructor(data?: PartialMessage<DeviceOrStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.DeviceOrStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: Status },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deleted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceOrStatus {
    return new DeviceOrStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceOrStatus {
    return new DeviceOrStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceOrStatus {
    return new DeviceOrStatus().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceOrStatus | PlainMessage<DeviceOrStatus> | undefined, b: DeviceOrStatus | PlainMessage<DeviceOrStatus> | undefined): boolean {
    return proto3.util.equals(DeviceOrStatus, a, b);
  }
}

/**
 * Request for CreateDeviceEnrollToken.
 *
 * @generated from message teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest
 */
export class CreateDeviceEnrollTokenRequest extends Message<CreateDeviceEnrollTokenRequest> {
  /**
   * ID of the device.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId = "";

  /**
   * Device collected data.
   * Used to authorize issuance of device enrollment tokens for auto-enrollment.
   * Not required otherwise.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 2;
   */
  deviceData?: DeviceCollectedData;

  /**
   * Custom expiration time for enrollment tokens.
   * A short (for humans) server default is used if unset.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 3;
   */
  expireTime?: Timestamp;

  constructor(data?: PartialMessage<CreateDeviceEnrollTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "device_data", kind: "message", T: DeviceCollectedData },
    { no: 3, name: "expire_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDeviceEnrollTokenRequest {
    return new CreateDeviceEnrollTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDeviceEnrollTokenRequest {
    return new CreateDeviceEnrollTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDeviceEnrollTokenRequest {
    return new CreateDeviceEnrollTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDeviceEnrollTokenRequest | PlainMessage<CreateDeviceEnrollTokenRequest> | undefined, b: CreateDeviceEnrollTokenRequest | PlainMessage<CreateDeviceEnrollTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreateDeviceEnrollTokenRequest, a, b);
  }
}

/**
 * Request for EnrollDevice.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceRequest
 */
export class EnrollDeviceRequest extends Message<EnrollDeviceRequest> {
  /**
   * @generated from oneof teleport.devicetrust.v1.EnrollDeviceRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.EnrollDeviceInit init = 1;
     */
    value: EnrollDeviceInit;
    case: "init";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.MacOSEnrollChallengeResponse macos_challenge_response = 2;
     */
    value: MacOSEnrollChallengeResponse;
    case: "macosChallengeResponse";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMEnrollChallengeResponse tpm_challenge_response = 3;
     */
    value: TPMEnrollChallengeResponse;
    case: "tpmChallengeResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EnrollDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.EnrollDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init", kind: "message", T: EnrollDeviceInit, oneof: "payload" },
    { no: 2, name: "macos_challenge_response", kind: "message", T: MacOSEnrollChallengeResponse, oneof: "payload" },
    { no: 3, name: "tpm_challenge_response", kind: "message", T: TPMEnrollChallengeResponse, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollDeviceRequest {
    return new EnrollDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollDeviceRequest {
    return new EnrollDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollDeviceRequest {
    return new EnrollDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollDeviceRequest | PlainMessage<EnrollDeviceRequest> | undefined, b: EnrollDeviceRequest | PlainMessage<EnrollDeviceRequest> | undefined): boolean {
    return proto3.util.equals(EnrollDeviceRequest, a, b);
  }
}

/**
 * Response for EnrollDevice.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceResponse
 */
export class EnrollDeviceResponse extends Message<EnrollDeviceResponse> {
  /**
   * @generated from oneof teleport.devicetrust.v1.EnrollDeviceResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.EnrollDeviceSuccess success = 1;
     */
    value: EnrollDeviceSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.MacOSEnrollChallenge macos_challenge = 2;
     */
    value: MacOSEnrollChallenge;
    case: "macosChallenge";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMEnrollChallenge tpm_challenge = 3;
     */
    value: TPMEnrollChallenge;
    case: "tpmChallenge";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EnrollDeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.EnrollDeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "message", T: EnrollDeviceSuccess, oneof: "payload" },
    { no: 2, name: "macos_challenge", kind: "message", T: MacOSEnrollChallenge, oneof: "payload" },
    { no: 3, name: "tpm_challenge", kind: "message", T: TPMEnrollChallenge, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollDeviceResponse {
    return new EnrollDeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollDeviceResponse {
    return new EnrollDeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollDeviceResponse {
    return new EnrollDeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollDeviceResponse | PlainMessage<EnrollDeviceResponse> | undefined, b: EnrollDeviceResponse | PlainMessage<EnrollDeviceResponse> | undefined): boolean {
    return proto3.util.equals(EnrollDeviceResponse, a, b);
  }
}

/**
 * EnrollDeviceInit initiates the enrollment ceremony.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceInit
 */
export class EnrollDeviceInit extends Message<EnrollDeviceInit> {
  /**
   * Device enrollment token.
   * See CreateDevice or CreateDeviceEnrollToken.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  /**
   * ID of the device credential.
   *
   * @generated from field: string credential_id = 2;
   */
  credentialId = "";

  /**
   * Device collected data.
   * Matched against the device registration information and any previously
   * collected data.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
   */
  deviceData?: DeviceCollectedData;

  /**
   * Payload for macOS-specific data.
   *
   * @generated from field: teleport.devicetrust.v1.MacOSEnrollPayload macos = 4;
   */
  macos?: MacOSEnrollPayload;

  /**
   * Payload for TPM-specific data. Used for Windows/Linux.
   *
   * @generated from field: teleport.devicetrust.v1.TPMEnrollPayload tpm = 5;
   */
  tpm?: TPMEnrollPayload;

  constructor(data?: PartialMessage<EnrollDeviceInit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.EnrollDeviceInit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "credential_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "device_data", kind: "message", T: DeviceCollectedData },
    { no: 4, name: "macos", kind: "message", T: MacOSEnrollPayload },
    { no: 5, name: "tpm", kind: "message", T: TPMEnrollPayload },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollDeviceInit {
    return new EnrollDeviceInit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollDeviceInit {
    return new EnrollDeviceInit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollDeviceInit {
    return new EnrollDeviceInit().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollDeviceInit | PlainMessage<EnrollDeviceInit> | undefined, b: EnrollDeviceInit | PlainMessage<EnrollDeviceInit> | undefined): boolean {
    return proto3.util.equals(EnrollDeviceInit, a, b);
  }
}

/**
 * EnrollDeviceSuccess marks a successful device enrollment ceremony.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceSuccess
 */
export class EnrollDeviceSuccess extends Message<EnrollDeviceSuccess> {
  /**
   * The enrolled device.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  constructor(data?: PartialMessage<EnrollDeviceSuccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.EnrollDeviceSuccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device", kind: "message", T: Device },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollDeviceSuccess {
    return new EnrollDeviceSuccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollDeviceSuccess {
    return new EnrollDeviceSuccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollDeviceSuccess {
    return new EnrollDeviceSuccess().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollDeviceSuccess | PlainMessage<EnrollDeviceSuccess> | undefined, b: EnrollDeviceSuccess | PlainMessage<EnrollDeviceSuccess> | undefined): boolean {
    return proto3.util.equals(EnrollDeviceSuccess, a, b);
  }
}

/**
 * MacOSEnrollPayload is the macOS-specific enrollment payload.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollPayload
 */
export class MacOSEnrollPayload extends Message<MacOSEnrollPayload> {
  /**
   * Device public key marshaled as a PKIX, ASN.1 DER.
   *
   * @generated from field: bytes public_key_der = 2;
   */
  publicKeyDer = new Uint8Array(0);

  constructor(data?: PartialMessage<MacOSEnrollPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.MacOSEnrollPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "public_key_der", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MacOSEnrollPayload {
    return new MacOSEnrollPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MacOSEnrollPayload {
    return new MacOSEnrollPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MacOSEnrollPayload {
    return new MacOSEnrollPayload().fromJsonString(jsonString, options);
  }

  static equals(a: MacOSEnrollPayload | PlainMessage<MacOSEnrollPayload> | undefined, b: MacOSEnrollPayload | PlainMessage<MacOSEnrollPayload> | undefined): boolean {
    return proto3.util.equals(MacOSEnrollPayload, a, b);
  }
}

/**
 * MacOSEnrollChallenge is a macOS enrollment challenge.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollChallenge
 */
export class MacOSEnrollChallenge extends Message<MacOSEnrollChallenge> {
  /**
   * Randomly-generated, opaque challenge to be signed using the device key.
   *
   * @generated from field: bytes challenge = 1;
   */
  challenge = new Uint8Array(0);

  constructor(data?: PartialMessage<MacOSEnrollChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.MacOSEnrollChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenge", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MacOSEnrollChallenge {
    return new MacOSEnrollChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MacOSEnrollChallenge {
    return new MacOSEnrollChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MacOSEnrollChallenge {
    return new MacOSEnrollChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MacOSEnrollChallenge | PlainMessage<MacOSEnrollChallenge> | undefined, b: MacOSEnrollChallenge | PlainMessage<MacOSEnrollChallenge> | undefined): boolean {
    return proto3.util.equals(MacOSEnrollChallenge, a, b);
  }
}

/**
 * MacOSEnrollChallengeResponse is a macOS enrollment challenge response.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollChallengeResponse
 */
export class MacOSEnrollChallengeResponse extends Message<MacOSEnrollChallengeResponse> {
  /**
   * Signature over the challenge, using the device key.
   *
   * @generated from field: bytes signature = 2;
   */
  signature = new Uint8Array(0);

  constructor(data?: PartialMessage<MacOSEnrollChallengeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.MacOSEnrollChallengeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MacOSEnrollChallengeResponse {
    return new MacOSEnrollChallengeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MacOSEnrollChallengeResponse {
    return new MacOSEnrollChallengeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MacOSEnrollChallengeResponse {
    return new MacOSEnrollChallengeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MacOSEnrollChallengeResponse | PlainMessage<MacOSEnrollChallengeResponse> | undefined, b: MacOSEnrollChallengeResponse | PlainMessage<MacOSEnrollChallengeResponse> | undefined): boolean {
    return proto3.util.equals(MacOSEnrollChallengeResponse, a, b);
  }
}

/**
 * The payload containing TPM specific information required on device
 * enrollment.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollPayload
 */
export class TPMEnrollPayload extends Message<TPMEnrollPayload> {
  /**
   * @generated from oneof teleport.devicetrust.v1.TPMEnrollPayload.ek
   */
  ek: {
    /**
     * The device's endorsement certificate in X509, ASN.1 DER form. This
     * certificate contains the public key of the endorsement key. This is
     * preferred to ek_key.
     *
     * @generated from field: bytes ek_cert = 1;
     */
    value: Uint8Array;
    case: "ekCert";
  } | {
    /**
     * The device's public endorsement key in PKIX, ASN.1 DER form. This is
     * used when a TPM does not contain any endorsement certificates.
     *
     * @generated from field: bytes ek_key = 2;
     */
    value: Uint8Array;
    case: "ekKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The attestation key and the parameters necessary to remotely verify it as
   * related to the endorsement key.
   *
   * @generated from field: teleport.devicetrust.v1.TPMAttestationParameters attestation_parameters = 3;
   */
  attestationParameters?: TPMAttestationParameters;

  constructor(data?: PartialMessage<TPMEnrollPayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.TPMEnrollPayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ek_cert", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "ek" },
    { no: 2, name: "ek_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "ek" },
    { no: 3, name: "attestation_parameters", kind: "message", T: TPMAttestationParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMEnrollPayload {
    return new TPMEnrollPayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMEnrollPayload {
    return new TPMEnrollPayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMEnrollPayload {
    return new TPMEnrollPayload().fromJsonString(jsonString, options);
  }

  static equals(a: TPMEnrollPayload | PlainMessage<TPMEnrollPayload> | undefined, b: TPMEnrollPayload | PlainMessage<TPMEnrollPayload> | undefined): boolean {
    return proto3.util.equals(TPMEnrollPayload, a, b);
  }
}

/**
 * The attestation key and the parameters necessary to remotely verify it as
 * related to the endorsement key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
 * This message excludes the `UseTCSDActivationFormat` field from the link above
 * as it is TMP 1.x specific and always false.
 *
 * @generated from message teleport.devicetrust.v1.TPMAttestationParameters
 */
export class TPMAttestationParameters extends Message<TPMAttestationParameters> {
  /**
   * The encoded TPMT_PUBLIC structure containing the attestation public key
   * and signing parameters.
   *
   * @generated from field: bytes public = 1;
   */
  public = new Uint8Array(0);

  /**
   * The properties of the attestation key, encoded as a TPMS_CREATION_DATA
   * structure.
   *
   * @generated from field: bytes create_data = 2;
   */
  createData = new Uint8Array(0);

  /**
   * An assertion as to the details of the key, encoded as a TPMS_ATTEST
   * structure.
   *
   * @generated from field: bytes create_attestation = 3;
   */
  createAttestation = new Uint8Array(0);

  /**
   * A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
   *
   * @generated from field: bytes create_signature = 4;
   */
  createSignature = new Uint8Array(0);

  constructor(data?: PartialMessage<TPMAttestationParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.TPMAttestationParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "public", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "create_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "create_attestation", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "create_signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMAttestationParameters {
    return new TPMAttestationParameters().fromJsonString(jsonString, options);
  }

  static equals(a: TPMAttestationParameters | PlainMessage<TPMAttestationParameters> | undefined, b: TPMAttestationParameters | PlainMessage<TPMAttestationParameters> | undefined): boolean {
    return proto3.util.equals(TPMAttestationParameters, a, b);
  }
}

/**
 * The challenge sent to the client by the server during enrollment.
 * The challenge involves two parts:
 * - Solving an encrypted credential with `ActivateCredential`.
 * - Producing a platform attestation using the provided nonce.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollChallenge
 */
export class TPMEnrollChallenge extends Message<TPMEnrollChallenge> {
  /**
   * The encrypted credential for the client to prove possession of the EK and
   * AK.
   *
   * @generated from field: teleport.devicetrust.v1.TPMEncryptedCredential encrypted_credential = 1;
   */
  encryptedCredential?: TPMEncryptedCredential;

  /**
   * The nonce to use when producing the quotes over the PCRs with the TPM
   * during the platform attestation.
   *
   * @generated from field: bytes attestation_nonce = 2;
   */
  attestationNonce = new Uint8Array(0);

  constructor(data?: PartialMessage<TPMEnrollChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.TPMEnrollChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_credential", kind: "message", T: TPMEncryptedCredential },
    { no: 2, name: "attestation_nonce", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMEnrollChallenge {
    return new TPMEnrollChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMEnrollChallenge {
    return new TPMEnrollChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMEnrollChallenge {
    return new TPMEnrollChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: TPMEnrollChallenge | PlainMessage<TPMEnrollChallenge> | undefined, b: TPMEnrollChallenge | PlainMessage<TPMEnrollChallenge> | undefined): boolean {
    return proto3.util.equals(TPMEnrollChallenge, a, b);
  }
}

/**
 * These values are used by the TPM2.0 `ActivateCredential` command to produce
 * the solution which proves possession of the EK and AK.
 *
 * For a more in-depth description see:
 * - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
 * - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
 * - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
 * - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
 *
 * @generated from message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export class TPMEncryptedCredential extends Message<TPMEncryptedCredential> {
  /**
   * The `credential_blob` parameter to be used with the `ActivateCredential`
   * command. This is used with the decrypted value of `secret` in a
   * cryptographic process to decrypt the solution.
   *
   * @generated from field: bytes credential_blob = 1;
   */
  credentialBlob = new Uint8Array(0);

  /**
   * The `secret` parameter to be used with `ActivateCredential`. This is a
   * seed which can be decrypted with the EK. The decrypted seed is then used
   * when decrypting `credential_blob`.
   *
   * @generated from field: bytes secret = 2;
   */
  secret = new Uint8Array(0);

  constructor(data?: PartialMessage<TPMEncryptedCredential>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.TPMEncryptedCredential";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "credential_blob", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "secret", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMEncryptedCredential {
    return new TPMEncryptedCredential().fromJsonString(jsonString, options);
  }

  static equals(a: TPMEncryptedCredential | PlainMessage<TPMEncryptedCredential> | undefined, b: TPMEncryptedCredential | PlainMessage<TPMEncryptedCredential> | undefined): boolean {
    return proto3.util.equals(TPMEncryptedCredential, a, b);
  }
}

/**
 * The enrollment challenge response containing the solution returned by
 * calling the TPM2.0 `ActivateCredential` command on the client with the
 * parameters provided in `TPMEnrollChallenge`.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollChallengeResponse
 */
export class TPMEnrollChallengeResponse extends Message<TPMEnrollChallengeResponse> {
  /**
   * The client's solution to `TPMEncryptedCredential` included in
   * `TPMEnrollChallenge` using ActivateCredential.
   *
   * @generated from field: bytes solution = 1;
   */
  solution = new Uint8Array(0);

  /**
   * The result of the client's platform attestation with the nonce provided
   * in `TPMEnrollChallenge`.
   *
   * @generated from field: teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2;
   */
  platformParameters?: TPMPlatformParameters;

  constructor(data?: PartialMessage<TPMEnrollChallengeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.TPMEnrollChallengeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "solution", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "platform_parameters", kind: "message", T: TPMPlatformParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TPMEnrollChallengeResponse {
    return new TPMEnrollChallengeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TPMEnrollChallengeResponse {
    return new TPMEnrollChallengeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TPMEnrollChallengeResponse {
    return new TPMEnrollChallengeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TPMEnrollChallengeResponse | PlainMessage<TPMEnrollChallengeResponse> | undefined, b: TPMEnrollChallengeResponse | PlainMessage<TPMEnrollChallengeResponse> | undefined): boolean {
    return proto3.util.equals(TPMEnrollChallengeResponse, a, b);
  }
}

/**
 * Request for AuthenticateDevice.
 *
 * Authentication ceremony flow:
 * -> AuthenticateDeviceInit (client)
 * <- AuthenticateDeviceChallenge (server)
 * -> AuthenticateDeviceChallengeResponse
 * <- UserCertificates (regular authn) or ConfirmationToken (web authn)
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceRequest
 */
export class AuthenticateDeviceRequest extends Message<AuthenticateDeviceRequest> {
  /**
   * @generated from oneof teleport.devicetrust.v1.AuthenticateDeviceRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceInit init = 1;
     */
    value: AuthenticateDeviceInit;
    case: "init";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2;
     */
    value: AuthenticateDeviceChallengeResponse;
    case: "challengeResponse";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3;
     */
    value: TPMAuthenticateDeviceChallengeResponse;
    case: "tpmChallengeResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuthenticateDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.AuthenticateDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init", kind: "message", T: AuthenticateDeviceInit, oneof: "payload" },
    { no: 2, name: "challenge_response", kind: "message", T: AuthenticateDeviceChallengeResponse, oneof: "payload" },
    { no: 3, name: "tpm_challenge_response", kind: "message", T: TPMAuthenticateDeviceChallengeResponse, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateDeviceRequest {
    return new AuthenticateDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateDeviceRequest {
    return new AuthenticateDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateDeviceRequest {
    return new AuthenticateDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateDeviceRequest | PlainMessage<AuthenticateDeviceRequest> | undefined, b: AuthenticateDeviceRequest | PlainMessage<AuthenticateDeviceRequest> | undefined): boolean {
    return proto3.util.equals(AuthenticateDeviceRequest, a, b);
  }
}

/**
 * Response for AuthenticateDevice.
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceResponse
 */
export class AuthenticateDeviceResponse extends Message<AuthenticateDeviceResponse> {
  /**
   * @generated from oneof teleport.devicetrust.v1.AuthenticateDeviceResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1;
     */
    value: AuthenticateDeviceChallenge;
    case: "challenge";
  } | {
    /**
     * User certificates are returned as the result of a successful device
     * authentication attempt ("regular" or non-web authentication).
     *
     * @generated from field: teleport.devicetrust.v1.UserCertificates user_certificates = 2;
     */
    value: UserCertificates;
    case: "userCertificates";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 3;
     */
    value: TPMAuthenticateDeviceChallenge;
    case: "tpmChallenge";
  } | {
    /**
     * A confirmation token is returned as the result of a successful device web
     * authentication.
     *
     * See AuthenticateDeviceInit.device_web_token.
     *
     * @generated from field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 4;
     */
    value: DeviceConfirmationToken;
    case: "confirmationToken";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuthenticateDeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.AuthenticateDeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenge", kind: "message", T: AuthenticateDeviceChallenge, oneof: "payload" },
    { no: 2, name: "user_certificates", kind: "message", T: UserCertificates, oneof: "payload" },
    { no: 3, name: "tpm_challenge", kind: "message", T: TPMAuthenticateDeviceChallenge, oneof: "payload" },
    { no: 4, name: "confirmation_token", kind: "message", T: DeviceConfirmationToken, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateDeviceResponse {
    return new AuthenticateDeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateDeviceResponse {
    return new AuthenticateDeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateDeviceResponse {
    return new AuthenticateDeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateDeviceResponse | PlainMessage<AuthenticateDeviceResponse> | undefined, b: AuthenticateDeviceResponse | PlainMessage<AuthenticateDeviceResponse> | undefined): boolean {
    return proto3.util.equals(AuthenticateDeviceResponse, a, b);
  }
}

/**
 * AuthenticateDeviceInit initiates the device authentication ceremony.
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceInit
 */
export class AuthenticateDeviceInit extends Message<AuthenticateDeviceInit> {
  /**
   * In-band user certificates to augment with device extensions.
   * - The x509 certificate is acquired from the mTLS connection, thus the
   *   in-band certificate is ignored.
   * - All certificates must be valid and issued by the Teleport CA.
   * - TLS and SSH certificates must match (same Teleport user, plus whatever
   *   additional checks the backend sees fit).
   * - TLS and SSH certificates must either have matching public keys, or
   *   (TPM)AuthenticateDeviceChallengeResponse.SshSignature must be a valid
   *   signature over the challenge by the SSH private key.
   * - Augmented certificates have the same expiration as the original
   *   certificates.
   *
   * @generated from field: teleport.devicetrust.v1.UserCertificates user_certificates = 1;
   */
  userCertificates?: UserCertificates;

  /**
   * ID of the enrolled device credential.
   *
   * @generated from field: string credential_id = 2;
   */
  credentialId = "";

  /**
   * Device collected data.
   * Matched against the device registration information and any previously
   * collected data.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
   */
  deviceData?: DeviceCollectedData;

  /**
   * If present, on-behalf-of device authentication is performed.
   * The user_certificates input field is ignored and no certificate data is
   * returned to the caller, instead a confirmation_token is returned in
   * the last step.
   *
   * See ConfirmDeviceWebAuthentication.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceWebToken device_web_token = 4;
   */
  deviceWebToken?: DeviceWebToken;

  constructor(data?: PartialMessage<AuthenticateDeviceInit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.AuthenticateDeviceInit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_certificates", kind: "message", T: UserCertificates },
    { no: 2, name: "credential_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "device_data", kind: "message", T: DeviceCollectedData },
    { no: 4, name: "device_web_token", kind: "message", T: DeviceWebToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateDeviceInit {
    return new AuthenticateDeviceInit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateDeviceInit {
    return new AuthenticateDeviceInit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateDeviceInit {
    return new AuthenticateDeviceInit().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateDeviceInit | PlainMessage<AuthenticateDeviceInit> | undefined, b: AuthenticateDeviceInit | PlainMessage<AuthenticateDeviceInit> | undefined): boolean {
    return proto3.util.equals(AuthenticateDeviceInit, a, b);
  }
}

/**
 * Request for ConfirmDeviceWebAuthentication.
 *
 * @generated from message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest
 */
export class ConfirmDeviceWebAuthenticationRequest extends Message<ConfirmDeviceWebAuthenticationRequest> {
  /**
   * Confirmation token to be spent.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1;
   */
  confirmationToken?: DeviceConfirmationToken;

  /**
   * Web Session identifier of the session that started this request, via
   * Teleport Proxy.
   *
   * For the request to be successful the Web Session must match the session
   * that started the authentication attempt.
   *
   * @generated from field: string current_web_session_id = 2;
   */
  currentWebSessionId = "";

  constructor(data?: PartialMessage<ConfirmDeviceWebAuthenticationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirmation_token", kind: "message", T: DeviceConfirmationToken },
    { no: 2, name: "current_web_session_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfirmDeviceWebAuthenticationRequest {
    return new ConfirmDeviceWebAuthenticationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfirmDeviceWebAuthenticationRequest {
    return new ConfirmDeviceWebAuthenticationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfirmDeviceWebAuthenticationRequest {
    return new ConfirmDeviceWebAuthenticationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ConfirmDeviceWebAuthenticationRequest | PlainMessage<ConfirmDeviceWebAuthenticationRequest> | undefined, b: ConfirmDeviceWebAuthenticationRequest | PlainMessage<ConfirmDeviceWebAuthenticationRequest> | undefined): boolean {
    return proto3.util.equals(ConfirmDeviceWebAuthenticationRequest, a, b);
  }
}

/**
 * Response for ConfirmDeviceWebAuthentication.
 *
 * @generated from message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse
 */
export class ConfirmDeviceWebAuthenticationResponse extends Message<ConfirmDeviceWebAuthenticationResponse> {
  constructor(data?: PartialMessage<ConfirmDeviceWebAuthenticationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfirmDeviceWebAuthenticationResponse {
    return new ConfirmDeviceWebAuthenticationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfirmDeviceWebAuthenticationResponse {
    return new ConfirmDeviceWebAuthenticationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfirmDeviceWebAuthenticationResponse {
    return new ConfirmDeviceWebAuthenticationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ConfirmDeviceWebAuthenticationResponse | PlainMessage<ConfirmDeviceWebAuthenticationResponse> | undefined, b: ConfirmDeviceWebAuthenticationResponse | PlainMessage<ConfirmDeviceWebAuthenticationResponse> | undefined): boolean {
    return proto3.util.equals(ConfirmDeviceWebAuthenticationResponse, a, b);
  }
}

/**
 * Request for SyncInventory.
 *
 * A typical message sequence is as follows:
 * (-> means client-to-server, <- means server-to-client)
 * -> SyncInventoryStart
 * <- SyncInventoryAck
 * (loop)
 * -> SyncInventoryDevices (add/remove devices)
 * <- SyncInventoryResult
 * (end loop)
 * -> SyncInventoryEnd
 * (loop until server closes the stream, zero or more times)
 * <- SyncInventoryMissingDevices
 * -> SyncInventoryDevices (removals only)
 * <- SyncInventoryResult
 * (end loop)
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryRequest
 */
export class SyncInventoryRequest extends Message<SyncInventoryRequest> {
  /**
   * @generated from oneof teleport.devicetrust.v1.SyncInventoryRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryStart start = 1;
     */
    value: SyncInventoryStart;
    case: "start";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryEnd end = 2;
     */
    value: SyncInventoryEnd;
    case: "end";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_upsert = 3;
     */
    value: SyncInventoryDevices;
    case: "devicesToUpsert";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_remove = 4;
     */
    value: SyncInventoryDevices;
    case: "devicesToRemove";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SyncInventoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: SyncInventoryStart, oneof: "payload" },
    { no: 2, name: "end", kind: "message", T: SyncInventoryEnd, oneof: "payload" },
    { no: 3, name: "devices_to_upsert", kind: "message", T: SyncInventoryDevices, oneof: "payload" },
    { no: 4, name: "devices_to_remove", kind: "message", T: SyncInventoryDevices, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryRequest {
    return new SyncInventoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryRequest {
    return new SyncInventoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryRequest {
    return new SyncInventoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryRequest | PlainMessage<SyncInventoryRequest> | undefined, b: SyncInventoryRequest | PlainMessage<SyncInventoryRequest> | undefined): boolean {
    return proto3.util.equals(SyncInventoryRequest, a, b);
  }
}

/**
 * Response for SyncInventory.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryResponse
 */
export class SyncInventoryResponse extends Message<SyncInventoryResponse> {
  /**
   * @generated from oneof teleport.devicetrust.v1.SyncInventoryResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryAck ack = 1;
     */
    value: SyncInventoryAck;
    case: "ack";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryResult result = 2;
     */
    value: SyncInventoryResult;
    case: "result";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryMissingDevices missing_devices = 3;
     */
    value: SyncInventoryMissingDevices;
    case: "missingDevices";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SyncInventoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ack", kind: "message", T: SyncInventoryAck, oneof: "payload" },
    { no: 2, name: "result", kind: "message", T: SyncInventoryResult, oneof: "payload" },
    { no: 3, name: "missing_devices", kind: "message", T: SyncInventoryMissingDevices, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryResponse {
    return new SyncInventoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryResponse {
    return new SyncInventoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryResponse {
    return new SyncInventoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryResponse | PlainMessage<SyncInventoryResponse> | undefined, b: SyncInventoryResponse | PlainMessage<SyncInventoryResponse> | undefined): boolean {
    return proto3.util.equals(SyncInventoryResponse, a, b);
  }
}

/**
 * SyncInventoryStart starts the inventory sync.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryStart
 */
export class SyncInventoryStart extends Message<SyncInventoryStart> {
  /**
   * Source of the inventory sync.
   * Used for all devices. The `source` field in individual devices is ignored
   * by this RPC.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceSource source = 1;
   */
  source?: DeviceSource;

  /**
   * If true, the server keeps track of the devices upserted during the sync.
   * After receiving the [SyncInventoryEnd] message, the server informs the
   * client of all devices that are present in storage but not observed in the
   * upserts.
   * See [SyncInventoryRequest] and [SyncInventoryMissingDevices] for details.
   *
   * @generated from field: bool track_missing_devices = 4;
   */
  trackMissingDevices = false;

  constructor(data?: PartialMessage<SyncInventoryStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: DeviceSource },
    { no: 4, name: "track_missing_devices", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryStart {
    return new SyncInventoryStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryStart {
    return new SyncInventoryStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryStart {
    return new SyncInventoryStart().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryStart | PlainMessage<SyncInventoryStart> | undefined, b: SyncInventoryStart | PlainMessage<SyncInventoryStart> | undefined): boolean {
    return proto3.util.equals(SyncInventoryStart, a, b);
  }
}

/**
 * SyncInventoryEnd ends the inventory sync, signaling that no more
 * SyncInventoryDevices messages will be sent by the client.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryEnd
 */
export class SyncInventoryEnd extends Message<SyncInventoryEnd> {
  constructor(data?: PartialMessage<SyncInventoryEnd>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryEnd";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryEnd {
    return new SyncInventoryEnd().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryEnd {
    return new SyncInventoryEnd().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryEnd {
    return new SyncInventoryEnd().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryEnd | PlainMessage<SyncInventoryEnd> | undefined, b: SyncInventoryEnd | PlainMessage<SyncInventoryEnd> | undefined): boolean {
    return proto3.util.equals(SyncInventoryEnd, a, b);
  }
}

/**
 * SyncInventoryDevices transports devices to add/update/remove.
 * Removals only need identifying fields to be set.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryDevices
 */
export class SyncInventoryDevices extends Message<SyncInventoryDevices> {
  /**
   * Devices to sync.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[] = [];

  constructor(data?: PartialMessage<SyncInventoryDevices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryDevices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: Device, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryDevices {
    return new SyncInventoryDevices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryDevices {
    return new SyncInventoryDevices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryDevices {
    return new SyncInventoryDevices().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryDevices | PlainMessage<SyncInventoryDevices> | undefined, b: SyncInventoryDevices | PlainMessage<SyncInventoryDevices> | undefined): boolean {
    return proto3.util.equals(SyncInventoryDevices, a, b);
  }
}

/**
 * SyncInventoryAck is used to confirm successful processing of messages that
 * lack a more specific response.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryAck
 */
export class SyncInventoryAck extends Message<SyncInventoryAck> {
  constructor(data?: PartialMessage<SyncInventoryAck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryAck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryAck {
    return new SyncInventoryAck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryAck {
    return new SyncInventoryAck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryAck {
    return new SyncInventoryAck().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryAck | PlainMessage<SyncInventoryAck> | undefined, b: SyncInventoryAck | PlainMessage<SyncInventoryAck> | undefined): boolean {
    return proto3.util.equals(SyncInventoryAck, a, b);
  }
}

/**
 * SyncInventoryResult is the response for SyncInventoryDevices or
 * SyncInventoryEnd
 * It lists all synced/deleted devices.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryResult
 */
export class SyncInventoryResult extends Message<SyncInventoryResult> {
  /**
   * Devices modified, in the same order as the input when applicable.
   *
   * @generated from field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
   */
  devices: DeviceOrStatus[] = [];

  constructor(data?: PartialMessage<SyncInventoryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: DeviceOrStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryResult {
    return new SyncInventoryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryResult {
    return new SyncInventoryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryResult {
    return new SyncInventoryResult().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryResult | PlainMessage<SyncInventoryResult> | undefined, b: SyncInventoryResult | PlainMessage<SyncInventoryResult> | undefined): boolean {
    return proto3.util.equals(SyncInventoryResult, a, b);
  }
}

/**
 * SyncInventoryMissingDevices informs the sync client of all stored devices
 * that were not observed in upserts during the sync.
 *
 * Requires `track_missing_devices` to be set in the [SyncInventoryStart]
 * message.
 *
 * The client must follow up with a [SyncInventoryDevices] message, including
 * any devices to be deleted.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryMissingDevices
 */
export class SyncInventoryMissingDevices extends Message<SyncInventoryMissingDevices> {
  /**
   * Devices missing from the client-side sync.
   * Guaranteed to have the following fields: id, os_type, asset_tag and
   * profile.external_id.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[] = [];

  constructor(data?: PartialMessage<SyncInventoryMissingDevices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.SyncInventoryMissingDevices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "devices", kind: "message", T: Device, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncInventoryMissingDevices {
    return new SyncInventoryMissingDevices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncInventoryMissingDevices {
    return new SyncInventoryMissingDevices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncInventoryMissingDevices {
    return new SyncInventoryMissingDevices().fromJsonString(jsonString, options);
  }

  static equals(a: SyncInventoryMissingDevices | PlainMessage<SyncInventoryMissingDevices> | undefined, b: SyncInventoryMissingDevices | PlainMessage<SyncInventoryMissingDevices> | undefined): boolean {
    return proto3.util.equals(SyncInventoryMissingDevices, a, b);
  }
}

/**
 * Superseded by ResourceUsageService.GetUsage.
 *
 * @generated from message teleport.devicetrust.v1.GetDevicesUsageRequest
 */
export class GetDevicesUsageRequest extends Message<GetDevicesUsageRequest> {
  constructor(data?: PartialMessage<GetDevicesUsageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.devicetrust.v1.GetDevicesUsageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDevicesUsageRequest {
    return new GetDevicesUsageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDevicesUsageRequest {
    return new GetDevicesUsageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDevicesUsageRequest {
    return new GetDevicesUsageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDevicesUsageRequest | PlainMessage<GetDevicesUsageRequest> | undefined, b: GetDevicesUsageRequest | PlainMessage<GetDevicesUsageRequest> | undefined): boolean {
    return proto3.util.equals(GetDevicesUsageRequest, a, b);
  }
}

