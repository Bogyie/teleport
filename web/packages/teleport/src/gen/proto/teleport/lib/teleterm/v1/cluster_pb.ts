//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/lib/teleterm/v1/cluster.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * ShowResources tells if the cluster can show requestable resources on the resources page.
 *
 * @generated from enum teleport.lib.teleterm.v1.ShowResources
 */
export enum ShowResources {
  /**
   * @generated from enum value: SHOW_RESOURCES_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SHOW_RESOURCES_REQUESTABLE = 1;
   */
  REQUESTABLE = 1,

  /**
   * @generated from enum value: SHOW_RESOURCES_ACCESSIBLE_ONLY = 2;
   */
  ACCESSIBLE_ONLY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ShowResources)
proto3.util.setEnumType(ShowResources, "teleport.lib.teleterm.v1.ShowResources", [
  { no: 0, name: "SHOW_RESOURCES_UNSPECIFIED" },
  { no: 1, name: "SHOW_RESOURCES_REQUESTABLE" },
  { no: 2, name: "SHOW_RESOURCES_ACCESSIBLE_ONLY" },
]);

/**
 * Cluster describes cluster fields.
 *
 * @generated from message teleport.lib.teleterm.v1.Cluster
 */
export class Cluster extends Message<Cluster> {
  /**
   * uri is the cluster resource URI.
   * For root clusters, it has the form of /clusters/:rootClusterId where rootClusterId is the
   * name of the profile, that is the hostname of the proxy used to connect to the root cluster.
   * rootClusterId is not equal to the name of the root cluster.
   *
   * For leaf clusters, it has the form of /clusters/:rootClusterId/leaves/:leafClusterId where
   * leafClusterId is equal to the name property of the cluster.
   *
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * name is used throughout the Teleport Connect codebase as the cluster name.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * proxy_host is address of the proxy used to connect to this cluster.
   * Always includes port number. Present only for root clusters.
   *
   * Example: "teleport-14-ent.example.com:3090"
   *
   * @generated from field: string proxy_host = 3;
   */
  proxyHost = "";

  /**
   * connected indicates if connection to the cluster can be established, that is if we have a
   * cert for the cluster that hasn't expired
   *
   * @generated from field: bool connected = 4;
   */
  connected = false;

  /**
   * leaf indicates if this is a leaf cluster
   *
   * @generated from field: bool leaf = 5;
   */
  leaf = false;

  /**
   * logged_in_user is present if the user has logged in to the cluster at least once, even
   * if the cert has since expired. If the cluster was added to the app but the
   * user is yet to log in, logged_in_user is not present.
   *
   * @generated from field: teleport.lib.teleterm.v1.LoggedInUser logged_in_user = 7;
   */
  loggedInUser?: LoggedInUser;

  /**
   * features describes the auth servers features.
   * Only present when detailed information is queried from the auth server.
   *
   * @generated from field: teleport.lib.teleterm.v1.Features features = 8;
   */
  features?: Features;

  /**
   * auth_cluster_id is the unique cluster ID that is set once
   * during the first auth server startup.
   * Only present when detailed information is queried from the auth server.
   *
   * @generated from field: string auth_cluster_id = 9;
   */
  authClusterId = "";

  /**
   * ProxyVersion is the cluster proxy's service version.
   * Only present when detailed information is queried from the proxy server.
   *
   * @generated from field: string proxy_version = 10;
   */
  proxyVersion = "";

  /**
   * show_resources tells if the cluster can show requestable resources on the resources page.
   * Controlled by the cluster config.
   *
   * @generated from field: teleport.lib.teleterm.v1.ShowResources show_resources = 11;
   */
  showResources = ShowResources.UNSPECIFIED;

  constructor(data?: PartialMessage<Cluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.Cluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "proxy_host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "connected", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "leaf", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "logged_in_user", kind: "message", T: LoggedInUser },
    { no: 8, name: "features", kind: "message", T: Features },
    { no: 9, name: "auth_cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "proxy_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "show_resources", kind: "enum", T: proto3.getEnumType(ShowResources) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cluster {
    return new Cluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJsonString(jsonString, options);
  }

  static equals(a: Cluster | PlainMessage<Cluster> | undefined, b: Cluster | PlainMessage<Cluster> | undefined): boolean {
    return proto3.util.equals(Cluster, a, b);
  }
}

/**
 * LoggedInUser describes a logged-in user
 *
 * @generated from message teleport.lib.teleterm.v1.LoggedInUser
 */
export class LoggedInUser extends Message<LoggedInUser> {
  /**
   * name is the user name
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * roles is the user roles
   *
   * @generated from field: repeated string roles = 2;
   */
  roles: string[] = [];

  /**
   * ssh_logins is the user ssh logins
   *
   * @generated from field: repeated string ssh_logins = 3;
   */
  sshLogins: string[] = [];

  /**
   * acl is a user access control list.
   * It is available only after the cluster details are fetched, as it is not stored on disk.
   *
   * @generated from field: teleport.lib.teleterm.v1.ACL acl = 4;
   */
  acl?: ACL;

  /**
   * active_requests is an array of request-id strings of active requests
   *
   * @generated from field: repeated string active_requests = 5;
   */
  activeRequests: string[] = [];

  /**
   * suggested_reviewers for the given user.
   * Only present when detailed information is queried from the auth server.
   *
   * @generated from field: repeated string suggested_reviewers = 6;
   */
  suggestedReviewers: string[] = [];

  /**
   * requestable_roles for the given user.
   * Only present when detailed information is queried from the auth server.
   *
   * @generated from field: repeated string requestable_roles = 7;
   */
  requestableRoles: string[] = [];

  /**
   * @generated from field: teleport.lib.teleterm.v1.LoggedInUser.UserType user_type = 8;
   */
  userType = LoggedInUser_UserType.UNSPECIFIED;

  constructor(data?: PartialMessage<LoggedInUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoggedInUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ssh_logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "acl", kind: "message", T: ACL },
    { no: 5, name: "active_requests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "suggested_reviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "requestable_roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "user_type", kind: "enum", T: proto3.getEnumType(LoggedInUser_UserType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoggedInUser {
    return new LoggedInUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoggedInUser {
    return new LoggedInUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoggedInUser {
    return new LoggedInUser().fromJsonString(jsonString, options);
  }

  static equals(a: LoggedInUser | PlainMessage<LoggedInUser> | undefined, b: LoggedInUser | PlainMessage<LoggedInUser> | undefined): boolean {
    return proto3.util.equals(LoggedInUser, a, b);
  }
}

/**
 * UserType indicates whether the user was created through an SSO provider or in Teleport itself.
 * Only present when detailed information is queried from the auth server.
 *
 * @generated from enum teleport.lib.teleterm.v1.LoggedInUser.UserType
 */
export enum LoggedInUser_UserType {
  /**
   * @generated from enum value: USER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: USER_TYPE_LOCAL = 1;
   */
  LOCAL = 1,

  /**
   * @generated from enum value: USER_TYPE_SSO = 2;
   */
  SSO = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LoggedInUser_UserType)
proto3.util.setEnumType(LoggedInUser_UserType, "teleport.lib.teleterm.v1.LoggedInUser.UserType", [
  { no: 0, name: "USER_TYPE_UNSPECIFIED" },
  { no: 1, name: "USER_TYPE_LOCAL" },
  { no: 2, name: "USER_TYPE_SSO" },
]);

/**
 * ACL is the access control list of the user
 *
 * @generated from message teleport.lib.teleterm.v1.ACL
 */
export class ACL extends Message<ACL> {
  /**
   * auth_connectors defines access to auth.connectors
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess auth_connectors = 2;
   */
  authConnectors?: ResourceAccess;

  /**
   * Roles defines access to roles
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess roles = 3;
   */
  roles?: ResourceAccess;

  /**
   * Users defines access to users.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess users = 4;
   */
  users?: ResourceAccess;

  /**
   * trusted_clusters defines access to trusted clusters
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess trusted_clusters = 5;
   */
  trustedClusters?: ResourceAccess;

  /**
   * Events defines access to audit logs
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess events = 6;
   */
  events?: ResourceAccess;

  /**
   * Tokens defines access to tokens.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess tokens = 7;
   */
  tokens?: ResourceAccess;

  /**
   * Servers defines access to servers.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess servers = 8;
   */
  servers?: ResourceAccess;

  /**
   * apps defines access to application servers
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess apps = 9;
   */
  apps?: ResourceAccess;

  /**
   * dbs defines access to database servers.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess dbs = 10;
   */
  dbs?: ResourceAccess;

  /**
   * kubeservers defines access to kubernetes servers.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess kubeservers = 11;
   */
  kubeservers?: ResourceAccess;

  /**
   * access_requests defines access to access requests
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess access_requests = 12;
   */
  accessRequests?: ResourceAccess;

  /**
   * recorded_sessions defines access to recorded sessions.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess recorded_sessions = 13;
   */
  recordedSessions?: ResourceAccess;

  /**
   * active_sessions defines access to active sessions.
   *
   * @generated from field: teleport.lib.teleterm.v1.ResourceAccess active_sessions = 14;
   */
  activeSessions?: ResourceAccess;

  constructor(data?: PartialMessage<ACL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ACL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "auth_connectors", kind: "message", T: ResourceAccess },
    { no: 3, name: "roles", kind: "message", T: ResourceAccess },
    { no: 4, name: "users", kind: "message", T: ResourceAccess },
    { no: 5, name: "trusted_clusters", kind: "message", T: ResourceAccess },
    { no: 6, name: "events", kind: "message", T: ResourceAccess },
    { no: 7, name: "tokens", kind: "message", T: ResourceAccess },
    { no: 8, name: "servers", kind: "message", T: ResourceAccess },
    { no: 9, name: "apps", kind: "message", T: ResourceAccess },
    { no: 10, name: "dbs", kind: "message", T: ResourceAccess },
    { no: 11, name: "kubeservers", kind: "message", T: ResourceAccess },
    { no: 12, name: "access_requests", kind: "message", T: ResourceAccess },
    { no: 13, name: "recorded_sessions", kind: "message", T: ResourceAccess },
    { no: 14, name: "active_sessions", kind: "message", T: ResourceAccess },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACL {
    return new ACL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACL {
    return new ACL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACL {
    return new ACL().fromJsonString(jsonString, options);
  }

  static equals(a: ACL | PlainMessage<ACL> | undefined, b: ACL | PlainMessage<ACL> | undefined): boolean {
    return proto3.util.equals(ACL, a, b);
  }
}

/**
 * ResourceAccess describes access verbs
 *
 * @generated from message teleport.lib.teleterm.v1.ResourceAccess
 */
export class ResourceAccess extends Message<ResourceAccess> {
  /**
   * list determines "list" access
   *
   * @generated from field: bool list = 1;
   */
  list = false;

  /**
   * read determines "read" access
   *
   * @generated from field: bool read = 2;
   */
  read = false;

  /**
   * edit determines "edit" access
   *
   * @generated from field: bool edit = 3;
   */
  edit = false;

  /**
   * create determines "create" access
   *
   * @generated from field: bool create = 4;
   */
  create = false;

  /**
   * delete determines "delete" access
   *
   * @generated from field: bool delete = 5;
   */
  delete = false;

  /**
   * use determines "use" access
   *
   * @generated from field: bool use = 6;
   */
  use = false;

  constructor(data?: PartialMessage<ResourceAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ResourceAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "read", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "edit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "create", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "use", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceAccess {
    return new ResourceAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceAccess {
    return new ResourceAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceAccess {
    return new ResourceAccess().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceAccess | PlainMessage<ResourceAccess> | undefined, b: ResourceAccess | PlainMessage<ResourceAccess> | undefined): boolean {
    return proto3.util.equals(ResourceAccess, a, b);
  }
}

/**
 * Features describes the auth servers features
 *
 * @generated from message teleport.lib.teleterm.v1.Features
 */
export class Features extends Message<Features> {
  /**
   * advanced_access_workflows enables search-based access requests
   *
   * @generated from field: bool advanced_access_workflows = 1;
   */
  advancedAccessWorkflows = false;

  /**
   * is_usage_based_billing determines if the cloud user subscription is usage-based (pay-as-you-go).
   *
   * @generated from field: bool is_usage_based_billing = 2;
   */
  isUsageBasedBilling = false;

  constructor(data?: PartialMessage<Features>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.Features";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "advanced_access_workflows", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "is_usage_based_billing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Features {
    return new Features().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Features {
    return new Features().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Features {
    return new Features().fromJsonString(jsonString, options);
  }

  static equals(a: Features | PlainMessage<Features> | undefined, b: Features | PlainMessage<Features> | undefined): boolean {
    return proto3.util.equals(Features, a, b);
  }
}

