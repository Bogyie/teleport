//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/lib/teleterm/v1/service.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccessRequest, ResourceID } from "./access_request_pb";
import { AccessList } from "../../../accesslist/v1/accesslist_pb";
import { Cluster } from "./cluster_pb";
import { Gateway } from "./gateway_pb";
import { Server } from "./server_pb";
import { Database } from "./database_pb";
import { Kube } from "./kube_pb";
import { App } from "./app_pb";
import { ClusterUserPreferences } from "../../../userpreferences/v1/cluster_preferences_pb";
import { UnifiedResourcePreferences } from "../../../userpreferences/v1/unified_resource_preferences_pb";
import { DeviceWebToken } from "../../../devicetrust/v1/device_web_token_pb";
import { DeviceConfirmationToken } from "../../../devicetrust/v1/device_confirmation_token_pb";

/**
 * PasswordlessPrompt describes different prompts we need from users
 * during the passwordless login flow.
 *
 * @generated from enum teleport.lib.teleterm.v1.PasswordlessPrompt
 */
export enum PasswordlessPrompt {
  /**
   * @generated from enum value: PASSWORDLESS_PROMPT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * PASSWORDLESS_PROMPT_PIN is used when we need a user's pin.
   *
   * @generated from enum value: PASSWORDLESS_PROMPT_PIN = 1;
   */
  PIN = 1,

  /**
   * PASSWORDLESS_PROMPT_TAP is used when we require a user to tap their device.
   *
   * @generated from enum value: PASSWORDLESS_PROMPT_TAP = 2;
   */
  TAP = 2,

  /**
   * PASSWORDLESS_PROMPT_CREDENTIAL is used when we require a user to select a username
   * associated with their account.
   *
   * @generated from enum value: PASSWORDLESS_PROMPT_CREDENTIAL = 3;
   */
  CREDENTIAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PasswordlessPrompt)
proto3.util.setEnumType(PasswordlessPrompt, "teleport.lib.teleterm.v1.PasswordlessPrompt", [
  { no: 0, name: "PASSWORDLESS_PROMPT_UNSPECIFIED" },
  { no: 1, name: "PASSWORDLESS_PROMPT_PIN" },
  { no: 2, name: "PASSWORDLESS_PROMPT_TAP" },
  { no: 3, name: "PASSWORDLESS_PROMPT_CREDENTIAL" },
]);

/**
 * FileTransferDirection describes directions of a file transfer
 *
 * @generated from enum teleport.lib.teleterm.v1.FileTransferDirection
 */
export enum FileTransferDirection {
  /**
   * @generated from enum value: FILE_TRANSFER_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FILE_TRANSFER_DIRECTION_DOWNLOAD = 1;
   */
  DOWNLOAD = 1,

  /**
   * @generated from enum value: FILE_TRANSFER_DIRECTION_UPLOAD = 2;
   */
  UPLOAD = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FileTransferDirection)
proto3.util.setEnumType(FileTransferDirection, "teleport.lib.teleterm.v1.FileTransferDirection", [
  { no: 0, name: "FILE_TRANSFER_DIRECTION_UNSPECIFIED" },
  { no: 1, name: "FILE_TRANSFER_DIRECTION_DOWNLOAD" },
  { no: 2, name: "FILE_TRANSFER_DIRECTION_UPLOAD" },
]);

/**
 * HeadlessAuthenticationState is a headless authentication state.
 *
 * @generated from enum teleport.lib.teleterm.v1.HeadlessAuthenticationState
 */
export enum HeadlessAuthenticationState {
  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_DENIED = 2;
   */
  DENIED = 2,

  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_APPROVED = 3;
   */
  APPROVED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(HeadlessAuthenticationState)
proto3.util.setEnumType(HeadlessAuthenticationState, "teleport.lib.teleterm.v1.HeadlessAuthenticationState", [
  { no: 0, name: "HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED" },
  { no: 1, name: "HEADLESS_AUTHENTICATION_STATE_PENDING" },
  { no: 2, name: "HEADLESS_AUTHENTICATION_STATE_DENIED" },
  { no: 3, name: "HEADLESS_AUTHENTICATION_STATE_APPROVED" },
]);

/**
 * @generated from message teleport.lib.teleterm.v1.EmptyResponse
 */
export class EmptyResponse extends Message<EmptyResponse> {
  constructor(data?: PartialMessage<EmptyResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.EmptyResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmptyResponse {
    return new EmptyResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmptyResponse {
    return new EmptyResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmptyResponse {
    return new EmptyResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EmptyResponse | PlainMessage<EmptyResponse> | undefined, b: EmptyResponse | PlainMessage<EmptyResponse> | undefined): boolean {
    return proto3.util.equals(EmptyResponse, a, b);
  }
}

/**
 * RemoveClusterRequest describes RemoveClusterRequest
 *
 * @generated from message teleport.lib.teleterm.v1.RemoveClusterRequest
 */
export class RemoveClusterRequest extends Message<RemoveClusterRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<RemoveClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.RemoveClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveClusterRequest {
    return new RemoveClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveClusterRequest {
    return new RemoveClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveClusterRequest {
    return new RemoveClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveClusterRequest | PlainMessage<RemoveClusterRequest> | undefined, b: RemoveClusterRequest | PlainMessage<RemoveClusterRequest> | undefined): boolean {
    return proto3.util.equals(RemoveClusterRequest, a, b);
  }
}

/**
 * GetClusterRequest describes GetClusterRequest
 *
 * @generated from message teleport.lib.teleterm.v1.GetClusterRequest
 */
export class GetClusterRequest extends Message<GetClusterRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<GetClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined, b: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterRequest, a, b);
  }
}

/**
 * LogoutRequest describes LogoutRequest
 *
 * @generated from message teleport.lib.teleterm.v1.LogoutRequest
 */
export class LogoutRequest extends Message<LogoutRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<LogoutRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LogoutRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogoutRequest {
    return new LogoutRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogoutRequest {
    return new LogoutRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogoutRequest {
    return new LogoutRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LogoutRequest | PlainMessage<LogoutRequest> | undefined, b: LogoutRequest | PlainMessage<LogoutRequest> | undefined): boolean {
    return proto3.util.equals(LogoutRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAccessRequestRequest
 */
export class GetAccessRequestRequest extends Message<GetAccessRequestRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * specifcies a specific request id
   *
   * @generated from field: string access_request_id = 2;
   */
  accessRequestId = "";

  constructor(data?: PartialMessage<GetAccessRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAccessRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "access_request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccessRequestRequest {
    return new GetAccessRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccessRequestRequest {
    return new GetAccessRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccessRequestRequest {
    return new GetAccessRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccessRequestRequest | PlainMessage<GetAccessRequestRequest> | undefined, b: GetAccessRequestRequest | PlainMessage<GetAccessRequestRequest> | undefined): boolean {
    return proto3.util.equals(GetAccessRequestRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAccessRequestsRequest
 */
export class GetAccessRequestsRequest extends Message<GetAccessRequestsRequest> {
  /**
   * cluster_uri is the cluster uri
   *
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<GetAccessRequestsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAccessRequestsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccessRequestsRequest {
    return new GetAccessRequestsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccessRequestsRequest {
    return new GetAccessRequestsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccessRequestsRequest {
    return new GetAccessRequestsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccessRequestsRequest | PlainMessage<GetAccessRequestsRequest> | undefined, b: GetAccessRequestsRequest | PlainMessage<GetAccessRequestsRequest> | undefined): boolean {
    return proto3.util.equals(GetAccessRequestsRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAccessRequestResponse
 */
export class GetAccessRequestResponse extends Message<GetAccessRequestResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.AccessRequest request = 1;
   */
  request?: AccessRequest;

  constructor(data?: PartialMessage<GetAccessRequestResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAccessRequestResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: AccessRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccessRequestResponse {
    return new GetAccessRequestResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccessRequestResponse {
    return new GetAccessRequestResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccessRequestResponse {
    return new GetAccessRequestResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccessRequestResponse | PlainMessage<GetAccessRequestResponse> | undefined, b: GetAccessRequestResponse | PlainMessage<GetAccessRequestResponse> | undefined): boolean {
    return proto3.util.equals(GetAccessRequestResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAccessRequestsResponse
 */
export class GetAccessRequestsResponse extends Message<GetAccessRequestsResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.AccessRequest requests = 1;
   */
  requests: AccessRequest[] = [];

  constructor(data?: PartialMessage<GetAccessRequestsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAccessRequestsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: AccessRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccessRequestsResponse {
    return new GetAccessRequestsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccessRequestsResponse {
    return new GetAccessRequestsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccessRequestsResponse {
    return new GetAccessRequestsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccessRequestsResponse | PlainMessage<GetAccessRequestsResponse> | undefined, b: GetAccessRequestsResponse | PlainMessage<GetAccessRequestsResponse> | undefined): boolean {
    return proto3.util.equals(GetAccessRequestsResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.DeleteAccessRequestRequest
 */
export class DeleteAccessRequestRequest extends Message<DeleteAccessRequestRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string access_request_id = 2;
   */
  accessRequestId = "";

  constructor(data?: PartialMessage<DeleteAccessRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.DeleteAccessRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "access_request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAccessRequestRequest {
    return new DeleteAccessRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAccessRequestRequest {
    return new DeleteAccessRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAccessRequestRequest {
    return new DeleteAccessRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAccessRequestRequest | PlainMessage<DeleteAccessRequestRequest> | undefined, b: DeleteAccessRequestRequest | PlainMessage<DeleteAccessRequestRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAccessRequestRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateAccessRequestRequest
 */
export class CreateAccessRequestRequest extends Message<CreateAccessRequestRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string reason = 2;
   */
  reason = "";

  /**
   * a list of roles requested
   *
   * @generated from field: repeated string roles = 3;
   */
  roles: string[] = [];

  /**
   * suggested_reviewers is a suggested list of reviewers that can review a request.
   *
   * @generated from field: repeated string suggested_reviewers = 4;
   */
  suggestedReviewers: string[] = [];

  /**
   * TODO(avatus) remove the resource_ids field once the changes to rely on resources instead is merged
   * a list of resourceIDs requested in the AccessRequest
   *
   * @generated from field: repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 5;
   */
  resourceIds: ResourceID[] = [];

  /**
   * assume_start_time is the time after which the requested access can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp assume_start_time = 6;
   */
  assumeStartTime?: Timestamp;

  /**
   * dry_run is a flag that indicates whether the request is a dry run to check and set defaults,
   * and return before actually creating the request in the backend.
   *
   * @generated from field: bool dry_run = 7;
   */
  dryRun = false;

  /**
   * max_duration is the maximum duration for which the request is valid.
   *
   * @generated from field: google.protobuf.Timestamp max_duration = 8;
   */
  maxDuration?: Timestamp;

  /**
   * request_ttl is the expiration time of the request (how long it will await
   * approval).
   *
   * @generated from field: google.protobuf.Timestamp request_ttl = 9;
   */
  requestTtl?: Timestamp;

  constructor(data?: PartialMessage<CreateAccessRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateAccessRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "suggested_reviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "resource_ids", kind: "message", T: ResourceID, repeated: true },
    { no: 6, name: "assume_start_time", kind: "message", T: Timestamp },
    { no: 7, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "max_duration", kind: "message", T: Timestamp },
    { no: 9, name: "request_ttl", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccessRequestRequest {
    return new CreateAccessRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccessRequestRequest {
    return new CreateAccessRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccessRequestRequest {
    return new CreateAccessRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccessRequestRequest | PlainMessage<CreateAccessRequestRequest> | undefined, b: CreateAccessRequestRequest | PlainMessage<CreateAccessRequestRequest> | undefined): boolean {
    return proto3.util.equals(CreateAccessRequestRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateAccessRequestResponse
 */
export class CreateAccessRequestResponse extends Message<CreateAccessRequestResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.AccessRequest request = 1;
   */
  request?: AccessRequest;

  constructor(data?: PartialMessage<CreateAccessRequestResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateAccessRequestResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: AccessRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccessRequestResponse {
    return new CreateAccessRequestResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccessRequestResponse {
    return new CreateAccessRequestResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccessRequestResponse {
    return new CreateAccessRequestResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccessRequestResponse | PlainMessage<CreateAccessRequestResponse> | undefined, b: CreateAccessRequestResponse | PlainMessage<CreateAccessRequestResponse> | undefined): boolean {
    return proto3.util.equals(CreateAccessRequestResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.AssumeRoleRequest
 */
export class AssumeRoleRequest extends Message<AssumeRoleRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: repeated string access_request_ids = 2;
   */
  accessRequestIds: string[] = [];

  /**
   * @generated from field: repeated string drop_request_ids = 3;
   */
  dropRequestIds: string[] = [];

  constructor(data?: PartialMessage<AssumeRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.AssumeRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "access_request_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "drop_request_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssumeRoleRequest {
    return new AssumeRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssumeRoleRequest {
    return new AssumeRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssumeRoleRequest {
    return new AssumeRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AssumeRoleRequest | PlainMessage<AssumeRoleRequest> | undefined, b: AssumeRoleRequest | PlainMessage<AssumeRoleRequest> | undefined): boolean {
    return proto3.util.equals(AssumeRoleRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetRequestableRolesRequest
 */
export class GetRequestableRolesRequest extends Message<GetRequestableRolesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.ResourceID resource_ids = 2;
   */
  resourceIds: ResourceID[] = [];

  constructor(data?: PartialMessage<GetRequestableRolesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetRequestableRolesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_ids", kind: "message", T: ResourceID, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRequestableRolesRequest {
    return new GetRequestableRolesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRequestableRolesRequest {
    return new GetRequestableRolesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRequestableRolesRequest {
    return new GetRequestableRolesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRequestableRolesRequest | PlainMessage<GetRequestableRolesRequest> | undefined, b: GetRequestableRolesRequest | PlainMessage<GetRequestableRolesRequest> | undefined): boolean {
    return proto3.util.equals(GetRequestableRolesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetRequestableRolesResponse
 */
export class GetRequestableRolesResponse extends Message<GetRequestableRolesResponse> {
  /**
   * @generated from field: repeated string roles = 1;
   */
  roles: string[] = [];

  /**
   * @generated from field: repeated string applicable_roles = 2;
   */
  applicableRoles: string[] = [];

  constructor(data?: PartialMessage<GetRequestableRolesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetRequestableRolesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "applicable_roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRequestableRolesResponse {
    return new GetRequestableRolesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRequestableRolesResponse {
    return new GetRequestableRolesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRequestableRolesResponse {
    return new GetRequestableRolesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRequestableRolesResponse | PlainMessage<GetRequestableRolesResponse> | undefined, b: GetRequestableRolesResponse | PlainMessage<GetRequestableRolesResponse> | undefined): boolean {
    return proto3.util.equals(GetRequestableRolesResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ReviewAccessRequestRequest
 */
export class ReviewAccessRequestRequest extends Message<ReviewAccessRequestRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string state = 2;
   */
  state = "";

  /**
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * @generated from field: repeated string roles = 4;
   */
  roles: string[] = [];

  /**
   * @generated from field: string access_request_id = 5;
   */
  accessRequestId = "";

  /**
   * Overwrites the requested start time (optional).
   *
   * @generated from field: google.protobuf.Timestamp assume_start_time = 6;
   */
  assumeStartTime?: Timestamp;

  constructor(data?: PartialMessage<ReviewAccessRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReviewAccessRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "access_request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "assume_start_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReviewAccessRequestRequest {
    return new ReviewAccessRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReviewAccessRequestRequest {
    return new ReviewAccessRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReviewAccessRequestRequest {
    return new ReviewAccessRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReviewAccessRequestRequest | PlainMessage<ReviewAccessRequestRequest> | undefined, b: ReviewAccessRequestRequest | PlainMessage<ReviewAccessRequestRequest> | undefined): boolean {
    return proto3.util.equals(ReviewAccessRequestRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ReviewAccessRequestResponse
 */
export class ReviewAccessRequestResponse extends Message<ReviewAccessRequestResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.AccessRequest request = 1;
   */
  request?: AccessRequest;

  constructor(data?: PartialMessage<ReviewAccessRequestResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReviewAccessRequestResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: AccessRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReviewAccessRequestResponse {
    return new ReviewAccessRequestResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReviewAccessRequestResponse {
    return new ReviewAccessRequestResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReviewAccessRequestResponse {
    return new ReviewAccessRequestResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReviewAccessRequestResponse | PlainMessage<ReviewAccessRequestResponse> | undefined, b: ReviewAccessRequestResponse | PlainMessage<ReviewAccessRequestResponse> | undefined): boolean {
    return proto3.util.equals(ReviewAccessRequestResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.PromoteAccessRequestRequest
 */
export class PromoteAccessRequestRequest extends Message<PromoteAccessRequestRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string access_list_id = 2;
   */
  accessListId = "";

  /**
   * @generated from field: string reason = 3;
   */
  reason = "";

  /**
   * @generated from field: string access_request_id = 4;
   */
  accessRequestId = "";

  constructor(data?: PartialMessage<PromoteAccessRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.PromoteAccessRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "access_list_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "access_request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromoteAccessRequestRequest {
    return new PromoteAccessRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromoteAccessRequestRequest {
    return new PromoteAccessRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromoteAccessRequestRequest {
    return new PromoteAccessRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PromoteAccessRequestRequest | PlainMessage<PromoteAccessRequestRequest> | undefined, b: PromoteAccessRequestRequest | PlainMessage<PromoteAccessRequestRequest> | undefined): boolean {
    return proto3.util.equals(PromoteAccessRequestRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.PromoteAccessRequestResponse
 */
export class PromoteAccessRequestResponse extends Message<PromoteAccessRequestResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.AccessRequest request = 1;
   */
  request?: AccessRequest;

  constructor(data?: PartialMessage<PromoteAccessRequestResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.PromoteAccessRequestResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: AccessRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromoteAccessRequestResponse {
    return new PromoteAccessRequestResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromoteAccessRequestResponse {
    return new PromoteAccessRequestResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromoteAccessRequestResponse {
    return new PromoteAccessRequestResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PromoteAccessRequestResponse | PlainMessage<PromoteAccessRequestResponse> | undefined, b: PromoteAccessRequestResponse | PlainMessage<PromoteAccessRequestResponse> | undefined): boolean {
    return proto3.util.equals(PromoteAccessRequestResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest
 */
export class GetSuggestedAccessListsRequest extends Message<GetSuggestedAccessListsRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string access_request_id = 2;
   */
  accessRequestId = "";

  constructor(data?: PartialMessage<GetSuggestedAccessListsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "access_request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSuggestedAccessListsRequest {
    return new GetSuggestedAccessListsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSuggestedAccessListsRequest {
    return new GetSuggestedAccessListsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSuggestedAccessListsRequest {
    return new GetSuggestedAccessListsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSuggestedAccessListsRequest | PlainMessage<GetSuggestedAccessListsRequest> | undefined, b: GetSuggestedAccessListsRequest | PlainMessage<GetSuggestedAccessListsRequest> | undefined): boolean {
    return proto3.util.equals(GetSuggestedAccessListsRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse
 */
export class GetSuggestedAccessListsResponse extends Message<GetSuggestedAccessListsResponse> {
  /**
   * @generated from field: repeated teleport.accesslist.v1.AccessList access_lists = 1;
   */
  accessLists: AccessList[] = [];

  constructor(data?: PartialMessage<GetSuggestedAccessListsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_lists", kind: "message", T: AccessList, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSuggestedAccessListsResponse {
    return new GetSuggestedAccessListsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSuggestedAccessListsResponse {
    return new GetSuggestedAccessListsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSuggestedAccessListsResponse {
    return new GetSuggestedAccessListsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSuggestedAccessListsResponse | PlainMessage<GetSuggestedAccessListsResponse> | undefined, b: GetSuggestedAccessListsResponse | PlainMessage<GetSuggestedAccessListsResponse> | undefined): boolean {
    return proto3.util.equals(GetSuggestedAccessListsResponse, a, b);
  }
}

/**
 * CredentialInfo holds fields related to a user's WebAuthn credential.
 *
 * @generated from message teleport.lib.teleterm.v1.CredentialInfo
 */
export class CredentialInfo extends Message<CredentialInfo> {
  /**
   * @generated from field: string username = 1;
   */
  username = "";

  constructor(data?: PartialMessage<CredentialInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CredentialInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CredentialInfo {
    return new CredentialInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CredentialInfo {
    return new CredentialInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CredentialInfo {
    return new CredentialInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CredentialInfo | PlainMessage<CredentialInfo> | undefined, b: CredentialInfo | PlainMessage<CredentialInfo> | undefined): boolean {
    return proto3.util.equals(CredentialInfo, a, b);
  }
}

/**
 * LoginPasswordlessResponse is a message sent by the server during the
 * passwordless login flow.
 *
 * @generated from message teleport.lib.teleterm.v1.LoginPasswordlessResponse
 */
export class LoginPasswordlessResponse extends Message<LoginPasswordlessResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.PasswordlessPrompt prompt = 1;
   */
  prompt = PasswordlessPrompt.UNSPECIFIED;

  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.CredentialInfo credentials = 2;
   */
  credentials: CredentialInfo[] = [];

  constructor(data?: PartialMessage<LoginPasswordlessResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginPasswordlessResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "prompt", kind: "enum", T: proto3.getEnumType(PasswordlessPrompt) },
    { no: 2, name: "credentials", kind: "message", T: CredentialInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginPasswordlessResponse {
    return new LoginPasswordlessResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginPasswordlessResponse {
    return new LoginPasswordlessResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginPasswordlessResponse {
    return new LoginPasswordlessResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoginPasswordlessResponse | PlainMessage<LoginPasswordlessResponse> | undefined, b: LoginPasswordlessResponse | PlainMessage<LoginPasswordlessResponse> | undefined): boolean {
    return proto3.util.equals(LoginPasswordlessResponse, a, b);
  }
}

/**
 * LoginPasswordlessRequest is a message sent by the client during the passwordless login flow.
 *
 * @generated from message teleport.lib.teleterm.v1.LoginPasswordlessRequest
 */
export class LoginPasswordlessRequest extends Message<LoginPasswordlessRequest> {
  /**
   * @generated from oneof teleport.lib.teleterm.v1.LoginPasswordlessRequest.request
   */
  request: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit init = 1;
     */
    value: LoginPasswordlessRequest_LoginPasswordlessRequestInit;
    case: "init";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse pin = 2;
     */
    value: LoginPasswordlessRequest_LoginPasswordlessPINResponse;
    case: "pin";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse credential = 3;
     */
    value: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse;
    case: "credential";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LoginPasswordlessRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginPasswordlessRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init", kind: "message", T: LoginPasswordlessRequest_LoginPasswordlessRequestInit, oneof: "request" },
    { no: 2, name: "pin", kind: "message", T: LoginPasswordlessRequest_LoginPasswordlessPINResponse, oneof: "request" },
    { no: 3, name: "credential", kind: "message", T: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse, oneof: "request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginPasswordlessRequest {
    return new LoginPasswordlessRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest {
    return new LoginPasswordlessRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest {
    return new LoginPasswordlessRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoginPasswordlessRequest | PlainMessage<LoginPasswordlessRequest> | undefined, b: LoginPasswordlessRequest | PlainMessage<LoginPasswordlessRequest> | undefined): boolean {
    return proto3.util.equals(LoginPasswordlessRequest, a, b);
  }
}

/**
 * LoginPasswordlessRequestInit contains fields needed to init the stream request.
 *
 * @generated from message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit
 */
export class LoginPasswordlessRequest_LoginPasswordlessRequestInit extends Message<LoginPasswordlessRequest_LoginPasswordlessRequestInit> {
  /**
   * cluster_uri is needed to resolve cluster by its uri.
   *
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessRequestInit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessRequestInit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginPasswordlessRequest_LoginPasswordlessRequestInit {
    return new LoginPasswordlessRequest_LoginPasswordlessRequestInit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessRequestInit {
    return new LoginPasswordlessRequest_LoginPasswordlessRequestInit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessRequestInit {
    return new LoginPasswordlessRequest_LoginPasswordlessRequestInit().fromJsonString(jsonString, options);
  }

  static equals(a: LoginPasswordlessRequest_LoginPasswordlessRequestInit | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessRequestInit> | undefined, b: LoginPasswordlessRequest_LoginPasswordlessRequestInit | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessRequestInit> | undefined): boolean {
    return proto3.util.equals(LoginPasswordlessRequest_LoginPasswordlessRequestInit, a, b);
  }
}

/**
 * LoginPasswordlessPINResponse contains fields related to request from webauthncli.PromptPIN.
 *
 * @generated from message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse
 */
export class LoginPasswordlessRequest_LoginPasswordlessPINResponse extends Message<LoginPasswordlessRequest_LoginPasswordlessPINResponse> {
  /**
   * pin is the user's device's pin.
   *
   * @generated from field: string pin = 1;
   */
  pin = "";

  constructor(data?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessPINResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessPINResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginPasswordlessRequest_LoginPasswordlessPINResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessPINResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessPINResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessPINResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessPINResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessPINResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoginPasswordlessRequest_LoginPasswordlessPINResponse | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessPINResponse> | undefined, b: LoginPasswordlessRequest_LoginPasswordlessPINResponse | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessPINResponse> | undefined): boolean {
    return proto3.util.equals(LoginPasswordlessRequest_LoginPasswordlessPINResponse, a, b);
  }
}

/**
 * LoginPasswordlessPINResponse contains fields related to request from
 * webauthncli.PromptCredential.
 *
 * @generated from message teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse
 */
export class LoginPasswordlessRequest_LoginPasswordlessCredentialResponse extends Message<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse> {
  /**
   * index is the associated number in the list of credentials that the user selected to log
   * in as.
   *
   * @generated from field: int64 index = 1;
   */
  index = protoInt64.zero;

  constructor(data?: PartialMessage<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginPasswordlessRequest.LoginPasswordlessCredentialResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessCredentialResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessCredentialResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginPasswordlessRequest_LoginPasswordlessCredentialResponse {
    return new LoginPasswordlessRequest_LoginPasswordlessCredentialResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse> | undefined, b: LoginPasswordlessRequest_LoginPasswordlessCredentialResponse | PlainMessage<LoginPasswordlessRequest_LoginPasswordlessCredentialResponse> | undefined): boolean {
    return proto3.util.equals(LoginPasswordlessRequest_LoginPasswordlessCredentialResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.FileTransferRequest
 */
export class FileTransferRequest extends Message<FileTransferRequest> {
  /**
   * login is the SSH username to use for the transfer.
   *
   * @generated from field: string login = 2;
   */
  login = "";

  /**
   * source path of the transferred file.
   *
   * @generated from field: string source = 4;
   */
  source = "";

  /**
   * destination path of the transferred file.
   *
   * @generated from field: string destination = 5;
   */
  destination = "";

  /**
   * direction indicates whether the file is uploaded/downloaded.
   *
   * @generated from field: teleport.lib.teleterm.v1.FileTransferDirection direction = 6;
   */
  direction = FileTransferDirection.UNSPECIFIED;

  /**
   * @generated from field: string server_uri = 7;
   */
  serverUri = "";

  constructor(data?: PartialMessage<FileTransferRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.FileTransferRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "direction", kind: "enum", T: proto3.getEnumType(FileTransferDirection) },
    { no: 7, name: "server_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTransferRequest {
    return new FileTransferRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTransferRequest {
    return new FileTransferRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTransferRequest {
    return new FileTransferRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FileTransferRequest | PlainMessage<FileTransferRequest> | undefined, b: FileTransferRequest | PlainMessage<FileTransferRequest> | undefined): boolean {
    return proto3.util.equals(FileTransferRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.FileTransferProgress
 */
export class FileTransferProgress extends Message<FileTransferProgress> {
  /**
   * @generated from field: uint32 percentage = 1;
   */
  percentage = 0;

  constructor(data?: PartialMessage<FileTransferProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.FileTransferProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "percentage", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTransferProgress {
    return new FileTransferProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTransferProgress {
    return new FileTransferProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTransferProgress {
    return new FileTransferProgress().fromJsonString(jsonString, options);
  }

  static equals(a: FileTransferProgress | PlainMessage<FileTransferProgress> | undefined, b: FileTransferProgress | PlainMessage<FileTransferProgress> | undefined): boolean {
    return proto3.util.equals(FileTransferProgress, a, b);
  }
}

/**
 * LoginRequest describes cluster login request
 *
 * @generated from message teleport.lib.teleterm.v1.LoginRequest
 */
export class LoginRequest extends Message<LoginRequest> {
  /**
   * cluster_uri is the cluster uri
   *
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from oneof teleport.lib.teleterm.v1.LoginRequest.params
   */
  params: {
    /**
     * local holds parameters for local logins
     *
     * @generated from field: teleport.lib.teleterm.v1.LoginRequest.LocalParams local = 2;
     */
    value: LoginRequest_LocalParams;
    case: "local";
  } | {
    /**
     * sso holds parameters for sso logins
     *
     * @generated from field: teleport.lib.teleterm.v1.LoginRequest.SsoParams sso = 3;
     */
    value: LoginRequest_SsoParams;
    case: "sso";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LoginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "local", kind: "message", T: LoginRequest_LocalParams, oneof: "params" },
    { no: 3, name: "sso", kind: "message", T: LoginRequest_SsoParams, oneof: "params" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRequest {
    return new LoginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRequest {
    return new LoginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRequest {
    return new LoginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRequest | PlainMessage<LoginRequest> | undefined, b: LoginRequest | PlainMessage<LoginRequest> | undefined): boolean {
    return proto3.util.equals(LoginRequest, a, b);
  }
}

/**
 * LocalParams describes parameters for local user logins
 *
 * @generated from message teleport.lib.teleterm.v1.LoginRequest.LocalParams
 */
export class LoginRequest_LocalParams extends Message<LoginRequest_LocalParams> {
  /**
   * user is the user name
   *
   * @generated from field: string user = 1;
   */
  user = "";

  /**
   * password is the user password
   *
   * @generated from field: string password = 2;
   */
  password = "";

  /**
   * token is the 2FA token
   *
   * @generated from field: string token = 3;
   */
  token = "";

  constructor(data?: PartialMessage<LoginRequest_LocalParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginRequest.LocalParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRequest_LocalParams {
    return new LoginRequest_LocalParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRequest_LocalParams {
    return new LoginRequest_LocalParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRequest_LocalParams {
    return new LoginRequest_LocalParams().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRequest_LocalParams | PlainMessage<LoginRequest_LocalParams> | undefined, b: LoginRequest_LocalParams | PlainMessage<LoginRequest_LocalParams> | undefined): boolean {
    return proto3.util.equals(LoginRequest_LocalParams, a, b);
  }
}

/**
 * SsoParams describes SSO parameters
 *
 * @generated from message teleport.lib.teleterm.v1.LoginRequest.SsoParams
 */
export class LoginRequest_SsoParams extends Message<LoginRequest_SsoParams> {
  /**
   * provider_type is the provider type
   *
   * @generated from field: string provider_type = 1;
   */
  providerType = "";

  /**
   * provider_name is the provider name
   *
   * @generated from field: string provider_name = 2;
   */
  providerName = "";

  constructor(data?: PartialMessage<LoginRequest_SsoParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.LoginRequest.SsoParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "provider_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRequest_SsoParams {
    return new LoginRequest_SsoParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRequest_SsoParams {
    return new LoginRequest_SsoParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRequest_SsoParams {
    return new LoginRequest_SsoParams().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRequest_SsoParams | PlainMessage<LoginRequest_SsoParams> | undefined, b: LoginRequest_SsoParams | PlainMessage<LoginRequest_SsoParams> | undefined): boolean {
    return proto3.util.equals(LoginRequest_SsoParams, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.AddClusterRequest
 */
export class AddClusterRequest extends Message<AddClusterRequest> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<AddClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.AddClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddClusterRequest {
    return new AddClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddClusterRequest {
    return new AddClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddClusterRequest {
    return new AddClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddClusterRequest | PlainMessage<AddClusterRequest> | undefined, b: AddClusterRequest | PlainMessage<AddClusterRequest> | undefined): boolean {
    return proto3.util.equals(AddClusterRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListClustersRequest
 */
export class ListClustersRequest extends Message<ListClustersRequest> {
  constructor(data?: PartialMessage<ListClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined, b: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined): boolean {
    return proto3.util.equals(ListClustersRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListClustersResponse
 */
export class ListClustersResponse extends Message<ListClustersResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.Cluster clusters = 1;
   */
  clusters: Cluster[] = [];

  constructor(data?: PartialMessage<ListClustersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListClustersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusters", kind: "message", T: Cluster, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined, b: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined): boolean {
    return proto3.util.equals(ListClustersResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetDatabasesRequest
 */
export class GetDatabasesRequest extends Message<GetDatabasesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  /**
   * @generated from field: string search = 4;
   */
  search = "";

  /**
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * @generated from field: string sort_by = 6;
   */
  sortBy = "";

  /**
   * @generated from field: string search_as_roles = 7;
   */
  searchAsRoles = "";

  constructor(data?: PartialMessage<GetDatabasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetDatabasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "search", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDatabasesRequest {
    return new GetDatabasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDatabasesRequest {
    return new GetDatabasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDatabasesRequest {
    return new GetDatabasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDatabasesRequest | PlainMessage<GetDatabasesRequest> | undefined, b: GetDatabasesRequest | PlainMessage<GetDatabasesRequest> | undefined): boolean {
    return proto3.util.equals(GetDatabasesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListLeafClustersRequest
 */
export class ListLeafClustersRequest extends Message<ListLeafClustersRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<ListLeafClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListLeafClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLeafClustersRequest {
    return new ListLeafClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLeafClustersRequest {
    return new ListLeafClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLeafClustersRequest {
    return new ListLeafClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListLeafClustersRequest | PlainMessage<ListLeafClustersRequest> | undefined, b: ListLeafClustersRequest | PlainMessage<ListLeafClustersRequest> | undefined): boolean {
    return proto3.util.equals(ListLeafClustersRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListDatabaseUsersRequest
 */
export class ListDatabaseUsersRequest extends Message<ListDatabaseUsersRequest> {
  /**
   * @generated from field: string db_uri = 1;
   */
  dbUri = "";

  constructor(data?: PartialMessage<ListDatabaseUsersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListDatabaseUsersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "db_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabaseUsersRequest {
    return new ListDatabaseUsersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabaseUsersRequest {
    return new ListDatabaseUsersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabaseUsersRequest {
    return new ListDatabaseUsersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabaseUsersRequest | PlainMessage<ListDatabaseUsersRequest> | undefined, b: ListDatabaseUsersRequest | PlainMessage<ListDatabaseUsersRequest> | undefined): boolean {
    return proto3.util.equals(ListDatabaseUsersRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListDatabaseUsersResponse
 */
export class ListDatabaseUsersResponse extends Message<ListDatabaseUsersResponse> {
  /**
   * @generated from field: repeated string users = 1;
   */
  users: string[] = [];

  constructor(data?: PartialMessage<ListDatabaseUsersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListDatabaseUsersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabaseUsersResponse {
    return new ListDatabaseUsersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabaseUsersResponse {
    return new ListDatabaseUsersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabaseUsersResponse {
    return new ListDatabaseUsersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabaseUsersResponse | PlainMessage<ListDatabaseUsersResponse> | undefined, b: ListDatabaseUsersResponse | PlainMessage<ListDatabaseUsersResponse> | undefined): boolean {
    return proto3.util.equals(ListDatabaseUsersResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateGatewayRequest
 */
export class CreateGatewayRequest extends Message<CreateGatewayRequest> {
  /**
   * @generated from field: string target_uri = 1;
   */
  targetUri = "";

  /**
   * @generated from field: string target_user = 2;
   */
  targetUser = "";

  /**
   * @generated from field: string local_port = 3;
   */
  localPort = "";

  /**
   * @generated from field: string target_subresource_name = 4;
   */
  targetSubresourceName = "";

  constructor(data?: PartialMessage<CreateGatewayRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateGatewayRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "local_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "target_subresource_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateGatewayRequest {
    return new CreateGatewayRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateGatewayRequest {
    return new CreateGatewayRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateGatewayRequest {
    return new CreateGatewayRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateGatewayRequest | PlainMessage<CreateGatewayRequest> | undefined, b: CreateGatewayRequest | PlainMessage<CreateGatewayRequest> | undefined): boolean {
    return proto3.util.equals(CreateGatewayRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListGatewaysRequest
 */
export class ListGatewaysRequest extends Message<ListGatewaysRequest> {
  constructor(data?: PartialMessage<ListGatewaysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListGatewaysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGatewaysRequest {
    return new ListGatewaysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGatewaysRequest {
    return new ListGatewaysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGatewaysRequest {
    return new ListGatewaysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListGatewaysRequest | PlainMessage<ListGatewaysRequest> | undefined, b: ListGatewaysRequest | PlainMessage<ListGatewaysRequest> | undefined): boolean {
    return proto3.util.equals(ListGatewaysRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListGatewaysResponse
 */
export class ListGatewaysResponse extends Message<ListGatewaysResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.Gateway gateways = 1;
   */
  gateways: Gateway[] = [];

  constructor(data?: PartialMessage<ListGatewaysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListGatewaysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateways", kind: "message", T: Gateway, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListGatewaysResponse {
    return new ListGatewaysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListGatewaysResponse {
    return new ListGatewaysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListGatewaysResponse {
    return new ListGatewaysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListGatewaysResponse | PlainMessage<ListGatewaysResponse> | undefined, b: ListGatewaysResponse | PlainMessage<ListGatewaysResponse> | undefined): boolean {
    return proto3.util.equals(ListGatewaysResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.RemoveGatewayRequest
 */
export class RemoveGatewayRequest extends Message<RemoveGatewayRequest> {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri = "";

  constructor(data?: PartialMessage<RemoveGatewayRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.RemoveGatewayRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveGatewayRequest {
    return new RemoveGatewayRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveGatewayRequest {
    return new RemoveGatewayRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveGatewayRequest {
    return new RemoveGatewayRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveGatewayRequest | PlainMessage<RemoveGatewayRequest> | undefined, b: RemoveGatewayRequest | PlainMessage<RemoveGatewayRequest> | undefined): boolean {
    return proto3.util.equals(RemoveGatewayRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest
 */
export class SetGatewayTargetSubresourceNameRequest extends Message<SetGatewayTargetSubresourceNameRequest> {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri = "";

  /**
   * @generated from field: string target_subresource_name = 2;
   */
  targetSubresourceName = "";

  constructor(data?: PartialMessage<SetGatewayTargetSubresourceNameRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_subresource_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetGatewayTargetSubresourceNameRequest {
    return new SetGatewayTargetSubresourceNameRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetGatewayTargetSubresourceNameRequest {
    return new SetGatewayTargetSubresourceNameRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetGatewayTargetSubresourceNameRequest {
    return new SetGatewayTargetSubresourceNameRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetGatewayTargetSubresourceNameRequest | PlainMessage<SetGatewayTargetSubresourceNameRequest> | undefined, b: SetGatewayTargetSubresourceNameRequest | PlainMessage<SetGatewayTargetSubresourceNameRequest> | undefined): boolean {
    return proto3.util.equals(SetGatewayTargetSubresourceNameRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.SetGatewayLocalPortRequest
 */
export class SetGatewayLocalPortRequest extends Message<SetGatewayLocalPortRequest> {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri = "";

  /**
   * @generated from field: string local_port = 2;
   */
  localPort = "";

  constructor(data?: PartialMessage<SetGatewayLocalPortRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SetGatewayLocalPortRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "local_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetGatewayLocalPortRequest {
    return new SetGatewayLocalPortRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetGatewayLocalPortRequest {
    return new SetGatewayLocalPortRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetGatewayLocalPortRequest {
    return new SetGatewayLocalPortRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetGatewayLocalPortRequest | PlainMessage<SetGatewayLocalPortRequest> | undefined, b: SetGatewayLocalPortRequest | PlainMessage<SetGatewayLocalPortRequest> | undefined): boolean {
    return proto3.util.equals(SetGatewayLocalPortRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetServersRequest
 */
export class GetServersRequest extends Message<GetServersRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  /**
   * @generated from field: string search = 4;
   */
  search = "";

  /**
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * @generated from field: string sort_by = 6;
   */
  sortBy = "";

  /**
   * @generated from field: string search_as_roles = 7;
   */
  searchAsRoles = "";

  constructor(data?: PartialMessage<GetServersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetServersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "search", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServersRequest {
    return new GetServersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServersRequest {
    return new GetServersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServersRequest {
    return new GetServersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetServersRequest | PlainMessage<GetServersRequest> | undefined, b: GetServersRequest | PlainMessage<GetServersRequest> | undefined): boolean {
    return proto3.util.equals(GetServersRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetServersResponse
 */
export class GetServersResponse extends Message<GetServersResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.Server agents = 1;
   */
  agents: Server[] = [];

  /**
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  constructor(data?: PartialMessage<GetServersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetServersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "agents", kind: "message", T: Server, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServersResponse {
    return new GetServersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServersResponse {
    return new GetServersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServersResponse {
    return new GetServersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetServersResponse | PlainMessage<GetServersResponse> | undefined, b: GetServersResponse | PlainMessage<GetServersResponse> | undefined): boolean {
    return proto3.util.equals(GetServersResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetDatabasesResponse
 */
export class GetDatabasesResponse extends Message<GetDatabasesResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.Database agents = 1;
   */
  agents: Database[] = [];

  /**
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  constructor(data?: PartialMessage<GetDatabasesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetDatabasesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "agents", kind: "message", T: Database, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDatabasesResponse {
    return new GetDatabasesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDatabasesResponse {
    return new GetDatabasesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDatabasesResponse {
    return new GetDatabasesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDatabasesResponse | PlainMessage<GetDatabasesResponse> | undefined, b: GetDatabasesResponse | PlainMessage<GetDatabasesResponse> | undefined): boolean {
    return proto3.util.equals(GetDatabasesResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetKubesRequest
 */
export class GetKubesRequest extends Message<GetKubesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  /**
   * @generated from field: string search = 4;
   */
  search = "";

  /**
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * @generated from field: string sort_by = 6;
   */
  sortBy = "";

  /**
   * @generated from field: string search_as_roles = 7;
   */
  searchAsRoles = "";

  constructor(data?: PartialMessage<GetKubesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetKubesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "search", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubesRequest {
    return new GetKubesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubesRequest {
    return new GetKubesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubesRequest {
    return new GetKubesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetKubesRequest | PlainMessage<GetKubesRequest> | undefined, b: GetKubesRequest | PlainMessage<GetKubesRequest> | undefined): boolean {
    return proto3.util.equals(GetKubesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetKubesResponse
 */
export class GetKubesResponse extends Message<GetKubesResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.Kube agents = 1;
   */
  agents: Kube[] = [];

  /**
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  constructor(data?: PartialMessage<GetKubesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetKubesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "agents", kind: "message", T: Kube, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetKubesResponse {
    return new GetKubesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetKubesResponse {
    return new GetKubesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetKubesResponse {
    return new GetKubesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetKubesResponse | PlainMessage<GetKubesResponse> | undefined, b: GetKubesResponse | PlainMessage<GetKubesResponse> | undefined): boolean {
    return proto3.util.equals(GetKubesResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAppsRequest
 */
export class GetAppsRequest extends Message<GetAppsRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  /**
   * @generated from field: string search = 4;
   */
  search = "";

  /**
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * @generated from field: string sort_by = 6;
   */
  sortBy = "";

  /**
   * @generated from field: string search_as_roles = 7;
   */
  searchAsRoles = "";

  constructor(data?: PartialMessage<GetAppsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAppsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "search", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "search_as_roles", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppsRequest {
    return new GetAppsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppsRequest {
    return new GetAppsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppsRequest {
    return new GetAppsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppsRequest | PlainMessage<GetAppsRequest> | undefined, b: GetAppsRequest | PlainMessage<GetAppsRequest> | undefined): boolean {
    return proto3.util.equals(GetAppsRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAppsResponse
 */
export class GetAppsResponse extends Message<GetAppsResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.App agents = 1;
   */
  agents: App[] = [];

  /**
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * @generated from field: string start_key = 3;
   */
  startKey = "";

  constructor(data?: PartialMessage<GetAppsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAppsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "agents", kind: "message", T: App, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppsResponse {
    return new GetAppsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppsResponse {
    return new GetAppsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppsResponse {
    return new GetAppsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppsResponse | PlainMessage<GetAppsResponse> | undefined, b: GetAppsResponse | PlainMessage<GetAppsResponse> | undefined): boolean {
    return proto3.util.equals(GetAppsResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetAuthSettingsRequest
 */
export class GetAuthSettingsRequest extends Message<GetAuthSettingsRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<GetAuthSettingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetAuthSettingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAuthSettingsRequest {
    return new GetAuthSettingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAuthSettingsRequest {
    return new GetAuthSettingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAuthSettingsRequest {
    return new GetAuthSettingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAuthSettingsRequest | PlainMessage<GetAuthSettingsRequest> | undefined, b: GetAuthSettingsRequest | PlainMessage<GetAuthSettingsRequest> | undefined): boolean {
    return proto3.util.equals(GetAuthSettingsRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest
 */
export class UpdateTshdEventsServerAddressRequest extends Message<UpdateTshdEventsServerAddressRequest> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<UpdateTshdEventsServerAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTshdEventsServerAddressRequest {
    return new UpdateTshdEventsServerAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTshdEventsServerAddressRequest {
    return new UpdateTshdEventsServerAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTshdEventsServerAddressRequest {
    return new UpdateTshdEventsServerAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTshdEventsServerAddressRequest | PlainMessage<UpdateTshdEventsServerAddressRequest> | undefined, b: UpdateTshdEventsServerAddressRequest | PlainMessage<UpdateTshdEventsServerAddressRequest> | undefined): boolean {
    return proto3.util.equals(UpdateTshdEventsServerAddressRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse
 */
export class UpdateTshdEventsServerAddressResponse extends Message<UpdateTshdEventsServerAddressResponse> {
  constructor(data?: PartialMessage<UpdateTshdEventsServerAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTshdEventsServerAddressResponse {
    return new UpdateTshdEventsServerAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTshdEventsServerAddressResponse {
    return new UpdateTshdEventsServerAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTshdEventsServerAddressResponse {
    return new UpdateTshdEventsServerAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTshdEventsServerAddressResponse | PlainMessage<UpdateTshdEventsServerAddressResponse> | undefined, b: UpdateTshdEventsServerAddressResponse | PlainMessage<UpdateTshdEventsServerAddressResponse> | undefined): boolean {
    return proto3.util.equals(UpdateTshdEventsServerAddressResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest
 */
export class UpdateHeadlessAuthenticationStateRequest extends Message<UpdateHeadlessAuthenticationStateRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string headless_authentication_id = 2;
   */
  headlessAuthenticationId = "";

  /**
   * @generated from field: teleport.lib.teleterm.v1.HeadlessAuthenticationState state = 3;
   */
  state = HeadlessAuthenticationState.UNSPECIFIED;

  constructor(data?: PartialMessage<UpdateHeadlessAuthenticationStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "headless_authentication_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(HeadlessAuthenticationState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateHeadlessAuthenticationStateRequest | PlainMessage<UpdateHeadlessAuthenticationStateRequest> | undefined, b: UpdateHeadlessAuthenticationStateRequest | PlainMessage<UpdateHeadlessAuthenticationStateRequest> | undefined): boolean {
    return proto3.util.equals(UpdateHeadlessAuthenticationStateRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse
 */
export class UpdateHeadlessAuthenticationStateResponse extends Message<UpdateHeadlessAuthenticationStateResponse> {
  constructor(data?: PartialMessage<UpdateHeadlessAuthenticationStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateHeadlessAuthenticationStateResponse {
    return new UpdateHeadlessAuthenticationStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateResponse {
    return new UpdateHeadlessAuthenticationStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateResponse {
    return new UpdateHeadlessAuthenticationStateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateHeadlessAuthenticationStateResponse | PlainMessage<UpdateHeadlessAuthenticationStateResponse> | undefined, b: UpdateHeadlessAuthenticationStateResponse | PlainMessage<UpdateHeadlessAuthenticationStateResponse> | undefined): boolean {
    return proto3.util.equals(UpdateHeadlessAuthenticationStateResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest
 */
export class CreateConnectMyComputerRoleRequest extends Message<CreateConnectMyComputerRoleRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<CreateConnectMyComputerRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectMyComputerRoleRequest {
    return new CreateConnectMyComputerRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectMyComputerRoleRequest {
    return new CreateConnectMyComputerRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectMyComputerRoleRequest {
    return new CreateConnectMyComputerRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectMyComputerRoleRequest | PlainMessage<CreateConnectMyComputerRoleRequest> | undefined, b: CreateConnectMyComputerRoleRequest | PlainMessage<CreateConnectMyComputerRoleRequest> | undefined): boolean {
    return proto3.util.equals(CreateConnectMyComputerRoleRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse
 */
export class CreateConnectMyComputerRoleResponse extends Message<CreateConnectMyComputerRoleResponse> {
  /**
   * certs_reloaded signals to the Electron app that tshd has reloaded the certs in order to refresh
   * the role list. The Electron app should refresh the details from the user cert as well.
   *
   * @generated from field: bool certs_reloaded = 1;
   */
  certsReloaded = false;

  constructor(data?: PartialMessage<CreateConnectMyComputerRoleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "certs_reloaded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectMyComputerRoleResponse {
    return new CreateConnectMyComputerRoleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectMyComputerRoleResponse {
    return new CreateConnectMyComputerRoleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectMyComputerRoleResponse {
    return new CreateConnectMyComputerRoleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectMyComputerRoleResponse | PlainMessage<CreateConnectMyComputerRoleResponse> | undefined, b: CreateConnectMyComputerRoleResponse | PlainMessage<CreateConnectMyComputerRoleResponse> | undefined): boolean {
    return proto3.util.equals(CreateConnectMyComputerRoleResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest
 */
export class CreateConnectMyComputerNodeTokenRequest extends Message<CreateConnectMyComputerNodeTokenRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<CreateConnectMyComputerNodeTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectMyComputerNodeTokenRequest {
    return new CreateConnectMyComputerNodeTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectMyComputerNodeTokenRequest {
    return new CreateConnectMyComputerNodeTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectMyComputerNodeTokenRequest {
    return new CreateConnectMyComputerNodeTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectMyComputerNodeTokenRequest | PlainMessage<CreateConnectMyComputerNodeTokenRequest> | undefined, b: CreateConnectMyComputerNodeTokenRequest | PlainMessage<CreateConnectMyComputerNodeTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreateConnectMyComputerNodeTokenRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse
 */
export class CreateConnectMyComputerNodeTokenResponse extends Message<CreateConnectMyComputerNodeTokenResponse> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<CreateConnectMyComputerNodeTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectMyComputerNodeTokenResponse {
    return new CreateConnectMyComputerNodeTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectMyComputerNodeTokenResponse {
    return new CreateConnectMyComputerNodeTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectMyComputerNodeTokenResponse {
    return new CreateConnectMyComputerNodeTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectMyComputerNodeTokenResponse | PlainMessage<CreateConnectMyComputerNodeTokenResponse> | undefined, b: CreateConnectMyComputerNodeTokenResponse | PlainMessage<CreateConnectMyComputerNodeTokenResponse> | undefined): boolean {
    return proto3.util.equals(CreateConnectMyComputerNodeTokenResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest
 */
export class WaitForConnectMyComputerNodeJoinRequest extends Message<WaitForConnectMyComputerNodeJoinRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<WaitForConnectMyComputerNodeJoinRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForConnectMyComputerNodeJoinRequest {
    return new WaitForConnectMyComputerNodeJoinRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForConnectMyComputerNodeJoinRequest {
    return new WaitForConnectMyComputerNodeJoinRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForConnectMyComputerNodeJoinRequest {
    return new WaitForConnectMyComputerNodeJoinRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WaitForConnectMyComputerNodeJoinRequest | PlainMessage<WaitForConnectMyComputerNodeJoinRequest> | undefined, b: WaitForConnectMyComputerNodeJoinRequest | PlainMessage<WaitForConnectMyComputerNodeJoinRequest> | undefined): boolean {
    return proto3.util.equals(WaitForConnectMyComputerNodeJoinRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse
 */
export class WaitForConnectMyComputerNodeJoinResponse extends Message<WaitForConnectMyComputerNodeJoinResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.Server server = 1;
   */
  server?: Server;

  constructor(data?: PartialMessage<WaitForConnectMyComputerNodeJoinResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server", kind: "message", T: Server },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WaitForConnectMyComputerNodeJoinResponse {
    return new WaitForConnectMyComputerNodeJoinResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WaitForConnectMyComputerNodeJoinResponse {
    return new WaitForConnectMyComputerNodeJoinResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WaitForConnectMyComputerNodeJoinResponse {
    return new WaitForConnectMyComputerNodeJoinResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WaitForConnectMyComputerNodeJoinResponse | PlainMessage<WaitForConnectMyComputerNodeJoinResponse> | undefined, b: WaitForConnectMyComputerNodeJoinResponse | PlainMessage<WaitForConnectMyComputerNodeJoinResponse> | undefined): boolean {
    return proto3.util.equals(WaitForConnectMyComputerNodeJoinResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest
 */
export class DeleteConnectMyComputerNodeRequest extends Message<DeleteConnectMyComputerNodeRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<DeleteConnectMyComputerNodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteConnectMyComputerNodeRequest {
    return new DeleteConnectMyComputerNodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteConnectMyComputerNodeRequest {
    return new DeleteConnectMyComputerNodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteConnectMyComputerNodeRequest {
    return new DeleteConnectMyComputerNodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteConnectMyComputerNodeRequest | PlainMessage<DeleteConnectMyComputerNodeRequest> | undefined, b: DeleteConnectMyComputerNodeRequest | PlainMessage<DeleteConnectMyComputerNodeRequest> | undefined): boolean {
    return proto3.util.equals(DeleteConnectMyComputerNodeRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse
 */
export class DeleteConnectMyComputerNodeResponse extends Message<DeleteConnectMyComputerNodeResponse> {
  constructor(data?: PartialMessage<DeleteConnectMyComputerNodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteConnectMyComputerNodeResponse {
    return new DeleteConnectMyComputerNodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteConnectMyComputerNodeResponse {
    return new DeleteConnectMyComputerNodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteConnectMyComputerNodeResponse {
    return new DeleteConnectMyComputerNodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteConnectMyComputerNodeResponse | PlainMessage<DeleteConnectMyComputerNodeResponse> | undefined, b: DeleteConnectMyComputerNodeResponse | PlainMessage<DeleteConnectMyComputerNodeResponse> | undefined): boolean {
    return proto3.util.equals(DeleteConnectMyComputerNodeResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest
 */
export class GetConnectMyComputerNodeNameRequest extends Message<GetConnectMyComputerNodeNameRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<GetConnectMyComputerNodeNameRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectMyComputerNodeNameRequest {
    return new GetConnectMyComputerNodeNameRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectMyComputerNodeNameRequest {
    return new GetConnectMyComputerNodeNameRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectMyComputerNodeNameRequest {
    return new GetConnectMyComputerNodeNameRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectMyComputerNodeNameRequest | PlainMessage<GetConnectMyComputerNodeNameRequest> | undefined, b: GetConnectMyComputerNodeNameRequest | PlainMessage<GetConnectMyComputerNodeNameRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectMyComputerNodeNameRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse
 */
export class GetConnectMyComputerNodeNameResponse extends Message<GetConnectMyComputerNodeNameResponse> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetConnectMyComputerNodeNameResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectMyComputerNodeNameResponse {
    return new GetConnectMyComputerNodeNameResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectMyComputerNodeNameResponse {
    return new GetConnectMyComputerNodeNameResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectMyComputerNodeNameResponse {
    return new GetConnectMyComputerNodeNameResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectMyComputerNodeNameResponse | PlainMessage<GetConnectMyComputerNodeNameResponse> | undefined, b: GetConnectMyComputerNodeNameResponse | PlainMessage<GetConnectMyComputerNodeNameResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectMyComputerNodeNameResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListUnifiedResourcesRequest
 */
export class ListUnifiedResourcesRequest extends Message<ListUnifiedResourcesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * A list of kinds to match against a resource's kind. This can be used in a
   * unified resource request that can include multiple types.
   *
   * @generated from field: repeated string kinds = 2;
   */
  kinds: string[] = [];

  /**
   * The maximum number of resources to retrieve.
   *
   * @generated from field: int32 limit = 3;
   */
  limit = 0;

  /**
   * Starts listing resources from a specific spot.
   * It should be set to the next_key from ListUnifiedResourcesResponse if
   * using pagination, or left empty.
   *
   * @generated from field: string start_key = 4;
   */
  startKey = "";

  /**
   * If defined, the advanced search is used. The search field should be left empty.
   *
   * @generated from field: string query = 5;
   */
  query = "";

  /**
   * If defined, the regular search is used. The query field should be left empty.
   *
   * @generated from field: string search = 6;
   */
  search = "";

  /**
   * SortBy describes which resource field and which direction to sort by.
   *
   * @generated from field: teleport.lib.teleterm.v1.SortBy sort_by = 7;
   */
  sortBy?: SortBy;

  /**
   * When true, all resources that the user can request access to are returned.
   *
   * @generated from field: bool search_as_roles = 8;
   */
  searchAsRoles = false;

  /**
   * Only the pinned resources will be returned for the requesting user.
   *
   * @generated from field: bool pinned_only = 9;
   */
  pinnedOnly = false;

  /**
   * include_requestable indicates that the response should include resources that the user must request access to.
   *
   * @generated from field: bool include_requestable = 10;
   */
  includeRequestable = false;

  constructor(data?: PartialMessage<ListUnifiedResourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListUnifiedResourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "start_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "search", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "sort_by", kind: "message", T: SortBy },
    { no: 8, name: "search_as_roles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "pinned_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "include_requestable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListUnifiedResourcesRequest | PlainMessage<ListUnifiedResourcesRequest> | undefined, b: ListUnifiedResourcesRequest | PlainMessage<ListUnifiedResourcesRequest> | undefined): boolean {
    return proto3.util.equals(ListUnifiedResourcesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.SortBy
 */
export class SortBy extends Message<SortBy> {
  /**
   * A sort direction flag where if true the direction is descending, else ascending.
   *
   * @generated from field: bool is_desc = 1;
   */
  isDesc = false;

  /**
   * Name of an object's field to sort by. Resources can be sorted by name and kind.
   *
   * @generated from field: string field = 2;
   */
  field = "";

  constructor(data?: PartialMessage<SortBy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SortBy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_desc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortBy {
    return new SortBy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortBy {
    return new SortBy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortBy {
    return new SortBy().fromJsonString(jsonString, options);
  }

  static equals(a: SortBy | PlainMessage<SortBy> | undefined, b: SortBy | PlainMessage<SortBy> | undefined): boolean {
    return proto3.util.equals(SortBy, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.ListUnifiedResourcesResponse
 */
export class ListUnifiedResourcesResponse extends Message<ListUnifiedResourcesResponse> {
  /**
   * @generated from field: repeated teleport.lib.teleterm.v1.PaginatedResource resources = 1;
   */
  resources: PaginatedResource[] = [];

  /**
   * A key to use as start_key in a ListResourcesRequest to continue retrieving
   * the next pages. If it is empty, there are no more pages.
   *
   * @generated from field: string next_key = 2;
   */
  nextKey = "";

  constructor(data?: PartialMessage<ListUnifiedResourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ListUnifiedResourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resources", kind: "message", T: PaginatedResource, repeated: true },
    { no: 2, name: "next_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListUnifiedResourcesResponse | PlainMessage<ListUnifiedResourcesResponse> | undefined, b: ListUnifiedResourcesResponse | PlainMessage<ListUnifiedResourcesResponse> | undefined): boolean {
    return proto3.util.equals(ListUnifiedResourcesResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.PaginatedResource
 */
export class PaginatedResource extends Message<PaginatedResource> {
  /**
   * @generated from oneof teleport.lib.teleterm.v1.PaginatedResource.resource
   */
  resource: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.Database database = 1;
     */
    value: Database;
    case: "database";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.Server server = 2;
     */
    value: Server;
    case: "server";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.Kube kube = 3;
     */
    value: Kube;
    case: "kube";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.App app = 4;
     */
    value: App;
    case: "app";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: bool requires_request = 5;
   */
  requiresRequest = false;

  constructor(data?: PartialMessage<PaginatedResource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.PaginatedResource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "message", T: Database, oneof: "resource" },
    { no: 2, name: "server", kind: "message", T: Server, oneof: "resource" },
    { no: 3, name: "kube", kind: "message", T: Kube, oneof: "resource" },
    { no: 4, name: "app", kind: "message", T: App, oneof: "resource" },
    { no: 5, name: "requires_request", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginatedResource {
    return new PaginatedResource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginatedResource {
    return new PaginatedResource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginatedResource {
    return new PaginatedResource().fromJsonString(jsonString, options);
  }

  static equals(a: PaginatedResource | PlainMessage<PaginatedResource> | undefined, b: PaginatedResource | PlainMessage<PaginatedResource> | undefined): boolean {
    return proto3.util.equals(PaginatedResource, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetUserPreferencesRequest
 */
export class GetUserPreferencesRequest extends Message<GetUserPreferencesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<GetUserPreferencesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetUserPreferencesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserPreferencesRequest {
    return new GetUserPreferencesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserPreferencesRequest {
    return new GetUserPreferencesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserPreferencesRequest {
    return new GetUserPreferencesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserPreferencesRequest | PlainMessage<GetUserPreferencesRequest> | undefined, b: GetUserPreferencesRequest | PlainMessage<GetUserPreferencesRequest> | undefined): boolean {
    return proto3.util.equals(GetUserPreferencesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.GetUserPreferencesResponse
 */
export class GetUserPreferencesResponse extends Message<GetUserPreferencesResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 1;
   */
  userPreferences?: UserPreferences;

  constructor(data?: PartialMessage<GetUserPreferencesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetUserPreferencesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_preferences", kind: "message", T: UserPreferences },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserPreferencesResponse {
    return new GetUserPreferencesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserPreferencesResponse {
    return new GetUserPreferencesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserPreferencesResponse {
    return new GetUserPreferencesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserPreferencesResponse | PlainMessage<GetUserPreferencesResponse> | undefined, b: GetUserPreferencesResponse | PlainMessage<GetUserPreferencesResponse> | undefined): boolean {
    return proto3.util.equals(GetUserPreferencesResponse, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateUserPreferencesRequest
 */
export class UpdateUserPreferencesRequest extends Message<UpdateUserPreferencesRequest> {
  /**
   * @generated from field: string cluster_uri = 1;
   */
  clusterUri = "";

  /**
   * @generated from field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 2;
   */
  userPreferences?: UserPreferences;

  constructor(data?: PartialMessage<UpdateUserPreferencesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateUserPreferencesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "user_preferences", kind: "message", T: UserPreferences },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateUserPreferencesRequest {
    return new UpdateUserPreferencesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateUserPreferencesRequest {
    return new UpdateUserPreferencesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateUserPreferencesRequest {
    return new UpdateUserPreferencesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateUserPreferencesRequest | PlainMessage<UpdateUserPreferencesRequest> | undefined, b: UpdateUserPreferencesRequest | PlainMessage<UpdateUserPreferencesRequest> | undefined): boolean {
    return proto3.util.equals(UpdateUserPreferencesRequest, a, b);
  }
}

/**
 * @generated from message teleport.lib.teleterm.v1.UpdateUserPreferencesResponse
 */
export class UpdateUserPreferencesResponse extends Message<UpdateUserPreferencesResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.UserPreferences user_preferences = 1;
   */
  userPreferences?: UserPreferences;

  constructor(data?: PartialMessage<UpdateUserPreferencesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UpdateUserPreferencesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_preferences", kind: "message", T: UserPreferences },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateUserPreferencesResponse {
    return new UpdateUserPreferencesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateUserPreferencesResponse {
    return new UpdateUserPreferencesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateUserPreferencesResponse {
    return new UpdateUserPreferencesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateUserPreferencesResponse | PlainMessage<UpdateUserPreferencesResponse> | undefined, b: UpdateUserPreferencesResponse | PlainMessage<UpdateUserPreferencesResponse> | undefined): boolean {
    return proto3.util.equals(UpdateUserPreferencesResponse, a, b);
  }
}

/**
 * UserPreferences is a subset of teleport.userpreferences.v1.UserPreferences.
 * It contains preferences that are relevant to Connect.
 *
 * @generated from message teleport.lib.teleterm.v1.UserPreferences
 */
export class UserPreferences extends Message<UserPreferences> {
  /**
   * @generated from field: teleport.userpreferences.v1.ClusterUserPreferences cluster_preferences = 1;
   */
  clusterPreferences?: ClusterUserPreferences;

  /**
   * @generated from field: teleport.userpreferences.v1.UnifiedResourcePreferences unified_resource_preferences = 2;
   */
  unifiedResourcePreferences?: UnifiedResourcePreferences;

  constructor(data?: PartialMessage<UserPreferences>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UserPreferences";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_preferences", kind: "message", T: ClusterUserPreferences },
    { no: 2, name: "unified_resource_preferences", kind: "message", T: UnifiedResourcePreferences },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserPreferences {
    return new UserPreferences().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserPreferences {
    return new UserPreferences().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserPreferences {
    return new UserPreferences().fromJsonString(jsonString, options);
  }

  static equals(a: UserPreferences | PlainMessage<UserPreferences> | undefined, b: UserPreferences | PlainMessage<UserPreferences> | undefined): boolean {
    return proto3.util.equals(UserPreferences, a, b);
  }
}

/**
 * Request for AuthenticateWebDevice.
 *
 * @generated from message teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest
 */
export class AuthenticateWebDeviceRequest extends Message<AuthenticateWebDeviceRequest> {
  /**
   * Device web token to be spent in exchange for the device authentication
   * attempt.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceWebToken device_web_token = 1;
   */
  deviceWebToken?: DeviceWebToken;

  /**
   * @generated from field: string root_cluster_uri = 2;
   */
  rootClusterUri = "";

  constructor(data?: PartialMessage<AuthenticateWebDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.AuthenticateWebDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "device_web_token", kind: "message", T: DeviceWebToken },
    { no: 2, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateWebDeviceRequest {
    return new AuthenticateWebDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateWebDeviceRequest {
    return new AuthenticateWebDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateWebDeviceRequest {
    return new AuthenticateWebDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateWebDeviceRequest | PlainMessage<AuthenticateWebDeviceRequest> | undefined, b: AuthenticateWebDeviceRequest | PlainMessage<AuthenticateWebDeviceRequest> | undefined): boolean {
    return proto3.util.equals(AuthenticateWebDeviceRequest, a, b);
  }
}

/**
 * Response for AuthenticateWebDevice.
 *
 * @generated from message teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse
 */
export class AuthenticateWebDeviceResponse extends Message<AuthenticateWebDeviceResponse> {
  /**
   * Device confirmation token to be sent to the browser that originated the
   * authentication attempt.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1;
   */
  confirmationToken?: DeviceConfirmationToken;

  constructor(data?: PartialMessage<AuthenticateWebDeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.AuthenticateWebDeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "confirmation_token", kind: "message", T: DeviceConfirmationToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateWebDeviceResponse {
    return new AuthenticateWebDeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateWebDeviceResponse {
    return new AuthenticateWebDeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateWebDeviceResponse {
    return new AuthenticateWebDeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateWebDeviceResponse | PlainMessage<AuthenticateWebDeviceResponse> | undefined, b: AuthenticateWebDeviceResponse | PlainMessage<AuthenticateWebDeviceResponse> | undefined): boolean {
    return proto3.util.equals(AuthenticateWebDeviceResponse, a, b);
  }
}

