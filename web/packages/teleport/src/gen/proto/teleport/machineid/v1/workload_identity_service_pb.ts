// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/machineid/v1/workload_identity_service.proto (package teleport.machineid.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * The request for an individual x509 SVID.
 *
 * @generated from message teleport.machineid.v1.SVIDRequest
 */
export class SVIDRequest extends Message<SVIDRequest> {
  /**
   * A PKIX, ASN.1 DER encoded public key that should be included in the x509
   * SVID.
   * Required.
   *
   * @generated from field: bytes public_key = 1;
   */
  publicKey = new Uint8Array(0);

  /**
   * The path that should be included in the SPIFFE ID.
   * This should have a preceding slash and should not have a trailing slash.
   * Required.
   *
   * @generated from field: string spiffe_id_path = 2;
   */
  spiffeIdPath = "";

  /**
   * The DNS SANs that should be included in the x509 SVID.
   * Optional.
   *
   * @generated from field: repeated string dns_sans = 3;
   */
  dnsSans: string[] = [];

  /**
   * The IP SANs that should be included in the x509 SVID.
   * Optional.
   *
   * @generated from field: repeated string ip_sans = 4;
   */
  ipSans: string[] = [];

  /**
   * A hint that provides a way of distinguishing between SVIDs. These are
   * user configured and are sent back to the actual workload.
   * Optional.
   *
   * @generated from field: string hint = 5;
   */
  hint = "";

  /**
   * The TTL to use for the x509 SVID. A maximum value is enforced on this
   * field. Callers should inspect the returned cert to determine if their
   * requested TTL has been met, and if not, adjust their behaviour. If not
   * supplied, the default TTL will be the maximum value.
   *
   * @generated from field: google.protobuf.Duration ttl = 6;
   */
  ttl?: Duration;

  constructor(data?: PartialMessage<SVIDRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.SVIDRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "spiffe_id_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dns_sans", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ip_sans", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "hint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ttl", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SVIDRequest {
    return new SVIDRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SVIDRequest {
    return new SVIDRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SVIDRequest {
    return new SVIDRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SVIDRequest | PlainMessage<SVIDRequest> | undefined, b: SVIDRequest | PlainMessage<SVIDRequest> | undefined): boolean {
    return proto3.util.equals(SVIDRequest, a, b);
  }
}

/**
 * The generated x509 SVID.
 *
 * @generated from message teleport.machineid.v1.SVIDResponse
 */
export class SVIDResponse extends Message<SVIDResponse> {
  /**
   * A ASN.1 DER encoded x509 SVID.
   *
   * @generated from field: bytes certificate = 1;
   */
  certificate = new Uint8Array(0);

  /**
   * The full SPIFFE ID that was included in the x509 SVID.
   *
   * @generated from field: string spiffe_id = 2;
   */
  spiffeId = "";

  /**
   * The hint that was included in SVIDRequest in order to allow a workload to
   * distinguish an individual SVID.
   *
   * @generated from field: string hint = 3;
   */
  hint = "";

  constructor(data?: PartialMessage<SVIDResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.SVIDResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "certificate", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "spiffe_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SVIDResponse {
    return new SVIDResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SVIDResponse {
    return new SVIDResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SVIDResponse {
    return new SVIDResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SVIDResponse | PlainMessage<SVIDResponse> | undefined, b: SVIDResponse | PlainMessage<SVIDResponse> | undefined): boolean {
    return proto3.util.equals(SVIDResponse, a, b);
  }
}

/**
 * The request for SignX509SVIDs.
 *
 * @generated from message teleport.machineid.v1.SignX509SVIDsRequest
 */
export class SignX509SVIDsRequest extends Message<SignX509SVIDsRequest> {
  /**
   * The SVIDs that should be generated. This is repeated to allow a bot to
   * request multiple SVIDs at once and reduce the number of round trips.
   * Must be non-zero length.
   *
   * @generated from field: repeated teleport.machineid.v1.SVIDRequest svids = 1;
   */
  svids: SVIDRequest[] = [];

  constructor(data?: PartialMessage<SignX509SVIDsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.SignX509SVIDsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "svids", kind: "message", T: SVIDRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignX509SVIDsRequest {
    return new SignX509SVIDsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignX509SVIDsRequest {
    return new SignX509SVIDsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignX509SVIDsRequest {
    return new SignX509SVIDsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SignX509SVIDsRequest | PlainMessage<SignX509SVIDsRequest> | undefined, b: SignX509SVIDsRequest | PlainMessage<SignX509SVIDsRequest> | undefined): boolean {
    return proto3.util.equals(SignX509SVIDsRequest, a, b);
  }
}

/**
 * The response for SignX509SVIDs.
 *
 * @generated from message teleport.machineid.v1.SignX509SVIDsResponse
 */
export class SignX509SVIDsResponse extends Message<SignX509SVIDsResponse> {
  /**
   * The generated SVIDs.
   *
   * @generated from field: repeated teleport.machineid.v1.SVIDResponse svids = 1;
   */
  svids: SVIDResponse[] = [];

  constructor(data?: PartialMessage<SignX509SVIDsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.SignX509SVIDsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "svids", kind: "message", T: SVIDResponse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignX509SVIDsResponse {
    return new SignX509SVIDsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignX509SVIDsResponse {
    return new SignX509SVIDsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignX509SVIDsResponse {
    return new SignX509SVIDsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SignX509SVIDsResponse | PlainMessage<SignX509SVIDsResponse> | undefined, b: SignX509SVIDsResponse | PlainMessage<SignX509SVIDsResponse> | undefined): boolean {
    return proto3.util.equals(SignX509SVIDsResponse, a, b);
  }
}

