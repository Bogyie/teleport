// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file teleport/accesslist/v1/accesslist.proto (package teleport.accesslist.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { ResourceHeader } from "../../header/v1/resourceheader_pb";
import { Trait } from "../../trait/v1/trait_pb";

/**
 * ReviewFrequency is the frequency of reviews.
 *
 * @generated from enum teleport.accesslist.v1.ReviewFrequency
 */
export enum ReviewFrequency {
  /**
   * @generated from enum value: REVIEW_FREQUENCY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_ONE_MONTH = 1;
   */
  ONE_MONTH = 1,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_THREE_MONTHS = 3;
   */
  THREE_MONTHS = 3,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_SIX_MONTHS = 6;
   */
  SIX_MONTHS = 6,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_ONE_YEAR = 12;
   */
  ONE_YEAR = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(ReviewFrequency)
proto3.util.setEnumType(ReviewFrequency, "teleport.accesslist.v1.ReviewFrequency", [
  { no: 0, name: "REVIEW_FREQUENCY_UNSPECIFIED" },
  { no: 1, name: "REVIEW_FREQUENCY_ONE_MONTH" },
  { no: 3, name: "REVIEW_FREQUENCY_THREE_MONTHS" },
  { no: 6, name: "REVIEW_FREQUENCY_SIX_MONTHS" },
  { no: 12, name: "REVIEW_FREQUENCY_ONE_YEAR" },
]);

/**
 * ReviewDayOfMonth is the day of month that reviews will repeat on.
 *
 * @generated from enum teleport.accesslist.v1.ReviewDayOfMonth
 */
export enum ReviewDayOfMonth {
  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_FIRST = 1;
   */
  FIRST = 1,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_FIFTEENTH = 15;
   */
  FIFTEENTH = 15,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_LAST = 31;
   */
  LAST = 31,
}
// Retrieve enum metadata with: proto3.getEnumType(ReviewDayOfMonth)
proto3.util.setEnumType(ReviewDayOfMonth, "teleport.accesslist.v1.ReviewDayOfMonth", [
  { no: 0, name: "REVIEW_DAY_OF_MONTH_UNSPECIFIED" },
  { no: 1, name: "REVIEW_DAY_OF_MONTH_FIRST" },
  { no: 15, name: "REVIEW_DAY_OF_MONTH_FIFTEENTH" },
  { no: 31, name: "REVIEW_DAY_OF_MONTH_LAST" },
]);

/**
 * IneligibleStatus describes how the user is ineligible.
 *
 * @generated from enum teleport.accesslist.v1.IneligibleStatus
 */
export enum IneligibleStatus {
  /**
   * INELIGIBLE_STATUS_UNSPECIFIED means eligiblity is unknown.
   *
   * @generated from enum value: INELIGIBLE_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * INELIGIBLE_STATUS_ELIGIBLE means checks were done and user met all
   * requirements.
   *
   * @generated from enum value: INELIGIBLE_STATUS_ELIGIBLE = 1;
   */
  ELIGIBLE = 1,

  /**
   * INELIGIBLE_STATUS_USER_NOT_EXIST means user was not found in backend.
   *
   * @generated from enum value: INELIGIBLE_STATUS_USER_NOT_EXIST = 2;
   */
  USER_NOT_EXIST = 2,

  /**
   * INELIGIBLE_STATUS_MISSING_REQUIREMENTS means user is missing some
   * requirements defined by AccessListRequires (fields can be either
   * ownership_requires or membership_requires)
   *
   * @generated from enum value: INELIGIBLE_STATUS_MISSING_REQUIREMENTS = 3;
   */
  MISSING_REQUIREMENTS = 3,

  /**
   * INELIGIBLE_STATUS_EXPIRED means user is expired.
   * Only applicable to members.
   *
   * @generated from enum value: INELIGIBLE_STATUS_EXPIRED = 4;
   */
  EXPIRED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(IneligibleStatus)
proto3.util.setEnumType(IneligibleStatus, "teleport.accesslist.v1.IneligibleStatus", [
  { no: 0, name: "INELIGIBLE_STATUS_UNSPECIFIED" },
  { no: 1, name: "INELIGIBLE_STATUS_ELIGIBLE" },
  { no: 2, name: "INELIGIBLE_STATUS_USER_NOT_EXIST" },
  { no: 3, name: "INELIGIBLE_STATUS_MISSING_REQUIREMENTS" },
  { no: 4, name: "INELIGIBLE_STATUS_EXPIRED" },
]);

/**
 * AccessList describes the basic building block of access grants, which are
 * similar to access requests but for longer lived permissions that need to be
 * regularly audited.
 *
 * @generated from message teleport.accesslist.v1.AccessList
 */
export class AccessList extends Message<AccessList> {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListSpec spec = 2;
   */
  spec?: AccessListSpec;

  /**
   * status contains dynamically calculated fields.
   *
   * @generated from field: teleport.accesslist.v1.AccessListStatus status = 3;
   */
  status?: AccessListStatus;

  constructor(data?: PartialMessage<AccessList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResourceHeader },
    { no: 2, name: "spec", kind: "message", T: AccessListSpec },
    { no: 3, name: "status", kind: "message", T: AccessListStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessList {
    return new AccessList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessList {
    return new AccessList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessList {
    return new AccessList().fromJsonString(jsonString, options);
  }

  static equals(a: AccessList | PlainMessage<AccessList> | undefined, b: AccessList | PlainMessage<AccessList> | undefined): boolean {
    return proto3.util.equals(AccessList, a, b);
  }
}

/**
 * AccessListSpec is the specification for an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListSpec
 */
export class AccessListSpec extends Message<AccessListSpec> {
  /**
   * description is an optional plaintext description of the access list.
   *
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * owners is a list of owners of the access list.
   *
   * @generated from field: repeated teleport.accesslist.v1.AccessListOwner owners = 2;
   */
  owners: AccessListOwner[] = [];

  /**
   * audit describes the frequency that this access list must be audited.
   *
   * @generated from field: teleport.accesslist.v1.AccessListAudit audit = 3;
   */
  audit?: AccessListAudit;

  /**
   * membership_requires describes the requirements for a user to be a member of
   * the access list. For a membership to an access list to be effective, the
   * user must meet the requirements of Membership_requires and must be in the
   * members list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires membership_requires = 4;
   */
  membershipRequires?: AccessListRequires;

  /**
   * ownership_requires describes the requirements for a user to be an owner of
   * the access list. For ownership of an access list to be effective, the user
   * must meet the requirements of ownership_requires and must be in the owners
   * list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires ownership_requires = 5;
   */
  ownershipRequires?: AccessListRequires;

  /**
   * grants describes the access granted by membership to this access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListGrants grants = 6;
   */
  grants?: AccessListGrants;

  /**
   * title is a plaintext short description of the access list.
   *
   * @generated from field: string title = 8;
   */
  title = "";

  /**
   * owner_grants describes the access granted by owners to this access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListGrants owner_grants = 11;
   */
  ownerGrants?: AccessListGrants;

  constructor(data?: PartialMessage<AccessListSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owners", kind: "message", T: AccessListOwner, repeated: true },
    { no: 3, name: "audit", kind: "message", T: AccessListAudit },
    { no: 4, name: "membership_requires", kind: "message", T: AccessListRequires },
    { no: 5, name: "ownership_requires", kind: "message", T: AccessListRequires },
    { no: 6, name: "grants", kind: "message", T: AccessListGrants },
    { no: 8, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "owner_grants", kind: "message", T: AccessListGrants },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListSpec {
    return new AccessListSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListSpec {
    return new AccessListSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListSpec {
    return new AccessListSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListSpec | PlainMessage<AccessListSpec> | undefined, b: AccessListSpec | PlainMessage<AccessListSpec> | undefined): boolean {
    return proto3.util.equals(AccessListSpec, a, b);
  }
}

/**
 * AccessListOwner is an owner of an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListOwner
 */
export class AccessListOwner extends Message<AccessListOwner> {
  /**
   * name is the username of the owner.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * description is the plaintext description of the owner and why they are an
   * owner.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * ineligible_status describes if this owner is eligible or not
   * and if not, describes how they're lacking eligibility.
   *
   * @generated from field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 3;
   */
  ineligibleStatus = IneligibleStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<AccessListOwner>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListOwner";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ineligible_status", kind: "enum", T: proto3.getEnumType(IneligibleStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListOwner {
    return new AccessListOwner().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListOwner {
    return new AccessListOwner().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListOwner {
    return new AccessListOwner().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListOwner | PlainMessage<AccessListOwner> | undefined, b: AccessListOwner | PlainMessage<AccessListOwner> | undefined): boolean {
    return proto3.util.equals(AccessListOwner, a, b);
  }
}

/**
 * AccessListAudit describes the audit configuration for an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListAudit
 */
export class AccessListAudit extends Message<AccessListAudit> {
  /**
   * next_audit_date is when the next audit date should be done by.
   *
   * @generated from field: google.protobuf.Timestamp next_audit_date = 2;
   */
  nextAuditDate?: Timestamp;

  /**
   * recurrence is the recurrence definition
   *
   * @generated from field: teleport.accesslist.v1.Recurrence recurrence = 3;
   */
  recurrence?: Recurrence;

  /**
   * notifications is the configuration for notifying users.
   *
   * @generated from field: teleport.accesslist.v1.Notifications notifications = 4;
   */
  notifications?: Notifications;

  constructor(data?: PartialMessage<AccessListAudit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListAudit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "next_audit_date", kind: "message", T: Timestamp },
    { no: 3, name: "recurrence", kind: "message", T: Recurrence },
    { no: 4, name: "notifications", kind: "message", T: Notifications },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListAudit {
    return new AccessListAudit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListAudit {
    return new AccessListAudit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListAudit {
    return new AccessListAudit().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListAudit | PlainMessage<AccessListAudit> | undefined, b: AccessListAudit | PlainMessage<AccessListAudit> | undefined): boolean {
    return proto3.util.equals(AccessListAudit, a, b);
  }
}

/**
 * Recurrence is the definition for when reviews will be scheduled.
 *
 * @generated from message teleport.accesslist.v1.Recurrence
 */
export class Recurrence extends Message<Recurrence> {
  /**
   * frequency is the frequency of reviews. This represents the period in months
   * between two reviews.
   * Supported values are 0, 1, 3, 6, and 12.
   *
   * @generated from field: teleport.accesslist.v1.ReviewFrequency frequency = 1;
   */
  frequency = ReviewFrequency.UNSPECIFIED;

  /**
   * day_of_month is the day of month that reviews will be scheduled on.
   * Supported values are 0, 1, 15, and 31.
   *
   * @generated from field: teleport.accesslist.v1.ReviewDayOfMonth day_of_month = 2;
   */
  dayOfMonth = ReviewDayOfMonth.UNSPECIFIED;

  constructor(data?: PartialMessage<Recurrence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.Recurrence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "frequency", kind: "enum", T: proto3.getEnumType(ReviewFrequency) },
    { no: 2, name: "day_of_month", kind: "enum", T: proto3.getEnumType(ReviewDayOfMonth) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Recurrence {
    return new Recurrence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Recurrence {
    return new Recurrence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Recurrence {
    return new Recurrence().fromJsonString(jsonString, options);
  }

  static equals(a: Recurrence | PlainMessage<Recurrence> | undefined, b: Recurrence | PlainMessage<Recurrence> | undefined): boolean {
    return proto3.util.equals(Recurrence, a, b);
  }
}

/**
 * Notifications contains the configuration for notifying users of a nearing
 * next audit date.
 *
 * @generated from message teleport.accesslist.v1.Notifications
 */
export class Notifications extends Message<Notifications> {
  /**
   * start specifies when to start notifying users that the next audit date is
   * coming up.
   *
   * @generated from field: google.protobuf.Duration start = 1;
   */
  start?: Duration;

  constructor(data?: PartialMessage<Notifications>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.Notifications";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Notifications {
    return new Notifications().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Notifications {
    return new Notifications().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Notifications {
    return new Notifications().fromJsonString(jsonString, options);
  }

  static equals(a: Notifications | PlainMessage<Notifications> | undefined, b: Notifications | PlainMessage<Notifications> | undefined): boolean {
    return proto3.util.equals(Notifications, a, b);
  }
}

/**
 * AccessListRequires describes a requirement section for an access list. A user
 * must meet the following criteria to obtain the specific access to the list.
 *
 * @generated from message teleport.accesslist.v1.AccessListRequires
 */
export class AccessListRequires extends Message<AccessListRequires> {
  /**
   * roles are the user roles that must be present for the user to obtain
   * access.
   *
   * @generated from field: repeated string roles = 1;
   */
  roles: string[] = [];

  /**
   * traits are the traits that must be present for the user to obtain access.
   *
   * @generated from field: repeated teleport.trait.v1.Trait traits = 2;
   */
  traits: Trait[] = [];

  constructor(data?: PartialMessage<AccessListRequires>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListRequires";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "traits", kind: "message", T: Trait, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListRequires {
    return new AccessListRequires().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListRequires {
    return new AccessListRequires().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListRequires {
    return new AccessListRequires().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListRequires | PlainMessage<AccessListRequires> | undefined, b: AccessListRequires | PlainMessage<AccessListRequires> | undefined): boolean {
    return proto3.util.equals(AccessListRequires, a, b);
  }
}

/**
 * AccessListGrants describes what access is granted by membership to the access
 * list.
 *
 * @generated from message teleport.accesslist.v1.AccessListGrants
 */
export class AccessListGrants extends Message<AccessListGrants> {
  /**
   * roles are the roles that are granted to users who are members of the access
   * list.
   *
   * @generated from field: repeated string roles = 1;
   */
  roles: string[] = [];

  /**
   * traits are the traits that are granted to users who are members of the
   * access list.
   *
   * @generated from field: repeated teleport.trait.v1.Trait traits = 2;
   */
  traits: Trait[] = [];

  constructor(data?: PartialMessage<AccessListGrants>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListGrants";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "traits", kind: "message", T: Trait, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListGrants {
    return new AccessListGrants().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListGrants {
    return new AccessListGrants().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListGrants {
    return new AccessListGrants().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListGrants | PlainMessage<AccessListGrants> | undefined, b: AccessListGrants | PlainMessage<AccessListGrants> | undefined): boolean {
    return proto3.util.equals(AccessListGrants, a, b);
  }
}

/**
 * Member describes a member of an access list.
 *
 * @generated from message teleport.accesslist.v1.Member
 */
export class Member extends Message<Member> {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list member.
   *
   * @generated from field: teleport.accesslist.v1.MemberSpec spec = 2;
   */
  spec?: MemberSpec;

  constructor(data?: PartialMessage<Member>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.Member";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResourceHeader },
    { no: 2, name: "spec", kind: "message", T: MemberSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Member {
    return new Member().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Member {
    return new Member().fromJsonString(jsonString, options);
  }

  static equals(a: Member | PlainMessage<Member> | undefined, b: Member | PlainMessage<Member> | undefined): boolean {
    return proto3.util.equals(Member, a, b);
  }
}

/**
 * MemberSpec is the specification for an access list member.
 *
 * @generated from message teleport.accesslist.v1.MemberSpec
 */
export class MemberSpec extends Message<MemberSpec> {
  /**
   * associated access list
   *
   * @generated from field: string access_list = 1;
   */
  accessList = "";

  /**
   * name is the name of the member of the access list.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * joined is when the user joined the access list.
   *
   * @generated from field: google.protobuf.Timestamp joined = 3;
   */
  joined?: Timestamp;

  /**
   * expires is when the user's membership to the access list expires.
   *
   * @generated from field: google.protobuf.Timestamp expires = 4;
   */
  expires?: Timestamp;

  /**
   * reason is the reason this user was added to the access list.
   *
   * @generated from field: string reason = 5;
   */
  reason = "";

  /**
   * added_by is the user that added this user to the access list.
   *
   * @generated from field: string added_by = 6;
   */
  addedBy = "";

  /**
   * ineligible_status describes if this member is eligible or not
   * and if not, describes how they're lacking eligibility.
   *
   * @generated from field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 7;
   */
  ineligibleStatus = IneligibleStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<MemberSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.MemberSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_list", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "joined", kind: "message", T: Timestamp },
    { no: 4, name: "expires", kind: "message", T: Timestamp },
    { no: 5, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "added_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ineligible_status", kind: "enum", T: proto3.getEnumType(IneligibleStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberSpec {
    return new MemberSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberSpec {
    return new MemberSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberSpec {
    return new MemberSpec().fromJsonString(jsonString, options);
  }

  static equals(a: MemberSpec | PlainMessage<MemberSpec> | undefined, b: MemberSpec | PlainMessage<MemberSpec> | undefined): boolean {
    return proto3.util.equals(MemberSpec, a, b);
  }
}

/**
 * Review is a review of an access list.
 *
 * @generated from message teleport.accesslist.v1.Review
 */
export class Review extends Message<Review> {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list review.
   *
   * @generated from field: teleport.accesslist.v1.ReviewSpec spec = 2;
   */
  spec?: ReviewSpec;

  constructor(data?: PartialMessage<Review>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.Review";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResourceHeader },
    { no: 2, name: "spec", kind: "message", T: ReviewSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Review {
    return new Review().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Review {
    return new Review().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Review {
    return new Review().fromJsonString(jsonString, options);
  }

  static equals(a: Review | PlainMessage<Review> | undefined, b: Review | PlainMessage<Review> | undefined): boolean {
    return proto3.util.equals(Review, a, b);
  }
}

/**
 * ReviewSpec is the specification for an access list review.
 *
 * @generated from message teleport.accesslist.v1.ReviewSpec
 */
export class ReviewSpec extends Message<ReviewSpec> {
  /**
   * access_list is the name of the access list that this review is for.
   *
   * @generated from field: string access_list = 1;
   */
  accessList = "";

  /**
   * reviewers are the users who performed the review.
   *
   * @generated from field: repeated string reviewers = 2;
   */
  reviewers: string[] = [];

  /**
   * review_date is the date that this review was created.
   *
   * @generated from field: google.protobuf.Timestamp review_date = 3;
   */
  reviewDate?: Timestamp;

  /**
   * notes is an optional plaintext attached to the review that can be used by
   * the review for arbitrary note taking on the review.
   *
   * @generated from field: string notes = 4;
   */
  notes = "";

  /**
   * changes are the changes made as part of the review.
   *
   * @generated from field: teleport.accesslist.v1.ReviewChanges changes = 5;
   */
  changes?: ReviewChanges;

  constructor(data?: PartialMessage<ReviewSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.ReviewSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_list", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "review_date", kind: "message", T: Timestamp },
    { no: 4, name: "notes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "changes", kind: "message", T: ReviewChanges },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReviewSpec {
    return new ReviewSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReviewSpec {
    return new ReviewSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReviewSpec {
    return new ReviewSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ReviewSpec | PlainMessage<ReviewSpec> | undefined, b: ReviewSpec | PlainMessage<ReviewSpec> | undefined): boolean {
    return proto3.util.equals(ReviewSpec, a, b);
  }
}

/**
 * ReviewChanges are the changes that were made as part of the review.
 *
 * @generated from message teleport.accesslist.v1.ReviewChanges
 */
export class ReviewChanges extends Message<ReviewChanges> {
  /**
   * membership_requirements_changed is populated if the requirements were
   * changed as part of this review.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires membership_requirements_changed = 2;
   */
  membershipRequirementsChanged?: AccessListRequires;

  /**
   * removed_members contains the members that were removed as part of this
   * review.
   *
   * @generated from field: repeated string removed_members = 3;
   */
  removedMembers: string[] = [];

  /**
   * review_frequency_changed is populated if the review frequency has changed.
   *
   * @generated from field: teleport.accesslist.v1.ReviewFrequency review_frequency_changed = 4;
   */
  reviewFrequencyChanged = ReviewFrequency.UNSPECIFIED;

  /**
   * review_day_of_month_changed is populated if the review day of month has
   * changed.
   *
   * @generated from field: teleport.accesslist.v1.ReviewDayOfMonth review_day_of_month_changed = 5;
   */
  reviewDayOfMonthChanged = ReviewDayOfMonth.UNSPECIFIED;

  constructor(data?: PartialMessage<ReviewChanges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.ReviewChanges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "membership_requirements_changed", kind: "message", T: AccessListRequires },
    { no: 3, name: "removed_members", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "review_frequency_changed", kind: "enum", T: proto3.getEnumType(ReviewFrequency) },
    { no: 5, name: "review_day_of_month_changed", kind: "enum", T: proto3.getEnumType(ReviewDayOfMonth) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReviewChanges {
    return new ReviewChanges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReviewChanges {
    return new ReviewChanges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReviewChanges {
    return new ReviewChanges().fromJsonString(jsonString, options);
  }

  static equals(a: ReviewChanges | PlainMessage<ReviewChanges> | undefined, b: ReviewChanges | PlainMessage<ReviewChanges> | undefined): boolean {
    return proto3.util.equals(ReviewChanges, a, b);
  }
}

/**
 * AccessListStatus contains dynamic fields calculated during retrieval.
 *
 * @generated from message teleport.accesslist.v1.AccessListStatus
 */
export class AccessListStatus extends Message<AccessListStatus> {
  /**
   * member_count is the number of members in the in the access list.
   *
   * @generated from field: optional uint32 member_count = 1;
   */
  memberCount?: number;

  constructor(data?: PartialMessage<AccessListStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accesslist.v1.AccessListStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListStatus {
    return new AccessListStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListStatus {
    return new AccessListStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListStatus {
    return new AccessListStatus().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListStatus | PlainMessage<AccessListStatus> | undefined, b: AccessListStatus | PlainMessage<AccessListStatus> | undefined): boolean {
    return proto3.util.equals(AccessListStatus, a, b);
  }
}

