// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/machineid/v1/bot_instance.proto (package teleport.machineid.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import { Metadata } from "../../header/v1/metadata_pb.js";

/**
 * A BotInstance
 *
 * @generated from message teleport.machineid.v1.BotInstance
 */
export class BotInstance extends Message<BotInstance> {
  /**
   * The kind of resource represented.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * Differentiates variations of the same kind. All resources should
   * contain one, even if it is never populated.
   *
   * @generated from field: string sub_kind = 2;
   */
  subKind = "";

  /**
   * The version of the resource being represented.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * Common metadata that all resources share.
   *
   * @generated from field: teleport.header.v1.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * The configured properties of a BotInstance.
   *
   * @generated from field: teleport.machineid.v1.BotInstanceSpec spec = 5;
   */
  spec?: BotInstanceSpec;

  /**
   * Fields that are set by the server as results of operations. These should
   * not be modified by users.
   *
   * @generated from field: teleport.machineid.v1.BotInstanceStatus status = 6;
   */
  status?: BotInstanceStatus;

  constructor(data?: PartialMessage<BotInstance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.BotInstance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "spec", kind: "message", T: BotInstanceSpec },
    { no: 6, name: "status", kind: "message", T: BotInstanceStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotInstance {
    return new BotInstance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotInstance {
    return new BotInstance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotInstance {
    return new BotInstance().fromJsonString(jsonString, options);
  }

  static equals(a: BotInstance | PlainMessage<BotInstance> | undefined, b: BotInstance | PlainMessage<BotInstance> | undefined): boolean {
    return proto3.util.equals(BotInstance, a, b);
  }
}

/**
 * BotInstanceSpec contains fields
 *
 * @generated from message teleport.machineid.v1.BotInstanceSpec
 */
export class BotInstanceSpec extends Message<BotInstanceSpec> {
  /**
   * The name of the bot associated with this instance.
   *
   * @generated from field: string bot_name = 1;
   */
  botName = "";

  /**
   * The unique identifier for this instance.
   *
   * @generated from field: string instance_id = 2;
   */
  instanceId = "";

  constructor(data?: PartialMessage<BotInstanceSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.BotInstanceSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bot_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "instance_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotInstanceSpec {
    return new BotInstanceSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotInstanceSpec {
    return new BotInstanceSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotInstanceSpec {
    return new BotInstanceSpec().fromJsonString(jsonString, options);
  }

  static equals(a: BotInstanceSpec | PlainMessage<BotInstanceSpec> | undefined, b: BotInstanceSpec | PlainMessage<BotInstanceSpec> | undefined): boolean {
    return proto3.util.equals(BotInstanceSpec, a, b);
  }
}

/**
 * BotInstanceStatusHeartbeat contains information self-reported by an instance
 * of a Bot. This information is not verified by the server and should not be
 * trusted.
 *
 * @generated from message teleport.machineid.v1.BotInstanceStatusHeartbeat
 */
export class BotInstanceStatusHeartbeat extends Message<BotInstanceStatusHeartbeat> {
  /**
   * The timestamp that the heartbeat was recorded by the Auth Server. Any
   * value submitted by `tbot` for this field will be ignored.
   *
   * @generated from field: google.protobuf.Timestamp recorded_at = 1;
   */
  recordedAt?: Timestamp;

  /**
   * Indicates whether this is the heartbeat submitted by `tbot` on startup.
   *
   * @generated from field: bool is_startup = 2;
   */
  isStartup = false;

  /**
   * The version of `tbot` that submitted this heartbeat.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * The hostname of the host that `tbot` is running on.
   *
   * @generated from field: string hostname = 4;
   */
  hostname = "";

  /**
   * The duration that `tbot` has been running for when it submitted this
   * heartbeat.
   *
   * @generated from field: google.protobuf.Duration uptime = 5;
   */
  uptime?: Duration;

  /**
   * The currently configured join_method.
   *
   * @generated from field: string join_method = 6;
   */
  joinMethod = "";

  /**
   * Indicates whether `tbot` is running in one-shot mode.
   *
   * @generated from field: bool one_shot = 7;
   */
  oneShot = false;

  /**
   * The architecture of the host that `tbot` is running on, determined by
   * runtime.GOARCH.
   *
   * @generated from field: string architecture = 8;
   */
  architecture = "";

  /**
   * The OS of the host that `tbot` is running on, determined by runtime.GOOS.
   *
   * In future iterations, additional information can be submitted here.
   * For example, the configuration of `tbot` or the health of individual
   * outputs.
   *
   * @generated from field: string os = 9;
   */
  os = "";

  constructor(data?: PartialMessage<BotInstanceStatusHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.BotInstanceStatusHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recorded_at", kind: "message", T: Timestamp },
    { no: 2, name: "is_startup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "uptime", kind: "message", T: Duration },
    { no: 6, name: "join_method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "one_shot", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "architecture", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "os", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotInstanceStatusHeartbeat {
    return new BotInstanceStatusHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotInstanceStatusHeartbeat {
    return new BotInstanceStatusHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotInstanceStatusHeartbeat {
    return new BotInstanceStatusHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: BotInstanceStatusHeartbeat | PlainMessage<BotInstanceStatusHeartbeat> | undefined, b: BotInstanceStatusHeartbeat | PlainMessage<BotInstanceStatusHeartbeat> | undefined): boolean {
    return proto3.util.equals(BotInstanceStatusHeartbeat, a, b);
  }
}

/**
 * BotInstanceStatusAuthentication contains information about a join or renewal.
 * Ths information is entirely sourced by the Auth Server and can be trusted.
 *
 * @generated from message teleport.machineid.v1.BotInstanceStatusAuthentication
 */
export class BotInstanceStatusAuthentication extends Message<BotInstanceStatusAuthentication> {
  /**
   * The timestamp that the join or renewal was authenticated by the Auth
   * Server.
   *
   * @generated from field: google.protobuf.Timestamp authenticated_at = 1;
   */
  authenticatedAt?: Timestamp;

  /**
   * The join method used for this join or renewal.
   *
   * @generated from field: string join_method = 2;
   */
  joinMethod = "";

  /**
   * The join token used for this join or renewal. This is only populated for
   * delegated join methods as the value for `token` join methods is sensitive.
   *
   * @generated from field: string join_token = 3;
   */
  joinToken = "";

  /**
   * The metadata sourced from the join method.
   *
   * @generated from field: google.protobuf.Struct metadata = 4;
   */
  metadata?: Struct;

  /**
   * On each renewal, this generation is incremented. For delegated join
   * methods, this counter is not checked during renewal. For the `token` join
   * method, this counter is checked during renewal and the Bot is locked out if
   * the counter in the certificate does not match the counter of the last
   * authentication.
   *
   * @generated from field: int32 generation = 5;
   */
  generation = 0;

  /**
   * The public key of the Bot instance. This must be a PEM wrapped, PKIX DER
   * encoded public key. This provides consistency and supports multiple types
   * of public key algorithm.
   *
   * @generated from field: bytes public_key = 6;
   */
  publicKey = new Uint8Array(0);

  constructor(data?: PartialMessage<BotInstanceStatusAuthentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.BotInstanceStatusAuthentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authenticated_at", kind: "message", T: Timestamp },
    { no: 2, name: "join_method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "join_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Struct },
    { no: 5, name: "generation", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotInstanceStatusAuthentication {
    return new BotInstanceStatusAuthentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotInstanceStatusAuthentication {
    return new BotInstanceStatusAuthentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotInstanceStatusAuthentication {
    return new BotInstanceStatusAuthentication().fromJsonString(jsonString, options);
  }

  static equals(a: BotInstanceStatusAuthentication | PlainMessage<BotInstanceStatusAuthentication> | undefined, b: BotInstanceStatusAuthentication | PlainMessage<BotInstanceStatusAuthentication> | undefined): boolean {
    return proto3.util.equals(BotInstanceStatusAuthentication, a, b);
  }
}

/**
 * BotInstanceStatus holds the status of a BotInstance.
 *
 * @generated from message teleport.machineid.v1.BotInstanceStatus
 */
export class BotInstanceStatus extends Message<BotInstanceStatus> {
  /**
   * The initial authentication status for this bot instance.
   *
   * @generated from field: teleport.machineid.v1.BotInstanceStatusAuthentication initial_authentication = 1;
   */
  initialAuthentication?: BotInstanceStatusAuthentication;

  /**
   * The N most recent authentication status records for this bot instance.
   *
   * @generated from field: repeated teleport.machineid.v1.BotInstanceStatusAuthentication latest_authentications = 2;
   */
  latestAuthentications: BotInstanceStatusAuthentication[] = [];

  /**
   * The initial heartbeat status for this bot instance.
   *
   * @generated from field: teleport.machineid.v1.BotInstanceStatusHeartbeat initial_heartbeat = 3;
   */
  initialHeartbeat?: BotInstanceStatusHeartbeat;

  /**
   * The N most recent heartbeats for this bot instance.
   *
   * @generated from field: repeated teleport.machineid.v1.BotInstanceStatusHeartbeat latest_heartbeats = 4;
   */
  latestHeartbeats: BotInstanceStatusHeartbeat[] = [];

  constructor(data?: PartialMessage<BotInstanceStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.machineid.v1.BotInstanceStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "initial_authentication", kind: "message", T: BotInstanceStatusAuthentication },
    { no: 2, name: "latest_authentications", kind: "message", T: BotInstanceStatusAuthentication, repeated: true },
    { no: 3, name: "initial_heartbeat", kind: "message", T: BotInstanceStatusHeartbeat },
    { no: 4, name: "latest_heartbeats", kind: "message", T: BotInstanceStatusHeartbeat, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BotInstanceStatus {
    return new BotInstanceStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BotInstanceStatus {
    return new BotInstanceStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BotInstanceStatus {
    return new BotInstanceStatus().fromJsonString(jsonString, options);
  }

  static equals(a: BotInstanceStatus | PlainMessage<BotInstanceStatus> | undefined, b: BotInstanceStatus | PlainMessage<BotInstanceStatus> | undefined): boolean {
    return proto3.util.equals(BotInstanceStatus, a, b);
  }
}

