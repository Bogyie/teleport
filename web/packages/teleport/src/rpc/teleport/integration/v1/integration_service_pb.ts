// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/integration/v1/integration_service.proto (package teleport.integration.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { IntegrationV1 } from "../../legacy/types/types_pb.js";

/**
 * ListIntegrationsRequest is a request for a paginated list of Integrations.
 *
 * @generated from message teleport.integration.v1.ListIntegrationsRequest
 */
export class ListIntegrationsRequest extends Message<ListIntegrationsRequest> {
  /**
   * Limit is the maximum amount of resources to retrieve.
   *
   * @generated from field: int32 limit = 1;
   */
  limit = 0;

  /**
   * NextKey is the key for the next page of Integrations.
   *
   * @generated from field: string next_key = 2;
   */
  nextKey = "";

  constructor(data?: PartialMessage<ListIntegrationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListIntegrationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "next_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationsRequest {
    return new ListIntegrationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationsRequest {
    return new ListIntegrationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationsRequest {
    return new ListIntegrationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListIntegrationsRequest | PlainMessage<ListIntegrationsRequest> | undefined, b: ListIntegrationsRequest | PlainMessage<ListIntegrationsRequest> | undefined): boolean {
    return proto3.util.equals(ListIntegrationsRequest, a, b);
  }
}

/**
 * ListIntegrationsResponse is the response for ListIntegrationsRequest.
 *
 * @generated from message teleport.integration.v1.ListIntegrationsResponse
 */
export class ListIntegrationsResponse extends Message<ListIntegrationsResponse> {
  /**
   * Integrations is a list of Integrations.
   *
   * @generated from field: repeated types.IntegrationV1 integrations = 1;
   */
  integrations: IntegrationV1[] = [];

  /**
   * NextKey is the key for the next page of Integrations.
   *
   * @generated from field: string next_key = 2;
   */
  nextKey = "";

  /**
   * TotalCount is the total number of integrations in all pages.
   *
   * @generated from field: int32 total_count = 3;
   */
  totalCount = 0;

  constructor(data?: PartialMessage<ListIntegrationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListIntegrationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integrations", kind: "message", T: IntegrationV1, repeated: true },
    { no: 2, name: "next_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationsResponse {
    return new ListIntegrationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationsResponse {
    return new ListIntegrationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationsResponse {
    return new ListIntegrationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListIntegrationsResponse | PlainMessage<ListIntegrationsResponse> | undefined, b: ListIntegrationsResponse | PlainMessage<ListIntegrationsResponse> | undefined): boolean {
    return proto3.util.equals(ListIntegrationsResponse, a, b);
  }
}

/**
 * GetIntegrationRequest is a request for a specific Integration resource.
 *
 * @generated from message teleport.integration.v1.GetIntegrationRequest
 */
export class GetIntegrationRequest extends Message<GetIntegrationRequest> {
  /**
   * Name is the name of the Integration to be requested.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetIntegrationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.GetIntegrationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationRequest {
    return new GetIntegrationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationRequest {
    return new GetIntegrationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationRequest {
    return new GetIntegrationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntegrationRequest | PlainMessage<GetIntegrationRequest> | undefined, b: GetIntegrationRequest | PlainMessage<GetIntegrationRequest> | undefined): boolean {
    return proto3.util.equals(GetIntegrationRequest, a, b);
  }
}

/**
 * CreateIntegrationRequest is the request to create the provided integration.
 *
 * @generated from message teleport.integration.v1.CreateIntegrationRequest
 */
export class CreateIntegrationRequest extends Message<CreateIntegrationRequest> {
  /**
   * Integration is the integration to be created.
   *
   * @generated from field: types.IntegrationV1 integration = 1;
   */
  integration?: IntegrationV1;

  constructor(data?: PartialMessage<CreateIntegrationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.CreateIntegrationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "message", T: IntegrationV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateIntegrationRequest {
    return new CreateIntegrationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateIntegrationRequest {
    return new CreateIntegrationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateIntegrationRequest {
    return new CreateIntegrationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateIntegrationRequest | PlainMessage<CreateIntegrationRequest> | undefined, b: CreateIntegrationRequest | PlainMessage<CreateIntegrationRequest> | undefined): boolean {
    return proto3.util.equals(CreateIntegrationRequest, a, b);
  }
}

/**
 * UpdateIntegrationRequest is the request to update the provided integration.
 *
 * @generated from message teleport.integration.v1.UpdateIntegrationRequest
 */
export class UpdateIntegrationRequest extends Message<UpdateIntegrationRequest> {
  /**
   * Integration is the integration to be created.
   *
   * @generated from field: types.IntegrationV1 integration = 1;
   */
  integration?: IntegrationV1;

  constructor(data?: PartialMessage<UpdateIntegrationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.UpdateIntegrationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "message", T: IntegrationV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateIntegrationRequest {
    return new UpdateIntegrationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateIntegrationRequest {
    return new UpdateIntegrationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateIntegrationRequest {
    return new UpdateIntegrationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateIntegrationRequest | PlainMessage<UpdateIntegrationRequest> | undefined, b: UpdateIntegrationRequest | PlainMessage<UpdateIntegrationRequest> | undefined): boolean {
    return proto3.util.equals(UpdateIntegrationRequest, a, b);
  }
}

/**
 * DeleteIntegrationRequest is a request for deleting a specific Integration resource.
 *
 * @generated from message teleport.integration.v1.DeleteIntegrationRequest
 */
export class DeleteIntegrationRequest extends Message<DeleteIntegrationRequest> {
  /**
   * Name is the name of the Integration to be deleted.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteIntegrationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeleteIntegrationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteIntegrationRequest {
    return new DeleteIntegrationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteIntegrationRequest {
    return new DeleteIntegrationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteIntegrationRequest {
    return new DeleteIntegrationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteIntegrationRequest | PlainMessage<DeleteIntegrationRequest> | undefined, b: DeleteIntegrationRequest | PlainMessage<DeleteIntegrationRequest> | undefined): boolean {
    return proto3.util.equals(DeleteIntegrationRequest, a, b);
  }
}

/**
 * DeleteAllIntegrationsRequest is the request for deleting all integrations.
 * DEPRECATED: Can't delete all integrations over gRPC.
 *
 * @generated from message teleport.integration.v1.DeleteAllIntegrationsRequest
 */
export class DeleteAllIntegrationsRequest extends Message<DeleteAllIntegrationsRequest> {
  constructor(data?: PartialMessage<DeleteAllIntegrationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeleteAllIntegrationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAllIntegrationsRequest {
    return new DeleteAllIntegrationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAllIntegrationsRequest {
    return new DeleteAllIntegrationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAllIntegrationsRequest {
    return new DeleteAllIntegrationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAllIntegrationsRequest | PlainMessage<DeleteAllIntegrationsRequest> | undefined, b: DeleteAllIntegrationsRequest | PlainMessage<DeleteAllIntegrationsRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAllIntegrationsRequest, a, b);
  }
}

/**
 * GenerateAWSOIDCTokenRequest are the parameters used to request an AWS OIDC
 * Integration token.
 *
 * @generated from message teleport.integration.v1.GenerateAWSOIDCTokenRequest
 */
export class GenerateAWSOIDCTokenRequest extends Message<GenerateAWSOIDCTokenRequest> {
  /**
   * Issuer is the entity that is signing the JWT.
   * This value must contain the AWS OIDC Integration configured provider (Teleport Proxy's Public URL)
   *
   * Deprecated: Ignored because value is calculated server side.
   *
   * @generated from field: string issuer = 1 [deprecated = true];
   * @deprecated
   */
  issuer = "";

  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 2;
   */
  integration = "";

  constructor(data?: PartialMessage<GenerateAWSOIDCTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.GenerateAWSOIDCTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "issuer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateAWSOIDCTokenRequest {
    return new GenerateAWSOIDCTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateAWSOIDCTokenRequest {
    return new GenerateAWSOIDCTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateAWSOIDCTokenRequest {
    return new GenerateAWSOIDCTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateAWSOIDCTokenRequest | PlainMessage<GenerateAWSOIDCTokenRequest> | undefined, b: GenerateAWSOIDCTokenRequest | PlainMessage<GenerateAWSOIDCTokenRequest> | undefined): boolean {
    return proto3.util.equals(GenerateAWSOIDCTokenRequest, a, b);
  }
}

/**
 * GenerateAWSOIDCTokenResponse contains a signed AWS OIDC Integration token.
 *
 * @generated from message teleport.integration.v1.GenerateAWSOIDCTokenResponse
 */
export class GenerateAWSOIDCTokenResponse extends Message<GenerateAWSOIDCTokenResponse> {
  /**
   * Token is the signed JWT ready to be used
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<GenerateAWSOIDCTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.GenerateAWSOIDCTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateAWSOIDCTokenResponse {
    return new GenerateAWSOIDCTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateAWSOIDCTokenResponse {
    return new GenerateAWSOIDCTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateAWSOIDCTokenResponse {
    return new GenerateAWSOIDCTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateAWSOIDCTokenResponse | PlainMessage<GenerateAWSOIDCTokenResponse> | undefined, b: GenerateAWSOIDCTokenResponse | PlainMessage<GenerateAWSOIDCTokenResponse> | undefined): boolean {
    return proto3.util.equals(GenerateAWSOIDCTokenResponse, a, b);
  }
}

