// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/integration/v1/awsoidc_service.proto (package teleport.integration.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DatabaseV3, ServerV2 } from "../../legacy/types/types_pb.js";

/**
 * ListEICERequest is a request for a paginated list of AWS EC2 Instance Connect Endpoints.
 *
 * @generated from message teleport.integration.v1.ListEICERequest
 */
export class ListEICERequest extends Message<ListEICERequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * VPCIDs is used to filter for EICEs of those VPCs.
   * Required.
   *
   * @generated from field: repeated string vpc_ids = 3;
   */
  vpcIds: string[] = [];

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 4;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEICERequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEICERequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "vpc_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEICERequest {
    return new ListEICERequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEICERequest {
    return new ListEICERequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEICERequest {
    return new ListEICERequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListEICERequest | PlainMessage<ListEICERequest> | undefined, b: ListEICERequest | PlainMessage<ListEICERequest> | undefined): boolean {
    return proto3.util.equals(ListEICERequest, a, b);
  }
}

/**
 * EC2InstanceConnectEndpoint is a representation of a Amazon VPC EC2 Instance Connect Endpoint.
 *
 * @generated from message teleport.integration.v1.EC2InstanceConnectEndpoint
 */
export class EC2InstanceConnectEndpoint extends Message<EC2InstanceConnectEndpoint> {
  /**
   * Name is the endpoint name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * State is the endpoint state.
   * Known values:
   * create-in-progress | create-complete | create-failed | delete-in-progress | delete-complete | delete-failed
   *
   * @generated from field: string state = 2;
   */
  state = "";

  /**
   * StateMessage contains a message describing the state of the EICE.
   *
   * @generated from field: string state_message = 3;
   */
  stateMessage = "";

  /**
   * DashboardLink is a URL to AWS Console where the user can see the EC2 Instance Connect Endpoint.
   *
   * @generated from field: string dashboard_link = 4;
   */
  dashboardLink = "";

  /**
   * SubnetID is the subnet used by the endpoint.
   *
   * @generated from field: string subnet_id = 5;
   */
  subnetId = "";

  /**
   * VPCID is the VPC ID where the Endpoint is created.
   *
   * @generated from field: string vpc_id = 6;
   */
  vpcId = "";

  constructor(data?: PartialMessage<EC2InstanceConnectEndpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EC2InstanceConnectEndpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dashboard_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "subnet_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "vpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EC2InstanceConnectEndpoint {
    return new EC2InstanceConnectEndpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EC2InstanceConnectEndpoint {
    return new EC2InstanceConnectEndpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EC2InstanceConnectEndpoint {
    return new EC2InstanceConnectEndpoint().fromJsonString(jsonString, options);
  }

  static equals(a: EC2InstanceConnectEndpoint | PlainMessage<EC2InstanceConnectEndpoint> | undefined, b: EC2InstanceConnectEndpoint | PlainMessage<EC2InstanceConnectEndpoint> | undefined): boolean {
    return proto3.util.equals(EC2InstanceConnectEndpoint, a, b);
  }
}

/**
 * ListEICEResponse contains a page of AWS EC2 Instance Connect Endpoints.
 *
 * @generated from message teleport.integration.v1.ListEICEResponse
 */
export class ListEICEResponse extends Message<ListEICEResponse> {
  /**
   * EC2ICEs contains the page of EC2 Instance Connect Endpoints.
   *
   * @generated from field: repeated teleport.integration.v1.EC2InstanceConnectEndpoint ec2ices = 1;
   */
  ec2ices: EC2InstanceConnectEndpoint[] = [];

  /**
   * DashboardLink is the URL for AWS Web Console that lists all the Endpoints for the queries VPCs.
   *
   * @generated from field: string dashboard_link = 2;
   */
  dashboardLink = "";

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 3;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEICEResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEICEResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ec2ices", kind: "message", T: EC2InstanceConnectEndpoint, repeated: true },
    { no: 2, name: "dashboard_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEICEResponse {
    return new ListEICEResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEICEResponse {
    return new ListEICEResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEICEResponse {
    return new ListEICEResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListEICEResponse | PlainMessage<ListEICEResponse> | undefined, b: ListEICEResponse | PlainMessage<ListEICEResponse> | undefined): boolean {
    return proto3.util.equals(ListEICEResponse, a, b);
  }
}

/**
 * CreateEICERequest contains the required fields to create an AWS EC2 Instance Connect Endpoint.
 *
 * @generated from message teleport.integration.v1.CreateEICERequest
 */
export class CreateEICERequest extends Message<CreateEICERequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * Endpoints is is a list of EC2 Instance Connect Endpoints to be created.
   * Required.
   *
   * @generated from field: repeated teleport.integration.v1.EC2ICEndpoint endpoints = 3;
   */
  endpoints: EC2ICEndpoint[] = [];

  constructor(data?: PartialMessage<CreateEICERequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.CreateEICERequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "endpoints", kind: "message", T: EC2ICEndpoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateEICERequest {
    return new CreateEICERequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateEICERequest {
    return new CreateEICERequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateEICERequest {
    return new CreateEICERequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateEICERequest | PlainMessage<CreateEICERequest> | undefined, b: CreateEICERequest | PlainMessage<CreateEICERequest> | undefined): boolean {
    return proto3.util.equals(CreateEICERequest, a, b);
  }
}

/**
 * EC2ICEndpoint contains the information for a single Endpoint to be created.
 *
 * @generated from message teleport.integration.v1.EC2ICEndpoint
 */
export class EC2ICEndpoint extends Message<EC2ICEndpoint> {
  /**
   * Name is the endpoint name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * SubnetID is the Subnet where the Endpoint will be created.
   *
   * @generated from field: string subnet_id = 2;
   */
  subnetId = "";

  /**
   * SecurityGroupIDs is a list of SecurityGroups to assign to the Endpoint.
   * If not specified, the Endpoint will receive the default SG for the Subnet's VPC.
   *
   * @generated from field: repeated string security_group_ids = 3;
   */
  securityGroupIds: string[] = [];

  constructor(data?: PartialMessage<EC2ICEndpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EC2ICEndpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subnet_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "security_group_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EC2ICEndpoint {
    return new EC2ICEndpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EC2ICEndpoint {
    return new EC2ICEndpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EC2ICEndpoint {
    return new EC2ICEndpoint().fromJsonString(jsonString, options);
  }

  static equals(a: EC2ICEndpoint | PlainMessage<EC2ICEndpoint> | undefined, b: EC2ICEndpoint | PlainMessage<EC2ICEndpoint> | undefined): boolean {
    return proto3.util.equals(EC2ICEndpoint, a, b);
  }
}

/**
 * CreateEICEResponse is a request to create a VPC Endpoint of EC2 Instance Connect Endpoint type.
 *
 * @generated from message teleport.integration.v1.CreateEICEResponse
 */
export class CreateEICEResponse extends Message<CreateEICEResponse> {
  /**
   * Name is the Endpoint ID.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * CreatedEndpoints contains the name of created endpoints and their Subnet.
   *
   * @generated from field: repeated teleport.integration.v1.EC2ICEndpoint created_endpoints = 2;
   */
  createdEndpoints: EC2ICEndpoint[] = [];

  constructor(data?: PartialMessage<CreateEICEResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.CreateEICEResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_endpoints", kind: "message", T: EC2ICEndpoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateEICEResponse {
    return new CreateEICEResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateEICEResponse {
    return new CreateEICEResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateEICEResponse {
    return new CreateEICEResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateEICEResponse | PlainMessage<CreateEICEResponse> | undefined, b: CreateEICEResponse | PlainMessage<CreateEICEResponse> | undefined): boolean {
    return proto3.util.equals(CreateEICEResponse, a, b);
  }
}

/**
 * ListDatabasesRequest is a request for a paginated list of AWS Databases.
 *
 * @generated from message teleport.integration.v1.ListDatabasesRequest
 */
export class ListDatabasesRequest extends Message<ListDatabasesRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * RDSType is either instance or cluster (for Aurora DBs).
   * Required.
   *
   * @generated from field: string rds_type = 3;
   */
  rdsType = "";

  /**
   * Engines filters the returned Databases based on their engine.
   * Eg, mysql, postgres, mariadb, aurora, aurora-mysql, aurora-postgresql
   * Required.
   *
   * @generated from field: repeated string engines = 4;
   */
  engines: string[] = [];

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 5;
   */
  nextToken = "";

  /**
   * VPCID filters databases to only include those deployed in the VPC.
   * If empty, no filtering is done.
   *
   * @generated from field: string vpc_id = 6;
   */
  vpcId = "";

  constructor(data?: PartialMessage<ListDatabasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListDatabasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rds_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "engines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "vpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabasesRequest | PlainMessage<ListDatabasesRequest> | undefined, b: ListDatabasesRequest | PlainMessage<ListDatabasesRequest> | undefined): boolean {
    return proto3.util.equals(ListDatabasesRequest, a, b);
  }
}

/**
 * ListDatabasesResponse contains a page of AWS Databases.
 *
 * @generated from message teleport.integration.v1.ListDatabasesResponse
 */
export class ListDatabasesResponse extends Message<ListDatabasesResponse> {
  /**
   * Databases contains the page of Databases.
   *
   * @generated from field: repeated types.DatabaseV3 databases = 1;
   */
  databases: DatabaseV3[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListDatabasesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListDatabasesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "databases", kind: "message", T: DatabaseV3, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabasesResponse | PlainMessage<ListDatabasesResponse> | undefined, b: ListDatabasesResponse | PlainMessage<ListDatabasesResponse> | undefined): boolean {
    return proto3.util.equals(ListDatabasesResponse, a, b);
  }
}

/**
 * ListSecurityGroupsRequest is a request for a paginated list of AWS SecurityGroups.
 *
 * @generated from message teleport.integration.v1.ListSecurityGroupsRequest
 */
export class ListSecurityGroupsRequest extends Message<ListSecurityGroupsRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * VPCID is the VPC ID for listing SecurityGroups.
   * Required.
   *
   * @generated from field: string vpc_id = 3;
   */
  vpcId = "";

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 4;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListSecurityGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListSecurityGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "vpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSecurityGroupsRequest {
    return new ListSecurityGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSecurityGroupsRequest {
    return new ListSecurityGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSecurityGroupsRequest {
    return new ListSecurityGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSecurityGroupsRequest | PlainMessage<ListSecurityGroupsRequest> | undefined, b: ListSecurityGroupsRequest | PlainMessage<ListSecurityGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListSecurityGroupsRequest, a, b);
  }
}

/**
 * CIDR has a CIDR (IP Range) and a description for the value.
 *
 * @generated from message teleport.integration.v1.SecurityGroupRuleCIDR
 */
export class SecurityGroupRuleCIDR extends Message<SecurityGroupRuleCIDR> {
  /**
   * CIDR is the IP range using CIDR notation.
   *
   * @generated from field: string cidr = 1;
   */
  cidr = "";

  /**
   * Description contains a small text describing the CIDR.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  constructor(data?: PartialMessage<SecurityGroupRuleCIDR>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.SecurityGroupRuleCIDR";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityGroupRuleCIDR {
    return new SecurityGroupRuleCIDR().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityGroupRuleCIDR {
    return new SecurityGroupRuleCIDR().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityGroupRuleCIDR {
    return new SecurityGroupRuleCIDR().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityGroupRuleCIDR | PlainMessage<SecurityGroupRuleCIDR> | undefined, b: SecurityGroupRuleCIDR | PlainMessage<SecurityGroupRuleCIDR> | undefined): boolean {
    return proto3.util.equals(SecurityGroupRuleCIDR, a, b);
  }
}

/**
 * SecurityGroupRule is a representation of a SecurityGroupRule.
 * Either for Inbound or Outbound rules.
 *
 * @generated from message teleport.integration.v1.SecurityGroupRule
 */
export class SecurityGroupRule extends Message<SecurityGroupRule> {
  /**
   * IPProtocol is the protocol used to describe the rule.
   * If the rule applies to all protocols, the "all" value is used.
   * The IP protocol name ( tcp , udp , icmp , icmpv6 ) or number (see Protocol
   * Numbers (http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml)).
   *
   * @generated from field: string ip_protocol = 1;
   */
  ipProtocol = "";

  /**
   * FromPort is the inclusive start of the Port range for the Rule.
   *
   * @generated from field: int32 from_port = 2;
   */
  fromPort = 0;

  /**
   * ToPort is the inclusive end of the Port range for the Rule.
   *
   * @generated from field: int32 to_port = 3;
   */
  toPort = 0;

  /**
   * CIDRs contains a list of IP ranges that this rule applies to and a description for the value.
   *
   * @generated from field: repeated teleport.integration.v1.SecurityGroupRuleCIDR cidrs = 4;
   */
  cidrs: SecurityGroupRuleCIDR[] = [];

  constructor(data?: PartialMessage<SecurityGroupRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.SecurityGroupRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ip_protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "from_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "to_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "cidrs", kind: "message", T: SecurityGroupRuleCIDR, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityGroupRule {
    return new SecurityGroupRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityGroupRule {
    return new SecurityGroupRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityGroupRule {
    return new SecurityGroupRule().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityGroupRule | PlainMessage<SecurityGroupRule> | undefined, b: SecurityGroupRule | PlainMessage<SecurityGroupRule> | undefined): boolean {
    return proto3.util.equals(SecurityGroupRule, a, b);
  }
}

/**
 * SecurityGroup is a representation of a SecurityGroup
 *
 * @generated from message teleport.integration.v1.SecurityGroup
 */
export class SecurityGroup extends Message<SecurityGroup> {
  /**
   * Name is the SecurityGroup name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * ID is the SecurityGroup ID.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * Description is a small description of the SecurityGroup.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * InboundRules describe the Security Group Inbound Rules.
   * The CIDR of each rule represents the source IP that the rule applies to.
   *
   * @generated from field: repeated teleport.integration.v1.SecurityGroupRule inbound_rules = 4;
   */
  inboundRules: SecurityGroupRule[] = [];

  /**
   * OutboundRules describe the Security Group Outbound Rules.
   * The CIDR of each rule represents the destination IP that the rule applies to.
   *
   * @generated from field: repeated teleport.integration.v1.SecurityGroupRule outbound_rules = 5;
   */
  outboundRules: SecurityGroupRule[] = [];

  constructor(data?: PartialMessage<SecurityGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.SecurityGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "inbound_rules", kind: "message", T: SecurityGroupRule, repeated: true },
    { no: 5, name: "outbound_rules", kind: "message", T: SecurityGroupRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityGroup {
    return new SecurityGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityGroup {
    return new SecurityGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityGroup {
    return new SecurityGroup().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityGroup | PlainMessage<SecurityGroup> | undefined, b: SecurityGroup | PlainMessage<SecurityGroup> | undefined): boolean {
    return proto3.util.equals(SecurityGroup, a, b);
  }
}

/**
 * ListSecurityGroupsResponse contains a page of AWS SecurityGroups.
 *
 * @generated from message teleport.integration.v1.ListSecurityGroupsResponse
 */
export class ListSecurityGroupsResponse extends Message<ListSecurityGroupsResponse> {
  /**
   * SecurityGroups contains the page of SecurityGroups.
   *
   * @generated from field: repeated teleport.integration.v1.SecurityGroup security_groups = 1;
   */
  securityGroups: SecurityGroup[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListSecurityGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListSecurityGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "security_groups", kind: "message", T: SecurityGroup, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSecurityGroupsResponse {
    return new ListSecurityGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSecurityGroupsResponse {
    return new ListSecurityGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSecurityGroupsResponse {
    return new ListSecurityGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSecurityGroupsResponse | PlainMessage<ListSecurityGroupsResponse> | undefined, b: ListSecurityGroupsResponse | PlainMessage<ListSecurityGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListSecurityGroupsResponse, a, b);
  }
}

/**
 * ListSubnetsRequest is a request for a paginated list of AWS VPC subnets.
 *
 * @generated from message teleport.integration.v1.ListSubnetsRequest
 */
export class ListSubnetsRequest extends Message<ListSubnetsRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * VPCID is the VPC ID for listing subnets.
   * Required.
   *
   * @generated from field: string vpc_id = 3;
   */
  vpcId = "";

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 4;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListSubnetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListSubnetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "vpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSubnetsRequest {
    return new ListSubnetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSubnetsRequest {
    return new ListSubnetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSubnetsRequest {
    return new ListSubnetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSubnetsRequest | PlainMessage<ListSubnetsRequest> | undefined, b: ListSubnetsRequest | PlainMessage<ListSubnetsRequest> | undefined): boolean {
    return proto3.util.equals(ListSubnetsRequest, a, b);
  }
}

/**
 * Subnet is a representation of an AWS VPC subnet.
 *
 * @generated from message teleport.integration.v1.Subnet
 */
export class Subnet extends Message<Subnet> {
  /**
   * Name is the subnet name. Can be empty.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * ID is the subnet ID.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * AvailabilityZone is the availability zone of the subnet.
   *
   * @generated from field: string availability_zone = 3;
   */
  availabilityZone = "";

  constructor(data?: PartialMessage<Subnet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.Subnet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "availability_zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subnet {
    return new Subnet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subnet {
    return new Subnet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subnet {
    return new Subnet().fromJsonString(jsonString, options);
  }

  static equals(a: Subnet | PlainMessage<Subnet> | undefined, b: Subnet | PlainMessage<Subnet> | undefined): boolean {
    return proto3.util.equals(Subnet, a, b);
  }
}

/**
 * ListSubnetsResponse contains a page of AWS VPC subnets.
 *
 * @generated from message teleport.integration.v1.ListSubnetsResponse
 */
export class ListSubnetsResponse extends Message<ListSubnetsResponse> {
  /**
   * Subnets contains the page of subnets.
   *
   * @generated from field: repeated teleport.integration.v1.Subnet subnets = 1;
   */
  subnets: Subnet[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListSubnetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListSubnetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subnets", kind: "message", T: Subnet, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSubnetsResponse {
    return new ListSubnetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSubnetsResponse {
    return new ListSubnetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSubnetsResponse {
    return new ListSubnetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSubnetsResponse | PlainMessage<ListSubnetsResponse> | undefined, b: ListSubnetsResponse | PlainMessage<ListSubnetsResponse> | undefined): boolean {
    return proto3.util.equals(ListSubnetsResponse, a, b);
  }
}

/**
 * ListVPCsRequest is a request for a paginated list of AWS VPCs.
 *
 * @generated from message teleport.integration.v1.ListVPCsRequest
 */
export class ListVPCsRequest extends Message<ListVPCsRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 3;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListVPCsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListVPCsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVPCsRequest {
    return new ListVPCsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVPCsRequest {
    return new ListVPCsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVPCsRequest {
    return new ListVPCsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListVPCsRequest | PlainMessage<ListVPCsRequest> | undefined, b: ListVPCsRequest | PlainMessage<ListVPCsRequest> | undefined): boolean {
    return proto3.util.equals(ListVPCsRequest, a, b);
  }
}

/**
 * VPC is a representation of an AWS VPC.
 *
 * @generated from message teleport.integration.v1.VPC
 */
export class VPC extends Message<VPC> {
  /**
   * Name is the VPC name. Can be empty.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * ID is the VPC ID.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<VPC>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.VPC";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VPC {
    return new VPC().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VPC {
    return new VPC().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VPC {
    return new VPC().fromJsonString(jsonString, options);
  }

  static equals(a: VPC | PlainMessage<VPC> | undefined, b: VPC | PlainMessage<VPC> | undefined): boolean {
    return proto3.util.equals(VPC, a, b);
  }
}

/**
 * ListVPCsResponse contains a page of AWS VPCs.
 *
 * @generated from message teleport.integration.v1.ListVPCsResponse
 */
export class ListVPCsResponse extends Message<ListVPCsResponse> {
  /**
   * VPCs contains the page of VPCs.
   *
   * @generated from field: repeated teleport.integration.v1.VPC vpcs = 1;
   */
  vpcs: VPC[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListVPCsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListVPCsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vpcs", kind: "message", T: VPC, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVPCsResponse {
    return new ListVPCsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVPCsResponse {
    return new ListVPCsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVPCsResponse {
    return new ListVPCsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListVPCsResponse | PlainMessage<ListVPCsResponse> | undefined, b: ListVPCsResponse | PlainMessage<ListVPCsResponse> | undefined): boolean {
    return proto3.util.equals(ListVPCsResponse, a, b);
  }
}

/**
 * DeployDatabaseServiceRequest is a request to deploy .
 *
 * @generated from message teleport.integration.v1.DeployDatabaseServiceRequest
 */
export class DeployDatabaseServiceRequest extends Message<DeployDatabaseServiceRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * TaskRoleARN is the AWS IAM Role received by the deployed service.
   * Required.
   *
   * @generated from field: string task_role_arn = 3;
   */
  taskRoleArn = "";

  /**
   * TeleportVersion is the teleport version to be deployed.
   * This is used to fetch the correct tag for the teleport container image.
   * Eg, 14.3.4 (no "v" prefix)
   * Required.
   *
   * @generated from field: string teleport_version = 4;
   */
  teleportVersion = "";

  /**
   * DeploymentJoinTokenName is the Teleport IAM Join Token to be used by the deployed
   * service to join the cluster.
   * Required.
   *
   * @generated from field: string deployment_join_token_name = 5;
   */
  deploymentJoinTokenName = "";

  /**
   * Deployments is a list of services that will be deployed.
   *
   * @generated from field: repeated teleport.integration.v1.DeployDatabaseServiceDeployment deployments = 6;
   */
  deployments: DeployDatabaseServiceDeployment[] = [];

  constructor(data?: PartialMessage<DeployDatabaseServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeployDatabaseServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_role_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "teleport_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "deployment_join_token_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "deployments", kind: "message", T: DeployDatabaseServiceDeployment, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeployDatabaseServiceRequest {
    return new DeployDatabaseServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeployDatabaseServiceRequest {
    return new DeployDatabaseServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeployDatabaseServiceRequest {
    return new DeployDatabaseServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeployDatabaseServiceRequest | PlainMessage<DeployDatabaseServiceRequest> | undefined, b: DeployDatabaseServiceRequest | PlainMessage<DeployDatabaseServiceRequest> | undefined): boolean {
    return proto3.util.equals(DeployDatabaseServiceRequest, a, b);
  }
}

/**
 * DeployDatabaseServiceDeployment represents a single deployment.
 *
 * @generated from message teleport.integration.v1.DeployDatabaseServiceDeployment
 */
export class DeployDatabaseServiceDeployment extends Message<DeployDatabaseServiceDeployment> {
  /**
   * TeleportConfigString is the teleport.yaml configuration (base64 encoded) used by teleport.
   * Required.
   *
   * @generated from field: string teleport_config_string = 1;
   */
  teleportConfigString = "";

  /**
   * VpcId is the VPCID where the service is going to be deployed.
   * Required.
   *
   * @generated from field: string vpc_id = 2;
   */
  vpcId = "";

  /**
   * SubnetIds are the subnets for the network configuration.
   * They must belong to the VpcId above.
   * Required.
   *
   * @generated from field: repeated string subnet_ids = 3;
   */
  subnetIds: string[] = [];

  /**
   * SecurityGroups are the SecurityGroup IDs to associate with this particular deployment.
   * If empty, the default security group for the VPC is going to be used.
   *
   * @generated from field: repeated string security_groups = 4;
   */
  securityGroups: string[] = [];

  constructor(data?: PartialMessage<DeployDatabaseServiceDeployment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeployDatabaseServiceDeployment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "teleport_config_string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "vpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subnet_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "security_groups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeployDatabaseServiceDeployment {
    return new DeployDatabaseServiceDeployment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeployDatabaseServiceDeployment {
    return new DeployDatabaseServiceDeployment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeployDatabaseServiceDeployment {
    return new DeployDatabaseServiceDeployment().fromJsonString(jsonString, options);
  }

  static equals(a: DeployDatabaseServiceDeployment | PlainMessage<DeployDatabaseServiceDeployment> | undefined, b: DeployDatabaseServiceDeployment | PlainMessage<DeployDatabaseServiceDeployment> | undefined): boolean {
    return proto3.util.equals(DeployDatabaseServiceDeployment, a, b);
  }
}

/**
 * DeployDatabaseServiceResponse contains information about the deployed service.
 *
 * @generated from message teleport.integration.v1.DeployDatabaseServiceResponse
 */
export class DeployDatabaseServiceResponse extends Message<DeployDatabaseServiceResponse> {
  /**
   * ClusterArn identifies the cluster where the deployment was made.
   *
   * @generated from field: string cluster_arn = 1;
   */
  clusterArn = "";

  /**
   * ClusterDashboardURL is a link to the Amazon ECS cluster dashboard or a
   * specific cluster service if a single deployment was requested.
   *
   * @generated from field: string cluster_dashboard_url = 2;
   */
  clusterDashboardUrl = "";

  constructor(data?: PartialMessage<DeployDatabaseServiceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeployDatabaseServiceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_dashboard_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeployDatabaseServiceResponse {
    return new DeployDatabaseServiceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeployDatabaseServiceResponse {
    return new DeployDatabaseServiceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeployDatabaseServiceResponse {
    return new DeployDatabaseServiceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeployDatabaseServiceResponse | PlainMessage<DeployDatabaseServiceResponse> | undefined, b: DeployDatabaseServiceResponse | PlainMessage<DeployDatabaseServiceResponse> | undefined): boolean {
    return proto3.util.equals(DeployDatabaseServiceResponse, a, b);
  }
}

/**
 * DeployServiceRequest is a request to deploy .
 *
 * @generated from message teleport.integration.v1.DeployServiceRequest
 */
export class DeployServiceRequest extends Message<DeployServiceRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * DeploymentMode is the deployment name that should be applied when creating the ECS Service.
   * Allowed modes: database-service
   * Required.
   *
   * @generated from field: string deployment_mode = 3;
   */
  deploymentMode = "";

  /**
   * SecurityGroups to apply to the service's network configuration.
   * If empty, the default security group for the VPC is going to be used.
   *
   * @generated from field: repeated string security_groups = 4;
   */
  securityGroups: string[] = [];

  /**
   * SubnetIds are the subnets for the network configuration.
   * Required.
   *
   * @generated from field: repeated string subnet_ids = 5;
   */
  subnetIds: string[] = [];

  /**
   * TaskRoleARN is the AWS IAM Role received by the deployed service.
   * Required.
   *
   * @generated from field: string task_role_arn = 6;
   */
  taskRoleArn = "";

  /**
   * TeleportVersion is the teleport version to be deployed.
   * This is used to fetch the correct tag for the teleport container image.
   * Eg, 14.3.4 (no "v" prefix)
   * Required.
   *
   * @generated from field: string teleport_version = 7;
   */
  teleportVersion = "";

  /**
   * DeploymentJoinTokenName is the Teleport IAM Join Token to be used by the deployed
   * service to join the cluster.
   * Required.
   *
   * @generated from field: string deployment_join_token_name = 8;
   */
  deploymentJoinTokenName = "";

  /**
   * TeleportConfigString is the teleport.yaml configuration (base64 encoded) used by teleport.
   * Required.
   *
   * @generated from field: string teleport_config_string = 9;
   */
  teleportConfigString = "";

  constructor(data?: PartialMessage<DeployServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeployServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment_mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "security_groups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "subnet_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "task_role_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "teleport_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "deployment_join_token_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "teleport_config_string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeployServiceRequest {
    return new DeployServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeployServiceRequest {
    return new DeployServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeployServiceRequest {
    return new DeployServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeployServiceRequest | PlainMessage<DeployServiceRequest> | undefined, b: DeployServiceRequest | PlainMessage<DeployServiceRequest> | undefined): boolean {
    return proto3.util.equals(DeployServiceRequest, a, b);
  }
}

/**
 * DeployServiceResponse contains information about the deployed service.
 *
 * @generated from message teleport.integration.v1.DeployServiceResponse
 */
export class DeployServiceResponse extends Message<DeployServiceResponse> {
  /**
   * ClusterArn identifies the cluster where the deployment was made.
   *
   * @generated from field: string cluster_arn = 1;
   */
  clusterArn = "";

  /**
   * ServiceARN is the Amazon ECS Cluster Service ARN created to run the task.
   *
   * @generated from field: string service_arn = 2;
   */
  serviceArn = "";

  /**
   * TaskDefinitionARN is the Amazon ECS Task Definition ARN created to run the Service.
   *
   * @generated from field: string task_definition_arn = 3;
   */
  taskDefinitionArn = "";

  /**
   * ServiceDashboardURL is a link to the service's Dashboard URL in Amazon Console.
   *
   * @generated from field: string service_dashboard_url = 4;
   */
  serviceDashboardUrl = "";

  constructor(data?: PartialMessage<DeployServiceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.DeployServiceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "service_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "task_definition_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "service_dashboard_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeployServiceResponse {
    return new DeployServiceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeployServiceResponse {
    return new DeployServiceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeployServiceResponse {
    return new DeployServiceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeployServiceResponse | PlainMessage<DeployServiceResponse> | undefined, b: DeployServiceResponse | PlainMessage<DeployServiceResponse> | undefined): boolean {
    return proto3.util.equals(DeployServiceResponse, a, b);
  }
}

/**
 * EnrollEKSClustersRequest is request to enroll EKS clusters.
 *
 * @generated from message teleport.integration.v1.EnrollEKSClustersRequest
 */
export class EnrollEKSClustersRequest extends Message<EnrollEKSClustersRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * ClusterNames is names of EKS clusters to enroll.
   * Required.
   *
   * @generated from field: repeated string eks_cluster_names = 3;
   */
  eksClusterNames: string[] = [];

  /**
   * EnableAppDiscovery specifies if we should enable Kubernetes App Discovery inside the enrolled EKS cluster.
   *
   * @generated from field: bool enable_app_discovery = 4;
   */
  enableAppDiscovery = false;

  /**
   * AgentVersion is version of agent Helm chart to install on the EKS cluster.
   * Required.
   *
   * @generated from field: string agent_version = 5;
   */
  agentVersion = "";

  constructor(data?: PartialMessage<EnrollEKSClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EnrollEKSClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "eks_cluster_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "enable_app_discovery", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "agent_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollEKSClustersRequest {
    return new EnrollEKSClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollEKSClustersRequest {
    return new EnrollEKSClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollEKSClustersRequest {
    return new EnrollEKSClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollEKSClustersRequest | PlainMessage<EnrollEKSClustersRequest> | undefined, b: EnrollEKSClustersRequest | PlainMessage<EnrollEKSClustersRequest> | undefined): boolean {
    return proto3.util.equals(EnrollEKSClustersRequest, a, b);
  }
}

/**
 * EnrollEKSClusterResult contains result for a single cluster enrollment.
 *
 * @generated from message teleport.integration.v1.EnrollEKSClusterResult
 */
export class EnrollEKSClusterResult extends Message<EnrollEKSClusterResult> {
  /**
   * ClusterName identifies what EKS cluster this result is for.
   *
   * @generated from field: string eks_cluster_name = 1;
   */
  eksClusterName = "";

  /**
   * ResourceID shows what internal resource ID label was used by the Helm chart.
   *
   * @generated from field: string resource_id = 2;
   */
  resourceId = "";

  /**
   * Error show what error happened during enrollment. Empty if no error happened.
   *
   * @generated from field: string error = 3;
   */
  error = "";

  constructor(data?: PartialMessage<EnrollEKSClusterResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EnrollEKSClusterResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eks_cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollEKSClusterResult {
    return new EnrollEKSClusterResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollEKSClusterResult {
    return new EnrollEKSClusterResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollEKSClusterResult {
    return new EnrollEKSClusterResult().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollEKSClusterResult | PlainMessage<EnrollEKSClusterResult> | undefined, b: EnrollEKSClusterResult | PlainMessage<EnrollEKSClusterResult> | undefined): boolean {
    return proto3.util.equals(EnrollEKSClusterResult, a, b);
  }
}

/**
 * EnrollEKSClustersResponse is a response to enrolling EKS clusters.
 *
 * @generated from message teleport.integration.v1.EnrollEKSClustersResponse
 */
export class EnrollEKSClustersResponse extends Message<EnrollEKSClustersResponse> {
  /**
   * Results shows result of enrollment for each requested EKS cluster.
   *
   * @generated from field: repeated teleport.integration.v1.EnrollEKSClusterResult results = 1;
   */
  results: EnrollEKSClusterResult[] = [];

  constructor(data?: PartialMessage<EnrollEKSClustersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EnrollEKSClustersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: EnrollEKSClusterResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrollEKSClustersResponse {
    return new EnrollEKSClustersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrollEKSClustersResponse {
    return new EnrollEKSClustersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrollEKSClustersResponse {
    return new EnrollEKSClustersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EnrollEKSClustersResponse | PlainMessage<EnrollEKSClustersResponse> | undefined, b: EnrollEKSClustersResponse | PlainMessage<EnrollEKSClustersResponse> | undefined): boolean {
    return proto3.util.equals(EnrollEKSClustersResponse, a, b);
  }
}

/**
 * ListEC2Request is a request for a paginated list of AWS EC2 instances.
 *
 * @generated from message teleport.integration.v1.ListEC2Request
 */
export class ListEC2Request extends Message<ListEC2Request> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 3;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEC2Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEC2Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEC2Request {
    return new ListEC2Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEC2Request {
    return new ListEC2Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEC2Request {
    return new ListEC2Request().fromJsonString(jsonString, options);
  }

  static equals(a: ListEC2Request | PlainMessage<ListEC2Request> | undefined, b: ListEC2Request | PlainMessage<ListEC2Request> | undefined): boolean {
    return proto3.util.equals(ListEC2Request, a, b);
  }
}

/**
 * ListEC2Response contains a page of AWS EC2 instances represented as Nodes.
 *
 * @generated from message teleport.integration.v1.ListEC2Response
 */
export class ListEC2Response extends Message<ListEC2Response> {
  /**
   * Servers contains the page of EC2.
   *
   * @generated from field: repeated types.ServerV2 servers = 1;
   */
  servers: ServerV2[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEC2Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEC2Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "servers", kind: "message", T: ServerV2, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEC2Response {
    return new ListEC2Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEC2Response {
    return new ListEC2Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEC2Response {
    return new ListEC2Response().fromJsonString(jsonString, options);
  }

  static equals(a: ListEC2Response | PlainMessage<ListEC2Response> | undefined, b: ListEC2Response | PlainMessage<ListEC2Response> | undefined): boolean {
    return proto3.util.equals(ListEC2Response, a, b);
  }
}

/**
 * ListEKSClustersRequest is a request for a paginated list of AWS EKS Clusters.
 *
 * @generated from message teleport.integration.v1.ListEKSClustersRequest
 */
export class ListEKSClustersRequest extends Message<ListEKSClustersRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  /**
   * Region is the AWS Region
   * Required.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * NextToken is the token to be used to fetch the next page.
   * If empty, the first page is fetched.
   *
   * @generated from field: string next_token = 3;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEKSClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEKSClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEKSClustersRequest {
    return new ListEKSClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEKSClustersRequest {
    return new ListEKSClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEKSClustersRequest {
    return new ListEKSClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListEKSClustersRequest | PlainMessage<ListEKSClustersRequest> | undefined, b: ListEKSClustersRequest | PlainMessage<ListEKSClustersRequest> | undefined): boolean {
    return proto3.util.equals(ListEKSClustersRequest, a, b);
  }
}

/**
 * EKSCluster represents an Amazon EKS Cluster.
 *
 * @generated from message teleport.integration.v1.EKSCluster
 */
export class EKSCluster extends Message<EKSCluster> {
  /**
   * Name is the name of AWS EKS cluster.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Region is an AWS region.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * Arn is an AWS ARN identification of the EKS cluster.
   *
   * @generated from field: string arn = 3;
   */
  arn = "";

  /**
   * Labels are labels of a EKS cluster.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  /**
   * JoinLabels are Teleport labels that should be injected into kube agent
   * if the cluster will be enrolled into Teleport (agent installed on it).
   *
   * @generated from field: map<string, string> join_labels = 5;
   */
  joinLabels: { [key: string]: string } = {};

  /**
   * Status is a current status of an EKS cluster in AWS.
   * Known values are:
   * CREATING | ACTIVE | DELETING | FAILED | UPDATING | PENDING
   *
   * @generated from field: string status = 6;
   */
  status = "";

  constructor(data?: PartialMessage<EKSCluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.EKSCluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "join_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EKSCluster {
    return new EKSCluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EKSCluster {
    return new EKSCluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EKSCluster {
    return new EKSCluster().fromJsonString(jsonString, options);
  }

  static equals(a: EKSCluster | PlainMessage<EKSCluster> | undefined, b: EKSCluster | PlainMessage<EKSCluster> | undefined): boolean {
    return proto3.util.equals(EKSCluster, a, b);
  }
}

/**
 * ListEKSClustersResponse contains a page of AWS EKS Clusters.
 *
 * @generated from message teleport.integration.v1.ListEKSClustersResponse
 */
export class ListEKSClustersResponse extends Message<ListEKSClustersResponse> {
  /**
   * Clusters contains the page of EKS Clusters.
   *
   * @generated from field: repeated teleport.integration.v1.EKSCluster clusters = 1;
   */
  clusters: EKSCluster[] = [];

  /**
   * NextToken is used for pagination.
   * If non-empty, it can be used to request the next page.
   *
   * @generated from field: string next_token = 2;
   */
  nextToken = "";

  constructor(data?: PartialMessage<ListEKSClustersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.ListEKSClustersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusters", kind: "message", T: EKSCluster, repeated: true },
    { no: 2, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListEKSClustersResponse {
    return new ListEKSClustersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListEKSClustersResponse {
    return new ListEKSClustersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListEKSClustersResponse {
    return new ListEKSClustersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListEKSClustersResponse | PlainMessage<ListEKSClustersResponse> | undefined, b: ListEKSClustersResponse | PlainMessage<ListEKSClustersResponse> | undefined): boolean {
    return proto3.util.equals(ListEKSClustersResponse, a, b);
  }
}

/**
 * PingRequest is a request for doing an health check against the configured integration.
 *
 * @generated from message teleport.integration.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  /**
   * Integration is the AWS OIDC Integration name.
   * Required.
   *
   * @generated from field: string integration = 1;
   */
  integration = "";

  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * PingResponse contains the response for the Ping operation.
 *
 * @generated from message teleport.integration.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * The AWS account ID number of the account that owns or contains the calling entity.
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * The AWS ARN associated with the calling entity.
   *
   * @generated from field: string arn = 2;
   */
  arn = "";

  /**
   * The unique identifier of the calling entity.
   *
   * @generated from field: string user_id = 3;
   */
  userId = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.integration.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

