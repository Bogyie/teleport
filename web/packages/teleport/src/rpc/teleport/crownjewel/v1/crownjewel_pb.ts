// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/crownjewel/v1/crownjewel.proto (package teleport.crownjewel.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, StringValue } from "@bufbuild/protobuf";
import { Metadata } from "../../header/v1/metadata_pb.js";
import { Label } from "../../label/v1/label_pb.js";

/**
 * CrownJewel represents a Crown Jewel resource.
 * Crown Jewel is a resource that represents a set of resources that are
 * considered critical to the organization. Access Graph uses Crown Jewel to
 * generate audit events if access to a resource has changed.
 *
 * @generated from message teleport.crownjewel.v1.CrownJewel
 */
export class CrownJewel extends Message<CrownJewel> {
  /**
   * The kind of resource represented.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * Mandatory field for all resources. Not populated for this resource type.
   *
   * @generated from field: string sub_kind = 2;
   */
  subKind = "";

  /**
   * The version of the resource being represented.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * Common metadata that all resources share.
   *
   * @generated from field: teleport.header.v1.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * Spec is the crown jewel spec.
   *
   * @generated from field: teleport.crownjewel.v1.CrownJewelSpec spec = 5;
   */
  spec?: CrownJewelSpec;

  constructor(data?: PartialMessage<CrownJewel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.crownjewel.v1.CrownJewel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "spec", kind: "message", T: CrownJewelSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrownJewel {
    return new CrownJewel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrownJewel {
    return new CrownJewel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrownJewel {
    return new CrownJewel().fromJsonString(jsonString, options);
  }

  static equals(a: CrownJewel | PlainMessage<CrownJewel> | undefined, b: CrownJewel | PlainMessage<CrownJewel> | undefined): boolean {
    return proto3.util.equals(CrownJewel, a, b);
  }
}

/**
 * CrownJewelSpec is the specification of a Crown Jewel.
 *
 * @generated from message teleport.crownjewel.v1.CrownJewelSpec
 */
export class CrownJewelSpec extends Message<CrownJewelSpec> {
  /**
   * TeleportMatchers is a list of teleport matchers.
   * DEPRECATED: Use query instead.
   *
   * @generated from field: repeated teleport.crownjewel.v1.TeleportMatcher teleport_matchers = 1;
   */
  teleportMatchers: TeleportMatcher[] = [];

  /**
   * AWSMatchers is a list of AWS matchers.
   * DEPRECATED: Use query instead.
   *
   * @generated from field: repeated teleport.crownjewel.v1.AWSMatcher aws_matchers = 2;
   */
  awsMatchers: AWSMatcher[] = [];

  /**
   * Query is a Access Graph query to match resources.
   *
   * @generated from field: string query = 3;
   */
  query = "";

  constructor(data?: PartialMessage<CrownJewelSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.crownjewel.v1.CrownJewelSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "teleport_matchers", kind: "message", T: TeleportMatcher, repeated: true },
    { no: 2, name: "aws_matchers", kind: "message", T: AWSMatcher, repeated: true },
    { no: 3, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrownJewelSpec {
    return new CrownJewelSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrownJewelSpec {
    return new CrownJewelSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrownJewelSpec {
    return new CrownJewelSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CrownJewelSpec | PlainMessage<CrownJewelSpec> | undefined, b: CrownJewelSpec | PlainMessage<CrownJewelSpec> | undefined): boolean {
    return proto3.util.equals(CrownJewelSpec, a, b);
  }
}

/**
 * TeleportMatcher represents a matcher for Teleport resources.
 *
 * @generated from message teleport.crownjewel.v1.TeleportMatcher
 */
export class TeleportMatcher extends Message<TeleportMatcher> {
  /**
   * Kind is the kind of the resource: ssh, k8s, db, etc
   * Multiple kinds can be provided to match multiple kinds.
   *
   * @generated from field: repeated string kinds = 2;
   */
  kinds: string[] = [];

  /**
   * Labels is a set of labels.
   *
   * @generated from field: repeated teleport.label.v1.Label labels = 3;
   */
  labels: Label[] = [];

  /**
   * Names are the name of resources. When the name is provided, it will match
   * resources with the same name.
   *
   * @generated from field: repeated string names = 4;
   */
  names: string[] = [];

  constructor(data?: PartialMessage<TeleportMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.crownjewel.v1.TeleportMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 4, name: "names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TeleportMatcher {
    return new TeleportMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TeleportMatcher {
    return new TeleportMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TeleportMatcher {
    return new TeleportMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: TeleportMatcher | PlainMessage<TeleportMatcher> | undefined, b: TeleportMatcher | PlainMessage<TeleportMatcher> | undefined): boolean {
    return proto3.util.equals(TeleportMatcher, a, b);
  }
}

/**
 * AWSMatcher represents a matcher for AWS resources.
 * Those matchers are used only by Access Graph. Teleport related matchers are
 * defined in the TeleportMatcher.
 *
 * @generated from message teleport.crownjewel.v1.AWSMatcher
 */
export class AWSMatcher extends Message<AWSMatcher> {
  /**
   * Types are AWS database types to match, "ec2", "rds", "s3", etc
   *
   * @generated from field: repeated string types = 1;
   */
  types: string[] = [];

  /**
   * Regions are AWS regions to query for resources.
   *
   * @generated from field: repeated string regions = 2;
   */
  regions: string[] = [];

  /**
   * Tags are AWS resource Tags to match.
   * labels is a set of labels.
   *
   * @generated from field: repeated teleport.crownjewel.v1.AWSTag tags = 3;
   */
  tags: AWSTag[] = [];

  /**
   * ARNs are AWS resources ARN to match.
   *
   * @generated from field: repeated string arns = 5;
   */
  arns: string[] = [];

  constructor(data?: PartialMessage<AWSMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.crownjewel.v1.AWSMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "regions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "tags", kind: "message", T: AWSTag, repeated: true },
    { no: 5, name: "arns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSMatcher {
    return new AWSMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSMatcher {
    return new AWSMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSMatcher {
    return new AWSMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: AWSMatcher | PlainMessage<AWSMatcher> | undefined, b: AWSMatcher | PlainMessage<AWSMatcher> | undefined): boolean {
    return proto3.util.equals(AWSMatcher, a, b);
  }
}

/**
 * AWSTag is a tag that is attached to an AWS resource.
 *
 * @generated from message teleport.crownjewel.v1.AWSTag
 */
export class AWSTag extends Message<AWSTag> {
  /**
   * Key is the key of the tag.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Value is the value of the tag.
   *
   * @generated from field: repeated google.protobuf.StringValue values = 2;
   */
  values: StringValue[] = [];

  constructor(data?: PartialMessage<AWSTag>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.crownjewel.v1.AWSTag";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "values", kind: "message", T: StringValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSTag {
    return new AWSTag().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSTag {
    return new AWSTag().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSTag {
    return new AWSTag().fromJsonString(jsonString, options);
  }

  static equals(a: AWSTag | PlainMessage<AWSTag> | undefined, b: AWSTag | PlainMessage<AWSTag> | undefined): boolean {
    return proto3.util.equals(AWSTag, a, b);
  }
}

