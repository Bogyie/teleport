// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/trust/v1/trust_service.proto (package teleport.trust.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { CertAuthorityV2 } from "../../legacy/types/types_pb.js";

/**
 * Request for GetCertAuthority
 *
 * @generated from message teleport.trust.v1.GetCertAuthorityRequest
 */
export class GetCertAuthorityRequest extends Message<GetCertAuthorityRequest> {
  /**
   * Type of certificate authority.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * The domain for the certificate authority.
   *
   * @generated from field: string domain = 2;
   */
  domain = "";

  /**
   * Whether the private key should be included in the response.
   *
   * @generated from field: bool include_key = 3;
   */
  includeKey = false;

  constructor(data?: PartialMessage<GetCertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.GetCertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "include_key", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCertAuthorityRequest {
    return new GetCertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCertAuthorityRequest {
    return new GetCertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCertAuthorityRequest {
    return new GetCertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCertAuthorityRequest | PlainMessage<GetCertAuthorityRequest> | undefined, b: GetCertAuthorityRequest | PlainMessage<GetCertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(GetCertAuthorityRequest, a, b);
  }
}

/**
 * Request for GetCertAuthorities
 *
 * @generated from message teleport.trust.v1.GetCertAuthoritiesRequest
 */
export class GetCertAuthoritiesRequest extends Message<GetCertAuthoritiesRequest> {
  /**
   * Type of certificate authority.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Whether the private key should be included in the response.
   *
   * @generated from field: bool include_key = 2;
   */
  includeKey = false;

  constructor(data?: PartialMessage<GetCertAuthoritiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.GetCertAuthoritiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "include_key", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCertAuthoritiesRequest {
    return new GetCertAuthoritiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCertAuthoritiesRequest {
    return new GetCertAuthoritiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCertAuthoritiesRequest {
    return new GetCertAuthoritiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCertAuthoritiesRequest | PlainMessage<GetCertAuthoritiesRequest> | undefined, b: GetCertAuthoritiesRequest | PlainMessage<GetCertAuthoritiesRequest> | undefined): boolean {
    return proto3.util.equals(GetCertAuthoritiesRequest, a, b);
  }
}

/**
 * Response for GetCertAuthorities
 *
 * @generated from message teleport.trust.v1.GetCertAuthoritiesResponse
 */
export class GetCertAuthoritiesResponse extends Message<GetCertAuthoritiesResponse> {
  /**
   * The matching certificate authorities.
   *
   * @generated from field: repeated types.CertAuthorityV2 cert_authorities_v2 = 1;
   */
  certAuthoritiesV2: CertAuthorityV2[] = [];

  constructor(data?: PartialMessage<GetCertAuthoritiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.GetCertAuthoritiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cert_authorities_v2", kind: "message", T: CertAuthorityV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCertAuthoritiesResponse {
    return new GetCertAuthoritiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCertAuthoritiesResponse {
    return new GetCertAuthoritiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCertAuthoritiesResponse {
    return new GetCertAuthoritiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCertAuthoritiesResponse | PlainMessage<GetCertAuthoritiesResponse> | undefined, b: GetCertAuthoritiesResponse | PlainMessage<GetCertAuthoritiesResponse> | undefined): boolean {
    return proto3.util.equals(GetCertAuthoritiesResponse, a, b);
  }
}

/**
 * Request for DeleteCertAuthority
 *
 * @generated from message teleport.trust.v1.DeleteCertAuthorityRequest
 */
export class DeleteCertAuthorityRequest extends Message<DeleteCertAuthorityRequest> {
  /**
   * Type of certificate authority.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * The domain for the certificate authority.
   *
   * @generated from field: string domain = 2;
   */
  domain = "";

  constructor(data?: PartialMessage<DeleteCertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.DeleteCertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCertAuthorityRequest {
    return new DeleteCertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCertAuthorityRequest {
    return new DeleteCertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCertAuthorityRequest {
    return new DeleteCertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteCertAuthorityRequest | PlainMessage<DeleteCertAuthorityRequest> | undefined, b: DeleteCertAuthorityRequest | PlainMessage<DeleteCertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(DeleteCertAuthorityRequest, a, b);
  }
}

/**
 * Request for UpsertCertAuthority
 *
 * @generated from message teleport.trust.v1.UpsertCertAuthorityRequest
 */
export class UpsertCertAuthorityRequest extends Message<UpsertCertAuthorityRequest> {
  /**
   * The certificate authority to create or update.
   *
   * @generated from field: types.CertAuthorityV2 cert_authority = 1;
   */
  certAuthority?: CertAuthorityV2;

  constructor(data?: PartialMessage<UpsertCertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.UpsertCertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cert_authority", kind: "message", T: CertAuthorityV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertCertAuthorityRequest {
    return new UpsertCertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertCertAuthorityRequest {
    return new UpsertCertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertCertAuthorityRequest {
    return new UpsertCertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertCertAuthorityRequest | PlainMessage<UpsertCertAuthorityRequest> | undefined, b: UpsertCertAuthorityRequest | PlainMessage<UpsertCertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(UpsertCertAuthorityRequest, a, b);
  }
}

/**
 * Request for RotateCertAuthority.
 *
 * @generated from message teleport.trust.v1.RotateCertAuthorityRequest
 */
export class RotateCertAuthorityRequest extends Message<RotateCertAuthorityRequest> {
  /**
   * Type is a certificate authority type, if omitted, both user and host CA
   * will be rotated.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * GracePeriod is used to generate cert rotation schedule that defines
   * times at which different rotation phases will be applied by the auth server
   * in auto mode. It is not used in manual rotation mode.
   * If omitted, default value is set, if 0 is supplied, it is interpreted as
   * forcing rotation of all certificate authorities with no grace period,
   * all existing users and hosts will have to re-login and re-added
   * into the cluster.
   *
   * @generated from field: google.protobuf.Duration grace_period = 2;
   */
  gracePeriod?: Duration;

  /**
   * TargetPhase sets desired rotation phase to move to, if not set
   * will be set automatically, it is a required argument
   * for manual rotation.
   *
   * @generated from field: string target_phase = 3;
   */
  targetPhase = "";

  /**
   * Mode sets manual or auto rotation mode.
   *
   * @generated from field: string mode = 4;
   */
  mode = "";

  /**
   * Schedule is an optional rotation schedule,
   * autogenerated based on GracePeriod parameter if not set.
   *
   * @generated from field: teleport.trust.v1.RotationSchedule schedule = 5;
   */
  schedule?: RotationSchedule;

  constructor(data?: PartialMessage<RotateCertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.RotateCertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grace_period", kind: "message", T: Duration },
    { no: 3, name: "target_phase", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "schedule", kind: "message", T: RotationSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateCertAuthorityRequest {
    return new RotateCertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateCertAuthorityRequest {
    return new RotateCertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateCertAuthorityRequest {
    return new RotateCertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RotateCertAuthorityRequest | PlainMessage<RotateCertAuthorityRequest> | undefined, b: RotateCertAuthorityRequest | PlainMessage<RotateCertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(RotateCertAuthorityRequest, a, b);
  }
}

/**
 * RotationSchedule is a rotation schedule setting time switches for different phases.
 *
 * @generated from message teleport.trust.v1.RotationSchedule
 */
export class RotationSchedule extends Message<RotationSchedule> {
  /**
   * UpdateClients specifies time to switch to the "Update clients" phase
   *
   * @generated from field: google.protobuf.Timestamp update_clients = 1;
   */
  updateClients?: Timestamp;

  /**
   * UpdateServers specifies time to switch to the "Update servers" phase.
   *
   * @generated from field: google.protobuf.Timestamp update_servers = 2;
   */
  updateServers?: Timestamp;

  /**
   * Standby specifies time to switch to the "Standby" phase.
   *
   * @generated from field: google.protobuf.Timestamp standby = 3;
   */
  standby?: Timestamp;

  constructor(data?: PartialMessage<RotationSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.RotationSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_clients", kind: "message", T: Timestamp },
    { no: 2, name: "update_servers", kind: "message", T: Timestamp },
    { no: 3, name: "standby", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotationSchedule {
    return new RotationSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotationSchedule {
    return new RotationSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotationSchedule {
    return new RotationSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: RotationSchedule | PlainMessage<RotationSchedule> | undefined, b: RotationSchedule | PlainMessage<RotationSchedule> | undefined): boolean {
    return proto3.util.equals(RotationSchedule, a, b);
  }
}

/**
 * Response for RotateCertAuthority.
 *
 * @generated from message teleport.trust.v1.RotateCertAuthorityResponse
 */
export class RotateCertAuthorityResponse extends Message<RotateCertAuthorityResponse> {
  constructor(data?: PartialMessage<RotateCertAuthorityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.RotateCertAuthorityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateCertAuthorityResponse {
    return new RotateCertAuthorityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateCertAuthorityResponse {
    return new RotateCertAuthorityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateCertAuthorityResponse {
    return new RotateCertAuthorityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RotateCertAuthorityResponse | PlainMessage<RotateCertAuthorityResponse> | undefined, b: RotateCertAuthorityResponse | PlainMessage<RotateCertAuthorityResponse> | undefined): boolean {
    return proto3.util.equals(RotateCertAuthorityResponse, a, b);
  }
}

/**
 * Request for RotateExternalCertAuthority.
 *
 * @generated from message teleport.trust.v1.RotateExternalCertAuthorityRequest
 */
export class RotateExternalCertAuthorityRequest extends Message<RotateExternalCertAuthorityRequest> {
  /**
   * The certificate authority to rotate.
   *
   * @generated from field: types.CertAuthorityV2 cert_authority = 1;
   */
  certAuthority?: CertAuthorityV2;

  constructor(data?: PartialMessage<RotateExternalCertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.RotateExternalCertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cert_authority", kind: "message", T: CertAuthorityV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateExternalCertAuthorityRequest {
    return new RotateExternalCertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateExternalCertAuthorityRequest {
    return new RotateExternalCertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateExternalCertAuthorityRequest {
    return new RotateExternalCertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RotateExternalCertAuthorityRequest | PlainMessage<RotateExternalCertAuthorityRequest> | undefined, b: RotateExternalCertAuthorityRequest | PlainMessage<RotateExternalCertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(RotateExternalCertAuthorityRequest, a, b);
  }
}

/**
 * Response for RotateExternalCertAuthority.
 *
 * @generated from message teleport.trust.v1.RotateExternalCertAuthorityResponse
 */
export class RotateExternalCertAuthorityResponse extends Message<RotateExternalCertAuthorityResponse> {
  constructor(data?: PartialMessage<RotateExternalCertAuthorityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.RotateExternalCertAuthorityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotateExternalCertAuthorityResponse {
    return new RotateExternalCertAuthorityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotateExternalCertAuthorityResponse {
    return new RotateExternalCertAuthorityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotateExternalCertAuthorityResponse {
    return new RotateExternalCertAuthorityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RotateExternalCertAuthorityResponse | PlainMessage<RotateExternalCertAuthorityResponse> | undefined, b: RotateExternalCertAuthorityResponse | PlainMessage<RotateExternalCertAuthorityResponse> | undefined): boolean {
    return proto3.util.equals(RotateExternalCertAuthorityResponse, a, b);
  }
}

/**
 * GenerateHostCertRequest is the request for GenerateHostCert.
 *
 * @generated from message teleport.trust.v1.GenerateHostCertRequest
 */
export class GenerateHostCertRequest extends Message<GenerateHostCertRequest> {
  /**
   * key is the SSH public key that the certificate should include.
   *
   * @generated from field: bytes key = 1;
   */
  key = new Uint8Array(0);

  /**
   * host_id is the ID of the host the certificate should include.
   *
   * @generated from field: string host_id = 2;
   */
  hostId = "";

  /**
   * node_name is the name of the node the certificate should include.
   *
   * @generated from field: string node_name = 3;
   */
  nodeName = "";

  /**
   * principals is a list of principals that the certificate should include.
   *
   * @generated from field: repeated string principals = 4;
   */
  principals: string[] = [];

  /**
   * cluster_name is a list of principals that the certificate should include.
   *
   * @generated from field: string cluster_name = 5;
   */
  clusterName = "";

  /**
   * role is a system role assigned to the host that will be included on the certificate.
   *
   * @generated from field: string role = 6;
   */
  role = "";

  /**
   * ttl is the duration the certificate will be valid for. This may be zero for indefinite.
   *
   * @generated from field: google.protobuf.Duration ttl = 7;
   */
  ttl?: Duration;

  constructor(data?: PartialMessage<GenerateHostCertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.GenerateHostCertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "node_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "principals", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ttl", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateHostCertRequest {
    return new GenerateHostCertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateHostCertRequest {
    return new GenerateHostCertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateHostCertRequest {
    return new GenerateHostCertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateHostCertRequest | PlainMessage<GenerateHostCertRequest> | undefined, b: GenerateHostCertRequest | PlainMessage<GenerateHostCertRequest> | undefined): boolean {
    return proto3.util.equals(GenerateHostCertRequest, a, b);
  }
}

/**
 * GenerateHostCertResponse is the response for GenerateHostCert.
 *
 * @generated from message teleport.trust.v1.GenerateHostCertResponse
 */
export class GenerateHostCertResponse extends Message<GenerateHostCertResponse> {
  /**
   * ssh_certificate is the encoded bytes of the SSH certificate generated by the RPC.
   *
   * @generated from field: bytes ssh_certificate = 1;
   */
  sshCertificate = new Uint8Array(0);

  constructor(data?: PartialMessage<GenerateHostCertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.trust.v1.GenerateHostCertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ssh_certificate", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateHostCertResponse {
    return new GenerateHostCertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateHostCertResponse {
    return new GenerateHostCertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateHostCertResponse {
    return new GenerateHostCertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateHostCertResponse | PlainMessage<GenerateHostCertResponse> | undefined, b: GenerateHostCertResponse | PlainMessage<GenerateHostCertResponse> | undefined): boolean {
    return proto3.util.equals(GenerateHostCertResponse, a, b);
  }
}

