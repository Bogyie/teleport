//
// Teleport
// Copyright (C) 2024 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/lib/teleterm/v1/app.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Label } from "./label_pb.js";

/**
 * App describes an app resource.
 *
 * @generated from message teleport.lib.teleterm.v1.App
 */
export class App extends Message<App> {
  /**
   * uri uniquely identifies an app within Teleport Connect.
   *
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * name is the name of the app.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * endpoint_uri is the URI to which the app service is going to proxy requests. It corresponds to
   * app_service.apps[].uri in the Teleport configuration.
   *
   * @generated from field: string endpoint_uri = 3;
   */
  endpointUri = "";

  /**
   * desc is the app description.
   *
   * @generated from field: string desc = 4;
   */
  desc = "";

  /**
   * aws_console is true if this app is AWS management console.
   *
   * @generated from field: bool aws_console = 5;
   */
  awsConsole = false;

  /**
   * public_addr is the public address the application is accessible at.
   *
   * If the app resource has its public_addr field set, this field returns the value of public_addr
   * from the app resource.
   *
   * If the app resource does not have public_addr field set, this field returns the name of the app
   * under the proxy hostname of the cluster to which the app belongs, e.g.,
   * dumper.root-cluster.com, example-app.leaf-cluster.org.
   *
   * In both cases public_addr does not include a port number. This is all cool and fine if the
   * actual public address and the proxy service share the default port 443. In a scenario where the
   * proxy uses a non-standard port like 3080 and the public address uses 443, it might cause
   * problems. public_addr of an app resource cannot include a port number. The backend will reject
   * such app resource with an error saying "public_addr "example.com:1337" can not contain a port,
   * applications will be available on the same port as the web proxy". This is not always the case
   * for custom public addresses. Ultimately, it means that public_addr alone might not be enough to
   * access the app if either the cluster or the custom address use a port number other than 443.
   *
   * public_addr is always empty for SAML applications.
   *
   * @generated from field: string public_addr = 6;
   */
  publicAddr = "";

  /**
   * friendly_name is a user readable name of the app.
   * Right now, it is set only for Okta applications.
   * It is constructed from a label value.
   * See more in api/types/resource.go.
   *
   * @generated from field: string friendly_name = 7;
   */
  friendlyName = "";

  /**
   * saml_app is true if the application is a SAML Application (Service Provider).
   *
   * @generated from field: bool saml_app = 8;
   */
  samlApp = false;

  /**
   * labels is a list of labels for the app.
   *
   * @generated from field: repeated teleport.lib.teleterm.v1.Label labels = 9;
   */
  labels: Label[] = [];

  /**
   * fqdn is the hostname under which the app is accessible within the root cluster. It is used by
   * the Web UI to route the requests from the /web/launch URL to the correct app. fqdn by itself
   * does not include the port number, so fqdn alone cannot be used to launch an app, hence why it's
   * incorporated into the /web/launch URL.
   *
   * If the app belongs to a root cluster, fqdn is equal to public_addr or [name].[root cluster
   * proxy hostname] if public_addr is not present.
   * If the app belongs to a leaf cluster, fqdn is equal to [name].[root cluster proxy hostname].
   *
   * fqdn is not present for SAML applications.
   *
   * @generated from field: string fqdn = 10;
   */
  fqdn = "";

  /**
   * aws_roles is a list of AWS IAM roles for the application representing AWS console.
   *
   * @generated from field: repeated teleport.lib.teleterm.v1.AWSRole aws_roles = 11;
   */
  awsRoles: AWSRole[] = [];

  constructor(data?: PartialMessage<App>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.App";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "endpoint_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "desc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "aws_console", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "public_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "friendly_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "saml_app", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 10, name: "fqdn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "aws_roles", kind: "message", T: AWSRole, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): App {
    return new App().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): App {
    return new App().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): App {
    return new App().fromJsonString(jsonString, options);
  }

  static equals(a: App | PlainMessage<App> | undefined, b: App | PlainMessage<App> | undefined): boolean {
    return proto3.util.equals(App, a, b);
  }
}

/**
 * AwsRole describes AWS IAM role.
 *
 * @generated from message teleport.lib.teleterm.v1.AWSRole
 */
export class AWSRole extends Message<AWSRole> {
  /**
   * Name is the full role name with the entire path.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Display is the role display name.
   *
   * @generated from field: string display = 2;
   */
  display = "";

  /**
   * ARN is the full role ARN.
   *
   * @generated from field: string arn = 3;
   */
  arn = "";

  /**
   * AccountID is the AWS Account ID this role refers to.
   *
   * @generated from field: string account_id = 4;
   */
  accountId = "";

  constructor(data?: PartialMessage<AWSRole>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.AWSRole";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSRole {
    return new AWSRole().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSRole {
    return new AWSRole().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSRole {
    return new AWSRole().fromJsonString(jsonString, options);
  }

  static equals(a: AWSRole | PlainMessage<AWSRole> | undefined, b: AWSRole | PlainMessage<AWSRole> | undefined): boolean {
    return proto3.util.equals(AWSRole, a, b);
  }
}

