//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/lib/teleterm/v1/gateway.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Gateway is Teleterm's name for a connection to a resource like a database or a web app
 * established through our ALPN proxy.
 *
 * The term "gateway" is used to avoid using the term "proxy" itself which could be confusing as
 * "proxy" means a couple of different things depending on the context. But for Teleterm, a gateway
 * is always an ALPN proxy connection.
 *
 * See RFD 39 for more info on ALPN.
 *
 * @generated from message teleport.lib.teleterm.v1.Gateway
 */
export class Gateway extends Message<Gateway> {
  /**
   * uri is the gateway uri
   *
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * target_name is the target resource name
   *
   * @generated from field: string target_name = 2;
   */
  targetName = "";

  /**
   * target_uri is the target uri
   *
   * @generated from field: string target_uri = 3;
   */
  targetUri = "";

  /**
   * target_user is the target user
   *
   * @generated from field: string target_user = 4;
   */
  targetUser = "";

  /**
   * local_address is the gateway address on localhost
   *
   * @generated from field: string local_address = 5;
   */
  localAddress = "";

  /**
   * local_port is the gateway address on localhost
   *
   * @generated from field: string local_port = 6;
   */
  localPort = "";

  /**
   * protocol is the gateway protocol
   *
   * @generated from field: string protocol = 7;
   */
  protocol = "";

  /**
   * target_subresource_name points at a subresource of the remote resource, for example a
   * database name on a database server.
   *
   * @generated from field: string target_subresource_name = 9;
   */
  targetSubresourceName = "";

  /**
   * gateway_cli_client represents a command that the user can execute to connect to the resource
   * through the gateway.
   *
   * Instead of generating those commands in in the frontend code, they are returned from the tsh
   * daemon. This means that the Database Access team can add support for a new protocol and
   * Connect will support it right away with no extra changes.
   *
   * @generated from field: teleport.lib.teleterm.v1.GatewayCLICommand gateway_cli_command = 10;
   */
  gatewayCliCommand?: GatewayCLICommand;

  constructor(data?: PartialMessage<Gateway>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.Gateway";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "target_user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "local_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "local_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "target_subresource_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "gateway_cli_command", kind: "message", T: GatewayCLICommand },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Gateway {
    return new Gateway().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Gateway {
    return new Gateway().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Gateway {
    return new Gateway().fromJsonString(jsonString, options);
  }

  static equals(a: Gateway | PlainMessage<Gateway> | undefined, b: Gateway | PlainMessage<Gateway> | undefined): boolean {
    return proto3.util.equals(Gateway, a, b);
  }
}

/**
 * GatewayCLICommand represents a command that the user can execute to connect to a gateway
 * resource. It is a combination of two different os/exec.Cmd structs, where path, args and env are
 * directly taken from one Cmd and the preview field is constructed from another Cmd.
 *
 * @generated from message teleport.lib.teleterm.v1.GatewayCLICommand
 */
export class GatewayCLICommand extends Message<GatewayCLICommand> {
  /**
   * path is the absolute path to the CLI client of a gateway if the client is
   * in PATH. Otherwise, the name of the program we were trying to find.
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * args is a list containing the name of the program as the first element
   * and the actual args as the other elements
   *
   * @generated from field: repeated string args = 2;
   */
  args: string[] = [];

  /**
   * env is a list of env vars that need to be set for the command
   * invocation. The elements of the list are in the format of NAME=value.
   *
   * @generated from field: repeated string env = 3;
   */
  env: string[] = [];

  /**
   * preview is used to show the user what command will be executed before they decide to run it.
   * It can also be copied and then pasted into a terminal.
   * It's like os/exec.Cmd.String with two exceptions:
   *
   * 1) It is prepended with Cmd.Env.
   * 2) The command name is relative and not absolute.
   * 3) It is taken from a different Cmd than the other fields in this message. This Cmd uses a
   * special print format which makes the args suitable to be entered into a terminal, but not to
   * directly spawn a process.
   *
   * Should not be used to execute the command in the shell. Instead, use path, args, and env.
   *
   * @generated from field: string preview = 4;
   */
  preview = "";

  constructor(data?: PartialMessage<GatewayCLICommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GatewayCLICommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "env", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "preview", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GatewayCLICommand {
    return new GatewayCLICommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GatewayCLICommand {
    return new GatewayCLICommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GatewayCLICommand {
    return new GatewayCLICommand().fromJsonString(jsonString, options);
  }

  static equals(a: GatewayCLICommand | PlainMessage<GatewayCLICommand> | undefined, b: GatewayCLICommand | PlainMessage<GatewayCLICommand> | undefined): boolean {
    return proto3.util.equals(GatewayCLICommand, a, b);
  }
}

