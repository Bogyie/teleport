//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/lib/teleterm/v1/tshd_events_service.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Request for Relogin.
 *
 * @generated from message teleport.lib.teleterm.v1.ReloginRequest
 */
export class ReloginRequest extends Message<ReloginRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from oneof teleport.lib.teleterm.v1.ReloginRequest.reason
   */
  reason: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.GatewayCertExpired gateway_cert_expired = 2;
     */
    value: GatewayCertExpired;
    case: "gatewayCertExpired";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.VnetCertExpired vnet_cert_expired = 3;
     */
    value: VnetCertExpired;
    case: "vnetCertExpired";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReloginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReloginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "gateway_cert_expired", kind: "message", T: GatewayCertExpired, oneof: "reason" },
    { no: 3, name: "vnet_cert_expired", kind: "message", T: VnetCertExpired, oneof: "reason" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReloginRequest {
    return new ReloginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReloginRequest {
    return new ReloginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReloginRequest {
    return new ReloginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReloginRequest | PlainMessage<ReloginRequest> | undefined, b: ReloginRequest | PlainMessage<ReloginRequest> | undefined): boolean {
    return proto3.util.equals(ReloginRequest, a, b);
  }
}

/**
 * GatewayCertExpired is given as the reason when a database client attempts to make a connection
 * through the gateway, the gateway middleware notices that the db cert has expired and tries to
 * connect to the cluster to reissue the cert, but fails because the user cert has expired as well.
 *
 * At that point in order to let the connection through, tshd needs the Electron app to refresh the
 * user cert by asking the user to log in again.
 *
 * @generated from message teleport.lib.teleterm.v1.GatewayCertExpired
 */
export class GatewayCertExpired extends Message<GatewayCertExpired> {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri = "";

  /**
   * @generated from field: string target_uri = 2;
   */
  targetUri = "";

  constructor(data?: PartialMessage<GatewayCertExpired>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GatewayCertExpired";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GatewayCertExpired {
    return new GatewayCertExpired().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GatewayCertExpired {
    return new GatewayCertExpired().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GatewayCertExpired {
    return new GatewayCertExpired().fromJsonString(jsonString, options);
  }

  static equals(a: GatewayCertExpired | PlainMessage<GatewayCertExpired> | undefined, b: GatewayCertExpired | PlainMessage<GatewayCertExpired> | undefined): boolean {
    return proto3.util.equals(GatewayCertExpired, a, b);
  }
}

/**
 * VnetCertExpired describes which app the user was trying to reach with an expired cert.
 *
 * @generated from message teleport.lib.teleterm.v1.VnetCertExpired
 */
export class VnetCertExpired extends Message<VnetCertExpired> {
  /**
   * target_uri for now points solely at apps, but it's not called app_uri to make it future-proof.
   *
   * @generated from field: string target_uri = 1;
   */
  targetUri = "";

  /**
   * public_addr is the public address of the app that the user tried to access.
   *
   * @generated from field: string public_addr = 2;
   */
  publicAddr = "";

  constructor(data?: PartialMessage<VnetCertExpired>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.VnetCertExpired";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "public_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VnetCertExpired {
    return new VnetCertExpired().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VnetCertExpired {
    return new VnetCertExpired().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VnetCertExpired {
    return new VnetCertExpired().fromJsonString(jsonString, options);
  }

  static equals(a: VnetCertExpired | PlainMessage<VnetCertExpired> | undefined, b: VnetCertExpired | PlainMessage<VnetCertExpired> | undefined): boolean {
    return proto3.util.equals(VnetCertExpired, a, b);
  }
}

/**
 * Response for Relogin.
 *
 * @generated from message teleport.lib.teleterm.v1.ReloginResponse
 */
export class ReloginResponse extends Message<ReloginResponse> {
  constructor(data?: PartialMessage<ReloginResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReloginResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReloginResponse {
    return new ReloginResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReloginResponse {
    return new ReloginResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReloginResponse {
    return new ReloginResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReloginResponse | PlainMessage<ReloginResponse> | undefined, b: ReloginResponse | PlainMessage<ReloginResponse> | undefined): boolean {
    return proto3.util.equals(ReloginResponse, a, b);
  }
}

/**
 * SendNotificationRequest includes details behind a notification.
 *
 * Rather than including arbitrary text strings, SendNotificationRequest should contain minimal
 * details. The Electron app can then consume and format them as needed, without having to change
 * what is sent over the wire.
 *
 * @generated from message teleport.lib.teleterm.v1.SendNotificationRequest
 */
export class SendNotificationRequest extends Message<SendNotificationRequest> {
  /**
   * @generated from oneof teleport.lib.teleterm.v1.SendNotificationRequest.subject
   */
  subject: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.CannotProxyGatewayConnection cannot_proxy_gateway_connection = 1;
     */
    value: CannotProxyGatewayConnection;
    case: "cannotProxyGatewayConnection";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.CannotProxyVnetConnection cannot_proxy_vnet_connection = 2;
     */
    value: CannotProxyVnetConnection;
    case: "cannotProxyVnetConnection";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SendNotificationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SendNotificationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cannot_proxy_gateway_connection", kind: "message", T: CannotProxyGatewayConnection, oneof: "subject" },
    { no: 2, name: "cannot_proxy_vnet_connection", kind: "message", T: CannotProxyVnetConnection, oneof: "subject" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendNotificationRequest {
    return new SendNotificationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendNotificationRequest {
    return new SendNotificationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendNotificationRequest {
    return new SendNotificationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendNotificationRequest | PlainMessage<SendNotificationRequest> | undefined, b: SendNotificationRequest | PlainMessage<SendNotificationRequest> | undefined): boolean {
    return proto3.util.equals(SendNotificationRequest, a, b);
  }
}

/**
 * CannotProxyGatewayConnection is the subject when the middleware used by the gateway encounters an
 * unrecoverable error and cannot let the connection through. The middleware code is executed within
 * a separate goroutine so if the error wasn't passed to the Electron app, it would have been
 * visible only in the logs.
 *
 * @generated from message teleport.lib.teleterm.v1.CannotProxyGatewayConnection
 */
export class CannotProxyGatewayConnection extends Message<CannotProxyGatewayConnection> {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri = "";

  /**
   * @generated from field: string target_uri = 2;
   */
  targetUri = "";

  /**
   * @generated from field: string error = 3;
   */
  error = "";

  constructor(data?: PartialMessage<CannotProxyGatewayConnection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CannotProxyGatewayConnection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gateway_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CannotProxyGatewayConnection {
    return new CannotProxyGatewayConnection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CannotProxyGatewayConnection {
    return new CannotProxyGatewayConnection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CannotProxyGatewayConnection {
    return new CannotProxyGatewayConnection().fromJsonString(jsonString, options);
  }

  static equals(a: CannotProxyGatewayConnection | PlainMessage<CannotProxyGatewayConnection> | undefined, b: CannotProxyGatewayConnection | PlainMessage<CannotProxyGatewayConnection> | undefined): boolean {
    return proto3.util.equals(CannotProxyGatewayConnection, a, b);
  }
}

/**
 * CannotProxyVnetConnection describes which app couldn't have been proxied through VNet and why.
 * At the moment this is used solely when refreshing an expired cert.
 *
 * @generated from message teleport.lib.teleterm.v1.CannotProxyVnetConnection
 */
export class CannotProxyVnetConnection extends Message<CannotProxyVnetConnection> {
  /**
   * @generated from field: string target_uri = 1;
   */
  targetUri = "";

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  /**
   * public_addr is the public address of the app that the user tried to access.
   *
   * @generated from field: string public_addr = 3;
   */
  publicAddr = "";

  constructor(data?: PartialMessage<CannotProxyVnetConnection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.CannotProxyVnetConnection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "public_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CannotProxyVnetConnection {
    return new CannotProxyVnetConnection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CannotProxyVnetConnection {
    return new CannotProxyVnetConnection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CannotProxyVnetConnection {
    return new CannotProxyVnetConnection().fromJsonString(jsonString, options);
  }

  static equals(a: CannotProxyVnetConnection | PlainMessage<CannotProxyVnetConnection> | undefined, b: CannotProxyVnetConnection | PlainMessage<CannotProxyVnetConnection> | undefined): boolean {
    return proto3.util.equals(CannotProxyVnetConnection, a, b);
  }
}

/**
 * Response for SendNotification.
 *
 * @generated from message teleport.lib.teleterm.v1.SendNotificationResponse
 */
export class SendNotificationResponse extends Message<SendNotificationResponse> {
  constructor(data?: PartialMessage<SendNotificationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SendNotificationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendNotificationResponse {
    return new SendNotificationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendNotificationResponse {
    return new SendNotificationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendNotificationResponse {
    return new SendNotificationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendNotificationResponse | PlainMessage<SendNotificationResponse> | undefined, b: SendNotificationResponse | PlainMessage<SendNotificationResponse> | undefined): boolean {
    return proto3.util.equals(SendNotificationResponse, a, b);
  }
}

/**
 * Request for SendPendingHeadlessAuthentication.
 *
 * @generated from message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest
 */
export class SendPendingHeadlessAuthenticationRequest extends Message<SendPendingHeadlessAuthenticationRequest> {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri = "";

  /**
   * @generated from field: string headless_authentication_id = 2;
   */
  headlessAuthenticationId = "";

  /**
   * @generated from field: string headless_authentication_client_ip = 3;
   */
  headlessAuthenticationClientIp = "";

  constructor(data?: PartialMessage<SendPendingHeadlessAuthenticationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "headless_authentication_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "headless_authentication_client_ip", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPendingHeadlessAuthenticationRequest {
    return new SendPendingHeadlessAuthenticationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPendingHeadlessAuthenticationRequest {
    return new SendPendingHeadlessAuthenticationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPendingHeadlessAuthenticationRequest {
    return new SendPendingHeadlessAuthenticationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendPendingHeadlessAuthenticationRequest | PlainMessage<SendPendingHeadlessAuthenticationRequest> | undefined, b: SendPendingHeadlessAuthenticationRequest | PlainMessage<SendPendingHeadlessAuthenticationRequest> | undefined): boolean {
    return proto3.util.equals(SendPendingHeadlessAuthenticationRequest, a, b);
  }
}

/**
 * Response for SendPendingHeadlessAuthentication.
 *
 * @generated from message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse
 */
export class SendPendingHeadlessAuthenticationResponse extends Message<SendPendingHeadlessAuthenticationResponse> {
  constructor(data?: PartialMessage<SendPendingHeadlessAuthenticationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendPendingHeadlessAuthenticationResponse {
    return new SendPendingHeadlessAuthenticationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendPendingHeadlessAuthenticationResponse {
    return new SendPendingHeadlessAuthenticationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendPendingHeadlessAuthenticationResponse {
    return new SendPendingHeadlessAuthenticationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendPendingHeadlessAuthenticationResponse | PlainMessage<SendPendingHeadlessAuthenticationResponse> | undefined, b: SendPendingHeadlessAuthenticationResponse | PlainMessage<SendPendingHeadlessAuthenticationResponse> | undefined): boolean {
    return proto3.util.equals(SendPendingHeadlessAuthenticationResponse, a, b);
  }
}

/**
 * Request for PromptMFA.
 *
 * @generated from message teleport.lib.teleterm.v1.PromptMFARequest
 */
export class PromptMFARequest extends Message<PromptMFARequest> {
  /**
   * @generated from field: string reason = 2;
   */
  reason = "";

  /**
   * @generated from field: bool totp = 3;
   */
  totp = false;

  /**
   * @generated from field: bool webauthn = 4;
   */
  webauthn = false;

  /**
   * @generated from field: string cluster_uri = 5;
   */
  clusterUri = "";

  constructor(data?: PartialMessage<PromptMFARequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.PromptMFARequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "totp", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "webauthn", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "cluster_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromptMFARequest {
    return new PromptMFARequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromptMFARequest {
    return new PromptMFARequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromptMFARequest {
    return new PromptMFARequest().fromJsonString(jsonString, options);
  }

  static equals(a: PromptMFARequest | PlainMessage<PromptMFARequest> | undefined, b: PromptMFARequest | PlainMessage<PromptMFARequest> | undefined): boolean {
    return proto3.util.equals(PromptMFARequest, a, b);
  }
}

/**
 * Response for PromptMFA.
 *
 * @generated from message teleport.lib.teleterm.v1.PromptMFAResponse
 */
export class PromptMFAResponse extends Message<PromptMFAResponse> {
  /**
   * @generated from field: string totp_code = 1;
   */
  totpCode = "";

  constructor(data?: PartialMessage<PromptMFAResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.PromptMFAResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "totp_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromptMFAResponse {
    return new PromptMFAResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromptMFAResponse {
    return new PromptMFAResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromptMFAResponse {
    return new PromptMFAResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PromptMFAResponse | PlainMessage<PromptMFAResponse> | undefined, b: PromptMFAResponse | PlainMessage<PromptMFAResponse> | undefined): boolean {
    return proto3.util.equals(PromptMFAResponse, a, b);
  }
}

/**
 * Request for GetUsageReportingSettings.
 *
 * @generated from message teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest
 */
export class GetUsageReportingSettingsRequest extends Message<GetUsageReportingSettingsRequest> {
  constructor(data?: PartialMessage<GetUsageReportingSettingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUsageReportingSettingsRequest {
    return new GetUsageReportingSettingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUsageReportingSettingsRequest {
    return new GetUsageReportingSettingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUsageReportingSettingsRequest {
    return new GetUsageReportingSettingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUsageReportingSettingsRequest | PlainMessage<GetUsageReportingSettingsRequest> | undefined, b: GetUsageReportingSettingsRequest | PlainMessage<GetUsageReportingSettingsRequest> | undefined): boolean {
    return proto3.util.equals(GetUsageReportingSettingsRequest, a, b);
  }
}

/**
 * Response for GetUsageReportingSettings.
 *
 * @generated from message teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse
 */
export class GetUsageReportingSettingsResponse extends Message<GetUsageReportingSettingsResponse> {
  /**
   * @generated from field: teleport.lib.teleterm.v1.UsageReportingSettings usage_reporting_settings = 1;
   */
  usageReportingSettings?: UsageReportingSettings;

  constructor(data?: PartialMessage<GetUsageReportingSettingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "usage_reporting_settings", kind: "message", T: UsageReportingSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUsageReportingSettingsResponse {
    return new GetUsageReportingSettingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUsageReportingSettingsResponse {
    return new GetUsageReportingSettingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUsageReportingSettingsResponse {
    return new GetUsageReportingSettingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUsageReportingSettingsResponse | PlainMessage<GetUsageReportingSettingsResponse> | undefined, b: GetUsageReportingSettingsResponse | PlainMessage<GetUsageReportingSettingsResponse> | undefined): boolean {
    return proto3.util.equals(GetUsageReportingSettingsResponse, a, b);
  }
}

/**
 * UsageReportingSettings contains information about usage reporting as understood by the Electron
 * app.
 *
 * @generated from message teleport.lib.teleterm.v1.UsageReportingSettings
 */
export class UsageReportingSettings extends Message<UsageReportingSettings> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<UsageReportingSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.UsageReportingSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageReportingSettings {
    return new UsageReportingSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageReportingSettings {
    return new UsageReportingSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageReportingSettings {
    return new UsageReportingSettings().fromJsonString(jsonString, options);
  }

  static equals(a: UsageReportingSettings | PlainMessage<UsageReportingSettings> | undefined, b: UsageReportingSettings | PlainMessage<UsageReportingSettings> | undefined): boolean {
    return proto3.util.equals(UsageReportingSettings, a, b);
  }
}

/**
 * Request for ReportUnexpectedVnetShutdown.
 *
 * @generated from message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest
 */
export class ReportUnexpectedVnetShutdownRequest extends Message<ReportUnexpectedVnetShutdownRequest> {
  /**
   * error is the error message with which VNet was shut down. Technically it can be empty, so
   * consumers should account for that.
   *
   * @generated from field: string error = 1;
   */
  error = "";

  constructor(data?: PartialMessage<ReportUnexpectedVnetShutdownRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportUnexpectedVnetShutdownRequest {
    return new ReportUnexpectedVnetShutdownRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportUnexpectedVnetShutdownRequest {
    return new ReportUnexpectedVnetShutdownRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportUnexpectedVnetShutdownRequest {
    return new ReportUnexpectedVnetShutdownRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReportUnexpectedVnetShutdownRequest | PlainMessage<ReportUnexpectedVnetShutdownRequest> | undefined, b: ReportUnexpectedVnetShutdownRequest | PlainMessage<ReportUnexpectedVnetShutdownRequest> | undefined): boolean {
    return proto3.util.equals(ReportUnexpectedVnetShutdownRequest, a, b);
  }
}

/**
 * Response for ReportUnexpectedVnetShutdown.
 *
 * @generated from message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse
 */
export class ReportUnexpectedVnetShutdownResponse extends Message<ReportUnexpectedVnetShutdownResponse> {
  constructor(data?: PartialMessage<ReportUnexpectedVnetShutdownResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportUnexpectedVnetShutdownResponse {
    return new ReportUnexpectedVnetShutdownResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportUnexpectedVnetShutdownResponse {
    return new ReportUnexpectedVnetShutdownResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportUnexpectedVnetShutdownResponse {
    return new ReportUnexpectedVnetShutdownResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReportUnexpectedVnetShutdownResponse | PlainMessage<ReportUnexpectedVnetShutdownResponse> | undefined, b: ReportUnexpectedVnetShutdownResponse | PlainMessage<ReportUnexpectedVnetShutdownResponse> | undefined): boolean {
    return proto3.util.equals(ReportUnexpectedVnetShutdownResponse, a, b);
  }
}

