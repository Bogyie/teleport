//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/lib/teleterm/v1/tshd_events_service.proto (package teleport.lib.teleterm.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/lib/teleterm/v1/tshd_events_service.proto.
 */
export const file_teleport_lib_teleterm_v1_tshd_events_service: GenFile = /*@__PURE__*/
  fileDesc("CjJ0ZWxlcG9ydC9saWIvdGVsZXRlcm0vdjEvdHNoZF9ldmVudHNfc2VydmljZS5wcm90bxIYdGVsZXBvcnQubGliLnRlbGV0ZXJtLnYxIsoBCg5SZWxvZ2luUmVxdWVzdBIYChByb290X2NsdXN0ZXJfdXJpGAEgASgJEkwKFGdhdGV3YXlfY2VydF9leHBpcmVkGAIgASgLMiwudGVsZXBvcnQubGliLnRlbGV0ZXJtLnYxLkdhdGV3YXlDZXJ0RXhwaXJlZEgAEkYKEXZuZXRfY2VydF9leHBpcmVkGAMgASgLMikudGVsZXBvcnQubGliLnRlbGV0ZXJtLnYxLlZuZXRDZXJ0RXhwaXJlZEgAQggKBnJlYXNvbiI9ChJHYXRld2F5Q2VydEV4cGlyZWQSEwoLZ2F0ZXdheV91cmkYASABKAkSEgoKdGFyZ2V0X3VyaRgCIAEoCSI6Cg9WbmV0Q2VydEV4cGlyZWQSEgoKdGFyZ2V0X3VyaRgBIAEoCRITCgtwdWJsaWNfYWRkchgCIAEoCSIRCg9SZWxvZ2luUmVzcG9uc2Ui5AEKF1NlbmROb3RpZmljYXRpb25SZXF1ZXN0EmEKH2Nhbm5vdF9wcm94eV9nYXRld2F5X2Nvbm5lY3Rpb24YASABKAsyNi50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuQ2Fubm90UHJveHlHYXRld2F5Q29ubmVjdGlvbkgAElsKHGNhbm5vdF9wcm94eV92bmV0X2Nvbm5lY3Rpb24YAiABKAsyMy50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuQ2Fubm90UHJveHlWbmV0Q29ubmVjdGlvbkgAQgkKB3N1YmplY3QiVgocQ2Fubm90UHJveHlHYXRld2F5Q29ubmVjdGlvbhITCgtnYXRld2F5X3VyaRgBIAEoCRISCgp0YXJnZXRfdXJpGAIgASgJEg0KBWVycm9yGAMgASgJIlMKGUNhbm5vdFByb3h5Vm5ldENvbm5lY3Rpb24SEgoKdGFyZ2V0X3VyaRgBIAEoCRINCgVlcnJvchgCIAEoCRITCgtwdWJsaWNfYWRkchgDIAEoCSIaChhTZW5kTm90aWZpY2F0aW9uUmVzcG9uc2UikwEKKFNlbmRQZW5kaW5nSGVhZGxlc3NBdXRoZW50aWNhdGlvblJlcXVlc3QSGAoQcm9vdF9jbHVzdGVyX3VyaRgBIAEoCRIiChpoZWFkbGVzc19hdXRoZW50aWNhdGlvbl9pZBgCIAEoCRIpCiFoZWFkbGVzc19hdXRoZW50aWNhdGlvbl9jbGllbnRfaXAYAyABKAkiKwopU2VuZFBlbmRpbmdIZWFkbGVzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2UibwoQUHJvbXB0TUZBUmVxdWVzdBIOCgZyZWFzb24YAiABKAkSDAoEdG90cBgDIAEoCBIQCgh3ZWJhdXRobhgEIAEoCBITCgtjbHVzdGVyX3VyaRgFIAEoCUoECAEQAlIQcm9vdF9jbHVzdGVyX3VyaSImChFQcm9tcHRNRkFSZXNwb25zZRIRCgl0b3RwX2NvZGUYASABKAkiIgogR2V0VXNhZ2VSZXBvcnRpbmdTZXR0aW5nc1JlcXVlc3QidwohR2V0VXNhZ2VSZXBvcnRpbmdTZXR0aW5nc1Jlc3BvbnNlElIKGHVzYWdlX3JlcG9ydGluZ19zZXR0aW5ncxgBIAEoCzIwLnRlbGVwb3J0LmxpYi50ZWxldGVybS52MS5Vc2FnZVJlcG9ydGluZ1NldHRpbmdzIikKFlVzYWdlUmVwb3J0aW5nU2V0dGluZ3MSDwoHZW5hYmxlZBgBIAEoCCI0CiNSZXBvcnRVbmV4cGVjdGVkVm5ldFNodXRkb3duUmVxdWVzdBINCgVlcnJvchgBIAEoCSImCiRSZXBvcnRVbmV4cGVjdGVkVm5ldFNodXRkb3duUmVzcG9uc2UyugYKEVRzaGRFdmVudHNTZXJ2aWNlEl4KB1JlbG9naW4SKC50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuUmVsb2dpblJlcXVlc3QaKS50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuUmVsb2dpblJlc3BvbnNlEnkKEFNlbmROb3RpZmljYXRpb24SMS50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuU2VuZE5vdGlmaWNhdGlvblJlcXVlc3QaMi50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuU2VuZE5vdGlmaWNhdGlvblJlc3BvbnNlEqwBCiFTZW5kUGVuZGluZ0hlYWRsZXNzQXV0aGVudGljYXRpb24SQi50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuU2VuZFBlbmRpbmdIZWFkbGVzc0F1dGhlbnRpY2F0aW9uUmVxdWVzdBpDLnRlbGVwb3J0LmxpYi50ZWxldGVybS52MS5TZW5kUGVuZGluZ0hlYWRsZXNzQXV0aGVudGljYXRpb25SZXNwb25zZRJkCglQcm9tcHRNRkESKi50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuUHJvbXB0TUZBUmVxdWVzdBorLnRlbGVwb3J0LmxpYi50ZWxldGVybS52MS5Qcm9tcHRNRkFSZXNwb25zZRKUAQoZR2V0VXNhZ2VSZXBvcnRpbmdTZXR0aW5ncxI6LnRlbGVwb3J0LmxpYi50ZWxldGVybS52MS5HZXRVc2FnZVJlcG9ydGluZ1NldHRpbmdzUmVxdWVzdBo7LnRlbGVwb3J0LmxpYi50ZWxldGVybS52MS5HZXRVc2FnZVJlcG9ydGluZ1NldHRpbmdzUmVzcG9uc2USnQEKHFJlcG9ydFVuZXhwZWN0ZWRWbmV0U2h1dGRvd24SPS50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuUmVwb3J0VW5leHBlY3RlZFZuZXRTaHV0ZG93blJlcXVlc3QaPi50ZWxlcG9ydC5saWIudGVsZXRlcm0udjEuUmVwb3J0VW5leHBlY3RlZFZuZXRTaHV0ZG93blJlc3BvbnNlQlRaUmdpdGh1Yi5jb20vZ3Jhdml0YXRpb25hbC90ZWxlcG9ydC9nZW4vcHJvdG8vZ28vdGVsZXBvcnQvbGliL3RlbGV0ZXJtL3YxO3RlbGV0ZXJtdjFiBnByb3RvMw");

/**
 * Request for Relogin.
 *
 * @generated from message teleport.lib.teleterm.v1.ReloginRequest
 */
export type ReloginRequest = Message<"teleport.lib.teleterm.v1.ReloginRequest"> & {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri: string;

  /**
   * @generated from oneof teleport.lib.teleterm.v1.ReloginRequest.reason
   */
  reason: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.GatewayCertExpired gateway_cert_expired = 2;
     */
    value: GatewayCertExpired;
    case: "gatewayCertExpired";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.VnetCertExpired vnet_cert_expired = 3;
     */
    value: VnetCertExpired;
    case: "vnetCertExpired";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.lib.teleterm.v1.ReloginRequest.
 * Use `create(ReloginRequestSchema)` to create a new message.
 */
export const ReloginRequestSchema: GenMessage<ReloginRequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 0);

/**
 * GatewayCertExpired is given as the reason when a database client attempts to make a connection
 * through the gateway, the gateway middleware notices that the db cert has expired and tries to
 * connect to the cluster to reissue the cert, but fails because the user cert has expired as well.
 *
 * At that point in order to let the connection through, tshd needs the Electron app to refresh the
 * user cert by asking the user to log in again.
 *
 * @generated from message teleport.lib.teleterm.v1.GatewayCertExpired
 */
export type GatewayCertExpired = Message<"teleport.lib.teleterm.v1.GatewayCertExpired"> & {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri: string;

  /**
   * @generated from field: string target_uri = 2;
   */
  targetUri: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.GatewayCertExpired.
 * Use `create(GatewayCertExpiredSchema)` to create a new message.
 */
export const GatewayCertExpiredSchema: GenMessage<GatewayCertExpired> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 1);

/**
 * VnetCertExpired describes which app the user was trying to reach with an expired cert.
 *
 * @generated from message teleport.lib.teleterm.v1.VnetCertExpired
 */
export type VnetCertExpired = Message<"teleport.lib.teleterm.v1.VnetCertExpired"> & {
  /**
   * target_uri for now points solely at apps, but it's not called app_uri to make it future-proof.
   *
   * @generated from field: string target_uri = 1;
   */
  targetUri: string;

  /**
   * public_addr is the public address of the app that the user tried to access.
   *
   * @generated from field: string public_addr = 2;
   */
  publicAddr: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.VnetCertExpired.
 * Use `create(VnetCertExpiredSchema)` to create a new message.
 */
export const VnetCertExpiredSchema: GenMessage<VnetCertExpired> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 2);

/**
 * Response for Relogin.
 *
 * @generated from message teleport.lib.teleterm.v1.ReloginResponse
 */
export type ReloginResponse = Message<"teleport.lib.teleterm.v1.ReloginResponse"> & {
};

/**
 * Describes the message teleport.lib.teleterm.v1.ReloginResponse.
 * Use `create(ReloginResponseSchema)` to create a new message.
 */
export const ReloginResponseSchema: GenMessage<ReloginResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 3);

/**
 * SendNotificationRequest includes details behind a notification.
 *
 * Rather than including arbitrary text strings, SendNotificationRequest should contain minimal
 * details. The Electron app can then consume and format them as needed, without having to change
 * what is sent over the wire.
 *
 * @generated from message teleport.lib.teleterm.v1.SendNotificationRequest
 */
export type SendNotificationRequest = Message<"teleport.lib.teleterm.v1.SendNotificationRequest"> & {
  /**
   * @generated from oneof teleport.lib.teleterm.v1.SendNotificationRequest.subject
   */
  subject: {
    /**
     * @generated from field: teleport.lib.teleterm.v1.CannotProxyGatewayConnection cannot_proxy_gateway_connection = 1;
     */
    value: CannotProxyGatewayConnection;
    case: "cannotProxyGatewayConnection";
  } | {
    /**
     * @generated from field: teleport.lib.teleterm.v1.CannotProxyVnetConnection cannot_proxy_vnet_connection = 2;
     */
    value: CannotProxyVnetConnection;
    case: "cannotProxyVnetConnection";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.lib.teleterm.v1.SendNotificationRequest.
 * Use `create(SendNotificationRequestSchema)` to create a new message.
 */
export const SendNotificationRequestSchema: GenMessage<SendNotificationRequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 4);

/**
 * CannotProxyGatewayConnection is the subject when the middleware used by the gateway encounters an
 * unrecoverable error and cannot let the connection through. The middleware code is executed within
 * a separate goroutine so if the error wasn't passed to the Electron app, it would have been
 * visible only in the logs.
 *
 * @generated from message teleport.lib.teleterm.v1.CannotProxyGatewayConnection
 */
export type CannotProxyGatewayConnection = Message<"teleport.lib.teleterm.v1.CannotProxyGatewayConnection"> & {
  /**
   * @generated from field: string gateway_uri = 1;
   */
  gatewayUri: string;

  /**
   * @generated from field: string target_uri = 2;
   */
  targetUri: string;

  /**
   * @generated from field: string error = 3;
   */
  error: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.CannotProxyGatewayConnection.
 * Use `create(CannotProxyGatewayConnectionSchema)` to create a new message.
 */
export const CannotProxyGatewayConnectionSchema: GenMessage<CannotProxyGatewayConnection> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 5);

/**
 * CannotProxyVnetConnection describes which app couldn't have been proxied through VNet and why.
 * At the moment this is used solely when refreshing an expired cert.
 *
 * @generated from message teleport.lib.teleterm.v1.CannotProxyVnetConnection
 */
export type CannotProxyVnetConnection = Message<"teleport.lib.teleterm.v1.CannotProxyVnetConnection"> & {
  /**
   * @generated from field: string target_uri = 1;
   */
  targetUri: string;

  /**
   * @generated from field: string error = 2;
   */
  error: string;

  /**
   * public_addr is the public address of the app that the user tried to access.
   *
   * @generated from field: string public_addr = 3;
   */
  publicAddr: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.CannotProxyVnetConnection.
 * Use `create(CannotProxyVnetConnectionSchema)` to create a new message.
 */
export const CannotProxyVnetConnectionSchema: GenMessage<CannotProxyVnetConnection> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 6);

/**
 * Response for SendNotification.
 *
 * @generated from message teleport.lib.teleterm.v1.SendNotificationResponse
 */
export type SendNotificationResponse = Message<"teleport.lib.teleterm.v1.SendNotificationResponse"> & {
};

/**
 * Describes the message teleport.lib.teleterm.v1.SendNotificationResponse.
 * Use `create(SendNotificationResponseSchema)` to create a new message.
 */
export const SendNotificationResponseSchema: GenMessage<SendNotificationResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 7);

/**
 * Request for SendPendingHeadlessAuthentication.
 *
 * @generated from message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest
 */
export type SendPendingHeadlessAuthenticationRequest = Message<"teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest"> & {
  /**
   * @generated from field: string root_cluster_uri = 1;
   */
  rootClusterUri: string;

  /**
   * @generated from field: string headless_authentication_id = 2;
   */
  headlessAuthenticationId: string;

  /**
   * @generated from field: string headless_authentication_client_ip = 3;
   */
  headlessAuthenticationClientIp: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationRequest.
 * Use `create(SendPendingHeadlessAuthenticationRequestSchema)` to create a new message.
 */
export const SendPendingHeadlessAuthenticationRequestSchema: GenMessage<SendPendingHeadlessAuthenticationRequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 8);

/**
 * Response for SendPendingHeadlessAuthentication.
 *
 * @generated from message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse
 */
export type SendPendingHeadlessAuthenticationResponse = Message<"teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse"> & {
};

/**
 * Describes the message teleport.lib.teleterm.v1.SendPendingHeadlessAuthenticationResponse.
 * Use `create(SendPendingHeadlessAuthenticationResponseSchema)` to create a new message.
 */
export const SendPendingHeadlessAuthenticationResponseSchema: GenMessage<SendPendingHeadlessAuthenticationResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 9);

/**
 * Request for PromptMFA.
 *
 * @generated from message teleport.lib.teleterm.v1.PromptMFARequest
 */
export type PromptMFARequest = Message<"teleport.lib.teleterm.v1.PromptMFARequest"> & {
  /**
   * @generated from field: string reason = 2;
   */
  reason: string;

  /**
   * @generated from field: bool totp = 3;
   */
  totp: boolean;

  /**
   * @generated from field: bool webauthn = 4;
   */
  webauthn: boolean;

  /**
   * @generated from field: string cluster_uri = 5;
   */
  clusterUri: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.PromptMFARequest.
 * Use `create(PromptMFARequestSchema)` to create a new message.
 */
export const PromptMFARequestSchema: GenMessage<PromptMFARequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 10);

/**
 * Response for PromptMFA.
 *
 * @generated from message teleport.lib.teleterm.v1.PromptMFAResponse
 */
export type PromptMFAResponse = Message<"teleport.lib.teleterm.v1.PromptMFAResponse"> & {
  /**
   * @generated from field: string totp_code = 1;
   */
  totpCode: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.PromptMFAResponse.
 * Use `create(PromptMFAResponseSchema)` to create a new message.
 */
export const PromptMFAResponseSchema: GenMessage<PromptMFAResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 11);

/**
 * Request for GetUsageReportingSettings.
 *
 * @generated from message teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest
 */
export type GetUsageReportingSettingsRequest = Message<"teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest"> & {
};

/**
 * Describes the message teleport.lib.teleterm.v1.GetUsageReportingSettingsRequest.
 * Use `create(GetUsageReportingSettingsRequestSchema)` to create a new message.
 */
export const GetUsageReportingSettingsRequestSchema: GenMessage<GetUsageReportingSettingsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 12);

/**
 * Response for GetUsageReportingSettings.
 *
 * @generated from message teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse
 */
export type GetUsageReportingSettingsResponse = Message<"teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse"> & {
  /**
   * @generated from field: teleport.lib.teleterm.v1.UsageReportingSettings usage_reporting_settings = 1;
   */
  usageReportingSettings?: UsageReportingSettings;
};

/**
 * Describes the message teleport.lib.teleterm.v1.GetUsageReportingSettingsResponse.
 * Use `create(GetUsageReportingSettingsResponseSchema)` to create a new message.
 */
export const GetUsageReportingSettingsResponseSchema: GenMessage<GetUsageReportingSettingsResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 13);

/**
 * UsageReportingSettings contains information about usage reporting as understood by the Electron
 * app.
 *
 * @generated from message teleport.lib.teleterm.v1.UsageReportingSettings
 */
export type UsageReportingSettings = Message<"teleport.lib.teleterm.v1.UsageReportingSettings"> & {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message teleport.lib.teleterm.v1.UsageReportingSettings.
 * Use `create(UsageReportingSettingsSchema)` to create a new message.
 */
export const UsageReportingSettingsSchema: GenMessage<UsageReportingSettings> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 14);

/**
 * Request for ReportUnexpectedVnetShutdown.
 *
 * @generated from message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest
 */
export type ReportUnexpectedVnetShutdownRequest = Message<"teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest"> & {
  /**
   * error is the error message with which VNet was shut down. Technically it can be empty, so
   * consumers should account for that.
   *
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * Describes the message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownRequest.
 * Use `create(ReportUnexpectedVnetShutdownRequestSchema)` to create a new message.
 */
export const ReportUnexpectedVnetShutdownRequestSchema: GenMessage<ReportUnexpectedVnetShutdownRequest> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 15);

/**
 * Response for ReportUnexpectedVnetShutdown.
 *
 * @generated from message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse
 */
export type ReportUnexpectedVnetShutdownResponse = Message<"teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse"> & {
};

/**
 * Describes the message teleport.lib.teleterm.v1.ReportUnexpectedVnetShutdownResponse.
 * Use `create(ReportUnexpectedVnetShutdownResponseSchema)` to create a new message.
 */
export const ReportUnexpectedVnetShutdownResponseSchema: GenMessage<ReportUnexpectedVnetShutdownResponse> = /*@__PURE__*/
  messageDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 16);

/**
 * TshdEventsService is served by the Electron app. The tsh daemon calls this service to notify the
 * app about actions that happen outside of the app itself.
 *
 * @generated from service teleport.lib.teleterm.v1.TshdEventsService
 */
export const TshdEventsService: GenService<{
  /**
   * Relogin makes the Electron app display a login modal for the specific root cluster. The request
   * returns a response after the relogin procedure has been successfully finished.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.Relogin
   */
  relogin: {
    methodKind: "unary";
    input: typeof ReloginRequestSchema;
    output: typeof ReloginResponseSchema;
  },
  /**
   * SendNotification causes the Electron app to display a notification in the UI. The request
   * accepts a specific message rather than a generic string so that the Electron is in control as
   * to what message is displayed and how exactly it looks.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.SendNotification
   */
  sendNotification: {
    methodKind: "unary";
    input: typeof SendNotificationRequestSchema;
    output: typeof SendNotificationResponseSchema;
  },
  /**
   * SendPendingHeadlessAuthentication notifies the Electron app of a pending headless authentication,
   * which it can use to initiate headless authentication resolution in the UI.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.SendPendingHeadlessAuthentication
   */
  sendPendingHeadlessAuthentication: {
    methodKind: "unary";
    input: typeof SendPendingHeadlessAuthenticationRequestSchema;
    output: typeof SendPendingHeadlessAuthenticationResponseSchema;
  },
  /**
   * PromptMFA notifies the Electron app that the daemon is waiting for the user to answer an MFA prompt.
   * If Webauthn is supported, tsh daemon starts another goroutine which readies the hardware key.
   * If TOTP is supported, tsh daemon expects that the Electron app responds to this RPC with the
   * code.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.PromptMFA
   */
  promptMFA: {
    methodKind: "unary";
    input: typeof PromptMFARequestSchema;
    output: typeof PromptMFAResponseSchema;
  },
  /**
   * GetUsageReportingSettings returns the current state of usage reporting.
   * At the moment, the user cannot toggle usage reporting on and off without shutting down the app,
   * with the only exception being the first start of the app when they're prompted about telemetry.
   * Hence why this is an RPC and not information passed over argv to tsh daemon.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.GetUsageReportingSettings
   */
  getUsageReportingSettings: {
    methodKind: "unary";
    input: typeof GetUsageReportingSettingsRequestSchema;
    output: typeof GetUsageReportingSettingsResponseSchema;
  },
  /**
   * ReportUnexpectedVnetShutdown is sent by tsh daemon when VNet exits outside of the
   * request-response cycle of Start and Stop RPCs of VnetService. The Electron app is then able to
   * update the state of VNet in the UI.
   *
   * @generated from rpc teleport.lib.teleterm.v1.TshdEventsService.ReportUnexpectedVnetShutdown
   */
  reportUnexpectedVnetShutdown: {
    methodKind: "unary";
    input: typeof ReportUnexpectedVnetShutdownRequestSchema;
    output: typeof ReportUnexpectedVnetShutdownResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_teleport_lib_teleterm_v1_tshd_events_service, 0);

