// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/dbobjectimportrule/v1/dbobjectimportrule.proto (package teleport.dbobjectimportrule.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Metadata } from "../../header/v1/metadata_pb.js";
import { Label } from "../../label/v1/label_pb.js";

/**
 * DatabaseObjectImportRule is the resource representing a global database object import rule.
 * The import rules govern which database objects are imported from databases.
 * See type teleport.dbobject.v1.DatabaseObject for the description of a database object.
 * For rationale behind this type, see the RFD 151.
 *
 * @generated from message teleport.dbobjectimportrule.v1.DatabaseObjectImportRule
 */
export class DatabaseObjectImportRule extends Message<DatabaseObjectImportRule> {
  /**
   * The kind of resource represented.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * Mandatory field for all resources. Not populated for this resource type.
   *
   * @generated from field: string sub_kind = 2;
   */
  subKind = "";

  /**
   * The version of the resource being represented.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * Common metadata that all resources share.
   *
   * @generated from field: teleport.header.v1.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * spec represents the specifications for the database object import rule.
   *
   * @generated from field: teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleSpec spec = 5;
   */
  spec?: DatabaseObjectImportRuleSpec;

  constructor(data?: PartialMessage<DatabaseObjectImportRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.dbobjectimportrule.v1.DatabaseObjectImportRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "spec", kind: "message", T: DatabaseObjectImportRuleSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseObjectImportRule {
    return new DatabaseObjectImportRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseObjectImportRule {
    return new DatabaseObjectImportRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseObjectImportRule {
    return new DatabaseObjectImportRule().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseObjectImportRule | PlainMessage<DatabaseObjectImportRule> | undefined, b: DatabaseObjectImportRule | PlainMessage<DatabaseObjectImportRule> | undefined): boolean {
    return proto3.util.equals(DatabaseObjectImportRule, a, b);
  }
}

/**
 * DatabaseObjectImportRuleSpec is the spec for database object import rule.
 *
 * @generated from message teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleSpec
 */
export class DatabaseObjectImportRuleSpec extends Message<DatabaseObjectImportRuleSpec> {
  /**
   * priority represents the priority of the rule application.
   *
   * Rules are processed from lowest to highest priority.
   * If two rules apply the same label, then the value applied with the rule with the highest priority wins.
   *
   * @generated from field: int32 priority = 1;
   */
  priority = 0;

  /**
   * db_labels is a set of labels matched against database labels.
   *
   * @generated from field: repeated teleport.label.v1.Label database_labels = 3;
   */
  databaseLabels: Label[] = [];

  /**
   * mappings is a list of matches that will map match conditions to labels.
   *
   * @generated from field: repeated teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleMapping mappings = 4;
   */
  mappings: DatabaseObjectImportRuleMapping[] = [];

  constructor(data?: PartialMessage<DatabaseObjectImportRuleSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "priority", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "database_labels", kind: "message", T: Label, repeated: true },
    { no: 4, name: "mappings", kind: "message", T: DatabaseObjectImportRuleMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseObjectImportRuleSpec {
    return new DatabaseObjectImportRuleSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseObjectImportRuleSpec {
    return new DatabaseObjectImportRuleSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseObjectImportRuleSpec {
    return new DatabaseObjectImportRuleSpec().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseObjectImportRuleSpec | PlainMessage<DatabaseObjectImportRuleSpec> | undefined, b: DatabaseObjectImportRuleSpec | PlainMessage<DatabaseObjectImportRuleSpec> | undefined): boolean {
    return proto3.util.equals(DatabaseObjectImportRuleSpec, a, b);
  }
}

/**
 * DatabaseObjectImportRuleMapping is the mapping between object properties and labels that will be added to the object.
 *
 * @generated from message teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleMapping
 */
export class DatabaseObjectImportRuleMapping extends Message<DatabaseObjectImportRuleMapping> {
  /**
   * match specifies the matching rules, like the object names.
   *
   * @generated from field: teleport.dbobjectimportrule.v1.DatabaseObjectImportMatch match = 1;
   */
  match?: DatabaseObjectImportMatch;

  /**
   * scope specifies the object scope. Optional. If not provided, all scopes will be accepted.
   *
   * @generated from field: teleport.dbobjectimportrule.v1.DatabaseObjectImportScope scope = 2;
   */
  scope?: DatabaseObjectImportScope;

  /**
   * add_labels specifies which labels to add if the match succeeds. At least one should be present.
   *
   * @generated from field: map<string, string> add_labels = 3;
   */
  addLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<DatabaseObjectImportRuleMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.dbobjectimportrule.v1.DatabaseObjectImportRuleMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "message", T: DatabaseObjectImportMatch },
    { no: 2, name: "scope", kind: "message", T: DatabaseObjectImportScope },
    { no: 3, name: "add_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseObjectImportRuleMapping {
    return new DatabaseObjectImportRuleMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseObjectImportRuleMapping {
    return new DatabaseObjectImportRuleMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseObjectImportRuleMapping {
    return new DatabaseObjectImportRuleMapping().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseObjectImportRuleMapping | PlainMessage<DatabaseObjectImportRuleMapping> | undefined, b: DatabaseObjectImportRuleMapping | PlainMessage<DatabaseObjectImportRuleMapping> | undefined): boolean {
    return proto3.util.equals(DatabaseObjectImportRuleMapping, a, b);
  }
}

/**
 * DatabaseObjectImportMatch specifies acceptable object names. Must have at least one non-empty member.
 *
 * @generated from message teleport.dbobjectimportrule.v1.DatabaseObjectImportMatch
 */
export class DatabaseObjectImportMatch extends Message<DatabaseObjectImportMatch> {
  /**
   * table_names specify the names of the tables to match. Optional.
   *
   * @generated from field: repeated string table_names = 1;
   */
  tableNames: string[] = [];

  /**
   * view_names specify the names of the views to match. Optional.
   *
   * @generated from field: repeated string view_names = 2;
   */
  viewNames: string[] = [];

  /**
   * procedure_names specify the names of the procedures to match. Optional.
   *
   * @generated from field: repeated string procedure_names = 3;
   */
  procedureNames: string[] = [];

  constructor(data?: PartialMessage<DatabaseObjectImportMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.dbobjectimportrule.v1.DatabaseObjectImportMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "view_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "procedure_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseObjectImportMatch {
    return new DatabaseObjectImportMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseObjectImportMatch {
    return new DatabaseObjectImportMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseObjectImportMatch {
    return new DatabaseObjectImportMatch().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseObjectImportMatch | PlainMessage<DatabaseObjectImportMatch> | undefined, b: DatabaseObjectImportMatch | PlainMessage<DatabaseObjectImportMatch> | undefined): boolean {
    return proto3.util.equals(DatabaseObjectImportMatch, a, b);
  }
}

/**
 * DatabaseObjectImportScope specifies the object scope. Members are matched independently of each other.
 *
 * @generated from message teleport.dbobjectimportrule.v1.DatabaseObjectImportScope
 */
export class DatabaseObjectImportScope extends Message<DatabaseObjectImportScope> {
  /**
   * database_names specify the names of the databases to include in the scope. Optional.
   *
   * @generated from field: repeated string database_names = 1;
   */
  databaseNames: string[] = [];

  /**
   * schema_names specify the names of the schemas to include in the scope. Optional.
   *
   * @generated from field: repeated string schema_names = 2;
   */
  schemaNames: string[] = [];

  constructor(data?: PartialMessage<DatabaseObjectImportScope>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.dbobjectimportrule.v1.DatabaseObjectImportScope";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "schema_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseObjectImportScope {
    return new DatabaseObjectImportScope().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseObjectImportScope {
    return new DatabaseObjectImportScope().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseObjectImportScope {
    return new DatabaseObjectImportScope().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseObjectImportScope | PlainMessage<DatabaseObjectImportScope> | undefined, b: DatabaseObjectImportScope | PlainMessage<DatabaseObjectImportScope> | undefined): boolean {
    return proto3.util.equals(DatabaseObjectImportScope, a, b);
  }
}

