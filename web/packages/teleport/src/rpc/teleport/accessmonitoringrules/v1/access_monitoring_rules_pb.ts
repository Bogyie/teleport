// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/accessmonitoringrules/v1/access_monitoring_rules.proto (package teleport.accessmonitoringrules.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Metadata } from "../../header/v1/metadata_pb.js";

/**
 * AccessMonitoringRule represents an access monitoring rule resources.
 *
 * @generated from message teleport.accessmonitoringrules.v1.AccessMonitoringRule
 */
export class AccessMonitoringRule extends Message<AccessMonitoringRule> {
  /**
   * metadata is the rules's metadata.
   *
   * @generated from field: teleport.header.v1.Metadata metadata = 1;
   */
  metadata?: Metadata;

  /**
   * kind is a resource kind
   *
   * @generated from field: string kind = 2;
   */
  kind = "";

  /**
   * sub_kind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string sub_kind = 3;
   */
  subKind = "";

  /**
   * version is version
   *
   * @generated from field: string version = 4;
   */
  version = "";

  /**
   * Spec is an AccessMonitoringRule specification
   *
   * @generated from field: teleport.accessmonitoringrules.v1.AccessMonitoringRuleSpec spec = 5;
   */
  spec?: AccessMonitoringRuleSpec;

  constructor(data?: PartialMessage<AccessMonitoringRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.AccessMonitoringRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: Metadata },
    { no: 2, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "spec", kind: "message", T: AccessMonitoringRuleSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessMonitoringRule {
    return new AccessMonitoringRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessMonitoringRule {
    return new AccessMonitoringRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessMonitoringRule {
    return new AccessMonitoringRule().fromJsonString(jsonString, options);
  }

  static equals(a: AccessMonitoringRule | PlainMessage<AccessMonitoringRule> | undefined, b: AccessMonitoringRule | PlainMessage<AccessMonitoringRule> | undefined): boolean {
    return proto3.util.equals(AccessMonitoringRule, a, b);
  }
}

/**
 * AccessMonitoringRuleSpec is the access monitoring rule spec
 *
 * @generated from message teleport.accessmonitoringrules.v1.AccessMonitoringRuleSpec
 */
export class AccessMonitoringRuleSpec extends Message<AccessMonitoringRuleSpec> {
  /**
   * subjects the rule operates on, can be a resource kind or a particular resource property.
   *
   * @generated from field: repeated string subjects = 1;
   */
  subjects: string[] = [];

  /**
   * states are the desired state which the monitoring rule is attempting to bring the subjects matching the condition to.
   *
   * @generated from field: repeated string states = 2;
   */
  states: string[] = [];

  /**
   * condition is a predicate expression that operates on the specified subject resources,
   * and determines whether the subject will be moved into desired state.
   *
   * @generated from field: string condition = 3;
   */
  condition = "";

  /**
   * notification defines the plugin configuration for notifications if rule is triggered.
   *
   * @generated from field: teleport.accessmonitoringrules.v1.Notification notification = 4;
   */
  notification?: Notification;

  constructor(data?: PartialMessage<AccessMonitoringRuleSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.AccessMonitoringRuleSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "states", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "condition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "notification", kind: "message", T: Notification },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessMonitoringRuleSpec {
    return new AccessMonitoringRuleSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessMonitoringRuleSpec {
    return new AccessMonitoringRuleSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessMonitoringRuleSpec {
    return new AccessMonitoringRuleSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AccessMonitoringRuleSpec | PlainMessage<AccessMonitoringRuleSpec> | undefined, b: AccessMonitoringRuleSpec | PlainMessage<AccessMonitoringRuleSpec> | undefined): boolean {
    return proto3.util.equals(AccessMonitoringRuleSpec, a, b);
  }
}

/**
 * Notification contains configurations for plugin notification rules.
 *
 * @generated from message teleport.accessmonitoringrules.v1.Notification
 */
export class Notification extends Message<Notification> {
  /**
   * name is the name of the plugin to which this configuration should apply.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * recipients is the list of recipients the plugin should notify.
   *
   * @generated from field: repeated string recipients = 2;
   */
  recipients: string[] = [];

  constructor(data?: PartialMessage<Notification>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.Notification";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recipients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Notification {
    return new Notification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Notification {
    return new Notification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Notification {
    return new Notification().fromJsonString(jsonString, options);
  }

  static equals(a: Notification | PlainMessage<Notification> | undefined, b: Notification | PlainMessage<Notification> | undefined): boolean {
    return proto3.util.equals(Notification, a, b);
  }
}

/**
 * CreateAccessMonitoringRuleRequest is the request for CreateAccessMonitoringRule.
 *
 * @generated from message teleport.accessmonitoringrules.v1.CreateAccessMonitoringRuleRequest
 */
export class CreateAccessMonitoringRuleRequest extends Message<CreateAccessMonitoringRuleRequest> {
  /**
   * access_monitoring_rule is the specification of the rule to be created.
   *
   * @generated from field: teleport.accessmonitoringrules.v1.AccessMonitoringRule rule = 1;
   */
  rule?: AccessMonitoringRule;

  constructor(data?: PartialMessage<CreateAccessMonitoringRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.CreateAccessMonitoringRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: AccessMonitoringRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccessMonitoringRuleRequest {
    return new CreateAccessMonitoringRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccessMonitoringRuleRequest {
    return new CreateAccessMonitoringRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccessMonitoringRuleRequest {
    return new CreateAccessMonitoringRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccessMonitoringRuleRequest | PlainMessage<CreateAccessMonitoringRuleRequest> | undefined, b: CreateAccessMonitoringRuleRequest | PlainMessage<CreateAccessMonitoringRuleRequest> | undefined): boolean {
    return proto3.util.equals(CreateAccessMonitoringRuleRequest, a, b);
  }
}

/**
 * UpdateAccessMonitoringRuleRequest is the request for UpdateAccessMonitoringRule.
 *
 * @generated from message teleport.accessmonitoringrules.v1.UpdateAccessMonitoringRuleRequest
 */
export class UpdateAccessMonitoringRuleRequest extends Message<UpdateAccessMonitoringRuleRequest> {
  /**
   * access_monitoring_rule is the specification of the rule to be updated.
   *
   * @generated from field: teleport.accessmonitoringrules.v1.AccessMonitoringRule rule = 1;
   */
  rule?: AccessMonitoringRule;

  constructor(data?: PartialMessage<UpdateAccessMonitoringRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.UpdateAccessMonitoringRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: AccessMonitoringRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAccessMonitoringRuleRequest {
    return new UpdateAccessMonitoringRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAccessMonitoringRuleRequest {
    return new UpdateAccessMonitoringRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAccessMonitoringRuleRequest {
    return new UpdateAccessMonitoringRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAccessMonitoringRuleRequest | PlainMessage<UpdateAccessMonitoringRuleRequest> | undefined, b: UpdateAccessMonitoringRuleRequest | PlainMessage<UpdateAccessMonitoringRuleRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAccessMonitoringRuleRequest, a, b);
  }
}

/**
 * UpsertAccessMonitoringRuleRequest is the request for UpsertAccessMonitoringRule.
 *
 * @generated from message teleport.accessmonitoringrules.v1.UpsertAccessMonitoringRuleRequest
 */
export class UpsertAccessMonitoringRuleRequest extends Message<UpsertAccessMonitoringRuleRequest> {
  /**
   * access_monitoring_rule is the specification of the rule to be upserted.
   *
   * @generated from field: teleport.accessmonitoringrules.v1.AccessMonitoringRule rule = 1;
   */
  rule?: AccessMonitoringRule;

  constructor(data?: PartialMessage<UpsertAccessMonitoringRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.UpsertAccessMonitoringRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule", kind: "message", T: AccessMonitoringRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertAccessMonitoringRuleRequest {
    return new UpsertAccessMonitoringRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertAccessMonitoringRuleRequest {
    return new UpsertAccessMonitoringRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertAccessMonitoringRuleRequest {
    return new UpsertAccessMonitoringRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertAccessMonitoringRuleRequest | PlainMessage<UpsertAccessMonitoringRuleRequest> | undefined, b: UpsertAccessMonitoringRuleRequest | PlainMessage<UpsertAccessMonitoringRuleRequest> | undefined): boolean {
    return proto3.util.equals(UpsertAccessMonitoringRuleRequest, a, b);
  }
}

/**
 * GetAccessMonitoringRuleRequest is the request for GetAccessMonitoringRule.
 *
 * @generated from message teleport.accessmonitoringrules.v1.GetAccessMonitoringRuleRequest
 */
export class GetAccessMonitoringRuleRequest extends Message<GetAccessMonitoringRuleRequest> {
  /**
   * resource_name is the name of the rule to be returned.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetAccessMonitoringRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.GetAccessMonitoringRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccessMonitoringRuleRequest {
    return new GetAccessMonitoringRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccessMonitoringRuleRequest {
    return new GetAccessMonitoringRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccessMonitoringRuleRequest {
    return new GetAccessMonitoringRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccessMonitoringRuleRequest | PlainMessage<GetAccessMonitoringRuleRequest> | undefined, b: GetAccessMonitoringRuleRequest | PlainMessage<GetAccessMonitoringRuleRequest> | undefined): boolean {
    return proto3.util.equals(GetAccessMonitoringRuleRequest, a, b);
  }
}

/**
 * DeleteAccessMonitoringRuleRequest is the request for DeleteAccessMonitoringRule.
 *
 * @generated from message teleport.accessmonitoringrules.v1.DeleteAccessMonitoringRuleRequest
 */
export class DeleteAccessMonitoringRuleRequest extends Message<DeleteAccessMonitoringRuleRequest> {
  /**
   * resource_name is the name of the rule to be removed.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteAccessMonitoringRuleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.DeleteAccessMonitoringRuleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAccessMonitoringRuleRequest {
    return new DeleteAccessMonitoringRuleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAccessMonitoringRuleRequest {
    return new DeleteAccessMonitoringRuleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAccessMonitoringRuleRequest {
    return new DeleteAccessMonitoringRuleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAccessMonitoringRuleRequest | PlainMessage<DeleteAccessMonitoringRuleRequest> | undefined, b: DeleteAccessMonitoringRuleRequest | PlainMessage<DeleteAccessMonitoringRuleRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAccessMonitoringRuleRequest, a, b);
  }
}

/**
 * ListAccessMonitoringRulesRequest is the request for ListAccessMonitoringRules.
 *
 * @generated from message teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesRequest
 */
export class ListAccessMonitoringRulesRequest extends Message<ListAccessMonitoringRulesRequest> {
  /**
   * page_size is the maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int64 page_size = 1;
   */
  pageSize = protoInt64.zero;

  /**
   * page_token is the next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListAccessMonitoringRulesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessMonitoringRulesRequest {
    return new ListAccessMonitoringRulesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesRequest {
    return new ListAccessMonitoringRulesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesRequest {
    return new ListAccessMonitoringRulesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessMonitoringRulesRequest | PlainMessage<ListAccessMonitoringRulesRequest> | undefined, b: ListAccessMonitoringRulesRequest | PlainMessage<ListAccessMonitoringRulesRequest> | undefined): boolean {
    return proto3.util.equals(ListAccessMonitoringRulesRequest, a, b);
  }
}

/**
 * ListAccessMonitoringRulesWithFilterRequest is the request for ListAccessMonitoringRulesWithFilter.
 *
 * @generated from message teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesWithFilterRequest
 */
export class ListAccessMonitoringRulesWithFilterRequest extends Message<ListAccessMonitoringRulesWithFilterRequest> {
  /**
   * page_size is the maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int64 page_size = 1;
   */
  pageSize = protoInt64.zero;

  /**
   * page_token is the next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * subjects are the subjects the access monitoring rules must have. This field is optional.
   *
   * @generated from field: repeated string subjects = 3;
   */
  subjects: string[] = [];

  /**
   * notification_name is the value of the notification name field the rule must have. This field is optional.
   *
   * @generated from field: string notification_name = 4;
   */
  notificationName = "";

  constructor(data?: PartialMessage<ListAccessMonitoringRulesWithFilterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesWithFilterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "notification_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessMonitoringRulesWithFilterRequest {
    return new ListAccessMonitoringRulesWithFilterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesWithFilterRequest {
    return new ListAccessMonitoringRulesWithFilterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesWithFilterRequest {
    return new ListAccessMonitoringRulesWithFilterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessMonitoringRulesWithFilterRequest | PlainMessage<ListAccessMonitoringRulesWithFilterRequest> | undefined, b: ListAccessMonitoringRulesWithFilterRequest | PlainMessage<ListAccessMonitoringRulesWithFilterRequest> | undefined): boolean {
    return proto3.util.equals(ListAccessMonitoringRulesWithFilterRequest, a, b);
  }
}

/**
 * ListAccessMonitoringRulesResponse is the response from ListAccessMonitoringRules.
 *
 * @generated from message teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesResponse
 */
export class ListAccessMonitoringRulesResponse extends Message<ListAccessMonitoringRulesResponse> {
  /**
   * The page of AccessMonitoringRule that matched the request.
   *
   * @generated from field: repeated teleport.accessmonitoringrules.v1.AccessMonitoringRule rules = 1;
   */
  rules: AccessMonitoringRule[] = [];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListAccessMonitoringRulesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: AccessMonitoringRule, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessMonitoringRulesResponse {
    return new ListAccessMonitoringRulesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesResponse {
    return new ListAccessMonitoringRulesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesResponse {
    return new ListAccessMonitoringRulesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessMonitoringRulesResponse | PlainMessage<ListAccessMonitoringRulesResponse> | undefined, b: ListAccessMonitoringRulesResponse | PlainMessage<ListAccessMonitoringRulesResponse> | undefined): boolean {
    return proto3.util.equals(ListAccessMonitoringRulesResponse, a, b);
  }
}

/**
 * ListAccessMonitoringRulesWithFilterResponse is the response from ListAccessMonitoringRulesWithFilter.
 *
 * @generated from message teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesWithFilterResponse
 */
export class ListAccessMonitoringRulesWithFilterResponse extends Message<ListAccessMonitoringRulesWithFilterResponse> {
  /**
   * The page of AccessMonitoringRule that matched the request.
   *
   * @generated from field: repeated teleport.accessmonitoringrules.v1.AccessMonitoringRule rules = 1;
   */
  rules: AccessMonitoringRule[] = [];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListAccessMonitoringRulesWithFilterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.accessmonitoringrules.v1.ListAccessMonitoringRulesWithFilterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: AccessMonitoringRule, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessMonitoringRulesWithFilterResponse {
    return new ListAccessMonitoringRulesWithFilterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesWithFilterResponse {
    return new ListAccessMonitoringRulesWithFilterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessMonitoringRulesWithFilterResponse {
    return new ListAccessMonitoringRulesWithFilterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessMonitoringRulesWithFilterResponse | PlainMessage<ListAccessMonitoringRulesWithFilterResponse> | undefined, b: ListAccessMonitoringRulesWithFilterResponse | PlainMessage<ListAccessMonitoringRulesWithFilterResponse> | undefined): boolean {
    return proto3.util.equals(ListAccessMonitoringRulesWithFilterResponse, a, b);
  }
}

