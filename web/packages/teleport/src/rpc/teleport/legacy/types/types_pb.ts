// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/legacy/types/types.proto (package types, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BoolValue as BoolValue$1, Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { CustomType, LabelValues, StringValues } from "./wrappers/wrappers_pb.js";
import { AttestationStatement } from "../../attestation/v1/attestation_pb.js";

/**
 * IAMPolicyStatus represents states that describe if an AWS database
 * has its IAM policy properly configured or not.
 * This enum is set in a Sync.Map during an IAM task that checks for the
 * validity of IAM policy, and the database gets updated with the value
 * from this map during a heartbeat.
 *
 * @generated from enum types.IAMPolicyStatus
 */
export enum IAMPolicyStatus {
  /**
   * IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
   * nothing has been attempted yet.
   *
   * @generated from enum value: IAM_POLICY_STATUS_UNSPECIFIED = 0;
   */
  IAM_POLICY_STATUS_UNSPECIFIED = 0,

  /**
   * IAM_POLICY_STATUS_PENDING represents a state where iam policy status
   * is pending to be checked. This enum value is set at the start of
   * registering a database -> IAM setup (before the db heartbeat starts).
   *
   * This state was required for two reasons:
   *   1) To be able to tell apart from an older service that do not update
   *      the IAMPolicyStatus (in which case the enum value will remain the
   *      zero value).
   *   2) When starting a database, the heartbeat and its IAM task starts,
   *      and the heartbeat may run first before the IAM task finishes.
   *
   * @generated from enum value: IAM_POLICY_STATUS_PENDING = 1;
   */
  IAM_POLICY_STATUS_PENDING = 1,

  /**
   * IAM_POLICY_STATUS_FAILED represents a state where an error occured
   * while checking for IAM policy status eg: no AWS credentials provider found
   * or the policy was misconfigured.
   *
   * @generated from enum value: IAM_POLICY_STATUS_FAILED = 2;
   */
  IAM_POLICY_STATUS_FAILED = 2,

  /**
   * IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
   * correctly.
   *
   * @generated from enum value: IAM_POLICY_STATUS_SUCCESS = 3;
   */
  IAM_POLICY_STATUS_SUCCESS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(IAMPolicyStatus)
proto3.util.setEnumType(IAMPolicyStatus, "types.IAMPolicyStatus", [
  { no: 0, name: "IAM_POLICY_STATUS_UNSPECIFIED" },
  { no: 1, name: "IAM_POLICY_STATUS_PENDING" },
  { no: 2, name: "IAM_POLICY_STATUS_FAILED" },
  { no: 3, name: "IAM_POLICY_STATUS_SUCCESS" },
]);

/**
 * DatabaseTLSMode represents the level of TLS verification performed by
 * DB agent when connecting to a database.
 *
 * @generated from enum types.DatabaseTLSMode
 */
export enum DatabaseTLSMode {
  /**
   * VERIFY_FULL performs full certificate validation.
   *
   * @generated from enum value: VERIFY_FULL = 0;
   */
  VERIFY_FULL = 0,

  /**
   * VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
   *
   * @generated from enum value: VERIFY_CA = 1;
   */
  VERIFY_CA = 1,

  /**
   * INSECURE accepts any certificate provided by server. This is the least secure option.
   *
   * @generated from enum value: INSECURE = 2;
   */
  INSECURE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DatabaseTLSMode)
proto3.util.setEnumType(DatabaseTLSMode, "types.DatabaseTLSMode", [
  { no: 0, name: "VERIFY_FULL" },
  { no: 1, name: "VERIFY_CA" },
  { no: 2, name: "INSECURE" },
]);

/**
 * PrivateKeyType is the storage type of a private key.
 *
 * @generated from enum types.PrivateKeyType
 */
export enum PrivateKeyType {
  /**
   * RAW is a plaintext private key.
   *
   * @generated from enum value: RAW = 0;
   */
  RAW = 0,

  /**
   * PKCS11 is a private key backed by a PKCS11 device such as HSM.
   *
   * @generated from enum value: PKCS11 = 1;
   */
  PKCS11 = 1,

  /**
   * GCP_KMS is a private key backed by GCP KMS.
   *
   * @generated from enum value: GCP_KMS = 2;
   */
  GCP_KMS = 2,

  /**
   * AWS_KMS is a private key backed by AWS KMS.
   *
   * @generated from enum value: AWS_KMS = 3;
   */
  AWS_KMS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PrivateKeyType)
proto3.util.setEnumType(PrivateKeyType, "types.PrivateKeyType", [
  { no: 0, name: "RAW" },
  { no: 1, name: "PKCS11" },
  { no: 2, name: "GCP_KMS" },
  { no: 3, name: "AWS_KMS" },
]);

/**
 * ProxyListenerMode represents the cluster proxy listener mode.
 *
 * @generated from enum types.ProxyListenerMode
 */
export enum ProxyListenerMode {
  /**
   * Separate is the proxy listener mode indicating that proxies are running
   * in separate listener mode where Teleport Proxy services use different listeners.
   *
   * @generated from enum value: Separate = 0;
   */
  Separate = 0,

  /**
   * Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
   * where all proxy services are multiplexed on a single proxy port.
   *
   * @generated from enum value: Multiplex = 1;
   */
  Multiplex = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ProxyListenerMode)
proto3.util.setEnumType(ProxyListenerMode, "types.ProxyListenerMode", [
  { no: 0, name: "Separate" },
  { no: 1, name: "Multiplex" },
]);

/**
 * RoutingStrategy determines the strategy used to route to nodes.
 *
 * @generated from enum types.RoutingStrategy
 */
export enum RoutingStrategy {
  /**
   * UnambiguousMatch only routes to distinct nodes.
   *
   * @generated from enum value: UNAMBIGUOUS_MATCH = 0;
   */
  UNAMBIGUOUS_MATCH = 0,

  /**
   * MostRecent routes to the most recently heartbeated node if duplicates are present.
   *
   * @generated from enum value: MOST_RECENT = 1;
   */
  MOST_RECENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RoutingStrategy)
proto3.util.setEnumType(RoutingStrategy, "types.RoutingStrategy", [
  { no: 0, name: "UNAMBIGUOUS_MATCH" },
  { no: 1, name: "MOST_RECENT" },
]);

/**
 * UserTokenUsage contains additional information about the intended usage of a user token.
 *
 * @generated from enum types.UserTokenUsage
 */
export enum UserTokenUsage {
  /**
   * Default value that implies token usage was not set.
   *
   * @generated from enum value: USER_TOKEN_USAGE_UNSPECIFIED = 0;
   */
  USER_TOKEN_USAGE_UNSPECIFIED = 0,

  /**
   * USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
   *
   * @generated from enum value: USER_TOKEN_RECOVER_PASSWORD = 1;
   */
  USER_TOKEN_RECOVER_PASSWORD = 1,

  /**
   * USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
   *
   * @generated from enum value: USER_TOKEN_RECOVER_MFA = 2;
   */
  USER_TOKEN_RECOVER_MFA = 2,

  /**
   * USER_TOKEN_RENEWAL_BOT is a request to generate certificates
   * for a bot user.
   *
   * @generated from enum value: USER_TOKEN_RENEWAL_BOT = 3;
   */
  USER_TOKEN_RENEWAL_BOT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(UserTokenUsage)
proto3.util.setEnumType(UserTokenUsage, "types.UserTokenUsage", [
  { no: 0, name: "USER_TOKEN_USAGE_UNSPECIFIED" },
  { no: 1, name: "USER_TOKEN_RECOVER_PASSWORD" },
  { no: 2, name: "USER_TOKEN_RECOVER_MFA" },
  { no: 3, name: "USER_TOKEN_RENEWAL_BOT" },
]);

/**
 * RequestState represents the state of a request for escalated privilege.
 *
 * @generated from enum types.RequestState
 */
export enum RequestState {
  /**
   * NONE variant exists to allow RequestState to be explicitly omitted
   * in certain circumstances (e.g. in an AccessRequestFilter).
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * PENDING variant is the default for newly created requests.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * APPROVED variant indicates that a request has been accepted by
   * an administrating party.
   *
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * DENIED variant indicates that a request has been rejected by
   * an administrating party.
   *
   * @generated from enum value: DENIED = 3;
   */
  DENIED = 3,

  /**
   * PROMOTED variant indicates that a request has been promoted to
   * an access list.
   *
   * @generated from enum value: PROMOTED = 4;
   */
  PROMOTED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RequestState)
proto3.util.setEnumType(RequestState, "types.RequestState", [
  { no: 0, name: "NONE" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "APPROVED" },
  { no: 3, name: "DENIED" },
  { no: 4, name: "PROMOTED" },
]);

/**
 * @generated from enum types.AccessRequestScope
 */
export enum AccessRequestScope {
  /**
   * DEFAULT allows all requests to be viewed
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * MY_REQUESTS will return only requests created by the requester
   *
   * @generated from enum value: MY_REQUESTS = 1;
   */
  MY_REQUESTS = 1,

  /**
   * NEEDS_REVIEW will return only requests that were not created by
   * the requester and do not include a review made by the requester
   *
   * @generated from enum value: NEEDS_REVIEW = 2;
   */
  NEEDS_REVIEW = 2,

  /**
   * REVIEWED will return only requests that were not created by
   * the requester and have a review submitted by the requester. This
   * can include requests that have no yet been completely approved/denied.
   *
   * @generated from enum value: REVIEWED = 3;
   */
  REVIEWED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AccessRequestScope)
proto3.util.setEnumType(AccessRequestScope, "types.AccessRequestScope", [
  { no: 0, name: "DEFAULT" },
  { no: 1, name: "MY_REQUESTS" },
  { no: 2, name: "NEEDS_REVIEW" },
  { no: 3, name: "REVIEWED" },
]);

/**
 * CreateHostUserMode determines whether host user creation should be
 * disabled or if host users should be cleaned up or kept after
 * sessions end.
 *
 * @generated from enum types.CreateHostUserMode
 */
export enum CreateHostUserMode {
  /**
   * @generated from enum value: HOST_USER_MODE_UNSPECIFIED = 0;
   */
  HOST_USER_MODE_UNSPECIFIED = 0,

  /**
   * HOST_USER_MODE_OFF disables host user creation.
   *
   * @generated from enum value: HOST_USER_MODE_OFF = 1;
   */
  HOST_USER_MODE_OFF = 1,

  /**
   * HOST_USER_MODE_DROP enables host user creation and deletes users at session end.
   * Deprecated: replaced by HOST_USER_MODE_INSECURE_DROP.
   *
   * @generated from enum value: HOST_USER_MODE_DROP = 2 [deprecated = true];
   * @deprecated
   */
  HOST_USER_MODE_DROP = 2,

  /**
   * HOST_USER_MODE_KEEP enables host user creation and leaves users behind at session end.
   *
   * @generated from enum value: HOST_USER_MODE_KEEP = 3;
   */
  HOST_USER_MODE_KEEP = 3,

  /**
   * HOST_USER_MODE_INSECURE_DROP enables host user creation without a home directory and deletes
   * users at session end.
   *
   * @generated from enum value: HOST_USER_MODE_INSECURE_DROP = 4;
   */
  HOST_USER_MODE_INSECURE_DROP = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CreateHostUserMode)
proto3.util.setEnumType(CreateHostUserMode, "types.CreateHostUserMode", [
  { no: 0, name: "HOST_USER_MODE_UNSPECIFIED" },
  { no: 1, name: "HOST_USER_MODE_OFF" },
  { no: 2, name: "HOST_USER_MODE_DROP" },
  { no: 3, name: "HOST_USER_MODE_KEEP" },
  { no: 4, name: "HOST_USER_MODE_INSECURE_DROP" },
]);

/**
 * CreateDatabaseUserMode determines whether database user creation should be
 * disabled or if users should be cleaned up or kept after sessions end.
 *
 * @generated from enum types.CreateDatabaseUserMode
 */
export enum CreateDatabaseUserMode {
  /**
   * @generated from enum value: DB_USER_MODE_UNSPECIFIED = 0;
   */
  DB_USER_MODE_UNSPECIFIED = 0,

  /**
   * DB_USER_MODE_OFF disables user creation.
   *
   * @generated from enum value: DB_USER_MODE_OFF = 1;
   */
  DB_USER_MODE_OFF = 1,

  /**
   * DB_USER_MODE_KEEP allows user creation and disable users at session end.
   *
   * @generated from enum value: DB_USER_MODE_KEEP = 2;
   */
  DB_USER_MODE_KEEP = 2,

  /**
   * DB_USER_MODE_BEST_EFFORT_DROP allows user creation and tries to drop user
   * at session end. If the drop fails, fallback to disabling them.
   *
   * @generated from enum value: DB_USER_MODE_BEST_EFFORT_DROP = 3;
   */
  DB_USER_MODE_BEST_EFFORT_DROP = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CreateDatabaseUserMode)
proto3.util.setEnumType(CreateDatabaseUserMode, "types.CreateDatabaseUserMode", [
  { no: 0, name: "DB_USER_MODE_UNSPECIFIED" },
  { no: 1, name: "DB_USER_MODE_OFF" },
  { no: 2, name: "DB_USER_MODE_KEEP" },
  { no: 3, name: "DB_USER_MODE_BEST_EFFORT_DROP" },
]);

/**
 * CertExtensionMode specifies the type of extension to use in the cert.
 *
 * @generated from enum types.CertExtensionMode
 */
export enum CertExtensionMode {
  /**
   * EXTENSION represents a cert extension that may or may not be
   * honored by the server.
   *
   * @generated from enum value: EXTENSION = 0;
   */
  EXTENSION = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(CertExtensionMode)
proto3.util.setEnumType(CertExtensionMode, "types.CertExtensionMode", [
  { no: 0, name: "EXTENSION" },
]);

/**
 * CertExtensionType represents the certificate type the extension is for.
 * Currently only ssh is supported.
 *
 * @generated from enum types.CertExtensionType
 */
export enum CertExtensionType {
  /**
   * SSH is used when extending an ssh certificate
   *
   * @generated from enum value: SSH = 0;
   */
  SSH = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(CertExtensionType)
proto3.util.setEnumType(CertExtensionType, "types.CertExtensionType", [
  { no: 0, name: "SSH" },
]);

/**
 * PasswordState indicates what is known about existence of user's password.
 *
 * @generated from enum types.PasswordState
 */
export enum PasswordState {
  /**
   * Unable to tell whether the password has been configured.
   *
   * @generated from enum value: PASSWORD_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Password is known to be not configured.
   *
   * @generated from enum value: PASSWORD_STATE_UNSET = 1;
   */
  UNSET = 1,

  /**
   * Password is known to be configured.
   *
   * @generated from enum value: PASSWORD_STATE_SET = 2;
   */
  SET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PasswordState)
proto3.util.setEnumType(PasswordState, "types.PasswordState", [
  { no: 0, name: "PASSWORD_STATE_UNSPECIFIED" },
  { no: 1, name: "PASSWORD_STATE_UNSET" },
  { no: 2, name: "PASSWORD_STATE_SET" },
]);

/**
 * TrustedDeviceRequirement indicates whether access may be hindered by the lack
 * of a trusted device.
 *
 * @generated from enum types.TrustedDeviceRequirement
 */
export enum TrustedDeviceRequirement {
  /**
   * Device requirement not determined.
   * Does not mean that a device is not required, only that the necessary data
   * was not considered.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Trusted device not required.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED = 1;
   */
  NOT_REQUIRED = 1,

  /**
   * Trusted device required by either cluster mode or user roles.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_REQUIRED = 2;
   */
  REQUIRED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TrustedDeviceRequirement)
proto3.util.setEnumType(TrustedDeviceRequirement, "types.TrustedDeviceRequirement", [
  { no: 0, name: "TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED" },
  { no: 1, name: "TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED" },
  { no: 2, name: "TRUSTED_DEVICE_REQUIREMENT_REQUIRED" },
]);

/**
 * SessionState represents the state of a session.
 *
 * @generated from enum types.SessionState
 */
export enum SessionState {
  /**
   * Pending variant represents a session that is waiting on participants to fulfill the criteria
   * to start the session.
   *
   * @generated from enum value: SessionStatePending = 0;
   */
  SessionStatePending = 0,

  /**
   * Running variant represents a session that has had it's criteria for starting
   * fulfilled at least once and has transitioned to a RUNNING state.
   *
   * @generated from enum value: SessionStateRunning = 1;
   */
  SessionStateRunning = 1,

  /**
   * Terminated variant represents a session that is no longer running and due for removal.
   *
   * @generated from enum value: SessionStateTerminated = 2;
   */
  SessionStateTerminated = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SessionState)
proto3.util.setEnumType(SessionState, "types.SessionState", [
  { no: 0, name: "SessionStatePending" },
  { no: 1, name: "SessionStateRunning" },
  { no: 2, name: "SessionStateTerminated" },
]);

/**
 * AlertSeverity represents how problematic/urgent an alert is, and is used to assist
 * in sorting alerts for display.
 *
 * @generated from enum types.AlertSeverity
 */
export enum AlertSeverity {
  /**
   * @generated from enum value: LOW = 0;
   */
  LOW = 0,

  /**
   * @generated from enum value: MEDIUM = 5;
   */
  MEDIUM = 5,

  /**
   * @generated from enum value: HIGH = 10;
   */
  HIGH = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(AlertSeverity)
proto3.util.setEnumType(AlertSeverity, "types.AlertSeverity", [
  { no: 0, name: "LOW" },
  { no: 5, name: "MEDIUM" },
  { no: 10, name: "HIGH" },
]);

/**
 * RequireMFAType is a type of MFA requirement enforced outside of login,
 * such as per-session MFA or per-request PIV touch.
 *
 * @generated from enum types.RequireMFAType
 */
export enum RequireMFAType {
  /**
   * OFF means additional MFA enforcement is not enabled.
   *
   * @generated from enum value: OFF = 0;
   */
  OFF = 0,

  /**
   * SESSION means MFA is required to begin server sessions.
   *
   * @generated from enum value: SESSION = 1;
   */
  SESSION = 1,

  /**
   * SESSION_AND_HARDWARE_KEY means MFA is required to begin server sessions,
   * and login sessions must use a private key backed by a hardware key.
   *
   * @generated from enum value: SESSION_AND_HARDWARE_KEY = 2;
   */
  SESSION_AND_HARDWARE_KEY = 2,

  /**
   * HARDWARE_KEY_TOUCH means login sessions must use a hardware private key that
   * requires touch to be used.
   *
   * @generated from enum value: HARDWARE_KEY_TOUCH = 3;
   */
  HARDWARE_KEY_TOUCH = 3,

  /**
   * HARDWARE_KEY_PIN means login sessions must use a hardware private key that
   * requires pin to be used.
   *
   * @generated from enum value: HARDWARE_KEY_PIN = 4;
   */
  HARDWARE_KEY_PIN = 4,

  /**
   * HARDWARE_KEY_TOUCH_AND_PIN means login sessions must use a hardware private key that
   * requires touch and pin to be used.
   *
   * @generated from enum value: HARDWARE_KEY_TOUCH_AND_PIN = 5;
   */
  HARDWARE_KEY_TOUCH_AND_PIN = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(RequireMFAType)
proto3.util.setEnumType(RequireMFAType, "types.RequireMFAType", [
  { no: 0, name: "OFF" },
  { no: 1, name: "SESSION" },
  { no: 2, name: "SESSION_AND_HARDWARE_KEY" },
  { no: 3, name: "HARDWARE_KEY_TOUCH" },
  { no: 4, name: "HARDWARE_KEY_PIN" },
  { no: 5, name: "HARDWARE_KEY_TOUCH_AND_PIN" },
]);

/**
 * SignatureAlgorithmSuite represents the suite of cryptographic signature algorithms used in the cluster.
 *
 * @generated from enum types.SignatureAlgorithmSuite
 */
export enum SignatureAlgorithmSuite {
  /**
   * SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED represents an unspecified signature algorithm suite.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * SIGNATURE_ALGORITHM_SUITE_LEGACY is the original algorithm suite used in
   * Teleport, it almost exclusively uses 2048-bit RSA.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_LEGACY = 1;
   */
  LEGACY = 1,

  /**
   * SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 aims to strikes a balance between
   * security, compatibility, and performance. It uses Ed25519 for most SSH
   * keys, ECDSA on the NIST P256 curve for most TLS keys, and 2048-bit RSA
   * where necessary for compatibility with third-party software.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 = 2;
   */
  BALANCED_V1 = 2,

  /**
   * SIGNATURE_ALGORITHM_SUITE_FIPS_V1 is tailored for FIPS compliance. It is
   * based on the BALANCED_V1 suite but replaces all instances of Ed25519 with
   * ECDSA on the NIST P256 curve.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_FIPS_V1 = 3;
   */
  FIPS_V1 = 3,

  /**
   * SIGNATURE_ALGORITHM_SUITE_HSM_V1 is tailored for clusters using an HSM or
   * KMS service to back CA private material. It is based on the BALANCED suite
   * but replaces Ed25519 with ECDSA on the NIST P256 curve for CA keys only,
   * not for server or client keys. It is also valid to use the LEGACY for FIPS
   * suites if your cluster uses an HSM or KMS.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_HSM_V1 = 4;
   */
  HSM_V1 = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SignatureAlgorithmSuite)
proto3.util.setEnumType(SignatureAlgorithmSuite, "types.SignatureAlgorithmSuite", [
  { no: 0, name: "SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED" },
  { no: 1, name: "SIGNATURE_ALGORITHM_SUITE_LEGACY" },
  { no: 2, name: "SIGNATURE_ALGORITHM_SUITE_BALANCED_V1" },
  { no: 3, name: "SIGNATURE_ALGORITHM_SUITE_FIPS_V1" },
  { no: 4, name: "SIGNATURE_ALGORITHM_SUITE_HSM_V1" },
]);

/**
 * @generated from enum types.PluginStatusCode
 */
export enum PluginStatusCode {
  /**
   * UNKNOWN is the default value when the plugin has not reported its status yet.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * RUNNING means the plugin reports running successfully.
   *
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * OTHER_ERROR indicates that an otherwise-unspecified error has been encountered.
   *
   * @generated from enum value: OTHER_ERROR = 2;
   */
  OTHER_ERROR = 2,

  /**
   * UNAUTHORIZED indicates that plugin is not able to authenticate to the 3rd party API.
   * This could be a result of e.g. the user revoking the authorization on the API provider's side.
   *
   * @generated from enum value: UNAUTHORIZED = 3;
   */
  UNAUTHORIZED = 3,

  /**
   * SLACK_NOT_IN_CHANNEL is a Slack-specific status code that indicates
   * that the bot has not been invited to a channel that it is configured to post in.
   *
   * @generated from enum value: SLACK_NOT_IN_CHANNEL = 10;
   */
  SLACK_NOT_IN_CHANNEL = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(PluginStatusCode)
proto3.util.setEnumType(PluginStatusCode, "types.PluginStatusCode", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "RUNNING" },
  { no: 2, name: "OTHER_ERROR" },
  { no: 3, name: "UNAUTHORIZED" },
  { no: 10, name: "SLACK_NOT_IN_CHANNEL" },
]);

/**
 * OktaPluginSyncStatusCode indicates the possible states of an Okta
 * synchronization service.
 *
 * @generated from enum types.OktaPluginSyncStatusCode
 */
export enum OktaPluginSyncStatusCode {
  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED is the status code zero value,
   * indicating that the service has not yet reported a status code.
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS indicates that the service is running
   * without error
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR indicates that the service is currently
   * in an error state.
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR = 2;
   */
  ERROR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OktaPluginSyncStatusCode)
proto3.util.setEnumType(OktaPluginSyncStatusCode, "types.OktaPluginSyncStatusCode", [
  { no: 0, name: "OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED" },
  { no: 1, name: "OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS" },
  { no: 2, name: "OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR" },
]);

/**
 * HeadlessAuthenticationState is a headless authentication state.
 *
 * @generated from enum types.HeadlessAuthenticationState
 */
export enum HeadlessAuthenticationState {
  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * authentication pending.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_PENDING = 1;
   */
  PENDING = 1,

  /**
   * authentication denied.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_DENIED = 2;
   */
  DENIED = 2,

  /**
   * authentication approved.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_APPROVED = 3;
   */
  APPROVED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(HeadlessAuthenticationState)
proto3.util.setEnumType(HeadlessAuthenticationState, "types.HeadlessAuthenticationState", [
  { no: 0, name: "HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED" },
  { no: 1, name: "HEADLESS_AUTHENTICATION_STATE_PENDING" },
  { no: 2, name: "HEADLESS_AUTHENTICATION_STATE_DENIED" },
  { no: 3, name: "HEADLESS_AUTHENTICATION_STATE_APPROVED" },
]);

/**
 * InstallParamEnrollMode is the mode used to enroll the node into the cluster.
 *
 * @generated from enum types.InstallParamEnrollMode
 */
export enum InstallParamEnrollMode {
  /**
   * INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED uses the EICE mode for EC2 Matchers with an Integration and SCRIPT mode otherwise.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * INSTALL_PARAM_ENROLL_MODE_SCRIPT runs a script on the target host.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_SCRIPT = 1;
   */
  SCRIPT = 1,

  /**
   * INSTALL_PARAM_ENROLL_MODE_EICE uses EC2 Instance Connect Endpoint to access the node and DiscoveryService handles the heartbeat.
   * Only available for AWS EC2 instances.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_EICE = 2;
   */
  EICE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InstallParamEnrollMode)
proto3.util.setEnumType(InstallParamEnrollMode, "types.InstallParamEnrollMode", [
  { no: 0, name: "INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED" },
  { no: 1, name: "INSTALL_PARAM_ENROLL_MODE_SCRIPT" },
  { no: 2, name: "INSTALL_PARAM_ENROLL_MODE_EICE" },
]);

/**
 * @generated from message types.KeepAlive
 */
export class KeepAlive extends Message<KeepAlive> {
  /**
   * Name of the resource to keep alive.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Namespace is the namespace of the resource.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace = "";

  /**
   * Expires is set to update expiry time of the resource.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  /**
   * Type is the type (or kind) of the resource that's being kept alive.
   *
   * @generated from field: types.KeepAlive.KeepAliveType Type = 9;
   */
  Type = KeepAlive_KeepAliveType.UNKNOWN;

  /**
   * HostID is an optional UUID of the host the resource belongs to.
   *
   * @generated from field: string HostID = 10;
   */
  HostID = "";

  constructor(data?: PartialMessage<KeepAlive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KeepAlive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Expires", kind: "message", T: Timestamp },
    { no: 9, name: "Type", kind: "enum", T: proto3.getEnumType(KeepAlive_KeepAliveType) },
    { no: 10, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeepAlive {
    return new KeepAlive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeepAlive {
    return new KeepAlive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeepAlive {
    return new KeepAlive().fromJsonString(jsonString, options);
  }

  static equals(a: KeepAlive | PlainMessage<KeepAlive> | undefined, b: KeepAlive | PlainMessage<KeepAlive> | undefined): boolean {
    return proto3.util.equals(KeepAlive, a, b);
  }
}

/**
 * The type of a KeepAlive. When adding a new type, please double-check
 * lib/usagereporter/teleport to see if we need any change in the resource
 * heartbeat event.
 *
 * @generated from enum types.KeepAlive.KeepAliveType
 */
export enum KeepAlive_KeepAliveType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * "node", KindNode. For the sake of correct usage reporting, it shouldn't
   * be used for OpenSSH nodes.
   *
   * @generated from enum value: NODE = 1;
   */
  NODE = 1,

  /**
   * "app_server", KindAppServer
   *
   * @generated from enum value: APP = 2;
   */
  APP = 2,

  /**
   * "db_server", KindDatabaseServer
   *
   * @generated from enum value: DATABASE = 3;
   */
  DATABASE = 3,

  /**
   * "windows_desktop_service", KindWindowsDesktopService
   *
   * @generated from enum value: WINDOWS_DESKTOP = 4;
   */
  WINDOWS_DESKTOP = 4,

  /**
   * "kube_server", KindKubeServer
   *
   * @generated from enum value: KUBERNETES = 5;
   */
  KUBERNETES = 5,

  /**
   * "db_service", KindDatabaseService
   *
   * @generated from enum value: DATABASE_SERVICE = 6;
   */
  DATABASE_SERVICE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(KeepAlive_KeepAliveType)
proto3.util.setEnumType(KeepAlive_KeepAliveType, "types.KeepAlive.KeepAliveType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "NODE" },
  { no: 2, name: "APP" },
  { no: 3, name: "DATABASE" },
  { no: 4, name: "WINDOWS_DESKTOP" },
  { no: 5, name: "KUBERNETES" },
  { no: 6, name: "DATABASE_SERVICE" },
]);

/**
 * Metadata is resource metadata
 *
 * @generated from message types.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * Name is an object name
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Namespace is object namespace. The field should be called "namespace"
   * when it returns in Teleport 2.4.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace = "";

  /**
   * Description is object description
   *
   * @generated from field: string Description = 3;
   */
  Description = "";

  /**
   * Labels is a set of labels
   *
   * @generated from field: map<string, string> Labels = 5;
   */
  Labels: { [key: string]: string } = {};

  /**
   * Expires is a global expiry time header can be set on any resource in the
   * system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 6;
   */
  Expires?: Timestamp;

  /**
   * Revision is an opaque identifier which tracks the versions of a resource
   * over time. Clients should ignore and not alter its value but must return
   * the revision in any updates of a resource.
   *
   * @generated from field: string Revision = 8;
   */
  Revision = "";

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "Expires", kind: "message", T: Timestamp },
    { no: 8, name: "Revision", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * Rotation is a status of the rotation of the certificate authority
 *
 * @generated from message types.Rotation
 */
export class Rotation extends Message<Rotation> {
  /**
   * State could be one of "init" or "in_progress".
   *
   * @generated from field: string State = 1;
   */
  State = "";

  /**
   * Phase is the current rotation phase.
   *
   * @generated from field: string Phase = 2;
   */
  Phase = "";

  /**
   * Mode sets manual or automatic rotation mode.
   *
   * @generated from field: string Mode = 3;
   */
  Mode = "";

  /**
   * CurrentID is the ID of the rotation operation
   * to differentiate between rotation attempts.
   *
   * @generated from field: string CurrentID = 4;
   */
  CurrentID = "";

  /**
   * Started is set to the time when rotation has been started
   * in case if the state of the rotation is "in_progress".
   *
   * @generated from field: google.protobuf.Timestamp Started = 5;
   */
  Started?: Timestamp;

  /**
   * GracePeriod is a period during which old and new CA
   * are valid for checking purposes, but only new CA is issuing certificates.
   *
   * @generated from field: int64 GracePeriod = 6;
   */
  GracePeriod = protoInt64.zero;

  /**
   * LastRotated specifies the last time of the completed rotation.
   *
   * @generated from field: google.protobuf.Timestamp LastRotated = 7;
   */
  LastRotated?: Timestamp;

  /**
   * Schedule is a rotation schedule - used in
   * automatic mode to switch between phases.
   *
   * @generated from field: types.RotationSchedule Schedule = 8;
   */
  Schedule?: RotationSchedule;

  constructor(data?: PartialMessage<Rotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Rotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "State", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Phase", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "CurrentID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Started", kind: "message", T: Timestamp },
    { no: 6, name: "GracePeriod", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "LastRotated", kind: "message", T: Timestamp },
    { no: 8, name: "Schedule", kind: "message", T: RotationSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rotation {
    return new Rotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rotation {
    return new Rotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rotation {
    return new Rotation().fromJsonString(jsonString, options);
  }

  static equals(a: Rotation | PlainMessage<Rotation> | undefined, b: Rotation | PlainMessage<Rotation> | undefined): boolean {
    return proto3.util.equals(Rotation, a, b);
  }
}

/**
 * RotationSchedule is a rotation schedule setting time switches
 * for different phases.
 *
 * @generated from message types.RotationSchedule
 */
export class RotationSchedule extends Message<RotationSchedule> {
  /**
   * UpdateClients specifies time to switch to the "Update clients" phase
   *
   * @generated from field: google.protobuf.Timestamp UpdateClients = 1;
   */
  UpdateClients?: Timestamp;

  /**
   * UpdateServers specifies time to switch to the "Update servers" phase.
   *
   * @generated from field: google.protobuf.Timestamp UpdateServers = 2;
   */
  UpdateServers?: Timestamp;

  /**
   * Standby specifies time to switch to the "Standby" phase.
   *
   * @generated from field: google.protobuf.Timestamp Standby = 3;
   */
  Standby?: Timestamp;

  constructor(data?: PartialMessage<RotationSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RotationSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UpdateClients", kind: "message", T: Timestamp },
    { no: 2, name: "UpdateServers", kind: "message", T: Timestamp },
    { no: 3, name: "Standby", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RotationSchedule {
    return new RotationSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RotationSchedule {
    return new RotationSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RotationSchedule {
    return new RotationSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: RotationSchedule | PlainMessage<RotationSchedule> | undefined, b: RotationSchedule | PlainMessage<RotationSchedule> | undefined): boolean {
    return proto3.util.equals(RotationSchedule, a, b);
  }
}

/**
 * ResourceHeader is a shared resource header
 * used in cases when only type and name is known
 *
 * @generated from message types.ResourceHeader
 */
export class ResourceHeader extends Message<ResourceHeader> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the API version used to create the resource. It must be
   * specified. Based on this version, Teleport will apply different defaults on
   * resource creation or deletion. It must be an integer prefixed by "v".
   * For example: `v1`
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  constructor(data?: PartialMessage<ResourceHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceHeader {
    return new ResourceHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceHeader {
    return new ResourceHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceHeader {
    return new ResourceHeader().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceHeader | PlainMessage<ResourceHeader> | undefined, b: ResourceHeader | PlainMessage<ResourceHeader> | undefined): boolean {
    return proto3.util.equals(ResourceHeader, a, b);
  }
}

/**
 * DatabaseServerV3 represents a database access server.
 *
 * @generated from message types.DatabaseServerV3
 */
export class DatabaseServerV3 extends Message<DatabaseServerV3> {
  /**
   * Kind is the database server resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the database server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the database server spec.
   *
   * @generated from field: types.DatabaseServerSpecV3 Spec = 5;
   */
  Spec?: DatabaseServerSpecV3;

  constructor(data?: PartialMessage<DatabaseServerV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseServerV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: DatabaseServerSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseServerV3 {
    return new DatabaseServerV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseServerV3 {
    return new DatabaseServerV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseServerV3 {
    return new DatabaseServerV3().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseServerV3 | PlainMessage<DatabaseServerV3> | undefined, b: DatabaseServerV3 | PlainMessage<DatabaseServerV3> | undefined): boolean {
    return proto3.util.equals(DatabaseServerV3, a, b);
  }
}

/**
 * DatabaseServerSpecV3 is the database server spec.
 *
 * @generated from message types.DatabaseServerSpecV3
 */
export class DatabaseServerSpecV3 extends Message<DatabaseServerSpecV3> {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 6;
   */
  Version = "";

  /**
   * Hostname is the database server hostname.
   *
   * @generated from field: string Hostname = 7;
   */
  Hostname = "";

  /**
   * HostID is the ID of the host the database server is running on.
   *
   * @generated from field: string HostID = 8;
   */
  HostID = "";

  /**
   * Rotation contains the server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 10;
   */
  Rotation?: Rotation;

  /**
   * Database is the database proxied by this database server.
   *
   * @generated from field: types.DatabaseV3 Database = 12;
   */
  Database?: DatabaseV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 13;
   */
  ProxyIDs: string[] = [];

  constructor(data?: PartialMessage<DatabaseServerSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseServerSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 6, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Rotation", kind: "message", T: Rotation },
    { no: 12, name: "Database", kind: "message", T: DatabaseV3 },
    { no: 13, name: "ProxyIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseServerSpecV3 {
    return new DatabaseServerSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseServerSpecV3 {
    return new DatabaseServerSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseServerSpecV3 {
    return new DatabaseServerSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseServerSpecV3 | PlainMessage<DatabaseServerSpecV3> | undefined, b: DatabaseServerSpecV3 | PlainMessage<DatabaseServerSpecV3> | undefined): boolean {
    return proto3.util.equals(DatabaseServerSpecV3, a, b);
  }
}

/**
 * DatabaseV3List represents a list of databases.
 *
 * @generated from message types.DatabaseV3List
 */
export class DatabaseV3List extends Message<DatabaseV3List> {
  /**
   * Databases is a list of database resources.
   *
   * @generated from field: repeated types.DatabaseV3 Databases = 1;
   */
  Databases: DatabaseV3[] = [];

  constructor(data?: PartialMessage<DatabaseV3List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseV3List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Databases", kind: "message", T: DatabaseV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseV3List {
    return new DatabaseV3List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseV3List {
    return new DatabaseV3List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseV3List {
    return new DatabaseV3List().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseV3List | PlainMessage<DatabaseV3List> | undefined, b: DatabaseV3List | PlainMessage<DatabaseV3List> | undefined): boolean {
    return proto3.util.equals(DatabaseV3List, a, b);
  }
}

/**
 * DatabaseV3 represents a single proxied database.
 *
 * @generated from message types.DatabaseV3
 */
export class DatabaseV3 extends Message<DatabaseV3> {
  /**
   * Kind is the database resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the database metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the database spec.
   *
   * @generated from field: types.DatabaseSpecV3 Spec = 5;
   */
  Spec?: DatabaseSpecV3;

  /**
   * Status is the database runtime information.
   *
   * @generated from field: types.DatabaseStatusV3 Status = 6;
   */
  Status?: DatabaseStatusV3;

  constructor(data?: PartialMessage<DatabaseV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: DatabaseSpecV3 },
    { no: 6, name: "Status", kind: "message", T: DatabaseStatusV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseV3 {
    return new DatabaseV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseV3 {
    return new DatabaseV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseV3 {
    return new DatabaseV3().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseV3 | PlainMessage<DatabaseV3> | undefined, b: DatabaseV3 | PlainMessage<DatabaseV3> | undefined): boolean {
    return proto3.util.equals(DatabaseV3, a, b);
  }
}

/**
 * DatabaseSpecV3 is the database spec.
 *
 * @generated from message types.DatabaseSpecV3
 */
export class DatabaseSpecV3 extends Message<DatabaseSpecV3> {
  /**
   * Protocol is the database protocol: postgres, mysql, mongodb, etc.
   *
   * @generated from field: string Protocol = 1;
   */
  Protocol = "";

  /**
   * URI is the database connection endpoint.
   *
   * @generated from field: string URI = 2;
   */
  URI = "";

  /**
   * CACert is the PEM-encoded database CA certificate.
   *
   * DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
   *
   * @generated from field: string CACert = 3 [deprecated = true];
   * @deprecated
   */
  CACert = "";

  /**
   * DynamicLabels is the database dynamic labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 4;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 } = {};

  /**
   * AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
   *
   * @generated from field: types.AWS AWS = 5;
   */
  AWS?: AWS;

  /**
   * GCP contains parameters specific to GCP Cloud SQL databases.
   *
   * @generated from field: types.GCPCloudSQL GCP = 6;
   */
  GCP?: GCPCloudSQL;

  /**
   * Azure contains Azure specific database metadata.
   *
   * @generated from field: types.Azure Azure = 7;
   */
  Azure?: Azure;

  /**
   * TLS is the TLS configuration used when establishing connection to target database.
   * Allows to provide custom CA cert or override server name.
   *
   * @generated from field: types.DatabaseTLS TLS = 8;
   */
  TLS?: DatabaseTLS;

  /**
   * AD is the Active Directory configuration for the database.
   *
   * @generated from field: types.AD AD = 9;
   */
  AD?: AD;

  /**
   * MySQL is an additional section with MySQL database options.
   *
   * @generated from field: types.MySQLOptions MySQL = 10;
   */
  MySQL?: MySQLOptions;

  /**
   * AdminUser is the database admin user for automatic user provisioning.
   *
   * @generated from field: types.DatabaseAdminUser AdminUser = 11;
   */
  AdminUser?: DatabaseAdminUser;

  /**
   * MongoAtlas contains Atlas metadata about the database.
   *
   * @generated from field: types.MongoAtlas MongoAtlas = 12;
   */
  MongoAtlas?: MongoAtlas;

  /**
   * Oracle is an additional Oracle configuration options.
   *
   * @generated from field: types.OracleOptions Oracle = 13;
   */
  Oracle?: OracleOptions;

  constructor(data?: PartialMessage<DatabaseSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "CACert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "DynamicLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CommandLabelV2} },
    { no: 5, name: "AWS", kind: "message", T: AWS },
    { no: 6, name: "GCP", kind: "message", T: GCPCloudSQL },
    { no: 7, name: "Azure", kind: "message", T: Azure },
    { no: 8, name: "TLS", kind: "message", T: DatabaseTLS },
    { no: 9, name: "AD", kind: "message", T: AD },
    { no: 10, name: "MySQL", kind: "message", T: MySQLOptions },
    { no: 11, name: "AdminUser", kind: "message", T: DatabaseAdminUser },
    { no: 12, name: "MongoAtlas", kind: "message", T: MongoAtlas },
    { no: 13, name: "Oracle", kind: "message", T: OracleOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseSpecV3 {
    return new DatabaseSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseSpecV3 {
    return new DatabaseSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseSpecV3 {
    return new DatabaseSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseSpecV3 | PlainMessage<DatabaseSpecV3> | undefined, b: DatabaseSpecV3 | PlainMessage<DatabaseSpecV3> | undefined): boolean {
    return proto3.util.equals(DatabaseSpecV3, a, b);
  }
}

/**
 * DatabaseAdminUser contains information about privileged database user used
 * for automatic user provisioning.
 *
 * @generated from message types.DatabaseAdminUser
 */
export class DatabaseAdminUser extends Message<DatabaseAdminUser> {
  /**
   * Name is the username of the privileged database user.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * DefaultDatabase is the database that the privileged database user logs
   * into by default.
   *
   * Depending on the database type, this database may be used to store
   * procedures or data for managing database users.
   *
   * @generated from field: string DefaultDatabase = 2;
   */
  DefaultDatabase = "";

  constructor(data?: PartialMessage<DatabaseAdminUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseAdminUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DefaultDatabase", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseAdminUser {
    return new DatabaseAdminUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseAdminUser {
    return new DatabaseAdminUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseAdminUser {
    return new DatabaseAdminUser().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseAdminUser | PlainMessage<DatabaseAdminUser> | undefined, b: DatabaseAdminUser | PlainMessage<DatabaseAdminUser> | undefined): boolean {
    return proto3.util.equals(DatabaseAdminUser, a, b);
  }
}

/**
 * OracleOptions contains information about privileged database user used
 * for database audit.
 *
 * @generated from message types.OracleOptions
 */
export class OracleOptions extends Message<OracleOptions> {
  /**
   * AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
   *
   * @generated from field: string AuditUser = 1;
   */
  AuditUser = "";

  constructor(data?: PartialMessage<OracleOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OracleOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AuditUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OracleOptions {
    return new OracleOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OracleOptions {
    return new OracleOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OracleOptions {
    return new OracleOptions().fromJsonString(jsonString, options);
  }

  static equals(a: OracleOptions | PlainMessage<OracleOptions> | undefined, b: OracleOptions | PlainMessage<OracleOptions> | undefined): boolean {
    return proto3.util.equals(OracleOptions, a, b);
  }
}

/**
 * DatabaseStatusV3 contains runtime information about the database.
 *
 * @generated from message types.DatabaseStatusV3
 */
export class DatabaseStatusV3 extends Message<DatabaseStatusV3> {
  /**
   * CACert is the auto-downloaded cloud database CA certificate.
   *
   * @generated from field: string CACert = 1;
   */
  CACert = "";

  /**
   * AWS is the auto-discovered AWS cloud database metadata.
   *
   * @generated from field: types.AWS AWS = 2;
   */
  AWS?: AWS;

  /**
   * MySQL is an additional section with MySQL runtime database information.
   *
   * @generated from field: types.MySQLOptions MySQL = 3;
   */
  MySQL?: MySQLOptions;

  /**
   * ManagedUsers is a list of database users that are managed by Teleport.
   *
   * @generated from field: repeated string ManagedUsers = 4;
   */
  ManagedUsers: string[] = [];

  /**
   * Azure is the auto-discovered Azure cloud database metadata.
   *
   * @generated from field: types.Azure Azure = 5;
   */
  Azure?: Azure;

  constructor(data?: PartialMessage<DatabaseStatusV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseStatusV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CACert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AWS", kind: "message", T: AWS },
    { no: 3, name: "MySQL", kind: "message", T: MySQLOptions },
    { no: 4, name: "ManagedUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Azure", kind: "message", T: Azure },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseStatusV3 {
    return new DatabaseStatusV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseStatusV3 {
    return new DatabaseStatusV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseStatusV3 {
    return new DatabaseStatusV3().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseStatusV3 | PlainMessage<DatabaseStatusV3> | undefined, b: DatabaseStatusV3 | PlainMessage<DatabaseStatusV3> | undefined): boolean {
    return proto3.util.equals(DatabaseStatusV3, a, b);
  }
}

/**
 * AWS contains AWS metadata about the database.
 *
 * @generated from message types.AWS
 */
export class AWS extends Message<AWS> {
  /**
   * Region is a AWS cloud region.
   *
   * @generated from field: string Region = 1;
   */
  Region = "";

  /**
   * Redshift contains Redshift specific metadata.
   *
   * @generated from field: types.Redshift Redshift = 2;
   */
  Redshift?: Redshift;

  /**
   * RDS contains RDS specific metadata.
   *
   * @generated from field: types.RDS RDS = 3;
   */
  RDS?: RDS;

  /**
   * AccountID is the AWS account ID this database belongs to.
   *
   * @generated from field: string AccountID = 4;
   */
  AccountID = "";

  /**
   * ElastiCache contains AWS ElastiCache Redis specific metadata.
   *
   * @generated from field: types.ElastiCache ElastiCache = 5;
   */
  ElastiCache?: ElastiCache;

  /**
   * SecretStore contains secret store configurations.
   *
   * @generated from field: types.SecretStore SecretStore = 6;
   */
  SecretStore?: SecretStore;

  /**
   * MemoryDB contains AWS MemoryDB specific metadata.
   *
   * @generated from field: types.MemoryDB MemoryDB = 7;
   */
  MemoryDB?: MemoryDB;

  /**
   * RDSProxy contains AWS Proxy specific metadata.
   *
   * @generated from field: types.RDSProxy RDSProxy = 8;
   */
  RDSProxy?: RDSProxy;

  /**
   * RedshiftServerless contains AWS Redshift Serverless specific metadata.
   *
   * @generated from field: types.RedshiftServerless RedshiftServerless = 9;
   */
  RedshiftServerless?: RedshiftServerless;

  /**
   * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
   *
   * @generated from field: string ExternalID = 10;
   */
  ExternalID = "";

  /**
   * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
   * Set this field and ExternalID to enable access across AWS accounts.
   *
   * @generated from field: string AssumeRoleARN = 11;
   */
  AssumeRoleARN = "";

  /**
   * OpenSearch contains AWS OpenSearch specific metadata.
   *
   * @generated from field: types.OpenSearch OpenSearch = 12;
   */
  OpenSearch?: OpenSearch;

  /**
   * IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
   * If not, the user must update the AWS profile identity to allow access to the Database.
   * Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
   *
   * @generated from field: types.IAMPolicyStatus IAMPolicyStatus = 14;
   */
  IAMPolicyStatus = IAMPolicyStatus.IAM_POLICY_STATUS_UNSPECIFIED;

  /**
   * SessionTags is a list of AWS STS session tags.
   *
   * @generated from field: map<string, string> SessionTags = 15;
   */
  SessionTags: { [key: string]: string } = {};

  /**
   * DocumentDB contains AWS DocumentDB specific metadata.
   *
   * @generated from field: types.DocumentDB DocumentDB = 16;
   */
  DocumentDB?: DocumentDB;

  constructor(data?: PartialMessage<AWS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AWS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Redshift", kind: "message", T: Redshift },
    { no: 3, name: "RDS", kind: "message", T: RDS },
    { no: 4, name: "AccountID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ElastiCache", kind: "message", T: ElastiCache },
    { no: 6, name: "SecretStore", kind: "message", T: SecretStore },
    { no: 7, name: "MemoryDB", kind: "message", T: MemoryDB },
    { no: 8, name: "RDSProxy", kind: "message", T: RDSProxy },
    { no: 9, name: "RedshiftServerless", kind: "message", T: RedshiftServerless },
    { no: 10, name: "ExternalID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "AssumeRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "OpenSearch", kind: "message", T: OpenSearch },
    { no: 14, name: "IAMPolicyStatus", kind: "enum", T: proto3.getEnumType(IAMPolicyStatus) },
    { no: 15, name: "SessionTags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 16, name: "DocumentDB", kind: "message", T: DocumentDB },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWS {
    return new AWS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWS {
    return new AWS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWS {
    return new AWS().fromJsonString(jsonString, options);
  }

  static equals(a: AWS | PlainMessage<AWS> | undefined, b: AWS | PlainMessage<AWS> | undefined): boolean {
    return proto3.util.equals(AWS, a, b);
  }
}

/**
 * SecretStore contains secret store configurations.
 *
 * @generated from message types.SecretStore
 */
export class SecretStore extends Message<SecretStore> {
  /**
   * KeyPrefix specifies the secret key prefix.
   *
   * @generated from field: string KeyPrefix = 1;
   */
  KeyPrefix = "";

  /**
   * KMSKeyID specifies the AWS KMS key for encryption.
   *
   * @generated from field: string KMSKeyID = 2;
   */
  KMSKeyID = "";

  constructor(data?: PartialMessage<SecretStore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SecretStore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KeyPrefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "KMSKeyID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecretStore {
    return new SecretStore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecretStore {
    return new SecretStore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecretStore {
    return new SecretStore().fromJsonString(jsonString, options);
  }

  static equals(a: SecretStore | PlainMessage<SecretStore> | undefined, b: SecretStore | PlainMessage<SecretStore> | undefined): boolean {
    return proto3.util.equals(SecretStore, a, b);
  }
}

/**
 * Redshift contains AWS Redshift specific database metadata.
 *
 * @generated from message types.Redshift
 */
export class Redshift extends Message<Redshift> {
  /**
   * ClusterID is the Redshift cluster identifier.
   *
   * @generated from field: string ClusterID = 1;
   */
  ClusterID = "";

  constructor(data?: PartialMessage<Redshift>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Redshift";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Redshift {
    return new Redshift().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Redshift {
    return new Redshift().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Redshift {
    return new Redshift().fromJsonString(jsonString, options);
  }

  static equals(a: Redshift | PlainMessage<Redshift> | undefined, b: Redshift | PlainMessage<Redshift> | undefined): boolean {
    return proto3.util.equals(Redshift, a, b);
  }
}

/**
 * RDS contains AWS RDS specific database metadata.
 *
 * @generated from message types.RDS
 */
export class RDS extends Message<RDS> {
  /**
   * InstanceID is the RDS instance identifier.
   *
   * @generated from field: string InstanceID = 1;
   */
  InstanceID = "";

  /**
   * ClusterID is the RDS cluster (Aurora) identifier.
   *
   * @generated from field: string ClusterID = 2;
   */
  ClusterID = "";

  /**
   * ResourceID is the RDS instance resource identifier (db-xxx).
   *
   * @generated from field: string ResourceID = 3;
   */
  ResourceID = "";

  /**
   * IAMAuth indicates whether database IAM authentication is enabled.
   *
   * @generated from field: bool IAMAuth = 4;
   */
  IAMAuth = false;

  /**
   * Subnets is a list of subnets for the RDS instance.
   *
   * @generated from field: repeated string Subnets = 5;
   */
  Subnets: string[] = [];

  /**
   * VPCID is the VPC where the RDS is running.
   *
   * @generated from field: string VPCID = 6;
   */
  VPCID = "";

  constructor(data?: PartialMessage<RDS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RDS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "InstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClusterID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ResourceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "IAMAuth", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "Subnets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "VPCID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RDS {
    return new RDS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RDS {
    return new RDS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RDS {
    return new RDS().fromJsonString(jsonString, options);
  }

  static equals(a: RDS | PlainMessage<RDS> | undefined, b: RDS | PlainMessage<RDS> | undefined): boolean {
    return proto3.util.equals(RDS, a, b);
  }
}

/**
 * RDSProxy contains AWS RDS Proxy specific database metadata.
 *
 * @generated from message types.RDSProxy
 */
export class RDSProxy extends Message<RDSProxy> {
  /**
   * Name is the identifier of an RDS Proxy.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
   *
   * @generated from field: string CustomEndpointName = 2;
   */
  CustomEndpointName = "";

  /**
   * ResourceID is the RDS instance resource identifier (prx-xxx).
   *
   * @generated from field: string ResourceID = 3;
   */
  ResourceID = "";

  constructor(data?: PartialMessage<RDSProxy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RDSProxy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "CustomEndpointName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ResourceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RDSProxy {
    return new RDSProxy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RDSProxy {
    return new RDSProxy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RDSProxy {
    return new RDSProxy().fromJsonString(jsonString, options);
  }

  static equals(a: RDSProxy | PlainMessage<RDSProxy> | undefined, b: RDSProxy | PlainMessage<RDSProxy> | undefined): boolean {
    return proto3.util.equals(RDSProxy, a, b);
  }
}

/**
 * ElastiCache contains AWS ElastiCache Redis specific metadata.
 *
 * @generated from message types.ElastiCache
 */
export class ElastiCache extends Message<ElastiCache> {
  /**
   * ReplicationGroupID is the Redis replication group ID.
   *
   * @generated from field: string ReplicationGroupID = 1;
   */
  ReplicationGroupID = "";

  /**
   * UserGroupIDs is a list of user group IDs.
   *
   * @generated from field: repeated string UserGroupIDs = 2;
   */
  UserGroupIDs: string[] = [];

  /**
   * TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
   *
   * @generated from field: bool TransitEncryptionEnabled = 3;
   */
  TransitEncryptionEnabled = false;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 4;
   */
  EndpointType = "";

  constructor(data?: PartialMessage<ElastiCache>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ElastiCache";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ReplicationGroupID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "UserGroupIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "TransitEncryptionEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "EndpointType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElastiCache {
    return new ElastiCache().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElastiCache {
    return new ElastiCache().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElastiCache {
    return new ElastiCache().fromJsonString(jsonString, options);
  }

  static equals(a: ElastiCache | PlainMessage<ElastiCache> | undefined, b: ElastiCache | PlainMessage<ElastiCache> | undefined): boolean {
    return proto3.util.equals(ElastiCache, a, b);
  }
}

/**
 * MemoryDB contains AWS MemoryDB specific metadata.
 *
 * @generated from message types.MemoryDB
 */
export class MemoryDB extends Message<MemoryDB> {
  /**
   * ClusterName is the name of the MemoryDB cluster.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * ACLName is the name of the ACL associated with the cluster.
   *
   * @generated from field: string ACLName = 2;
   */
  ACLName = "";

  /**
   * TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
   *
   * @generated from field: bool TLSEnabled = 3;
   */
  TLSEnabled = false;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 4;
   */
  EndpointType = "";

  constructor(data?: PartialMessage<MemoryDB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MemoryDB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ACLName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TLSEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "EndpointType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemoryDB {
    return new MemoryDB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemoryDB {
    return new MemoryDB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemoryDB {
    return new MemoryDB().fromJsonString(jsonString, options);
  }

  static equals(a: MemoryDB | PlainMessage<MemoryDB> | undefined, b: MemoryDB | PlainMessage<MemoryDB> | undefined): boolean {
    return proto3.util.equals(MemoryDB, a, b);
  }
}

/**
 * RedshiftServerless contains AWS Redshift Serverless specific metadata.
 *
 * @generated from message types.RedshiftServerless
 */
export class RedshiftServerless extends Message<RedshiftServerless> {
  /**
   * WorkgroupName is the workgroup name.
   *
   * @generated from field: string WorkgroupName = 1;
   */
  WorkgroupName = "";

  /**
   * EndpointName is the VPC endpoint name.
   *
   * @generated from field: string EndpointName = 2;
   */
  EndpointName = "";

  /**
   * WorkgroupID is the workgroup ID.
   *
   * @generated from field: string WorkgroupID = 3;
   */
  WorkgroupID = "";

  constructor(data?: PartialMessage<RedshiftServerless>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RedshiftServerless";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "WorkgroupName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "EndpointName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "WorkgroupID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedshiftServerless {
    return new RedshiftServerless().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedshiftServerless {
    return new RedshiftServerless().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedshiftServerless {
    return new RedshiftServerless().fromJsonString(jsonString, options);
  }

  static equals(a: RedshiftServerless | PlainMessage<RedshiftServerless> | undefined, b: RedshiftServerless | PlainMessage<RedshiftServerless> | undefined): boolean {
    return proto3.util.equals(RedshiftServerless, a, b);
  }
}

/**
 * OpenSearch contains AWS OpenSearch specific metadata.
 *
 * @generated from message types.OpenSearch
 */
export class OpenSearch extends Message<OpenSearch> {
  /**
   * DomainName is the name of the domain.
   *
   * @generated from field: string DomainName = 1;
   */
  DomainName = "";

  /**
   * DomainID is the ID of the domain.
   *
   * @generated from field: string DomainID = 2;
   */
  DomainID = "";

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 3;
   */
  EndpointType = "";

  constructor(data?: PartialMessage<OpenSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OpenSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DomainName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DomainID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "EndpointType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenSearch {
    return new OpenSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenSearch {
    return new OpenSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenSearch {
    return new OpenSearch().fromJsonString(jsonString, options);
  }

  static equals(a: OpenSearch | PlainMessage<OpenSearch> | undefined, b: OpenSearch | PlainMessage<OpenSearch> | undefined): boolean {
    return proto3.util.equals(OpenSearch, a, b);
  }
}

/**
 * DocumentDB contains AWS DocumentDB specific metadata.
 *
 * @generated from message types.DocumentDB
 */
export class DocumentDB extends Message<DocumentDB> {
  /**
   * ClusterID is the cluster identifier.
   *
   * @generated from field: string ClusterID = 1;
   */
  ClusterID = "";

  /**
   * InstanceID is the instance identifier.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID = "";

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 3;
   */
  EndpointType = "";

  constructor(data?: PartialMessage<DocumentDB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DocumentDB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "InstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "EndpointType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentDB {
    return new DocumentDB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentDB {
    return new DocumentDB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentDB {
    return new DocumentDB().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentDB | PlainMessage<DocumentDB> | undefined, b: DocumentDB | PlainMessage<DocumentDB> | undefined): boolean {
    return proto3.util.equals(DocumentDB, a, b);
  }
}

/**
 * GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
 *
 * @generated from message types.GCPCloudSQL
 */
export class GCPCloudSQL extends Message<GCPCloudSQL> {
  /**
   * ProjectID is the GCP project ID the Cloud SQL instance resides in.
   *
   * @generated from field: string ProjectID = 1;
   */
  ProjectID = "";

  /**
   * InstanceID is the Cloud SQL instance ID.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID = "";

  constructor(data?: PartialMessage<GCPCloudSQL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GCPCloudSQL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ProjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "InstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GCPCloudSQL {
    return new GCPCloudSQL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GCPCloudSQL {
    return new GCPCloudSQL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GCPCloudSQL {
    return new GCPCloudSQL().fromJsonString(jsonString, options);
  }

  static equals(a: GCPCloudSQL | PlainMessage<GCPCloudSQL> | undefined, b: GCPCloudSQL | PlainMessage<GCPCloudSQL> | undefined): boolean {
    return proto3.util.equals(GCPCloudSQL, a, b);
  }
}

/**
 * Azure contains Azure specific database metadata.
 *
 * @generated from message types.Azure
 */
export class Azure extends Message<Azure> {
  /**
   * Name is the Azure database server name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * ResourceID is the Azure fully qualified ID for the resource.
   *
   * @generated from field: string ResourceID = 2;
   */
  ResourceID = "";

  /**
   * Redis contains Azure Cache for Redis specific database metadata.
   *
   * @generated from field: types.AzureRedis Redis = 3;
   */
  Redis?: AzureRedis;

  /**
   * IsFlexiServer is true if the database is an Azure Flexible server.
   *
   * @generated from field: bool IsFlexiServer = 4;
   */
  IsFlexiServer = false;

  constructor(data?: PartialMessage<Azure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Azure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ResourceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Redis", kind: "message", T: AzureRedis },
    { no: 4, name: "IsFlexiServer", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Azure {
    return new Azure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Azure {
    return new Azure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Azure {
    return new Azure().fromJsonString(jsonString, options);
  }

  static equals(a: Azure | PlainMessage<Azure> | undefined, b: Azure | PlainMessage<Azure> | undefined): boolean {
    return proto3.util.equals(Azure, a, b);
  }
}

/**
 * AzureRedis contains Azure Cache for Redis specific database metadata.
 *
 * @generated from message types.AzureRedis
 */
export class AzureRedis extends Message<AzureRedis> {
  /**
   * ClusteringPolicy is the clustering policy for Redis Enterprise.
   *
   * @generated from field: string ClusteringPolicy = 1;
   */
  ClusteringPolicy = "";

  constructor(data?: PartialMessage<AzureRedis>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AzureRedis";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusteringPolicy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureRedis {
    return new AzureRedis().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureRedis {
    return new AzureRedis().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureRedis {
    return new AzureRedis().fromJsonString(jsonString, options);
  }

  static equals(a: AzureRedis | PlainMessage<AzureRedis> | undefined, b: AzureRedis | PlainMessage<AzureRedis> | undefined): boolean {
    return proto3.util.equals(AzureRedis, a, b);
  }
}

/**
 * AD contains Active Directory specific database configuration.
 *
 * @generated from message types.AD
 */
export class AD extends Message<AD> {
  /**
   * KeytabFile is the path to the Kerberos keytab file.
   *
   * @generated from field: string KeytabFile = 1;
   */
  KeytabFile = "";

  /**
   * Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
   *
   * @generated from field: string Krb5File = 2;
   */
  Krb5File = "";

  /**
   * Domain is the Active Directory domain the database resides in.
   *
   * @generated from field: string Domain = 3;
   */
  Domain = "";

  /**
   * SPN is the service principal name for the database.
   *
   * @generated from field: string SPN = 4;
   */
  SPN = "";

  /**
   * LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
   *
   * @generated from field: string LDAPCert = 5;
   */
  LDAPCert = "";

  /**
   * KDCHostName is the host name for a KDC for x509 Authentication.
   *
   * @generated from field: string KDCHostName = 6;
   */
  KDCHostName = "";

  constructor(data?: PartialMessage<AD>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AD";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KeytabFile", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Krb5File", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "SPN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "LDAPCert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "KDCHostName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AD {
    return new AD().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AD {
    return new AD().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AD {
    return new AD().fromJsonString(jsonString, options);
  }

  static equals(a: AD | PlainMessage<AD> | undefined, b: AD | PlainMessage<AD> | undefined): boolean {
    return proto3.util.equals(AD, a, b);
  }
}

/**
 * DatabaseTLS contains TLS configuration options.
 *
 * @generated from message types.DatabaseTLS
 */
export class DatabaseTLS extends Message<DatabaseTLS> {
  /**
   * Mode is a TLS connection mode.
   * 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
   *
   * @generated from field: types.DatabaseTLSMode Mode = 1;
   */
  Mode = DatabaseTLSMode.VERIFY_FULL;

  /**
   * CACert is an optional user provided CA certificate used for verifying
   * database TLS connection.
   *
   * @generated from field: string CACert = 2;
   */
  CACert = "";

  /**
   * ServerName allows to provide custom hostname. This value will override the
   * servername/hostname on a certificate during validation.
   *
   * @generated from field: string ServerName = 3;
   */
  ServerName = "";

  /**
   * TrustSystemCertPool allows Teleport to trust certificate authorities
   * available on the host system. If not set (by default), Teleport only
   * trusts self-signed databases with TLS certificates signed by Teleport's
   * Database Server CA or the ca_cert specified in this TLS setting. For
   * cloud-hosted databases, Teleport downloads the corresponding required CAs
   * for validation.
   *
   * @generated from field: bool TrustSystemCertPool = 4;
   */
  TrustSystemCertPool = false;

  constructor(data?: PartialMessage<DatabaseTLS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseTLS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Mode", kind: "enum", T: proto3.getEnumType(DatabaseTLSMode) },
    { no: 2, name: "CACert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ServerName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "TrustSystemCertPool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseTLS {
    return new DatabaseTLS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseTLS {
    return new DatabaseTLS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseTLS {
    return new DatabaseTLS().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseTLS | PlainMessage<DatabaseTLS> | undefined, b: DatabaseTLS | PlainMessage<DatabaseTLS> | undefined): boolean {
    return proto3.util.equals(DatabaseTLS, a, b);
  }
}

/**
 * MySQLOptions are additional MySQL database options.
 *
 * @generated from message types.MySQLOptions
 */
export class MySQLOptions extends Message<MySQLOptions> {
  /**
   * ServerVersion is the server version reported by DB proxy if the runtime information is
   * not available.
   *
   * @generated from field: string ServerVersion = 1;
   */
  ServerVersion = "";

  constructor(data?: PartialMessage<MySQLOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MySQLOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MySQLOptions {
    return new MySQLOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MySQLOptions {
    return new MySQLOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MySQLOptions {
    return new MySQLOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MySQLOptions | PlainMessage<MySQLOptions> | undefined, b: MySQLOptions | PlainMessage<MySQLOptions> | undefined): boolean {
    return proto3.util.equals(MySQLOptions, a, b);
  }
}

/**
 * MongoAtlas contains Atlas metadata about the database.
 *
 * @generated from message types.MongoAtlas
 */
export class MongoAtlas extends Message<MongoAtlas> {
  /**
   * Name is the Atlas database instance name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<MongoAtlas>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MongoAtlas";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MongoAtlas {
    return new MongoAtlas().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MongoAtlas {
    return new MongoAtlas().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MongoAtlas {
    return new MongoAtlas().fromJsonString(jsonString, options);
  }

  static equals(a: MongoAtlas | PlainMessage<MongoAtlas> | undefined, b: MongoAtlas | PlainMessage<MongoAtlas> | undefined): boolean {
    return proto3.util.equals(MongoAtlas, a, b);
  }
}

/**
 * InstanceV1 represents the state of a running teleport instance independent
 * of the specific services that instance exposes.
 *
 * @generated from message types.InstanceV1
 */
export class InstanceV1 extends Message<InstanceV1> {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.InstanceSpecV1 Spec = 2;
   */
  Spec?: InstanceSpecV1;

  constructor(data?: PartialMessage<InstanceV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstanceV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: InstanceSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceV1 {
    return new InstanceV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceV1 {
    return new InstanceV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceV1 {
    return new InstanceV1().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceV1 | PlainMessage<InstanceV1> | undefined, b: InstanceV1 | PlainMessage<InstanceV1> | undefined): boolean {
    return proto3.util.equals(InstanceV1, a, b);
  }
}

/**
 * @generated from message types.InstanceSpecV1
 */
export class InstanceSpecV1 extends Message<InstanceSpecV1> {
  /**
   * Version is the version of teleport this instance most recently advertised.
   *
   * @generated from field: string Version = 1;
   */
  Version = "";

  /**
   * Services is the list of active services this instance most recently advertised.
   *
   * @generated from field: repeated string Services = 2;
   */
  Services: string[] = [];

  /**
   * Hostname is the hostname this instance most recently advertised.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname = "";

  /**
   * AuthID is the ID of the auth server that most recently observed this instance.
   *
   * @generated from field: string AuthID = 4;
   */
  AuthID = "";

  /**
   * LastSeen is the last time an auth server reported observing this instance.
   *
   * @generated from field: google.protobuf.Timestamp LastSeen = 5;
   */
  LastSeen?: Timestamp;

  /**
   * ControlLog is the log of recent important instance control events related to this instance. See comments
   * on the InstanceControlLogEntry type for details.
   *
   * @generated from field: repeated types.InstanceControlLogEntry ControlLog = 6;
   */
  ControlLog: InstanceControlLogEntry[] = [];

  /**
   * ExternalUpgrader identifies the external upgrader that the instance is configured to
   * export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgrader = 7;
   */
  ExternalUpgrader = "";

  /**
   * ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgraderVersion = 8;
   */
  ExternalUpgraderVersion = "";

  constructor(data?: PartialMessage<InstanceSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstanceSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Services", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AuthID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "LastSeen", kind: "message", T: Timestamp },
    { no: 6, name: "ControlLog", kind: "message", T: InstanceControlLogEntry, repeated: true },
    { no: 7, name: "ExternalUpgrader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ExternalUpgraderVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceSpecV1 {
    return new InstanceSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceSpecV1 {
    return new InstanceSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceSpecV1 {
    return new InstanceSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceSpecV1 | PlainMessage<InstanceSpecV1> | undefined, b: InstanceSpecV1 | PlainMessage<InstanceSpecV1> | undefined): boolean {
    return proto3.util.equals(InstanceSpecV1, a, b);
  }
}

/**
 * InstanceControlLogEntry represents an entry in a given instance's control log. The control log of
 * an instance is protected by CompareAndSwap semantics, allowing entries to function as a means of
 * synchronization as well as recordkeeping. For example, an auth server intending to trigger an upgrade
 * for a given instance can check its control log for 'upgrade-attempt' entries. If no such entry exists,
 * it can attempt to write an 'upgrade-attempt' entry of its own. If that entry successfully writes without
 * hitting a CompareFailed, the auth server knows that no other auth servers will make concurrent upgrade
 * attempts while that entry persists.
 *
 * NOTE: Due to resource size and backend throughput limitations, care should be taken to minimize the
 * use and size of instance control log entries.
 *
 *
 * @generated from message types.InstanceControlLogEntry
 */
export class InstanceControlLogEntry extends Message<InstanceControlLogEntry> {
  /**
   * Type represents the type of control log entry this is (e.g. 'upgrade-attempt').
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * ID is a random identifier used to assist in uniquely identifying entries. This value may
   * be unique, or it may be used to associate a collection of related entries (e.g. an upgrade
   * attempt entry may use the same ID as an associated upgrade failure entry if appropriate).
   *
   * @generated from field: uint64 ID = 2;
   */
  ID = protoInt64.zero;

  /**
   * Time is the time at which the event represented by this entry occurred (used in determining
   * ordering and expiry).
   *
   * @generated from field: google.protobuf.Timestamp Time = 3;
   */
  Time?: Timestamp;

  /**
   * TTL is an optional custom time to live for this control log entry. Some control log entries
   * (e.g. an upgrade failure) may require longer than normal TTLs in order to ensure visibility.
   * If a log entry's TTL results in it having an intended expiry further in the future than the
   * expiry of the enclosing Instance resource, the instance resource's expiry will be bumped
   * to accommodate preservation of the log. Because of this fact, custom entry TTLs should be
   * used sparingly, as excess usage could result in unexpected backend growth for high churn
   * clusters.
   *
   * @generated from field: int64 TTL = 4;
   */
  TTL = protoInt64.zero;

  /**
   * Labels is an arbitrary collection of key-value pairs. The expected labels are determined by the
   * type of the entry. Use of labels is preferable to adding new fields in some cases in order to
   * preserve fields across auth downgrades (this is mostly relevant for the version-control system).
   *
   * @generated from field: map<string, string> Labels = 5;
   */
  Labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<InstanceControlLogEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstanceControlLogEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "Time", kind: "message", T: Timestamp },
    { no: 4, name: "TTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceControlLogEntry {
    return new InstanceControlLogEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceControlLogEntry {
    return new InstanceControlLogEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceControlLogEntry {
    return new InstanceControlLogEntry().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceControlLogEntry | PlainMessage<InstanceControlLogEntry> | undefined, b: InstanceControlLogEntry | PlainMessage<InstanceControlLogEntry> | undefined): boolean {
    return proto3.util.equals(InstanceControlLogEntry, a, b);
  }
}

/**
 * InstanceFilter matches instance resources.
 *
 * @generated from message types.InstanceFilter
 */
export class InstanceFilter extends Message<InstanceFilter> {
  /**
   * ServerID matches exactly one instance by server ID if specified.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID = "";

  /**
   * Version matches instance version if specified.
   *
   * @generated from field: string Version = 2;
   */
  Version = "";

  /**
   * Services matches the instance services if specified. Note that this field matches all instances which
   * expose *at least* one of the listed services. This is in contrast to service matching in version
   * directives which match instances that expose a *at most* the listed services.
   *
   * @generated from field: repeated string Services = 3;
   */
  Services: string[] = [];

  /**
   * ExternalUpgrader matches instance upgrader if specified.
   *
   * @generated from field: string ExternalUpgrader = 4;
   */
  ExternalUpgrader = "";

  /**
   * NoExtUpgrader explicitly matches instances for which no upgrader is defined.
   *
   * @generated from field: bool NoExtUpgrader = 5;
   */
  NoExtUpgrader = false;

  /**
   * OlderThanVersion is an optional exclusive upper version bound.
   *
   * @generated from field: string OlderThanVersion = 6;
   */
  OlderThanVersion = "";

  /**
   * NewerThanVersion is an optional exclusive lower version bound.
   *
   * @generated from field: string NewerThanVersion = 7;
   */
  NewerThanVersion = "";

  constructor(data?: PartialMessage<InstanceFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstanceFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Services", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ExternalUpgrader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "NoExtUpgrader", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "OlderThanVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "NewerThanVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceFilter {
    return new InstanceFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceFilter {
    return new InstanceFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceFilter {
    return new InstanceFilter().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceFilter | PlainMessage<InstanceFilter> | undefined, b: InstanceFilter | PlainMessage<InstanceFilter> | undefined): boolean {
    return proto3.util.equals(InstanceFilter, a, b);
  }
}

/**
 * ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.
 *
 * @generated from message types.ServerV2
 */
export class ServerV2 extends Message<ServerV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a server spec
   *
   * @generated from field: types.ServerSpecV2 Spec = 5;
   */
  Spec?: ServerSpecV2;

  constructor(data?: PartialMessage<ServerV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ServerV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ServerSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerV2 {
    return new ServerV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerV2 {
    return new ServerV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerV2 {
    return new ServerV2().fromJsonString(jsonString, options);
  }

  static equals(a: ServerV2 | PlainMessage<ServerV2> | undefined, b: ServerV2 | PlainMessage<ServerV2> | undefined): boolean {
    return proto3.util.equals(ServerV2, a, b);
  }
}

/**
 * ServerSpecV2 is a specification for V2 Server
 *
 * @generated from message types.ServerSpecV2
 */
export class ServerSpecV2 extends Message<ServerSpecV2> {
  /**
   * Addr is a host:port address where this server can be reached.
   *
   * @generated from field: string Addr = 1;
   */
  Addr = "";

  /**
   * Hostname is server hostname
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname = "";

  /**
   * CmdLabels is server dynamic labels
   *
   * @generated from field: map<string, types.CommandLabelV2> CmdLabels = 4;
   */
  CmdLabels: { [key: string]: CommandLabelV2 } = {};

  /**
   * Rotation specifies server rotation
   *
   * @generated from field: types.Rotation Rotation = 5;
   */
  Rotation?: Rotation;

  /**
   * UseTunnel indicates that connections to this server should occur over a
   * reverse tunnel.
   *
   * @generated from field: bool UseTunnel = 6;
   */
  UseTunnel = false;

  /**
   * TeleportVersion is the teleport version that the server is running on
   *
   * @generated from field: string Version = 7;
   */
  Version = "";

  /**
   * PeerAddr is the address a proxy server is reachable at by its peer proxies.
   *
   * @generated from field: string PeerAddr = 11;
   */
  PeerAddr = "";

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 12;
   */
  ProxyIDs: string[] = [];

  /**
   * PublicAddrs is a list of public addresses where this server can be reached.
   *
   * @generated from field: repeated string public_addrs = 13;
   */
  publicAddrs: string[] = [];

  /**
   * CloudMetadata contains info about the cloud instance the server is running
   * on, if any.
   *
   * @generated from field: types.CloudMetadata CloudMetadata = 14;
   */
  CloudMetadata?: CloudMetadata;

  constructor(data?: PartialMessage<ServerSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ServerSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "CmdLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CommandLabelV2} },
    { no: 5, name: "Rotation", kind: "message", T: Rotation },
    { no: 6, name: "UseTunnel", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "PeerAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "ProxyIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "public_addrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "CloudMetadata", kind: "message", T: CloudMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerSpecV2 {
    return new ServerSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerSpecV2 {
    return new ServerSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerSpecV2 {
    return new ServerSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ServerSpecV2 | PlainMessage<ServerSpecV2> | undefined, b: ServerSpecV2 | PlainMessage<ServerSpecV2> | undefined): boolean {
    return proto3.util.equals(ServerSpecV2, a, b);
  }
}

/**
 * AWSInfo contains attributes to match to an EC2 instance.
 *
 * @generated from message types.AWSInfo
 */
export class AWSInfo extends Message<AWSInfo> {
  /**
   * AccountID is an AWS account ID.
   *
   * @generated from field: string AccountID = 1;
   */
  AccountID = "";

  /**
   * InstanceID is an EC2 instance ID.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID = "";

  /**
   * Region is the AWS EC2 Instance Region.
   *
   * @generated from field: string Region = 3;
   */
  Region = "";

  /**
   * VPCID is the AWS VPC ID where the Instance is running.
   *
   * @generated from field: string VPCID = 4;
   */
  VPCID = "";

  /**
   * Integration is the integration name that added this Node.
   * When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection.
   * This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
   *
   * @generated from field: string Integration = 5;
   */
  Integration = "";

  /**
   * SubnetID is the Subnet ID in use by the instance.
   *
   * @generated from field: string SubnetID = 6;
   */
  SubnetID = "";

  constructor(data?: PartialMessage<AWSInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AWSInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AccountID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "InstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "VPCID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "SubnetID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSInfo {
    return new AWSInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSInfo {
    return new AWSInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSInfo {
    return new AWSInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AWSInfo | PlainMessage<AWSInfo> | undefined, b: AWSInfo | PlainMessage<AWSInfo> | undefined): boolean {
    return proto3.util.equals(AWSInfo, a, b);
  }
}

/**
 * CloudMetadata contains info about the cloud instance a server is running
 * on, if any.
 *
 * @generated from message types.CloudMetadata
 */
export class CloudMetadata extends Message<CloudMetadata> {
  /**
   * AWSInfo contains attributes to match to an EC2 instance.
   *
   * @generated from field: types.AWSInfo AWS = 1;
   */
  AWS?: AWSInfo;

  constructor(data?: PartialMessage<CloudMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CloudMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AWS", kind: "message", T: AWSInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CloudMetadata {
    return new CloudMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloudMetadata {
    return new CloudMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CloudMetadata {
    return new CloudMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CloudMetadata | PlainMessage<CloudMetadata> | undefined, b: CloudMetadata | PlainMessage<CloudMetadata> | undefined): boolean {
    return proto3.util.equals(CloudMetadata, a, b);
  }
}

/**
 * AppServerV3 represents a single proxied web app.
 *
 * @generated from message types.AppServerV3
 */
export class AppServerV3 extends Message<AppServerV3> {
  /**
   * Kind is the app server resource kind. Always "app_server".
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the app server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the app server spec.
   *
   * @generated from field: types.AppServerSpecV3 Spec = 5;
   */
  Spec?: AppServerSpecV3;

  constructor(data?: PartialMessage<AppServerV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppServerV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: AppServerSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppServerV3 {
    return new AppServerV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppServerV3 {
    return new AppServerV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppServerV3 {
    return new AppServerV3().fromJsonString(jsonString, options);
  }

  static equals(a: AppServerV3 | PlainMessage<AppServerV3> | undefined, b: AppServerV3 | PlainMessage<AppServerV3> | undefined): boolean {
    return proto3.util.equals(AppServerV3, a, b);
  }
}

/**
 * AppServerSpecV3 is the app access server spec.
 *
 * @generated from message types.AppServerSpecV3
 */
export class AppServerSpecV3 extends Message<AppServerSpecV3> {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 1;
   */
  Version = "";

  /**
   * Hostname is the app server hostname.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname = "";

  /**
   * HostID is the app server host uuid.
   *
   * @generated from field: string HostID = 3;
   */
  HostID = "";

  /**
   * Rotation contains the app server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 4;
   */
  Rotation?: Rotation;

  /**
   * App is the app proxied by this app server.
   *
   * @generated from field: types.AppV3 App = 5;
   */
  App?: AppV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 6;
   */
  ProxyIDs: string[] = [];

  constructor(data?: PartialMessage<AppServerSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppServerSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Rotation", kind: "message", T: Rotation },
    { no: 5, name: "App", kind: "message", T: AppV3 },
    { no: 6, name: "ProxyIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppServerSpecV3 {
    return new AppServerSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppServerSpecV3 {
    return new AppServerSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppServerSpecV3 {
    return new AppServerSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: AppServerSpecV3 | PlainMessage<AppServerSpecV3> | undefined, b: AppServerSpecV3 | PlainMessage<AppServerSpecV3> | undefined): boolean {
    return proto3.util.equals(AppServerSpecV3, a, b);
  }
}

/**
 * AppV3List represents a list of app resources.
 *
 * @generated from message types.AppV3List
 */
export class AppV3List extends Message<AppV3List> {
  /**
   * Apps is a list of app resources.
   *
   * @generated from field: repeated types.AppV3 Apps = 1;
   */
  Apps: AppV3[] = [];

  constructor(data?: PartialMessage<AppV3List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppV3List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Apps", kind: "message", T: AppV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppV3List {
    return new AppV3List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppV3List {
    return new AppV3List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppV3List {
    return new AppV3List().fromJsonString(jsonString, options);
  }

  static equals(a: AppV3List | PlainMessage<AppV3List> | undefined, b: AppV3List | PlainMessage<AppV3List> | undefined): boolean {
    return proto3.util.equals(AppV3List, a, b);
  }
}

/**
 * AppV3 represents an app resource.
 *
 * @generated from message types.AppV3
 */
export class AppV3 extends Message<AppV3> {
  /**
   * Kind is the app resource kind. Always "app".
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the app resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the app resource spec.
   *
   * @generated from field: types.AppSpecV3 Spec = 5;
   */
  Spec?: AppSpecV3;

  constructor(data?: PartialMessage<AppV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: AppSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppV3 {
    return new AppV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppV3 {
    return new AppV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppV3 {
    return new AppV3().fromJsonString(jsonString, options);
  }

  static equals(a: AppV3 | PlainMessage<AppV3> | undefined, b: AppV3 | PlainMessage<AppV3> | undefined): boolean {
    return proto3.util.equals(AppV3, a, b);
  }
}

/**
 * CORSPolicy defines the CORS policy for AppSpecV3
 *
 * @generated from message types.CORSPolicy
 */
export class CORSPolicy extends Message<CORSPolicy> {
  /**
   * allowed_origins specifies which origins are allowed to access the app.
   *
   * @generated from field: repeated string allowed_origins = 1;
   */
  allowedOrigins: string[] = [];

  /**
   * allowed_methods specifies which methods are allowed when accessing the app.
   *
   * @generated from field: repeated string allowed_methods = 2;
   */
  allowedMethods: string[] = [];

  /**
   * allowed_headers specifies which headers can be used when accessing the app.
   *
   * @generated from field: repeated string allowed_headers = 3;
   */
  allowedHeaders: string[] = [];

  /**
   * allow_credentials indicates whether credentials are allowed.
   *
   * @generated from field: bool allow_credentials = 4;
   */
  allowCredentials = false;

  /**
   * max_age indicates how long (in seconds) the results of a preflight request can be cached.
   *
   * @generated from field: uint32 max_age = 5;
   */
  maxAge = 0;

  /**
   * exposed_headers indicates which headers are made available to scripts via the browser.
   *
   * @generated from field: repeated string exposed_headers = 6;
   */
  exposedHeaders: string[] = [];

  constructor(data?: PartialMessage<CORSPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CORSPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_origins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "allowed_methods", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "allowed_headers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "allow_credentials", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "max_age", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "exposed_headers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CORSPolicy {
    return new CORSPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CORSPolicy {
    return new CORSPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CORSPolicy {
    return new CORSPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: CORSPolicy | PlainMessage<CORSPolicy> | undefined, b: CORSPolicy | PlainMessage<CORSPolicy> | undefined): boolean {
    return proto3.util.equals(CORSPolicy, a, b);
  }
}

/**
 * AppSpecV3 is the AppV3 resource spec.
 *
 * @generated from message types.AppSpecV3
 */
export class AppSpecV3 extends Message<AppSpecV3> {
  /**
   * URI is the web app endpoint.
   *
   * @generated from field: string URI = 1;
   */
  URI = "";

  /**
   * PublicAddr is the public address the application is accessible at.
   *
   * @generated from field: string PublicAddr = 2;
   */
  PublicAddr = "";

  /**
   * DynamicLabels are the app's command labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 3;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 } = {};

  /**
   * InsecureSkipVerify disables app's TLS certificate verification.
   *
   * @generated from field: bool InsecureSkipVerify = 4;
   */
  InsecureSkipVerify = false;

  /**
   * Rewrite is a list of rewriting rules to apply to requests and responses.
   *
   * @generated from field: types.Rewrite Rewrite = 5;
   */
  Rewrite?: Rewrite;

  /**
   * AWS contains additional options for AWS applications.
   *
   * @generated from field: types.AppAWS AWS = 6;
   */
  AWS?: AppAWS;

  /**
   * Cloud identifies the cloud instance the app represents.
   *
   * @generated from field: string Cloud = 7;
   */
  Cloud = "";

  /**
   * UserGroups are a list of user group IDs that this app is associated with.
   *
   * @generated from field: repeated string UserGroups = 8;
   */
  UserGroups: string[] = [];

  /**
   * Integration is the integration name that must be used to access this Application.
   * Only applicable to AWS App Access.
   * If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
   *
   * @generated from field: string Integration = 9;
   */
  Integration = "";

  /**
   * RequiredAppNames is a list of app names that are required for this app to function. Any app listed here will
   * be part of the authentication redirect flow and authenticate along side this app.
   *
   * @generated from field: repeated string RequiredAppNames = 10;
   */
  RequiredAppNames: string[] = [];

  /**
   * CORSPolicy defines the Cross-Origin Resource Sharing settings for the app.
   *
   * @generated from field: types.CORSPolicy CORS = 11;
   */
  CORS?: CORSPolicy;

  constructor(data?: PartialMessage<AppSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "PublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "DynamicLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CommandLabelV2} },
    { no: 4, name: "InsecureSkipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "Rewrite", kind: "message", T: Rewrite },
    { no: 6, name: "AWS", kind: "message", T: AppAWS },
    { no: 7, name: "Cloud", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "UserGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "Integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "RequiredAppNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "CORS", kind: "message", T: CORSPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppSpecV3 {
    return new AppSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppSpecV3 {
    return new AppSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppSpecV3 {
    return new AppSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: AppSpecV3 | PlainMessage<AppSpecV3> | undefined, b: AppSpecV3 | PlainMessage<AppSpecV3> | undefined): boolean {
    return proto3.util.equals(AppSpecV3, a, b);
  }
}

/**
 * AppServerOrSAMLIdPServiceProviderV1 holds either an AppServerV3 or a SAMLIdPServiceProviderV1 resource (never both).
 * Used in application listings that request both app servers and saml apps.
 *
 * DEPRECATED: Use AppServer and SAMLIdPServiceProvider type individually.
 *
 * @generated from message types.AppServerOrSAMLIdPServiceProviderV1
 * @deprecated
 */
export class AppServerOrSAMLIdPServiceProviderV1 extends Message<AppServerOrSAMLIdPServiceProviderV1> {
  /**
   * Kind is the resource kind. Always "app_server_saml_idp_sp".
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * The AppServer or SAMLIdPServiceProvider resource.
   *
   * @generated from oneof types.AppServerOrSAMLIdPServiceProviderV1.Resource
   */
  Resource: {
    /**
     * AppServer is the AppServer resource.
     *
     * @generated from field: types.AppServerV3 AppServer = 2;
     */
    value: AppServerV3;
    case: "AppServer";
  } | {
    /**
     * SAMLIdPServiceProvider is the SAMLIdPServiceProvider resource.
     *
     * @generated from field: types.SAMLIdPServiceProviderV1 SAMLIdPServiceProvider = 3;
     */
    value: SAMLIdPServiceProviderV1;
    case: "SAMLIdPServiceProvider";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AppServerOrSAMLIdPServiceProviderV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppServerOrSAMLIdPServiceProviderV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AppServer", kind: "message", T: AppServerV3, oneof: "Resource" },
    { no: 3, name: "SAMLIdPServiceProvider", kind: "message", T: SAMLIdPServiceProviderV1, oneof: "Resource" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppServerOrSAMLIdPServiceProviderV1 {
    return new AppServerOrSAMLIdPServiceProviderV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppServerOrSAMLIdPServiceProviderV1 {
    return new AppServerOrSAMLIdPServiceProviderV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppServerOrSAMLIdPServiceProviderV1 {
    return new AppServerOrSAMLIdPServiceProviderV1().fromJsonString(jsonString, options);
  }

  static equals(a: AppServerOrSAMLIdPServiceProviderV1 | PlainMessage<AppServerOrSAMLIdPServiceProviderV1> | undefined, b: AppServerOrSAMLIdPServiceProviderV1 | PlainMessage<AppServerOrSAMLIdPServiceProviderV1> | undefined): boolean {
    return proto3.util.equals(AppServerOrSAMLIdPServiceProviderV1, a, b);
  }
}

/**
 * Rewrite is a list of rewriting rules to apply to requests and responses.
 *
 * @generated from message types.Rewrite
 */
export class Rewrite extends Message<Rewrite> {
  /**
   * Redirect defines a list of hosts which will be rewritten to the public
   * address of the application if they occur in the "Location" header.
   *
   * @generated from field: repeated string Redirect = 1;
   */
  Redirect: string[] = [];

  /**
   * Headers is a list of headers to inject when passing the request over
   * to the application.
   *
   * @generated from field: repeated types.Header Headers = 2;
   */
  Headers: Header[] = [];

  /**
   * JWTClaims configures whether roles/traits are included in the JWT token.
   *
   * @generated from field: string JWTClaims = 3;
   */
  JWTClaims = "";

  constructor(data?: PartialMessage<Rewrite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Rewrite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Redirect", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Headers", kind: "message", T: Header, repeated: true },
    { no: 3, name: "JWTClaims", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rewrite {
    return new Rewrite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rewrite {
    return new Rewrite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rewrite {
    return new Rewrite().fromJsonString(jsonString, options);
  }

  static equals(a: Rewrite | PlainMessage<Rewrite> | undefined, b: Rewrite | PlainMessage<Rewrite> | undefined): boolean {
    return proto3.util.equals(Rewrite, a, b);
  }
}

/**
 * Header represents a single http header passed over to the proxied application.
 *
 * @generated from message types.Header
 */
export class Header extends Message<Header> {
  /**
   * Name is the http header name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Value is the http header value.
   *
   * @generated from field: string Value = 2;
   */
  Value = "";

  constructor(data?: PartialMessage<Header>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Header";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Header {
    return new Header().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Header {
    return new Header().fromJsonString(jsonString, options);
  }

  static equals(a: Header | PlainMessage<Header> | undefined, b: Header | PlainMessage<Header> | undefined): boolean {
    return proto3.util.equals(Header, a, b);
  }
}

/**
 * CommandLabelV2 is a label that has a value as a result of the
 * output generated by running command, e.g. hostname
 *
 * @generated from message types.CommandLabelV2
 */
export class CommandLabelV2 extends Message<CommandLabelV2> {
  /**
   * Period is a time between command runs
   *
   * @generated from field: int64 Period = 1;
   */
  Period = protoInt64.zero;

  /**
   * Command is a command to run
   *
   * @generated from field: repeated string Command = 2;
   */
  Command: string[] = [];

  /**
   * Result captures standard output
   *
   * @generated from field: string Result = 3;
   */
  Result = "";

  constructor(data?: PartialMessage<CommandLabelV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CommandLabelV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Period", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "Command", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Result", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommandLabelV2 {
    return new CommandLabelV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommandLabelV2 {
    return new CommandLabelV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommandLabelV2 {
    return new CommandLabelV2().fromJsonString(jsonString, options);
  }

  static equals(a: CommandLabelV2 | PlainMessage<CommandLabelV2> | undefined, b: CommandLabelV2 | PlainMessage<CommandLabelV2> | undefined): boolean {
    return proto3.util.equals(CommandLabelV2, a, b);
  }
}

/**
 * AppAWS contains additional options for AWS applications.
 *
 * @generated from message types.AppAWS
 */
export class AppAWS extends Message<AppAWS> {
  /**
   * ExternalID is the AWS External ID used when assuming roles in this app.
   *
   * @generated from field: string ExternalID = 1;
   */
  ExternalID = "";

  constructor(data?: PartialMessage<AppAWS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AppAWS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ExternalID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppAWS {
    return new AppAWS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppAWS {
    return new AppAWS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppAWS {
    return new AppAWS().fromJsonString(jsonString, options);
  }

  static equals(a: AppAWS | PlainMessage<AppAWS> | undefined, b: AppAWS | PlainMessage<AppAWS> | undefined): boolean {
    return proto3.util.equals(AppAWS, a, b);
  }
}

/**
 * SSHKeyPair is an SSH CA key pair.
 *
 * @generated from message types.SSHKeyPair
 */
export class SSHKeyPair extends Message<SSHKeyPair> {
  /**
   * PublicKey is the SSH public key.
   *
   * @generated from field: bytes PublicKey = 1;
   */
  PublicKey = new Uint8Array(0);

  /**
   * PrivateKey is the SSH private key.
   *
   * @generated from field: bytes PrivateKey = 2;
   */
  PrivateKey = new Uint8Array(0);

  /**
   * PrivateKeyType is the type of the PrivateKey.
   *
   * @generated from field: types.PrivateKeyType PrivateKeyType = 3;
   */
  PrivateKeyType = PrivateKeyType.RAW;

  constructor(data?: PartialMessage<SSHKeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SSHKeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "PrivateKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "PrivateKeyType", kind: "enum", T: proto3.getEnumType(PrivateKeyType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHKeyPair {
    return new SSHKeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHKeyPair {
    return new SSHKeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHKeyPair {
    return new SSHKeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: SSHKeyPair | PlainMessage<SSHKeyPair> | undefined, b: SSHKeyPair | PlainMessage<SSHKeyPair> | undefined): boolean {
    return proto3.util.equals(SSHKeyPair, a, b);
  }
}

/**
 * TLSKeyPair is a TLS key pair
 *
 * @generated from message types.TLSKeyPair
 */
export class TLSKeyPair extends Message<TLSKeyPair> {
  /**
   * Cert is a PEM encoded TLS cert
   *
   * @generated from field: bytes Cert = 1;
   */
  Cert = new Uint8Array(0);

  /**
   * Key is a PEM encoded TLS key
   *
   * @generated from field: bytes Key = 2;
   */
  Key = new Uint8Array(0);

  /**
   * KeyType is the type of the Key.
   *
   * @generated from field: types.PrivateKeyType KeyType = 3;
   */
  KeyType = PrivateKeyType.RAW;

  constructor(data?: PartialMessage<TLSKeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TLSKeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "Key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "KeyType", kind: "enum", T: proto3.getEnumType(PrivateKeyType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSKeyPair {
    return new TLSKeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSKeyPair {
    return new TLSKeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSKeyPair {
    return new TLSKeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: TLSKeyPair | PlainMessage<TLSKeyPair> | undefined, b: TLSKeyPair | PlainMessage<TLSKeyPair> | undefined): boolean {
    return proto3.util.equals(TLSKeyPair, a, b);
  }
}

/**
 * JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
 *
 * @generated from message types.JWTKeyPair
 */
export class JWTKeyPair extends Message<JWTKeyPair> {
  /**
   * PublicKey is a PEM encoded public key.
   *
   * @generated from field: bytes PublicKey = 1;
   */
  PublicKey = new Uint8Array(0);

  /**
   * PrivateKey is a PEM encoded private key.
   *
   * @generated from field: bytes PrivateKey = 2;
   */
  PrivateKey = new Uint8Array(0);

  /**
   * PrivateKeyType is the type of the PrivateKey.
   *
   * @generated from field: types.PrivateKeyType PrivateKeyType = 3;
   */
  PrivateKeyType = PrivateKeyType.RAW;

  constructor(data?: PartialMessage<JWTKeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.JWTKeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "PrivateKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "PrivateKeyType", kind: "enum", T: proto3.getEnumType(PrivateKeyType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JWTKeyPair {
    return new JWTKeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JWTKeyPair {
    return new JWTKeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JWTKeyPair {
    return new JWTKeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: JWTKeyPair | PlainMessage<JWTKeyPair> | undefined, b: JWTKeyPair | PlainMessage<JWTKeyPair> | undefined): boolean {
    return proto3.util.equals(JWTKeyPair, a, b);
  }
}

/**
 * CertAuthorityV2 is version 2 resource spec for Cert Authority
 *
 * @generated from message types.CertAuthorityV2
 */
export class CertAuthorityV2 extends Message<CertAuthorityV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is connector metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains cert authority specification
   *
   * @generated from field: types.CertAuthoritySpecV2 Spec = 5;
   */
  Spec?: CertAuthoritySpecV2;

  constructor(data?: PartialMessage<CertAuthorityV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CertAuthorityV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: CertAuthoritySpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertAuthorityV2 {
    return new CertAuthorityV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertAuthorityV2 {
    return new CertAuthorityV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertAuthorityV2 {
    return new CertAuthorityV2().fromJsonString(jsonString, options);
  }

  static equals(a: CertAuthorityV2 | PlainMessage<CertAuthorityV2> | undefined, b: CertAuthorityV2 | PlainMessage<CertAuthorityV2> | undefined): boolean {
    return proto3.util.equals(CertAuthorityV2, a, b);
  }
}

/**
 * CertAuthoritySpecV2 is a host or user certificate authority that
 * can check and if it has private key stored as well, sign it too
 *
 * @generated from message types.CertAuthoritySpecV2
 */
export class CertAuthoritySpecV2 extends Message<CertAuthoritySpecV2> {
  /**
   * Type is either user or host certificate authority
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * ClusterName identifies the cluster name this authority serves.
   *
   * @generated from field: string ClusterName = 2;
   */
  ClusterName = "";

  /**
   * Roles is a list of roles assumed by users signed by this CA
   *
   * @generated from field: repeated string Roles = 5;
   */
  Roles: string[] = [];

  /**
   * RoleMap specifies role mappings to remote roles
   *
   * @generated from field: repeated types.RoleMapping RoleMap = 6;
   */
  RoleMap: RoleMapping[] = [];

  /**
   * Rotation is a status of the certificate authority rotation
   *
   * @generated from field: types.Rotation Rotation = 8;
   */
  Rotation?: Rotation;

  /**
   * SigningAlg is unused.
   *
   * Deprecated: SigningAlg is unused.
   *
   * @generated from field: types.CertAuthoritySpecV2.SigningAlgType SigningAlg = 9 [deprecated = true];
   * @deprecated
   */
  SigningAlg = CertAuthoritySpecV2_SigningAlgType.UNKNOWN;

  /**
   * ActiveKeys are the CA key sets used to sign any new certificates.
   *
   * @generated from field: types.CAKeySet ActiveKeys = 11;
   */
  ActiveKeys?: CAKeySet;

  /**
   * AdditionalTrustedKeys are additional CA key sets that can be used to
   * verify certificates. Certificates should be verified with
   * AdditionalTrustedKeys and ActiveKeys combined.
   *
   * @generated from field: types.CAKeySet AdditionalTrustedKeys = 12;
   */
  AdditionalTrustedKeys?: CAKeySet;

  constructor(data?: PartialMessage<CertAuthoritySpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CertAuthoritySpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "RoleMap", kind: "message", T: RoleMapping, repeated: true },
    { no: 8, name: "Rotation", kind: "message", T: Rotation },
    { no: 9, name: "SigningAlg", kind: "enum", T: proto3.getEnumType(CertAuthoritySpecV2_SigningAlgType) },
    { no: 11, name: "ActiveKeys", kind: "message", T: CAKeySet },
    { no: 12, name: "AdditionalTrustedKeys", kind: "message", T: CAKeySet },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertAuthoritySpecV2 {
    return new CertAuthoritySpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertAuthoritySpecV2 {
    return new CertAuthoritySpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertAuthoritySpecV2 {
    return new CertAuthoritySpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: CertAuthoritySpecV2 | PlainMessage<CertAuthoritySpecV2> | undefined, b: CertAuthoritySpecV2 | PlainMessage<CertAuthoritySpecV2> | undefined): boolean {
    return proto3.util.equals(CertAuthoritySpecV2, a, b);
  }
}

/**
 * SigningAlgType is unused.
 *
 * Deprecated: SigningAlgType is unused.
 *
 * @generated from enum types.CertAuthoritySpecV2.SigningAlgType
 * @deprecated
 */
export enum CertAuthoritySpecV2_SigningAlgType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: RSA_SHA1 = 1;
   */
  RSA_SHA1 = 1,

  /**
   * @generated from enum value: RSA_SHA2_256 = 2;
   */
  RSA_SHA2_256 = 2,

  /**
   * @generated from enum value: RSA_SHA2_512 = 3;
   */
  RSA_SHA2_512 = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CertAuthoritySpecV2_SigningAlgType)
proto3.util.setEnumType(CertAuthoritySpecV2_SigningAlgType, "types.CertAuthoritySpecV2.SigningAlgType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "RSA_SHA1" },
  { no: 2, name: "RSA_SHA2_256" },
  { no: 3, name: "RSA_SHA2_512" },
]);

/**
 * CAKeySet is the set of CA keys.
 *
 * @generated from message types.CAKeySet
 */
export class CAKeySet extends Message<CAKeySet> {
  /**
   * SSH contains SSH CA key pairs.
   *
   * @generated from field: repeated types.SSHKeyPair SSH = 1;
   */
  SSH: SSHKeyPair[] = [];

  /**
   * TLS contains TLS CA key/cert pairs.
   *
   * @generated from field: repeated types.TLSKeyPair TLS = 2;
   */
  TLS: TLSKeyPair[] = [];

  /**
   * JWT contains JWT signing key pairs.
   *
   * @generated from field: repeated types.JWTKeyPair JWT = 3;
   */
  JWT: JWTKeyPair[] = [];

  constructor(data?: PartialMessage<CAKeySet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CAKeySet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SSH", kind: "message", T: SSHKeyPair, repeated: true },
    { no: 2, name: "TLS", kind: "message", T: TLSKeyPair, repeated: true },
    { no: 3, name: "JWT", kind: "message", T: JWTKeyPair, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CAKeySet {
    return new CAKeySet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CAKeySet {
    return new CAKeySet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CAKeySet {
    return new CAKeySet().fromJsonString(jsonString, options);
  }

  static equals(a: CAKeySet | PlainMessage<CAKeySet> | undefined, b: CAKeySet | PlainMessage<CAKeySet> | undefined): boolean {
    return proto3.util.equals(CAKeySet, a, b);
  }
}

/**
 * RoleMapping provides mapping of remote roles to local roles
 * for trusted clusters
 *
 * @generated from message types.RoleMapping
 */
export class RoleMapping extends Message<RoleMapping> {
  /**
   * Remote specifies remote role name to map from
   *
   * @generated from field: string Remote = 1;
   */
  Remote = "";

  /**
   * Local specifies local roles to map to
   *
   * @generated from field: repeated string Local = 2;
   */
  Local: string[] = [];

  constructor(data?: PartialMessage<RoleMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Remote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Local", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleMapping {
    return new RoleMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleMapping {
    return new RoleMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleMapping {
    return new RoleMapping().fromJsonString(jsonString, options);
  }

  static equals(a: RoleMapping | PlainMessage<RoleMapping> | undefined, b: RoleMapping | PlainMessage<RoleMapping> | undefined): boolean {
    return proto3.util.equals(RoleMapping, a, b);
  }
}

/**
 * ProvisionTokenV1 is a provisioning token V1
 *
 * @generated from message types.ProvisionTokenV1
 */
export class ProvisionTokenV1 extends Message<ProvisionTokenV1> {
  /**
   * Roles is a list of roles associated with the token,
   * that will be converted to metadata in the SSH and X509
   * certificates issued to the user of the token
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[] = [];

  /**
   * Expires is a global expiry time header can be set on any resource in the
   * system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 2;
   */
  Expires?: Timestamp;

  /**
   * Token is a token name
   *
   * @generated from field: string Token = 3;
   */
  Token = "";

  constructor(data?: PartialMessage<ProvisionTokenV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Expires", kind: "message", T: Timestamp },
    { no: 3, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenV1 {
    return new ProvisionTokenV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenV1 {
    return new ProvisionTokenV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenV1 {
    return new ProvisionTokenV1().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenV1 | PlainMessage<ProvisionTokenV1> | undefined, b: ProvisionTokenV1 | PlainMessage<ProvisionTokenV1> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenV1, a, b);
  }
}

/**
 * ProvisionTokenV2 specifies provisioning token
 *
 * @generated from message types.ProvisionTokenV2
 */
export class ProvisionTokenV2 extends Message<ProvisionTokenV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a provisioning token V2 spec
   *
   * @generated from field: types.ProvisionTokenSpecV2 Spec = 5;
   */
  Spec?: ProvisionTokenSpecV2;

  constructor(data?: PartialMessage<ProvisionTokenV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ProvisionTokenSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenV2 {
    return new ProvisionTokenV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenV2 {
    return new ProvisionTokenV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenV2 {
    return new ProvisionTokenV2().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenV2 | PlainMessage<ProvisionTokenV2> | undefined, b: ProvisionTokenV2 | PlainMessage<ProvisionTokenV2> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenV2, a, b);
  }
}

/**
 * ProvisionTokenV2List is a list of provisioning tokens.
 *
 * @generated from message types.ProvisionTokenV2List
 */
export class ProvisionTokenV2List extends Message<ProvisionTokenV2List> {
  /**
   * ProvisionTokens is a list of provisioning tokens.
   *
   * @generated from field: repeated types.ProvisionTokenV2 ProvisionTokens = 1;
   */
  ProvisionTokens: ProvisionTokenV2[] = [];

  constructor(data?: PartialMessage<ProvisionTokenV2List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenV2List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ProvisionTokens", kind: "message", T: ProvisionTokenV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenV2List {
    return new ProvisionTokenV2List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenV2List {
    return new ProvisionTokenV2List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenV2List {
    return new ProvisionTokenV2List().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenV2List | PlainMessage<ProvisionTokenV2List> | undefined, b: ProvisionTokenV2List | PlainMessage<ProvisionTokenV2List> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenV2List, a, b);
  }
}

/**
 * TokenRule is a rule that a joining node must match in order to use the
 * associated token.
 *
 * @generated from message types.TokenRule
 */
export class TokenRule extends Message<TokenRule> {
  /**
   * AWSAccount is the AWS account ID.
   *
   * @generated from field: string AWSAccount = 1;
   */
  AWSAccount = "";

  /**
   * AWSRegions is used for the EC2 join method and is a list of AWS regions a
   * node is allowed to join from.
   *
   * @generated from field: repeated string AWSRegions = 2;
   */
  AWSRegions: string[] = [];

  /**
   * AWSRole is used for the EC2 join method and is the ARN of the AWS
   * role that the auth server will assume in order to call the ec2 API.
   *
   * @generated from field: string AWSRole = 3;
   */
  AWSRole = "";

  /**
   * AWSARN is used for the IAM join method, the AWS identity of joining nodes
   * must match this ARN. Supports wildcards "*" and "?".
   *
   * @generated from field: string AWSARN = 4;
   */
  AWSARN = "";

  constructor(data?: PartialMessage<TokenRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TokenRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AWSAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AWSRegions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "AWSRole", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AWSARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenRule {
    return new TokenRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenRule {
    return new TokenRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenRule {
    return new TokenRule().fromJsonString(jsonString, options);
  }

  static equals(a: TokenRule | PlainMessage<TokenRule> | undefined, b: TokenRule | PlainMessage<TokenRule> | undefined): boolean {
    return proto3.util.equals(TokenRule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2 is a specification for V2 token
 *
 * @generated from message types.ProvisionTokenSpecV2
 */
export class ProvisionTokenSpecV2 extends Message<ProvisionTokenSpecV2> {
  /**
   * Roles is a list of roles associated with the token,
   * that will be converted to metadata in the SSH and X509
   * certificates issued to the user of the token
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[] = [];

  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.TokenRule Allow = 2;
   */
  Allow: TokenRule[] = [];

  /**
   * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
   * to join the cluster with this token.
   *
   * @generated from field: int64 AWSIIDTTL = 3;
   */
  AWSIIDTTL = protoInt64.zero;

  /**
   * JoinMethod is the joining method required in order to use this token.
   * Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
   *
   * @generated from field: string JoinMethod = 4;
   */
  JoinMethod = "";

  /**
   * BotName is the name of the bot this token grants access to, if any
   *
   * @generated from field: string BotName = 5;
   */
  BotName = "";

  /**
   * SuggestedLabels is a set of labels that resources should set when using this token to enroll
   * themselves in the cluster.
   * Currently, only node-join scripts create a configuration according to the suggestion.
   *
   * @generated from field: wrappers.LabelValues SuggestedLabels = 6;
   */
  SuggestedLabels?: LabelValues;

  /**
   * GitHub allows the configuration of options specific to the "github" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GitHub GitHub = 7;
   */
  GitHub?: ProvisionTokenSpecV2GitHub;

  /**
   * CircleCI allows the configuration of options specific to the "circleci" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2CircleCI CircleCI = 8;
   */
  CircleCI?: ProvisionTokenSpecV2CircleCI;

  /**
   * SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources.
   * When an agent uses this token, the agent should monitor resources that match those labels.
   * For databases, this means adding the labels to `db_service.resources.labels`.
   * Currently, only node-join scripts create a configuration according to the suggestion.
   *
   * @generated from field: wrappers.LabelValues SuggestedAgentMatcherLabels = 9;
   */
  SuggestedAgentMatcherLabels?: LabelValues;

  /**
   * Kubernetes allows the configuration of options specific to the "kubernetes" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Kubernetes Kubernetes = 10;
   */
  Kubernetes?: ProvisionTokenSpecV2Kubernetes;

  /**
   * Azure allows the configuration of options specific to the "azure" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Azure Azure = 11;
   */
  Azure?: ProvisionTokenSpecV2Azure;

  /**
   * GitLab allows the configuration of options specific to the "gitlab" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GitLab GitLab = 12;
   */
  GitLab?: ProvisionTokenSpecV2GitLab;

  /**
   * GCP allows the configuration of options specific to the "gcp" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GCP GCP = 13;
   */
  GCP?: ProvisionTokenSpecV2GCP;

  /**
   * Spacelift allows the configuration of options specific to the "spacelift" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Spacelift Spacelift = 14;
   */
  Spacelift?: ProvisionTokenSpecV2Spacelift;

  /**
   * TPM allows the configuration of options specific to the "tpm" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2TPM TPM = 15;
   */
  TPM?: ProvisionTokenSpecV2TPM;

  /**
   * TerraformCloud allows the configuration of options specific to the "terraform_cloud" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2TerraformCloud TerraformCloud = 16;
   */
  TerraformCloud?: ProvisionTokenSpecV2TerraformCloud;

  constructor(data?: PartialMessage<ProvisionTokenSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Allow", kind: "message", T: TokenRule, repeated: true },
    { no: 3, name: "AWSIIDTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "JoinMethod", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "BotName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "SuggestedLabels", kind: "message", T: LabelValues },
    { no: 7, name: "GitHub", kind: "message", T: ProvisionTokenSpecV2GitHub },
    { no: 8, name: "CircleCI", kind: "message", T: ProvisionTokenSpecV2CircleCI },
    { no: 9, name: "SuggestedAgentMatcherLabels", kind: "message", T: LabelValues },
    { no: 10, name: "Kubernetes", kind: "message", T: ProvisionTokenSpecV2Kubernetes },
    { no: 11, name: "Azure", kind: "message", T: ProvisionTokenSpecV2Azure },
    { no: 12, name: "GitLab", kind: "message", T: ProvisionTokenSpecV2GitLab },
    { no: 13, name: "GCP", kind: "message", T: ProvisionTokenSpecV2GCP },
    { no: 14, name: "Spacelift", kind: "message", T: ProvisionTokenSpecV2Spacelift },
    { no: 15, name: "TPM", kind: "message", T: ProvisionTokenSpecV2TPM },
    { no: 16, name: "TerraformCloud", kind: "message", T: ProvisionTokenSpecV2TerraformCloud },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2 {
    return new ProvisionTokenSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2 {
    return new ProvisionTokenSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2 {
    return new ProvisionTokenSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2 | PlainMessage<ProvisionTokenSpecV2> | undefined, b: ProvisionTokenSpecV2 | PlainMessage<ProvisionTokenSpecV2> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2, a, b);
  }
}

/**
 * ProvisionTokenSpecV2TPM contains the TPM-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2TPM
 */
export class ProvisionTokenSpecV2TPM extends Message<ProvisionTokenSpecV2TPM> {
  /**
   * Allow is a list of Rules, the presented delegated identity must match one
   * allow rule to permit joining.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2TPM.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2TPM_Rule[] = [];

  /**
   * EKCertAllowedCAs is a list of CA certificates that will be used to validate
   * TPM EKCerts.
   * When specified, joining TPMs must present an EKCert signed by one of the
   * specified CAs. TPMs that do not present an EKCert will be not permitted to
   * join.
   * When unspecified, TPMs will be allowed to join with either an EKCert or an
   * EKPubHash.
   *
   * @generated from field: repeated string EKCertAllowedCAs = 2;
   */
  EKCertAllowedCAs: string[] = [];

  constructor(data?: PartialMessage<ProvisionTokenSpecV2TPM>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2TPM";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2TPM_Rule, repeated: true },
    { no: 2, name: "EKCertAllowedCAs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2TPM {
    return new ProvisionTokenSpecV2TPM().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TPM {
    return new ProvisionTokenSpecV2TPM().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TPM {
    return new ProvisionTokenSpecV2TPM().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2TPM | PlainMessage<ProvisionTokenSpecV2TPM> | undefined, b: ProvisionTokenSpecV2TPM | PlainMessage<ProvisionTokenSpecV2TPM> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2TPM, a, b);
  }
}

/**
 * @generated from message types.ProvisionTokenSpecV2TPM.Rule
 */
export class ProvisionTokenSpecV2TPM_Rule extends Message<ProvisionTokenSpecV2TPM_Rule> {
  /**
   * Description is a human-readable description of the rule. It has no
   * bearing on whether or not a TPM is allowed to join, but can be used
   * to associate a rule with a specific host (e.g the asset tag of the server
   * in which the TPM resides).
   * Example: "build-server-100"
   *
   * @generated from field: string Description = 1;
   */
  Description = "";

  /**
   * EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format
   * and encoded in hexadecimal. This value will also be checked when a TPM
   * has submitted an EKCert, and the public key in the EKCert will be used
   * for this check.
   * Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
   *
   * @generated from field: string EKPublicHash = 4;
   */
  EKPublicHash = "";

  /**
   * EKCertificateSerial is the serial number of the EKCert in hexadecimal
   * with colon separated nibbles. This value will not be checked when a TPM
   * does not have an EKCert configured.
   * Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
   *
   * @generated from field: string EKCertificateSerial = 5;
   */
  EKCertificateSerial = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2TPM_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2TPM.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "EKPublicHash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "EKCertificateSerial", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2TPM_Rule {
    return new ProvisionTokenSpecV2TPM_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TPM_Rule {
    return new ProvisionTokenSpecV2TPM_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TPM_Rule {
    return new ProvisionTokenSpecV2TPM_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2TPM_Rule | PlainMessage<ProvisionTokenSpecV2TPM_Rule> | undefined, b: ProvisionTokenSpecV2TPM_Rule | PlainMessage<ProvisionTokenSpecV2TPM_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2TPM_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2Github contains the GitHub-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2GitHub
 */
export class ProvisionTokenSpecV2GitHub extends Message<ProvisionTokenSpecV2GitHub> {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GitHub.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GitHub_Rule[] = [];

  /**
   * EnterpriseServerHost allows joining from runners associated with a
   * GitHub Enterprise Server instance. When unconfigured, tokens will be
   * validated against github.com, but when configured to the host of a GHES
   * instance, then the tokens will be validated against host.
   *
   * This value should be the hostname of the GHES instance, and should not
   * include the scheme or a path. The instance must be accessible over HTTPS
   * at this hostname and the certificate must be trusted by the Auth Server.
   *
   * @generated from field: string EnterpriseServerHost = 2;
   */
  EnterpriseServerHost = "";

  /**
   * EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be
   * included in the expected issuer of the OIDC tokens. This is for
   * compatibility with the `include_enterprise_slug` option in GHE.
   *
   * This field should be set to the slug of your enterprise if this is enabled. If
   * this is not enabled, then this field must be left empty. This field cannot
   * be specified if `enterprise_server_host` is specified.
   *
   * See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise
   * for more information about customized issuer values.
   *
   * @generated from field: string EnterpriseSlug = 3;
   */
  EnterpriseSlug = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GitHub>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GitHub";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2GitHub_Rule, repeated: true },
    { no: 2, name: "EnterpriseServerHost", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "EnterpriseSlug", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GitHub {
    return new ProvisionTokenSpecV2GitHub().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitHub {
    return new ProvisionTokenSpecV2GitHub().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitHub {
    return new ProvisionTokenSpecV2GitHub().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GitHub | PlainMessage<ProvisionTokenSpecV2GitHub> | undefined, b: ProvisionTokenSpecV2GitHub | PlainMessage<ProvisionTokenSpecV2GitHub> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GitHub, a, b);
  }
}

/**
 * Rule includes fields mapped from `lib/githubactions.IDToken`
 * Not all fields should be included, only ones that we expect to be useful
 * when trying to create rules around which workflows should be allowed to
 * authenticate against a cluster.
 *
 * @generated from message types.ProvisionTokenSpecV2GitHub.Rule
 */
export class ProvisionTokenSpecV2GitHub_Rule extends Message<ProvisionTokenSpecV2GitHub_Rule> {
  /**
   * Sub also known as Subject is a string that roughly uniquely identifies
   * the workload. The format of this varies depending on the type of
   * github action run.
   *
   * @generated from field: string Sub = 1;
   */
  Sub = "";

  /**
   * The repository from where the workflow is running.
   * This includes the name of the owner e.g `gravitational/teleport`
   *
   * @generated from field: string Repository = 2;
   */
  Repository = "";

  /**
   * The name of the organization in which the repository is stored.
   *
   * @generated from field: string RepositoryOwner = 3;
   */
  RepositoryOwner = "";

  /**
   * The name of the workflow.
   *
   * @generated from field: string Workflow = 4;
   */
  Workflow = "";

  /**
   * The name of the environment used by the job.
   *
   * @generated from field: string Environment = 5;
   */
  Environment = "";

  /**
   * The personal account that initiated the workflow run.
   *
   * @generated from field: string Actor = 6;
   */
  Actor = "";

  /**
   * The git ref that triggered the workflow run.
   *
   * @generated from field: string Ref = 7;
   */
  Ref = "";

  /**
   * The type of ref, for example: "branch".
   *
   * @generated from field: string RefType = 8;
   */
  RefType = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GitHub_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GitHub.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sub", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Repository", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "RepositoryOwner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Workflow", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Environment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Actor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "RefType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GitHub_Rule {
    return new ProvisionTokenSpecV2GitHub_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitHub_Rule {
    return new ProvisionTokenSpecV2GitHub_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitHub_Rule {
    return new ProvisionTokenSpecV2GitHub_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GitHub_Rule | PlainMessage<ProvisionTokenSpecV2GitHub_Rule> | undefined, b: ProvisionTokenSpecV2GitHub_Rule | PlainMessage<ProvisionTokenSpecV2GitHub_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GitHub_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2GitLab contains the GitLab-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2GitLab
 */
export class ProvisionTokenSpecV2GitLab extends Message<ProvisionTokenSpecV2GitLab> {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GitLab.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GitLab_Rule[] = [];

  /**
   * Domain is the domain of your GitLab instance. This will default to
   * `gitlab.com` - but can be set to the domain of your self-hosted GitLab
   * e.g `gitlab.example.com`.
   *
   * @generated from field: string Domain = 2;
   */
  Domain = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GitLab>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GitLab";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2GitLab_Rule, repeated: true },
    { no: 2, name: "Domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GitLab {
    return new ProvisionTokenSpecV2GitLab().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitLab {
    return new ProvisionTokenSpecV2GitLab().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitLab {
    return new ProvisionTokenSpecV2GitLab().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GitLab | PlainMessage<ProvisionTokenSpecV2GitLab> | undefined, b: ProvisionTokenSpecV2GitLab | PlainMessage<ProvisionTokenSpecV2GitLab> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GitLab, a, b);
  }
}

/**
 * @generated from message types.ProvisionTokenSpecV2GitLab.Rule
 */
export class ProvisionTokenSpecV2GitLab_Rule extends Message<ProvisionTokenSpecV2GitLab_Rule> {
  /**
   * Sub roughly uniquely identifies the workload. Example:
   * `project_path:mygroup/my-project:ref_type:branch:ref:main`
   * project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string Sub = 1;
   */
  Sub = "";

  /**
   * Ref allows access to be limited to jobs triggered by a specific git ref.
   * Ensure this is used in combination with ref_type.
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string Ref = 2;
   */
  Ref = "";

  /**
   * RefType allows access to be limited to jobs triggered by a specific git
   * ref type. Example:
   * `branch` or `tag`
   *
   * @generated from field: string RefType = 3;
   */
  RefType = "";

  /**
   * NamespacePath is used to limit access to jobs in a group or user's
   * projects.
   * Example:
   * `mygroup`
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string NamespacePath = 4;
   */
  NamespacePath = "";

  /**
   * ProjectPath is used to limit access to jobs belonging to an individual
   * project. Example:
   * `mygroup/myproject`
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string ProjectPath = 5;
   */
  ProjectPath = "";

  /**
   * PipelineSource limits access by the job pipeline source type.
   * https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules
   * Example: `web`
   *
   * @generated from field: string PipelineSource = 6;
   */
  PipelineSource = "";

  /**
   * Environment limits access by the environment the job deploys to
   * (if one is associated)
   *
   * @generated from field: string Environment = 7;
   */
  Environment = "";

  /**
   * UserLogin is the username of the user executing the job
   *
   * @generated from field: string UserLogin = 8;
   */
  UserLogin = "";

  /**
   * UserID is the ID of the user executing the job
   *
   * @generated from field: string UserID = 9;
   */
  UserID = "";

  /**
   * UserEmail is the email of the user executing the job
   *
   * @generated from field: string UserEmail = 10;
   */
  UserEmail = "";

  /**
   * RefProtected is true if the Git ref is protected, false otherwise.
   *
   * @generated from field: types.BoolValue RefProtected = 11;
   */
  RefProtected?: BoolValue;

  /**
   * EnvironmentProtected is true if the Git ref is protected, false otherwise.
   *
   * @generated from field: types.BoolValue EnvironmentProtected = 12;
   */
  EnvironmentProtected?: BoolValue;

  /**
   * CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
   *
   * @generated from field: string CIConfigSHA = 13;
   */
  CIConfigSHA = "";

  /**
   * CIConfigRefURI is the ref path to the top-level pipeline definition, for example,
   * gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
   *
   * @generated from field: string CIConfigRefURI = 14;
   */
  CIConfigRefURI = "";

  /**
   * DeploymentTier is the deployment tier of the environment the job specifies
   *
   * @generated from field: string DeploymentTier = 15;
   */
  DeploymentTier = "";

  /**
   * ProjectVisibility is the visibility of the project where the pipeline is running.
   * Can be internal, private, or public.
   *
   * @generated from field: string ProjectVisibility = 16;
   */
  ProjectVisibility = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GitLab_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GitLab.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sub", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Ref", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "RefType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "NamespacePath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ProjectPath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "PipelineSource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Environment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "UserLogin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "UserID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "UserEmail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "RefProtected", kind: "message", T: BoolValue },
    { no: 12, name: "EnvironmentProtected", kind: "message", T: BoolValue },
    { no: 13, name: "CIConfigSHA", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "CIConfigRefURI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "DeploymentTier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "ProjectVisibility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GitLab_Rule {
    return new ProvisionTokenSpecV2GitLab_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitLab_Rule {
    return new ProvisionTokenSpecV2GitLab_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GitLab_Rule {
    return new ProvisionTokenSpecV2GitLab_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GitLab_Rule | PlainMessage<ProvisionTokenSpecV2GitLab_Rule> | undefined, b: ProvisionTokenSpecV2GitLab_Rule | PlainMessage<ProvisionTokenSpecV2GitLab_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GitLab_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2CircleCI contains the CircleCI-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2CircleCI
 */
export class ProvisionTokenSpecV2CircleCI extends Message<ProvisionTokenSpecV2CircleCI> {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2CircleCI.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2CircleCI_Rule[] = [];

  /**
   * @generated from field: string OrganizationID = 2;
   */
  OrganizationID = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2CircleCI>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2CircleCI";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2CircleCI_Rule, repeated: true },
    { no: 2, name: "OrganizationID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2CircleCI {
    return new ProvisionTokenSpecV2CircleCI().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2CircleCI {
    return new ProvisionTokenSpecV2CircleCI().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2CircleCI {
    return new ProvisionTokenSpecV2CircleCI().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2CircleCI | PlainMessage<ProvisionTokenSpecV2CircleCI> | undefined, b: ProvisionTokenSpecV2CircleCI | PlainMessage<ProvisionTokenSpecV2CircleCI> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2CircleCI, a, b);
  }
}

/**
 * @generated from message types.ProvisionTokenSpecV2CircleCI.Rule
 */
export class ProvisionTokenSpecV2CircleCI_Rule extends Message<ProvisionTokenSpecV2CircleCI_Rule> {
  /**
   * @generated from field: string ProjectID = 1;
   */
  ProjectID = "";

  /**
   * @generated from field: string ContextID = 2;
   */
  ContextID = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2CircleCI_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2CircleCI.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ProjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ContextID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2CircleCI_Rule {
    return new ProvisionTokenSpecV2CircleCI_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2CircleCI_Rule {
    return new ProvisionTokenSpecV2CircleCI_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2CircleCI_Rule {
    return new ProvisionTokenSpecV2CircleCI_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2CircleCI_Rule | PlainMessage<ProvisionTokenSpecV2CircleCI_Rule> | undefined, b: ProvisionTokenSpecV2CircleCI_Rule | PlainMessage<ProvisionTokenSpecV2CircleCI_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2CircleCI_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2Spacelift contains the Spacelift-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2Spacelift
 */
export class ProvisionTokenSpecV2Spacelift extends Message<ProvisionTokenSpecV2Spacelift> {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Spacelift.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Spacelift_Rule[] = [];

  /**
   * Hostname is the hostname of the Spacelift tenant that tokens
   * will originate from. E.g `example.app.spacelift.io`
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Spacelift>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Spacelift";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2Spacelift_Rule, repeated: true },
    { no: 2, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Spacelift {
    return new ProvisionTokenSpecV2Spacelift().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Spacelift {
    return new ProvisionTokenSpecV2Spacelift().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Spacelift {
    return new ProvisionTokenSpecV2Spacelift().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Spacelift | PlainMessage<ProvisionTokenSpecV2Spacelift> | undefined, b: ProvisionTokenSpecV2Spacelift | PlainMessage<ProvisionTokenSpecV2Spacelift> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Spacelift, a, b);
  }
}

/**
 * @generated from message types.ProvisionTokenSpecV2Spacelift.Rule
 */
export class ProvisionTokenSpecV2Spacelift_Rule extends Message<ProvisionTokenSpecV2Spacelift_Rule> {
  /**
   * SpaceID is the ID of the space in which the run that owns the token was
   * executed.
   *
   * @generated from field: string SpaceID = 1;
   */
  SpaceID = "";

  /**
   * CallerID is the ID of the caller, ie. the stack or module that generated
   * the run.
   *
   * @generated from field: string CallerID = 2;
   */
  CallerID = "";

  /**
   * CallerType is the type of the caller, ie. the entity that owns the run -
   * either `stack` or `module`.
   *
   * @generated from field: string CallerType = 3;
   */
  CallerType = "";

  /**
   * Scope is the scope of the token - either `read` or `write`.
   * See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
   *
   * @generated from field: string Scope = 4;
   */
  Scope = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Spacelift_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Spacelift.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SpaceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "CallerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "CallerType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Spacelift_Rule {
    return new ProvisionTokenSpecV2Spacelift_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Spacelift_Rule {
    return new ProvisionTokenSpecV2Spacelift_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Spacelift_Rule {
    return new ProvisionTokenSpecV2Spacelift_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Spacelift_Rule | PlainMessage<ProvisionTokenSpecV2Spacelift_Rule> | undefined, b: ProvisionTokenSpecV2Spacelift_Rule | PlainMessage<ProvisionTokenSpecV2Spacelift_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Spacelift_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2Kubernetes contains the Kubernetes-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2Kubernetes
 */
export class ProvisionTokenSpecV2Kubernetes extends Message<ProvisionTokenSpecV2Kubernetes> {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Kubernetes.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Kubernetes_Rule[] = [];

  /**
   * Type controls which behavior should be used for validating the Kubernetes
   * Service Account token. Support values:
   * - `in_cluster`
   * - `static_jwks`
   * If unset, this defaults to `in_cluster`.
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * StaticJWKS is the configuration specific to the `static_jwks` type.
   *
   * @generated from field: types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig StaticJWKS = 3;
   */
  StaticJWKS?: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig;

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Kubernetes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Kubernetes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2Kubernetes_Rule, repeated: true },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "StaticJWKS", kind: "message", T: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Kubernetes {
    return new ProvisionTokenSpecV2Kubernetes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes {
    return new ProvisionTokenSpecV2Kubernetes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes {
    return new ProvisionTokenSpecV2Kubernetes().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Kubernetes | PlainMessage<ProvisionTokenSpecV2Kubernetes> | undefined, b: ProvisionTokenSpecV2Kubernetes | PlainMessage<ProvisionTokenSpecV2Kubernetes> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Kubernetes, a, b);
  }
}

/**
 * @generated from message types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig
 */
export class ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig extends Message<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig> {
  /**
   * JWKS should be the JSON Web Key Set formatted public keys of that the
   * Kubernetes Cluster uses to sign service account tokens.
   * This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
   *
   * @generated from field: string JWKS = 1;
   */
  JWKS = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "JWKS", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
    return new ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
    return new ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig {
    return new ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig | PlainMessage<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig> | undefined, b: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig | PlainMessage<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig, a, b);
  }
}

/**
 * Rule is a set of properties the Kubernetes-issued token might have to be
 * allowed to use this ProvisionToken
 *
 * @generated from message types.ProvisionTokenSpecV2Kubernetes.Rule
 */
export class ProvisionTokenSpecV2Kubernetes_Rule extends Message<ProvisionTokenSpecV2Kubernetes_Rule> {
  /**
   * ServiceAccount is the namespaced name of the Kubernetes service account.
   * Its format is "namespace:service-account".
   *
   * @generated from field: string ServiceAccount = 1;
   */
  ServiceAccount = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Kubernetes_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Kubernetes.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Kubernetes_Rule {
    return new ProvisionTokenSpecV2Kubernetes_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes_Rule {
    return new ProvisionTokenSpecV2Kubernetes_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Kubernetes_Rule {
    return new ProvisionTokenSpecV2Kubernetes_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Kubernetes_Rule | PlainMessage<ProvisionTokenSpecV2Kubernetes_Rule> | undefined, b: ProvisionTokenSpecV2Kubernetes_Rule | PlainMessage<ProvisionTokenSpecV2Kubernetes_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Kubernetes_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2Azure contains the Azure-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2Azure
 */
export class ProvisionTokenSpecV2Azure extends Message<ProvisionTokenSpecV2Azure> {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Azure.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Azure_Rule[] = [];

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Azure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Azure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2Azure_Rule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Azure {
    return new ProvisionTokenSpecV2Azure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Azure {
    return new ProvisionTokenSpecV2Azure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Azure {
    return new ProvisionTokenSpecV2Azure().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Azure | PlainMessage<ProvisionTokenSpecV2Azure> | undefined, b: ProvisionTokenSpecV2Azure | PlainMessage<ProvisionTokenSpecV2Azure> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Azure, a, b);
  }
}

/**
 * Rule is a set of properties the Azure-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2Azure.Rule
 */
export class ProvisionTokenSpecV2Azure_Rule extends Message<ProvisionTokenSpecV2Azure_Rule> {
  /**
   * Subscription is the Azure subscription.
   *
   * @generated from field: string Subscription = 1;
   */
  Subscription = "";

  /**
   * ResourceGroups is a list of Azure resource groups the node is allowed
   * to join from.
   *
   * @generated from field: repeated string ResourceGroups = 2;
   */
  ResourceGroups: string[] = [];

  constructor(data?: PartialMessage<ProvisionTokenSpecV2Azure_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2Azure.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ResourceGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2Azure_Rule {
    return new ProvisionTokenSpecV2Azure_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Azure_Rule {
    return new ProvisionTokenSpecV2Azure_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2Azure_Rule {
    return new ProvisionTokenSpecV2Azure_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2Azure_Rule | PlainMessage<ProvisionTokenSpecV2Azure_Rule> | undefined, b: ProvisionTokenSpecV2Azure_Rule | PlainMessage<ProvisionTokenSpecV2Azure_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2Azure_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2GCP contains the GCP-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2GCP
 */
export class ProvisionTokenSpecV2GCP extends Message<ProvisionTokenSpecV2GCP> {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GCP.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GCP_Rule[] = [];

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GCP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GCP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2GCP_Rule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GCP {
    return new ProvisionTokenSpecV2GCP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GCP {
    return new ProvisionTokenSpecV2GCP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GCP {
    return new ProvisionTokenSpecV2GCP().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GCP | PlainMessage<ProvisionTokenSpecV2GCP> | undefined, b: ProvisionTokenSpecV2GCP | PlainMessage<ProvisionTokenSpecV2GCP> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GCP, a, b);
  }
}

/**
 * Rule is a set of properties the GCP-ussued token might have to be allowed
 * to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2GCP.Rule
 */
export class ProvisionTokenSpecV2GCP_Rule extends Message<ProvisionTokenSpecV2GCP_Rule> {
  /**
   * ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
   *
   * @generated from field: repeated string ProjectIDs = 1;
   */
  ProjectIDs: string[] = [];

  /**
   * Locations is a list of regions (e.g. "us-west1") and/or zones (e.g.
   * "us-west1-b").
   *
   * @generated from field: repeated string Locations = 2;
   */
  Locations: string[] = [];

  /**
   * ServiceAccounts is a list of service account emails (e.g.
   * `<project-number>-compute@developer.gserviceaccount.com`).
   *
   * @generated from field: repeated string ServiceAccounts = 3;
   */
  ServiceAccounts: string[] = [];

  constructor(data?: PartialMessage<ProvisionTokenSpecV2GCP_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2GCP.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ProjectIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ServiceAccounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2GCP_Rule {
    return new ProvisionTokenSpecV2GCP_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GCP_Rule {
    return new ProvisionTokenSpecV2GCP_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2GCP_Rule {
    return new ProvisionTokenSpecV2GCP_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2GCP_Rule | PlainMessage<ProvisionTokenSpecV2GCP_Rule> | undefined, b: ProvisionTokenSpecV2GCP_Rule | PlainMessage<ProvisionTokenSpecV2GCP_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2GCP_Rule, a, b);
  }
}

/**
 * ProvisionTokenSpecV2Terraform contains Terraform-specific parts of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2TerraformCloud
 */
export class ProvisionTokenSpecV2TerraformCloud extends Message<ProvisionTokenSpecV2TerraformCloud> {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2TerraformCloud.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2TerraformCloud_Rule[] = [];

  /**
   * Audience is the JWT audience as configured in the
   * TFC_WORKLOAD_IDENTITY_AUDIENCE(_$TAG) variable in Terraform Cloud. If
   * unset, defaults to the Teleport cluster name.
   * For example, if `TFC_WORKLOAD_IDENTITY_AUDIENCE_TELEPORT=foo` is set in
   * Terraform Cloud, this value should be `foo`. If the variable is set to
   * match the cluster name, it does not need to be set here.
   *
   * @generated from field: string Audience = 2;
   */
  Audience = "";

  /**
   * Hostname is the hostname of the Terraform Enterprise instance expected to
   * issue JWTs allowed by this token. This may be unset for regular Terraform
   * Cloud use, in which case it will be assumed to be `app.terraform.io`.
   * Otherwise, it must both match the `iss` (issuer) field included in JWTs,
   * and provide standard JWKS endpoints.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2TerraformCloud>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2TerraformCloud";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: ProvisionTokenSpecV2TerraformCloud_Rule, repeated: true },
    { no: 2, name: "Audience", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2TerraformCloud {
    return new ProvisionTokenSpecV2TerraformCloud().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TerraformCloud {
    return new ProvisionTokenSpecV2TerraformCloud().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TerraformCloud {
    return new ProvisionTokenSpecV2TerraformCloud().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2TerraformCloud | PlainMessage<ProvisionTokenSpecV2TerraformCloud> | undefined, b: ProvisionTokenSpecV2TerraformCloud | PlainMessage<ProvisionTokenSpecV2TerraformCloud> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2TerraformCloud, a, b);
  }
}

/**
 * Rule is a set of properties the Terraform-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2TerraformCloud.Rule
 */
export class ProvisionTokenSpecV2TerraformCloud_Rule extends Message<ProvisionTokenSpecV2TerraformCloud_Rule> {
  /**
   * OrganizationID is the ID of the HCP Terraform organization. At least
   * one organization value is required, either ID or name.
   *
   * @generated from field: string OrganizationID = 1;
   */
  OrganizationID = "";

  /**
   * OrganizationName is the human-readable name of the HCP Terraform
   * organization. At least one organization value is required, either ID or
   * name.
   *
   * @generated from field: string OrganizationName = 2;
   */
  OrganizationName = "";

  /**
   * ProjectID is the ID of the HCP Terraform project. At least one project or
   * workspace value is required, either ID or name.
   *
   * @generated from field: string ProjectID = 3;
   */
  ProjectID = "";

  /**
   * ProjectName is the human-readable name for the HCP Terraform project. At
   * least one project or workspace value is required, either ID or name.
   *
   * @generated from field: string ProjectName = 4;
   */
  ProjectName = "";

  /**
   * WorkspaceID is the ID of the HCP Terraform workspace. At least one
   * project or workspace value is required, either ID or name.
   *
   * @generated from field: string WorkspaceID = 5;
   */
  WorkspaceID = "";

  /**
   * WorkspaceName is the human-readable name of the HCP Terraform workspace.
   * At least one project or workspace value is required, either ID or name.
   *
   * @generated from field: string WorkspaceName = 6;
   */
  WorkspaceName = "";

  /**
   * RunPhase is the phase of the run the token was issued for, e.g. `plan` or
   * `apply`
   *
   * @generated from field: string RunPhase = 7;
   */
  RunPhase = "";

  constructor(data?: PartialMessage<ProvisionTokenSpecV2TerraformCloud_Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProvisionTokenSpecV2TerraformCloud.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "OrganizationID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "OrganizationName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ProjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ProjectName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "WorkspaceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "WorkspaceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "RunPhase", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvisionTokenSpecV2TerraformCloud_Rule {
    return new ProvisionTokenSpecV2TerraformCloud_Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TerraformCloud_Rule {
    return new ProvisionTokenSpecV2TerraformCloud_Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvisionTokenSpecV2TerraformCloud_Rule {
    return new ProvisionTokenSpecV2TerraformCloud_Rule().fromJsonString(jsonString, options);
  }

  static equals(a: ProvisionTokenSpecV2TerraformCloud_Rule | PlainMessage<ProvisionTokenSpecV2TerraformCloud_Rule> | undefined, b: ProvisionTokenSpecV2TerraformCloud_Rule | PlainMessage<ProvisionTokenSpecV2TerraformCloud_Rule> | undefined): boolean {
    return proto3.util.equals(ProvisionTokenSpecV2TerraformCloud_Rule, a, b);
  }
}

/**
 * StaticTokensV2 implements the StaticTokens interface.
 *
 * @generated from message types.StaticTokensV2
 */
export class StaticTokensV2 extends Message<StaticTokensV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a provisioning token V2 spec
   *
   * @generated from field: types.StaticTokensSpecV2 Spec = 5;
   */
  Spec?: StaticTokensSpecV2;

  constructor(data?: PartialMessage<StaticTokensV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.StaticTokensV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: StaticTokensSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StaticTokensV2 {
    return new StaticTokensV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StaticTokensV2 {
    return new StaticTokensV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StaticTokensV2 {
    return new StaticTokensV2().fromJsonString(jsonString, options);
  }

  static equals(a: StaticTokensV2 | PlainMessage<StaticTokensV2> | undefined, b: StaticTokensV2 | PlainMessage<StaticTokensV2> | undefined): boolean {
    return proto3.util.equals(StaticTokensV2, a, b);
  }
}

/**
 * StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
 *
 * @generated from message types.StaticTokensSpecV2
 */
export class StaticTokensSpecV2 extends Message<StaticTokensSpecV2> {
  /**
   * StaticTokens is a list of tokens that can be used to add nodes to the
   * cluster.
   *
   * @generated from field: repeated types.ProvisionTokenV1 StaticTokens = 1;
   */
  StaticTokens: ProvisionTokenV1[] = [];

  constructor(data?: PartialMessage<StaticTokensSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.StaticTokensSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "StaticTokens", kind: "message", T: ProvisionTokenV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StaticTokensSpecV2 {
    return new StaticTokensSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StaticTokensSpecV2 {
    return new StaticTokensSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StaticTokensSpecV2 {
    return new StaticTokensSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: StaticTokensSpecV2 | PlainMessage<StaticTokensSpecV2> | undefined, b: StaticTokensSpecV2 | PlainMessage<StaticTokensSpecV2> | undefined): boolean {
    return proto3.util.equals(StaticTokensSpecV2, a, b);
  }
}

/**
 * ClusterNameV2 implements the ClusterName interface.
 *
 * @generated from message types.ClusterNameV2
 */
export class ClusterNameV2 extends Message<ClusterNameV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a cluster name V2 spec
   *
   * @generated from field: types.ClusterNameSpecV2 Spec = 5;
   */
  Spec?: ClusterNameSpecV2;

  constructor(data?: PartialMessage<ClusterNameV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterNameV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ClusterNameSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterNameV2 {
    return new ClusterNameV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterNameV2 {
    return new ClusterNameV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterNameV2 {
    return new ClusterNameV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterNameV2 | PlainMessage<ClusterNameV2> | undefined, b: ClusterNameV2 | PlainMessage<ClusterNameV2> | undefined): boolean {
    return proto3.util.equals(ClusterNameV2, a, b);
  }
}

/**
 * ClusterNameSpecV2 is the actual data we care about for ClusterName.
 *
 * @generated from message types.ClusterNameSpecV2
 */
export class ClusterNameSpecV2 extends Message<ClusterNameSpecV2> {
  /**
   * ClusterName is the name of the cluster. Changing this value once the
   * cluster is setup can and will cause catastrophic problems.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * ClusterID is the unique cluster ID that is set once during the first
   * auth server startup.
   *
   * @generated from field: string ClusterID = 2;
   */
  ClusterID = "";

  constructor(data?: PartialMessage<ClusterNameSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterNameSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClusterID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterNameSpecV2 {
    return new ClusterNameSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterNameSpecV2 {
    return new ClusterNameSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterNameSpecV2 {
    return new ClusterNameSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterNameSpecV2 | PlainMessage<ClusterNameSpecV2> | undefined, b: ClusterNameSpecV2 | PlainMessage<ClusterNameSpecV2> | undefined): boolean {
    return proto3.util.equals(ClusterNameSpecV2, a, b);
  }
}

/**
 * ClusterAuditConfigV2 represents audit log settings in the cluster.
 *
 * @generated from message types.ClusterAuditConfigV2
 */
export class ClusterAuditConfigV2 extends Message<ClusterAuditConfigV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is a resource version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a ClusterAuditConfig specification
   *
   * @generated from field: types.ClusterAuditConfigSpecV2 Spec = 5;
   */
  Spec?: ClusterAuditConfigSpecV2;

  constructor(data?: PartialMessage<ClusterAuditConfigV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterAuditConfigV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ClusterAuditConfigSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterAuditConfigV2 {
    return new ClusterAuditConfigV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterAuditConfigV2 {
    return new ClusterAuditConfigV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterAuditConfigV2 {
    return new ClusterAuditConfigV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterAuditConfigV2 | PlainMessage<ClusterAuditConfigV2> | undefined, b: ClusterAuditConfigV2 | PlainMessage<ClusterAuditConfigV2> | undefined): boolean {
    return proto3.util.equals(ClusterAuditConfigV2, a, b);
  }
}

/**
 * ClusterAuditConfigSpecV2 is the actual data we care about
 * for ClusterAuditConfig.
 *
 * @generated from message types.ClusterAuditConfigSpecV2
 */
export class ClusterAuditConfigSpecV2 extends Message<ClusterAuditConfigSpecV2> {
  /**
   * Type is audit backend type
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * Region is a region setting for audit sessions used by cloud providers
   *
   * @generated from field: string Region = 2;
   */
  Region = "";

  /**
   * AuditSessionsURI is a parameter where to upload sessions
   *
   * @generated from field: string AuditSessionsURI = 3;
   */
  AuditSessionsURI = "";

  /**
   * AuditEventsURI is a parameter with all supported outputs
   * for audit events
   *
   * @generated from field: wrappers.StringValues AuditEventsURI = 4;
   */
  AuditEventsURI?: StringValues;

  /**
   * EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
   *
   * @generated from field: bool EnableContinuousBackups = 6;
   */
  EnableContinuousBackups = false;

  /**
   * EnableAutoScaling is used to enable (or disable) auto scaling policy.
   *
   * @generated from field: bool EnableAutoScaling = 7;
   */
  EnableAutoScaling = false;

  /**
   * ReadMaxCapacity is the maximum provisioned read capacity.
   *
   * @generated from field: int64 ReadMaxCapacity = 8;
   */
  ReadMaxCapacity = protoInt64.zero;

  /**
   * ReadMinCapacity is the minimum provisioned read capacity.
   *
   * @generated from field: int64 ReadMinCapacity = 9;
   */
  ReadMinCapacity = protoInt64.zero;

  /**
   * ReadTargetValue is the ratio of consumed read to provisioned capacity.
   *
   * @generated from field: double ReadTargetValue = 10;
   */
  ReadTargetValue = 0;

  /**
   * WriteMaxCapacity is the maximum provisioned write capacity.
   *
   * @generated from field: int64 WriteMaxCapacity = 11;
   */
  WriteMaxCapacity = protoInt64.zero;

  /**
   * WriteMinCapacity is the minimum provisioned write capacity.
   *
   * @generated from field: int64 WriteMinCapacity = 12;
   */
  WriteMinCapacity = protoInt64.zero;

  /**
   * WriteTargetValue is the ratio of consumed write to provisioned capacity.
   *
   * @generated from field: double WriteTargetValue = 13;
   */
  WriteTargetValue = 0;

  /**
   * RetentionPeriod is the retention period for audit events.
   *
   * @generated from field: int64 RetentionPeriod = 14;
   */
  RetentionPeriod = protoInt64.zero;

  /**
   * UseFIPSEndpoint configures AWS endpoints to use FIPS.
   *
   * @generated from field: types.ClusterAuditConfigSpecV2.FIPSEndpointState UseFIPSEndpoint = 15;
   */
  UseFIPSEndpoint = ClusterAuditConfigSpecV2_FIPSEndpointState.FIPS_UNSET;

  constructor(data?: PartialMessage<ClusterAuditConfigSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterAuditConfigSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "AuditSessionsURI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AuditEventsURI", kind: "message", T: StringValues },
    { no: 6, name: "EnableContinuousBackups", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "EnableAutoScaling", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "ReadMaxCapacity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "ReadMinCapacity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "ReadTargetValue", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 11, name: "WriteMaxCapacity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "WriteMinCapacity", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 13, name: "WriteTargetValue", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 14, name: "RetentionPeriod", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "UseFIPSEndpoint", kind: "enum", T: proto3.getEnumType(ClusterAuditConfigSpecV2_FIPSEndpointState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterAuditConfigSpecV2 {
    return new ClusterAuditConfigSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterAuditConfigSpecV2 {
    return new ClusterAuditConfigSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterAuditConfigSpecV2 {
    return new ClusterAuditConfigSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterAuditConfigSpecV2 | PlainMessage<ClusterAuditConfigSpecV2> | undefined, b: ClusterAuditConfigSpecV2 | PlainMessage<ClusterAuditConfigSpecV2> | undefined): boolean {
    return proto3.util.equals(ClusterAuditConfigSpecV2, a, b);
  }
}

/**
 * FIPSEndpointState represents an AWS FIPS endpoint state.
 *
 * @generated from enum types.ClusterAuditConfigSpecV2.FIPSEndpointState
 */
export enum ClusterAuditConfigSpecV2_FIPSEndpointState {
  /**
   * FIPS_UNSET allows setting FIPS state for AWS S3/Dynamo using configuration files or
   * environment variables
   *
   * @generated from enum value: FIPS_UNSET = 0;
   */
  FIPS_UNSET = 0,

  /**
   * FIPS_ENABLED explicitly enables FIPS support for AWS S3/Dynamo
   *
   * @generated from enum value: FIPS_ENABLED = 1;
   */
  FIPS_ENABLED = 1,

  /**
   * FIPS_DISABLED explicitly disables FIPS support for AWS S3/Dynamo
   *
   * @generated from enum value: FIPS_DISABLED = 2;
   */
  FIPS_DISABLED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ClusterAuditConfigSpecV2_FIPSEndpointState)
proto3.util.setEnumType(ClusterAuditConfigSpecV2_FIPSEndpointState, "types.ClusterAuditConfigSpecV2.FIPSEndpointState", [
  { no: 0, name: "FIPS_UNSET" },
  { no: 1, name: "FIPS_ENABLED" },
  { no: 2, name: "FIPS_DISABLED" },
]);

/**
 * ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
 *
 * @generated from message types.ClusterNetworkingConfigV2
 */
export class ClusterNetworkingConfigV2 extends Message<ClusterNetworkingConfigV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a ClusterNetworkingConfig specification
   *
   * @generated from field: types.ClusterNetworkingConfigSpecV2 Spec = 5;
   */
  Spec?: ClusterNetworkingConfigSpecV2;

  constructor(data?: PartialMessage<ClusterNetworkingConfigV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterNetworkingConfigV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ClusterNetworkingConfigSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterNetworkingConfigV2 {
    return new ClusterNetworkingConfigV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigV2 {
    return new ClusterNetworkingConfigV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigV2 {
    return new ClusterNetworkingConfigV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterNetworkingConfigV2 | PlainMessage<ClusterNetworkingConfigV2> | undefined, b: ClusterNetworkingConfigV2 | PlainMessage<ClusterNetworkingConfigV2> | undefined): boolean {
    return proto3.util.equals(ClusterNetworkingConfigV2, a, b);
  }
}

/**
 * ClusterNetworkingConfigSpecV2 is the actual data we care about
 * for ClusterNetworkingConfig.
 *
 * @generated from message types.ClusterNetworkingConfigSpecV2
 */
export class ClusterNetworkingConfigSpecV2 extends Message<ClusterNetworkingConfigSpecV2> {
  /**
   * ClientIdleTimeout sets global cluster default setting for client idle
   * timeouts.
   *
   * @generated from field: int64 ClientIdleTimeout = 1;
   */
  ClientIdleTimeout = protoInt64.zero;

  /**
   * KeepAliveInterval is the interval at which the server sends keep-alive messages
   * to the client.
   *
   * @generated from field: int64 KeepAliveInterval = 2;
   */
  KeepAliveInterval = protoInt64.zero;

  /**
   * KeepAliveCountMax is the number of keep-alive messages that can be
   * missed before the server disconnects the connection to the client.
   *
   * @generated from field: int64 KeepAliveCountMax = 3;
   */
  KeepAliveCountMax = protoInt64.zero;

  /**
   * SessionControlTimeout is the session control lease expiry and defines
   * the upper limit of how long a node may be out of contact with the auth
   * server before it begins terminating controlled sessions.
   *
   * @generated from field: int64 SessionControlTimeout = 4;
   */
  SessionControlTimeout = protoInt64.zero;

  /**
   * ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
   *
   * @generated from field: string ClientIdleTimeoutMessage = 5;
   */
  ClientIdleTimeoutMessage = "";

  /**
   * WebIdleTimeout sets global cluster default setting for the web UI idle
   * timeouts.
   *
   * @generated from field: int64 WebIdleTimeout = 6;
   */
  WebIdleTimeout = protoInt64.zero;

  /**
   * ProxyListenerMode is proxy listener mode used by Teleport Proxies.
   * 0 is "separate"; 1 is "multiplex".
   *
   * @generated from field: types.ProxyListenerMode ProxyListenerMode = 7;
   */
  ProxyListenerMode = ProxyListenerMode.Separate;

  /**
   * RoutingStrategy determines the strategy used to route to nodes.
   * 0 is "unambiguous_match"; 1 is "most_recent".
   *
   * @generated from field: types.RoutingStrategy RoutingStrategy = 8;
   */
  RoutingStrategy = RoutingStrategy.UNAMBIGUOUS_MATCH;

  /**
   * TunnelStrategyV1 determines the tunnel strategy used in the cluster.
   *
   * @generated from field: types.TunnelStrategyV1 TunnelStrategy = 9;
   */
  TunnelStrategy?: TunnelStrategyV1;

  /**
   * ProxyPingInterval defines in which interval the TLS routing ping message
   * should be sent. This is applicable only when using ping-wrapped
   * connections, regular TLS routing connections are not affected.
   *
   * @generated from field: int64 ProxyPingInterval = 10;
   */
  ProxyPingInterval = protoInt64.zero;

  /**
   * AssistCommandExecutionWorkers determines the number of workers that will
   * execute arbitrary Assist commands on servers in parallel
   *
   * @generated from field: int32 AssistCommandExecutionWorkers = 11;
   */
  AssistCommandExecutionWorkers = 0;

  /**
   * CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
   *
   * @generated from field: bool CaseInsensitiveRouting = 12;
   */
  CaseInsensitiveRouting = false;

  /**
   * SSHDialTimeout is a custom dial timeout used when establishing
   * SSH connections. If not set, the default timeout of 30s will be used.
   *
   * @generated from field: int64 SSHDialTimeout = 13;
   */
  SSHDialTimeout = protoInt64.zero;

  constructor(data?: PartialMessage<ClusterNetworkingConfigSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterNetworkingConfigSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClientIdleTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "KeepAliveInterval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "KeepAliveCountMax", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "SessionControlTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "ClientIdleTimeoutMessage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "WebIdleTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "ProxyListenerMode", kind: "enum", T: proto3.getEnumType(ProxyListenerMode) },
    { no: 8, name: "RoutingStrategy", kind: "enum", T: proto3.getEnumType(RoutingStrategy) },
    { no: 9, name: "TunnelStrategy", kind: "message", T: TunnelStrategyV1 },
    { no: 10, name: "ProxyPingInterval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "AssistCommandExecutionWorkers", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 12, name: "CaseInsensitiveRouting", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "SSHDialTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterNetworkingConfigSpecV2 {
    return new ClusterNetworkingConfigSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigSpecV2 {
    return new ClusterNetworkingConfigSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterNetworkingConfigSpecV2 {
    return new ClusterNetworkingConfigSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterNetworkingConfigSpecV2 | PlainMessage<ClusterNetworkingConfigSpecV2> | undefined, b: ClusterNetworkingConfigSpecV2 | PlainMessage<ClusterNetworkingConfigSpecV2> | undefined): boolean {
    return proto3.util.equals(ClusterNetworkingConfigSpecV2, a, b);
  }
}

/**
 * TunnelStrategyV1 defines possible tunnel strategy types.
 *
 * @generated from message types.TunnelStrategyV1
 */
export class TunnelStrategyV1 extends Message<TunnelStrategyV1> {
  /**
   * @generated from oneof types.TunnelStrategyV1.Strategy
   */
  Strategy: {
    /**
     * @generated from field: types.AgentMeshTunnelStrategy AgentMesh = 1;
     */
    value: AgentMeshTunnelStrategy;
    case: "AgentMesh";
  } | {
    /**
     * @generated from field: types.ProxyPeeringTunnelStrategy ProxyPeering = 2;
     */
    value: ProxyPeeringTunnelStrategy;
    case: "ProxyPeering";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TunnelStrategyV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TunnelStrategyV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AgentMesh", kind: "message", T: AgentMeshTunnelStrategy, oneof: "Strategy" },
    { no: 2, name: "ProxyPeering", kind: "message", T: ProxyPeeringTunnelStrategy, oneof: "Strategy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TunnelStrategyV1 {
    return new TunnelStrategyV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TunnelStrategyV1 {
    return new TunnelStrategyV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TunnelStrategyV1 {
    return new TunnelStrategyV1().fromJsonString(jsonString, options);
  }

  static equals(a: TunnelStrategyV1 | PlainMessage<TunnelStrategyV1> | undefined, b: TunnelStrategyV1 | PlainMessage<TunnelStrategyV1> | undefined): boolean {
    return proto3.util.equals(TunnelStrategyV1, a, b);
  }
}

/**
 * AgentMeshTunnelStrategy requires reverse tunnels to dial every proxy.
 *
 * @generated from message types.AgentMeshTunnelStrategy
 */
export class AgentMeshTunnelStrategy extends Message<AgentMeshTunnelStrategy> {
  constructor(data?: PartialMessage<AgentMeshTunnelStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AgentMeshTunnelStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentMeshTunnelStrategy {
    return new AgentMeshTunnelStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentMeshTunnelStrategy {
    return new AgentMeshTunnelStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentMeshTunnelStrategy {
    return new AgentMeshTunnelStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: AgentMeshTunnelStrategy | PlainMessage<AgentMeshTunnelStrategy> | undefined, b: AgentMeshTunnelStrategy | PlainMessage<AgentMeshTunnelStrategy> | undefined): boolean {
    return proto3.util.equals(AgentMeshTunnelStrategy, a, b);
  }
}

/**
 * ProxyPeeringTunnelStrategy requires reverse tunnels to dial a fixed number of proxies.
 *
 * @generated from message types.ProxyPeeringTunnelStrategy
 */
export class ProxyPeeringTunnelStrategy extends Message<ProxyPeeringTunnelStrategy> {
  /**
   * @generated from field: int64 AgentConnectionCount = 1;
   */
  AgentConnectionCount = protoInt64.zero;

  constructor(data?: PartialMessage<ProxyPeeringTunnelStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ProxyPeeringTunnelStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AgentConnectionCount", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProxyPeeringTunnelStrategy {
    return new ProxyPeeringTunnelStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProxyPeeringTunnelStrategy {
    return new ProxyPeeringTunnelStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProxyPeeringTunnelStrategy {
    return new ProxyPeeringTunnelStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: ProxyPeeringTunnelStrategy | PlainMessage<ProxyPeeringTunnelStrategy> | undefined, b: ProxyPeeringTunnelStrategy | PlainMessage<ProxyPeeringTunnelStrategy> | undefined): boolean {
    return proto3.util.equals(ProxyPeeringTunnelStrategy, a, b);
  }
}

/**
 * SessionRecordingConfigV2 contains session recording configuration.
 *
 * @generated from message types.SessionRecordingConfigV2
 */
export class SessionRecordingConfigV2 extends Message<SessionRecordingConfigV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a SessionRecordingConfig specification
   *
   * @generated from field: types.SessionRecordingConfigSpecV2 Spec = 5;
   */
  Spec?: SessionRecordingConfigSpecV2;

  constructor(data?: PartialMessage<SessionRecordingConfigV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionRecordingConfigV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: SessionRecordingConfigSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionRecordingConfigV2 {
    return new SessionRecordingConfigV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionRecordingConfigV2 {
    return new SessionRecordingConfigV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionRecordingConfigV2 {
    return new SessionRecordingConfigV2().fromJsonString(jsonString, options);
  }

  static equals(a: SessionRecordingConfigV2 | PlainMessage<SessionRecordingConfigV2> | undefined, b: SessionRecordingConfigV2 | PlainMessage<SessionRecordingConfigV2> | undefined): boolean {
    return proto3.util.equals(SessionRecordingConfigV2, a, b);
  }
}

/**
 * SessionRecordingConfigSpecV2 is the actual data we care about
 * for SessionRecordingConfig.
 *
 * @generated from message types.SessionRecordingConfigSpecV2
 */
export class SessionRecordingConfigSpecV2 extends Message<SessionRecordingConfigSpecV2> {
  /**
   * Mode controls where (or if) the session is recorded.
   *
   * @generated from field: string Mode = 1;
   */
  Mode = "";

  /**
   * ProxyChecksHostKeys is used to control if the proxy will check host keys
   * when in recording mode.
   *
   * @generated from field: types.BoolValue ProxyChecksHostKeys = 2;
   */
  ProxyChecksHostKeys?: BoolValue;

  constructor(data?: PartialMessage<SessionRecordingConfigSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionRecordingConfigSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ProxyChecksHostKeys", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionRecordingConfigSpecV2 {
    return new SessionRecordingConfigSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionRecordingConfigSpecV2 {
    return new SessionRecordingConfigSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionRecordingConfigSpecV2 {
    return new SessionRecordingConfigSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: SessionRecordingConfigSpecV2 | PlainMessage<SessionRecordingConfigSpecV2> | undefined, b: SessionRecordingConfigSpecV2 | PlainMessage<SessionRecordingConfigSpecV2> | undefined): boolean {
    return proto3.util.equals(SessionRecordingConfigSpecV2, a, b);
  }
}

/**
 * AuthPreferenceV2 implements the AuthPreference interface.
 *
 * @generated from message types.AuthPreferenceV2
 */
export class AuthPreferenceV2 extends Message<AuthPreferenceV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an AuthPreference specification
   *
   * @generated from field: types.AuthPreferenceSpecV2 Spec = 5;
   */
  Spec?: AuthPreferenceSpecV2;

  constructor(data?: PartialMessage<AuthPreferenceV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AuthPreferenceV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: AuthPreferenceSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthPreferenceV2 {
    return new AuthPreferenceV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthPreferenceV2 {
    return new AuthPreferenceV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthPreferenceV2 {
    return new AuthPreferenceV2().fromJsonString(jsonString, options);
  }

  static equals(a: AuthPreferenceV2 | PlainMessage<AuthPreferenceV2> | undefined, b: AuthPreferenceV2 | PlainMessage<AuthPreferenceV2> | undefined): boolean {
    return proto3.util.equals(AuthPreferenceV2, a, b);
  }
}

/**
 * AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
 *
 * @generated from message types.AuthPreferenceSpecV2
 */
export class AuthPreferenceSpecV2 extends Message<AuthPreferenceSpecV2> {
  /**
   * Type is the type of authentication.
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * SecondFactor is the type of second factor.
   *
   * @generated from field: string SecondFactor = 2;
   */
  SecondFactor = "";

  /**
   * ConnectorName is the name of the OIDC or SAML connector. If this value is
   * not set the first connector in the backend will be used.
   *
   * @generated from field: string ConnectorName = 3;
   */
  ConnectorName = "";

  /**
   * U2F are the settings for the U2F device.
   *
   * @generated from field: types.U2F U2F = 4;
   */
  U2F?: U2F;

  /**
   * DisconnectExpiredCert provides disconnect expired certificate setting -
   * if true, connections with expired client certificates will get disconnected
   *
   * @generated from field: types.BoolValue DisconnectExpiredCert = 6;
   */
  DisconnectExpiredCert?: BoolValue;

  /**
   * AllowLocalAuth is true if local authentication is enabled.
   *
   * @generated from field: types.BoolValue AllowLocalAuth = 7;
   */
  AllowLocalAuth?: BoolValue;

  /**
   * @generated from field: string MessageOfTheDay = 8;
   */
  MessageOfTheDay = "";

  /**
   * LockingMode is the cluster-wide locking mode default.
   *
   * @generated from field: string LockingMode = 9;
   */
  LockingMode = "";

  /**
   * Webauthn are the settings for server-side Web Authentication support.
   *
   * @generated from field: types.Webauthn Webauthn = 10;
   */
  Webauthn?: Webauthn;

  /**
   * AllowPasswordless enables/disables passwordless support.
   * Passwordless requires Webauthn to work.
   * Defaults to true if the Webauthn is configured, defaults to false
   * otherwise.
   *
   * @generated from field: types.BoolValue AllowPasswordless = 11;
   */
  AllowPasswordless?: BoolValue;

  /**
   * RequireMFAType is the type of MFA requirement enforced for this cluster.
   * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
   * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
   *
   * @generated from field: types.RequireMFAType RequireMFAType = 12;
   */
  RequireMFAType = RequireMFAType.OFF;

  /**
   * DeviceTrust holds settings related to trusted device verification.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.DeviceTrust DeviceTrust = 13;
   */
  DeviceTrust?: DeviceTrust;

  /**
   * IDP is a set of options related to accessing IdPs within Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.IdPOptions IDP = 14;
   */
  IDP?: IdPOptions;

  /**
   * AllowHeadless enables/disables headless support.
   * Headless authentication requires Webauthn to work.
   * Defaults to true if the Webauthn is configured, defaults to false
   * otherwise.
   *
   * @generated from field: types.BoolValue AllowHeadless = 15;
   */
  AllowHeadless?: BoolValue;

  /**
   * DefaultSessionTTL is the TTL to use for user certs when
   * an explicit TTL is not requested.
   *
   * @generated from field: int64 DefaultSessionTTL = 16;
   */
  DefaultSessionTTL = protoInt64.zero;

  /**
   * Okta is a set of options related to the Okta service in Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.OktaOptions Okta = 17;
   */
  Okta?: OktaOptions;

  /**
   * TODO(Joerger): DELETE IN 17.0.0
   * Deprecated, replaced by HardwareKey settings.
   *
   * @generated from field: string PIVSlot = 18 [deprecated = true];
   * @deprecated
   */
  PIVSlot = "";

  /**
   * HardwareKey are the settings for hardware key support.
   *
   * @generated from field: types.HardwareKey HardwareKey = 19;
   */
  HardwareKey?: HardwareKey;

  /**
   * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster.
   * The current default value is "legacy". This field is not yet fully supported.
   *
   * @generated from field: types.SignatureAlgorithmSuite signature_algorithm_suite = 20;
   */
  signatureAlgorithmSuite = SignatureAlgorithmSuite.UNSPECIFIED;

  constructor(data?: PartialMessage<AuthPreferenceSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AuthPreferenceSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SecondFactor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ConnectorName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "U2F", kind: "message", T: U2F },
    { no: 6, name: "DisconnectExpiredCert", kind: "message", T: BoolValue },
    { no: 7, name: "AllowLocalAuth", kind: "message", T: BoolValue },
    { no: 8, name: "MessageOfTheDay", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "LockingMode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Webauthn", kind: "message", T: Webauthn },
    { no: 11, name: "AllowPasswordless", kind: "message", T: BoolValue },
    { no: 12, name: "RequireMFAType", kind: "enum", T: proto3.getEnumType(RequireMFAType) },
    { no: 13, name: "DeviceTrust", kind: "message", T: DeviceTrust },
    { no: 14, name: "IDP", kind: "message", T: IdPOptions },
    { no: 15, name: "AllowHeadless", kind: "message", T: BoolValue },
    { no: 16, name: "DefaultSessionTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "Okta", kind: "message", T: OktaOptions },
    { no: 18, name: "PIVSlot", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "HardwareKey", kind: "message", T: HardwareKey },
    { no: 20, name: "signature_algorithm_suite", kind: "enum", T: proto3.getEnumType(SignatureAlgorithmSuite) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthPreferenceSpecV2 {
    return new AuthPreferenceSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthPreferenceSpecV2 {
    return new AuthPreferenceSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthPreferenceSpecV2 {
    return new AuthPreferenceSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: AuthPreferenceSpecV2 | PlainMessage<AuthPreferenceSpecV2> | undefined, b: AuthPreferenceSpecV2 | PlainMessage<AuthPreferenceSpecV2> | undefined): boolean {
    return proto3.util.equals(AuthPreferenceSpecV2, a, b);
  }
}

/**
 * U2F defines settings for U2F device.
 * Deprecated: U2F is transparently converted to WebAuthn by Teleport. Prefer
 * using WebAuthn instead.
 *
 * @generated from message types.U2F
 */
export class U2F extends Message<U2F> {
  /**
   * AppID returns the application ID for universal second factor.
   *
   * @generated from field: string AppID = 1;
   */
  AppID = "";

  /**
   * Facets returns the facets for universal second factor.
   * Deprecated: Kept for backwards compatibility reasons, but Facets have no
   * effect since Teleport v10, when Webauthn replaced the U2F implementation.
   *
   * @generated from field: repeated string Facets = 2;
   */
  Facets: string[] = [];

  /**
   * DeviceAttestationCAs contains the trusted attestation CAs for U2F
   * devices.
   *
   * @generated from field: repeated string DeviceAttestationCAs = 3;
   */
  DeviceAttestationCAs: string[] = [];

  constructor(data?: PartialMessage<U2F>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.U2F";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AppID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Facets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "DeviceAttestationCAs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): U2F {
    return new U2F().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): U2F {
    return new U2F().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): U2F {
    return new U2F().fromJsonString(jsonString, options);
  }

  static equals(a: U2F | PlainMessage<U2F> | undefined, b: U2F | PlainMessage<U2F> | undefined): boolean {
    return proto3.util.equals(U2F, a, b);
  }
}

/**
 * Webauthn defines user-visible settings for server-side Web Authentication
 * support.
 *
 * @generated from message types.Webauthn
 */
export class Webauthn extends Message<Webauthn> {
  /**
   * RPID is the ID of the Relying Party.
   * It should be set to the domain name of the Teleport installation.
   *
   * IMPORTANT: RPID must never change in the lifetime of the cluster, because
   * it's recorded in the registration data on the WebAuthn device. If the
   * RPID changes, all existing WebAuthn key registrations will become invalid
   * and all users who use WebAuthn as the second factor will need to
   * re-register.
   *
   * @generated from field: string RPID = 1;
   */
  RPID = "";

  /**
   * Allow list of device attestation CAs in PEM format.
   * If present, only devices whose attestation certificates match the
   * certificates specified here may be registered (existing registrations are
   * unchanged).
   * If supplied in conjunction with AttestationDeniedCAs, then both
   * conditions need to be true for registration to be allowed (the device
   * MUST match an allowed CA and MUST NOT match a denied CA).
   * By default all devices are allowed.
   *
   * @generated from field: repeated string AttestationAllowedCAs = 2;
   */
  AttestationAllowedCAs: string[] = [];

  /**
   * Deny list of device attestation CAs in PEM format.
   * If present, only devices whose attestation certificates don't match the
   * certificates specified here may be registered (existing registrations are
   * unchanged).
   * If supplied in conjunction with AttestationAllowedCAs, then both
   * conditions need to be true for registration to be allowed (the device
   * MUST match an allowed CA and MUST NOT match a denied CA).
   * By default no devices are denied.
   *
   * @generated from field: repeated string AttestationDeniedCAs = 3;
   */
  AttestationDeniedCAs: string[] = [];

  constructor(data?: PartialMessage<Webauthn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Webauthn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RPID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AttestationAllowedCAs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "AttestationDeniedCAs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Webauthn {
    return new Webauthn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Webauthn {
    return new Webauthn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Webauthn {
    return new Webauthn().fromJsonString(jsonString, options);
  }

  static equals(a: Webauthn | PlainMessage<Webauthn> | undefined, b: Webauthn | PlainMessage<Webauthn> | undefined): boolean {
    return proto3.util.equals(Webauthn, a, b);
  }
}

/**
 * DeviceTrust holds settings related to trusted device verification.
 * Requires Teleport Enterprise.
 *
 * @generated from message types.DeviceTrust
 */
export class DeviceTrust extends Message<DeviceTrust> {
  /**
   * Mode of verification for trusted devices.
   *
   * The following modes are supported:
   *
   * - "off": disables both device authentication and authorization.
   * - "optional": allows both device authentication and authorization, but
   *   doesn't enforce the presence of device extensions for sensitive
   *   endpoints.
   * - "required": enforces the presence of device extensions for sensitive
   *   endpoints.
   *
   * Mode is always "off" for OSS.
   * Defaults to "optional" for Enterprise.
   *
   * @generated from field: string Mode = 1;
   */
  Mode = "";

  /**
   * Enable device auto-enroll.
   * Auto-enroll lets any user issue a device enrollment token for a known
   * device that is not already enrolled.
   * `tsh` takes advantage of auto-enroll to automatically enroll devices on
   * user login, when appropriate.
   * The effective cluster Mode still applies: AutoEnroll=true is meaningless if
   * Mode="off".
   *
   * @generated from field: bool AutoEnroll = 2;
   */
  AutoEnroll = false;

  /**
   * Allow list of EKCert CAs in PEM format.
   * If present, only TPM devices that present an EKCert that is signed by a
   * CA specified here may be enrolled (existing enrollments are
   * unchanged).
   *
   * If not present, then the CA of TPM EKCerts will not be checked during
   * enrollment, this allows any device to enroll.
   *
   * @generated from field: repeated string EKCertAllowedCAs = 3;
   */
  EKCertAllowedCAs: string[] = [];

  constructor(data?: PartialMessage<DeviceTrust>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DeviceTrust";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AutoEnroll", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "EKCertAllowedCAs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceTrust {
    return new DeviceTrust().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceTrust {
    return new DeviceTrust().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceTrust {
    return new DeviceTrust().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceTrust | PlainMessage<DeviceTrust> | undefined, b: DeviceTrust | PlainMessage<DeviceTrust> | undefined): boolean {
    return proto3.util.equals(DeviceTrust, a, b);
  }
}

/**
 * HardwareKey holds settings related to hardware key support.
 * Requires Teleport Enterprise.
 *
 * @generated from message types.HardwareKey
 */
export class HardwareKey extends Message<HardwareKey> {
  /**
   * PIVSlot is a PIV slot that Teleport clients should use instead of the
   * default based on private key policy. For example, "9a" or "9e".
   *
   * @generated from field: string PIVSlot = 1;
   */
  PIVSlot = "";

  /**
   * SerialNumberValidation holds settings for hardware key serial number validation.
   * By default, serial number validation is disabled.
   *
   * @generated from field: types.HardwareKeySerialNumberValidation SerialNumberValidation = 2;
   */
  SerialNumberValidation?: HardwareKeySerialNumberValidation;

  constructor(data?: PartialMessage<HardwareKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.HardwareKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PIVSlot", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SerialNumberValidation", kind: "message", T: HardwareKeySerialNumberValidation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HardwareKey {
    return new HardwareKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HardwareKey {
    return new HardwareKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HardwareKey {
    return new HardwareKey().fromJsonString(jsonString, options);
  }

  static equals(a: HardwareKey | PlainMessage<HardwareKey> | undefined, b: HardwareKey | PlainMessage<HardwareKey> | undefined): boolean {
    return proto3.util.equals(HardwareKey, a, b);
  }
}

/**
 * @generated from message types.HardwareKeySerialNumberValidation
 */
export class HardwareKeySerialNumberValidation extends Message<HardwareKeySerialNumberValidation> {
  /**
   * Enabled indicates whether hardware key serial number validation is enabled.
   *
   * @generated from field: bool Enabled = 1;
   */
  Enabled = false;

  /**
   * SerialNumberTraitName is an optional custom user trait name for hardware key
   * serial numbers to replace the default: "hardware_key_serial_numbers".
   *
   * Note: Values for this user trait should be a comma-separated list of serial numbers,
   * or a list of comm-separated lists. e.g ["123", "345,678"]
   *
   * @generated from field: string SerialNumberTraitName = 2;
   */
  SerialNumberTraitName = "";

  constructor(data?: PartialMessage<HardwareKeySerialNumberValidation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.HardwareKeySerialNumberValidation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "SerialNumberTraitName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HardwareKeySerialNumberValidation {
    return new HardwareKeySerialNumberValidation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HardwareKeySerialNumberValidation {
    return new HardwareKeySerialNumberValidation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HardwareKeySerialNumberValidation {
    return new HardwareKeySerialNumberValidation().fromJsonString(jsonString, options);
  }

  static equals(a: HardwareKeySerialNumberValidation | PlainMessage<HardwareKeySerialNumberValidation> | undefined, b: HardwareKeySerialNumberValidation | PlainMessage<HardwareKeySerialNumberValidation> | undefined): boolean {
    return proto3.util.equals(HardwareKeySerialNumberValidation, a, b);
  }
}

/**
 * Namespace represents namespace resource specification
 *
 * @generated from message types.Namespace
 */
export class Namespace extends Message<Namespace> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a namespace spec
   *
   * @generated from field: types.NamespaceSpec Spec = 5;
   */
  Spec?: NamespaceSpec;

  constructor(data?: PartialMessage<Namespace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Namespace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: NamespaceSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Namespace {
    return new Namespace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJsonString(jsonString, options);
  }

  static equals(a: Namespace | PlainMessage<Namespace> | undefined, b: Namespace | PlainMessage<Namespace> | undefined): boolean {
    return proto3.util.equals(Namespace, a, b);
  }
}

/**
 * NamespaceSpec is a namespace specification
 *
 * @generated from message types.NamespaceSpec
 */
export class NamespaceSpec extends Message<NamespaceSpec> {
  constructor(data?: PartialMessage<NamespaceSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.NamespaceSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamespaceSpec {
    return new NamespaceSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamespaceSpec {
    return new NamespaceSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamespaceSpec {
    return new NamespaceSpec().fromJsonString(jsonString, options);
  }

  static equals(a: NamespaceSpec | PlainMessage<NamespaceSpec> | undefined, b: NamespaceSpec | PlainMessage<NamespaceSpec> | undefined): boolean {
    return proto3.util.equals(NamespaceSpec, a, b);
  }
}

/**
 * @generated from message types.UserTokenV3
 */
export class UserTokenV3 extends Message<UserTokenV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is a resource sub kind, used to define the type of user token.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an resource specification
   *
   * @generated from field: types.UserTokenSpecV3 Spec = 5;
   */
  Spec?: UserTokenSpecV3;

  constructor(data?: PartialMessage<UserTokenV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserTokenV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: UserTokenSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserTokenV3 {
    return new UserTokenV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserTokenV3 {
    return new UserTokenV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserTokenV3 {
    return new UserTokenV3().fromJsonString(jsonString, options);
  }

  static equals(a: UserTokenV3 | PlainMessage<UserTokenV3> | undefined, b: UserTokenV3 | PlainMessage<UserTokenV3> | undefined): boolean {
    return proto3.util.equals(UserTokenV3, a, b);
  }
}

/**
 * @generated from message types.UserTokenSpecV3
 */
export class UserTokenSpecV3 extends Message<UserTokenSpecV3> {
  /**
   * User is user name associated with this token
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * URL is this token URL
   *
   * @generated from field: string URL = 2;
   */
  URL = "";

  /**
   * Usage is an optional field that provides more information about how this token will be used.
   *
   * @generated from field: types.UserTokenUsage Usage = 3;
   */
  Usage = UserTokenUsage.USER_TOKEN_USAGE_UNSPECIFIED;

  /**
   * Created holds information about when the token was created
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;

  constructor(data?: PartialMessage<UserTokenSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserTokenSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "URL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Usage", kind: "enum", T: proto3.getEnumType(UserTokenUsage) },
    { no: 4, name: "Created", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserTokenSpecV3 {
    return new UserTokenSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserTokenSpecV3 {
    return new UserTokenSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserTokenSpecV3 {
    return new UserTokenSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: UserTokenSpecV3 | PlainMessage<UserTokenSpecV3> | undefined, b: UserTokenSpecV3 | PlainMessage<UserTokenSpecV3> | undefined): boolean {
    return proto3.util.equals(UserTokenSpecV3, a, b);
  }
}

/**
 * @generated from message types.UserTokenSecretsV3
 */
export class UserTokenSecretsV3 extends Message<UserTokenSecretsV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an resource specification
   *
   * @generated from field: types.UserTokenSecretsSpecV3 Spec = 5;
   */
  Spec?: UserTokenSecretsSpecV3;

  constructor(data?: PartialMessage<UserTokenSecretsV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserTokenSecretsV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: UserTokenSecretsSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserTokenSecretsV3 {
    return new UserTokenSecretsV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserTokenSecretsV3 {
    return new UserTokenSecretsV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserTokenSecretsV3 {
    return new UserTokenSecretsV3().fromJsonString(jsonString, options);
  }

  static equals(a: UserTokenSecretsV3 | PlainMessage<UserTokenSecretsV3> | undefined, b: UserTokenSecretsV3 | PlainMessage<UserTokenSecretsV3> | undefined): boolean {
    return proto3.util.equals(UserTokenSecretsV3, a, b);
  }
}

/**
 * @generated from message types.UserTokenSecretsSpecV3
 */
export class UserTokenSecretsSpecV3 extends Message<UserTokenSecretsSpecV3> {
  /**
   * OTPKey is is a secret value of one time password secret generator
   *
   * @generated from field: string OTPKey = 1;
   */
  OTPKey = "";

  /**
   * OTPKey is is a secret value of one time password secret generator
   *
   * @generated from field: string QRCode = 2;
   */
  QRCode = "";

  /**
   * Created holds information about when the token was created
   *
   * @generated from field: google.protobuf.Timestamp Created = 3;
   */
  Created?: Timestamp;

  constructor(data?: PartialMessage<UserTokenSecretsSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserTokenSecretsSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "OTPKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "QRCode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Created", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserTokenSecretsSpecV3 {
    return new UserTokenSecretsSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserTokenSecretsSpecV3 {
    return new UserTokenSecretsSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserTokenSecretsSpecV3 {
    return new UserTokenSecretsSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: UserTokenSecretsSpecV3 | PlainMessage<UserTokenSecretsSpecV3> | undefined, b: UserTokenSecretsSpecV3 | PlainMessage<UserTokenSecretsSpecV3> | undefined): boolean {
    return proto3.util.equals(UserTokenSecretsSpecV3, a, b);
  }
}

/**
 * AccessRequest represents an access request resource specification
 *
 * @generated from message types.AccessRequestV3
 */
export class AccessRequestV3 extends Message<AccessRequestV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is AccessRequest metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an AccessRequest specification
   *
   * @generated from field: types.AccessRequestSpecV3 Spec = 5;
   */
  Spec?: AccessRequestSpecV3;

  constructor(data?: PartialMessage<AccessRequestV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: AccessRequestSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestV3 {
    return new AccessRequestV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestV3 {
    return new AccessRequestV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestV3 {
    return new AccessRequestV3().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestV3 | PlainMessage<AccessRequestV3> | undefined, b: AccessRequestV3 | PlainMessage<AccessRequestV3> | undefined): boolean {
    return proto3.util.equals(AccessRequestV3, a, b);
  }
}

/**
 * AccessReviewThreshold describes a filter used to match access reviews,
 * as well as approval/denial counts which trigger state-transitions.  This type
 * can be used to describe policies such as "can be approved by 2 admins"
 * or "can be denied by any non-contractor".
 *
 * @generated from message types.AccessReviewThreshold
 */
export class AccessReviewThreshold extends Message<AccessReviewThreshold> {
  /**
   * Name is the optional human-readable name of the threshold.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Filter is an optional predicate used to determine which reviews
   * count toward this threshold.
   *
   * @generated from field: string Filter = 2;
   */
  Filter = "";

  /**
   * Approve is the number of matching approvals needed for state-transition.
   *
   * @generated from field: uint32 Approve = 3;
   */
  Approve = 0;

  /**
   * Deny is the number of denials needed for state-transition.
   *
   * @generated from field: uint32 Deny = 4;
   */
  Deny = 0;

  constructor(data?: PartialMessage<AccessReviewThreshold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessReviewThreshold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Approve", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "Deny", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessReviewThreshold {
    return new AccessReviewThreshold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessReviewThreshold {
    return new AccessReviewThreshold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessReviewThreshold {
    return new AccessReviewThreshold().fromJsonString(jsonString, options);
  }

  static equals(a: AccessReviewThreshold | PlainMessage<AccessReviewThreshold> | undefined, b: AccessReviewThreshold | PlainMessage<AccessReviewThreshold> | undefined): boolean {
    return proto3.util.equals(AccessReviewThreshold, a, b);
  }
}

/**
 * PromotedAccessList is a minimal access list representation used for
 * promoting access requests to access lists.
 *
 * @generated from message types.PromotedAccessList
 */
export class PromotedAccessList extends Message<PromotedAccessList> {
  /**
   * Name is the name of the access list.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Title is the title of the access list.
   *
   * @generated from field: string Title = 2;
   */
  Title = "";

  constructor(data?: PartialMessage<PromotedAccessList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PromotedAccessList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromotedAccessList {
    return new PromotedAccessList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromotedAccessList {
    return new PromotedAccessList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromotedAccessList {
    return new PromotedAccessList().fromJsonString(jsonString, options);
  }

  static equals(a: PromotedAccessList | PlainMessage<PromotedAccessList> | undefined, b: PromotedAccessList | PlainMessage<PromotedAccessList> | undefined): boolean {
    return proto3.util.equals(PromotedAccessList, a, b);
  }
}

/**
 * AccessReview is a review to be applied to an access request.
 *
 * @generated from message types.AccessReview
 */
export class AccessReview extends Message<AccessReview> {
  /**
   * Author is the teleport username of the review author.
   *
   * @generated from field: string Author = 1;
   */
  Author = "";

  /**
   * Roles is a list used for role-subselection (not yet fully supported).
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * ProposedState is the proposed state (must be APPROVED or DENIED).
   *
   * @generated from field: types.RequestState ProposedState = 3;
   */
  ProposedState = RequestState.NONE;

  /**
   * Reason is an optional human-readable reason for why the above state
   * is being proposed.
   *
   * @generated from field: string Reason = 4;
   */
  Reason = "";

  /**
   * Created is the time at which the review was created.
   *
   * @generated from field: google.protobuf.Timestamp Created = 5;
   */
  Created?: Timestamp;

  /**
   * Annotations is the proposed value of the request's resolve_annotations field.
   *
   * @generated from field: wrappers.LabelValues Annotations = 6;
   */
  Annotations?: LabelValues;

  /**
   * ThresholdIndexes stores the indexes of thresholds which this review matches
   * (internal use only).
   *
   * @generated from field: repeated uint32 ThresholdIndexes = 7;
   */
  ThresholdIndexes: number[] = [];

  /**
   * AccessList is the access list that this request was promoted to.
   * This field is only populated when the request is in the PROMOTED state.
   *
   * @generated from field: types.PromotedAccessList accessList = 9;
   */
  accessList?: PromotedAccessList;

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 10;
   */
  AssumeStartTime?: Timestamp;

  constructor(data?: PartialMessage<AccessReview>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessReview";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Author", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ProposedState", kind: "enum", T: proto3.getEnumType(RequestState) },
    { no: 4, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Created", kind: "message", T: Timestamp },
    { no: 6, name: "Annotations", kind: "message", T: LabelValues },
    { no: 7, name: "ThresholdIndexes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 9, name: "accessList", kind: "message", T: PromotedAccessList },
    { no: 10, name: "AssumeStartTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessReview {
    return new AccessReview().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessReview {
    return new AccessReview().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessReview {
    return new AccessReview().fromJsonString(jsonString, options);
  }

  static equals(a: AccessReview | PlainMessage<AccessReview> | undefined, b: AccessReview | PlainMessage<AccessReview> | undefined): boolean {
    return proto3.util.equals(AccessReview, a, b);
  }
}

/**
 * AccessReviewSubmission encodes the necessary parameters for submitting
 * a new access review.
 *
 * @generated from message types.AccessReviewSubmission
 */
export class AccessReviewSubmission extends Message<AccessReviewSubmission> {
  /**
   * RequestID is the unique ID of the request to be reviewed.
   *
   * @generated from field: string RequestID = 1;
   */
  RequestID = "";

  /**
   * Review is the review to be applied.
   *
   * @generated from field: types.AccessReview Review = 2;
   */
  Review?: AccessReview;

  constructor(data?: PartialMessage<AccessReviewSubmission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessReviewSubmission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Review", kind: "message", T: AccessReview },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessReviewSubmission {
    return new AccessReviewSubmission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessReviewSubmission {
    return new AccessReviewSubmission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessReviewSubmission {
    return new AccessReviewSubmission().fromJsonString(jsonString, options);
  }

  static equals(a: AccessReviewSubmission | PlainMessage<AccessReviewSubmission> | undefined, b: AccessReviewSubmission | PlainMessage<AccessReviewSubmission> | undefined): boolean {
    return proto3.util.equals(AccessReviewSubmission, a, b);
  }
}

/**
 * ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
 * must pass for the set to be considered to have passed (i.e. this is an `or` operator).
 *
 * @generated from message types.ThresholdIndexSet
 */
export class ThresholdIndexSet extends Message<ThresholdIndexSet> {
  /**
   * Indexes are the indexes of thresholds which relate to the role.
   *
   * @generated from field: repeated uint32 Indexes = 1;
   */
  Indexes: number[] = [];

  constructor(data?: PartialMessage<ThresholdIndexSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ThresholdIndexSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Indexes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThresholdIndexSet {
    return new ThresholdIndexSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThresholdIndexSet {
    return new ThresholdIndexSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThresholdIndexSet {
    return new ThresholdIndexSet().fromJsonString(jsonString, options);
  }

  static equals(a: ThresholdIndexSet | PlainMessage<ThresholdIndexSet> | undefined, b: ThresholdIndexSet | PlainMessage<ThresholdIndexSet> | undefined): boolean {
    return proto3.util.equals(ThresholdIndexSet, a, b);
  }
}

/**
 * ThresholdIndexSets is a list of threshold index sets.  Each of the individual
 * sets must pass (i.e. this is an `and` operator).
 *
 * @generated from message types.ThresholdIndexSets
 */
export class ThresholdIndexSets extends Message<ThresholdIndexSets> {
  /**
   * Sets are the sets that make up this group.
   *
   * @generated from field: repeated types.ThresholdIndexSet Sets = 1;
   */
  Sets: ThresholdIndexSet[] = [];

  constructor(data?: PartialMessage<ThresholdIndexSets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ThresholdIndexSets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sets", kind: "message", T: ThresholdIndexSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThresholdIndexSets {
    return new ThresholdIndexSets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThresholdIndexSets {
    return new ThresholdIndexSets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThresholdIndexSets {
    return new ThresholdIndexSets().fromJsonString(jsonString, options);
  }

  static equals(a: ThresholdIndexSets | PlainMessage<ThresholdIndexSets> | undefined, b: ThresholdIndexSets | PlainMessage<ThresholdIndexSets> | undefined): boolean {
    return proto3.util.equals(ThresholdIndexSets, a, b);
  }
}

/**
 * AccessRequestSpec is the specification for AccessRequest
 *
 * @generated from message types.AccessRequestSpecV3
 */
export class AccessRequestSpecV3 extends Message<AccessRequestSpecV3> {
  /**
   * User is the name of the user to whom the roles will be applied.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Roles is the name of the roles being requested.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * State is the current state of this access request.
   *
   * @generated from field: types.RequestState State = 3;
   */
  State = RequestState.NONE;

  /**
   * Created encodes the time at which the request was registered with the auth
   * server.
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;

  /**
   * Expires constrains the maximum lifetime of any login session for which this
   * request is active.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;

  /**
   * RequestReason is an optional message explaining the reason for the request.
   *
   * @generated from field: string RequestReason = 6;
   */
  RequestReason = "";

  /**
   * ResolveReason is an optional message explaining the reason for the resolution
   * of the request (approval, denial, etc...).
   *
   * @generated from field: string ResolveReason = 7;
   */
  ResolveReason = "";

  /**
   * ResolveAnnotations is a set of arbitrary values received from plugins or other
   * resolving parties during approval/denial.  Importantly, these annotations are
   * included in the access_request.update event, allowing plugins to propagate
   * arbitrary structured data to the audit log.
   *
   * @generated from field: wrappers.LabelValues ResolveAnnotations = 8;
   */
  ResolveAnnotations?: LabelValues;

  /**
   * SystemAnnotations is a set of programmatically generated annotations attached
   * to pending access requests by teleport.  These annotations are generated by
   * applying variable interpolation to the RoleConditions.Request.Annotations block
   * of a user's role(s).  These annotations serve as a mechanism for administrators
   * to pass extra information to plugins when they process pending access requests.
   *
   * @generated from field: wrappers.LabelValues SystemAnnotations = 9;
   */
  SystemAnnotations?: LabelValues;

  /**
   * Thresholds is a list of review thresholds relevant to this request.  Order must be
   * preserved, as thresholds are referenced by index (internal use only).
   *
   * @generated from field: repeated types.AccessReviewThreshold Thresholds = 10;
   */
  Thresholds: AccessReviewThreshold[] = [];

  /**
   * RoleThresholdMapping encodes the relationship between the requested roles and
   * the review threshold requirements for the given role (internal use only).
   * By storing a representation of which thresholds must pass for each requested role, we
   * both eliminate the need to cache the requestor's roles directly, and allow future
   * versions of teleport to become smarter about calculating more granular requirements
   * in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
   * Storing this relationship on the request is necessary in order to avoid unexpected or
   * inconsistent behavior due to review submission timing.
   *
   * @generated from field: map<string, types.ThresholdIndexSets> RoleThresholdMapping = 11;
   */
  RoleThresholdMapping: { [key: string]: ThresholdIndexSets } = {};

  /**
   * Reviews is a list of reviews applied to this request (internal use only).
   *
   * @generated from field: repeated types.AccessReview Reviews = 12;
   */
  Reviews: AccessReview[] = [];

  /**
   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
   * that is not a requirement.
   *
   * @generated from field: repeated string SuggestedReviewers = 13;
   */
  SuggestedReviewers: string[] = [];

  /**
   * RequestedResourceIDs is a set of resources to which access is being requested.
   *
   * @generated from field: repeated types.ResourceID RequestedResourceIDs = 14;
   */
  RequestedResourceIDs: ResourceID[] = [];

  /**
   * LoginHint is used as a hint for search-based access requests to select
   * roles based on the login the user is attempting.
   *
   * @generated from field: string LoginHint = 15;
   */
  LoginHint = "";

  /**
   * DryRun indicates that the request should not actually be created, the
   * auth server should only validate the access request.
   *
   * @generated from field: bool DryRun = 16;
   */
  DryRun = false;

  /**
   * MaxDuration indicates how long the access should be granted for.
   *
   * @generated from field: google.protobuf.Timestamp MaxDuration = 17;
   */
  MaxDuration?: Timestamp;

  /**
   * SessionTLL indicated how long a certificate for a session should be valid for.
   *
   * @generated from field: google.protobuf.Timestamp SessionTTL = 18;
   */
  SessionTTL?: Timestamp;

  /**
   * PromotedAccessListTitle is the title of the access list that this request
   * was promoted to. Used by WebUI to display the title of the access list.
   * This field is only populated when the request is in the PROMOTED state.
   *
   * @generated from field: types.PromotedAccessList accessList = 20;
   */
  accessList?: PromotedAccessList;

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 21;
   */
  AssumeStartTime?: Timestamp;

  constructor(data?: PartialMessage<AccessRequestSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "State", kind: "enum", T: proto3.getEnumType(RequestState) },
    { no: 4, name: "Created", kind: "message", T: Timestamp },
    { no: 5, name: "Expires", kind: "message", T: Timestamp },
    { no: 6, name: "RequestReason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ResolveReason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ResolveAnnotations", kind: "message", T: LabelValues },
    { no: 9, name: "SystemAnnotations", kind: "message", T: LabelValues },
    { no: 10, name: "Thresholds", kind: "message", T: AccessReviewThreshold, repeated: true },
    { no: 11, name: "RoleThresholdMapping", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ThresholdIndexSets} },
    { no: 12, name: "Reviews", kind: "message", T: AccessReview, repeated: true },
    { no: 13, name: "SuggestedReviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "RequestedResourceIDs", kind: "message", T: ResourceID, repeated: true },
    { no: 15, name: "LoginHint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "DryRun", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "MaxDuration", kind: "message", T: Timestamp },
    { no: 18, name: "SessionTTL", kind: "message", T: Timestamp },
    { no: 20, name: "accessList", kind: "message", T: PromotedAccessList },
    { no: 21, name: "AssumeStartTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestSpecV3 {
    return new AccessRequestSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestSpecV3 {
    return new AccessRequestSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestSpecV3 {
    return new AccessRequestSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestSpecV3 | PlainMessage<AccessRequestSpecV3> | undefined, b: AccessRequestSpecV3 | PlainMessage<AccessRequestSpecV3> | undefined): boolean {
    return proto3.util.equals(AccessRequestSpecV3, a, b);
  }
}

/**
 * AccessRequestFilter encodes filter params for access requests.
 *
 * @generated from message types.AccessRequestFilter
 */
export class AccessRequestFilter extends Message<AccessRequestFilter> {
  /**
   * ID specifies a request ID if set.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * User specifies a username if set.
   *
   * @generated from field: string User = 2;
   */
  User = "";

  /**
   * RequestState filters for requests in a specific state.
   *
   * @generated from field: types.RequestState State = 3;
   */
  State = RequestState.NONE;

  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   * The matcher goes through select field values from a resource
   * and tries to match against the list of search values, ignoring case and order.
   * Returns true if all search vals were matched (or if nil search vals).
   * Returns false if no or partial match (or nil field values).
   *
   * @generated from field: repeated string SearchKeywords = 4;
   */
  SearchKeywords: string[] = [];

  /**
   * Scope is an aditional filter to view requests based on needs review, reviewed, my requests
   *
   * @generated from field: types.AccessRequestScope Scope = 5;
   */
  Scope = AccessRequestScope.DEFAULT;

  /**
   * Requester is the requester of the api call. This is set by the auth server
   * Use User for the requester of the request.
   *
   * @generated from field: string Requester = 6;
   */
  Requester = "";

  constructor(data?: PartialMessage<AccessRequestFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "State", kind: "enum", T: proto3.getEnumType(RequestState) },
    { no: 4, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Scope", kind: "enum", T: proto3.getEnumType(AccessRequestScope) },
    { no: 6, name: "Requester", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestFilter {
    return new AccessRequestFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestFilter {
    return new AccessRequestFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestFilter {
    return new AccessRequestFilter().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestFilter | PlainMessage<AccessRequestFilter> | undefined, b: AccessRequestFilter | PlainMessage<AccessRequestFilter> | undefined): boolean {
    return proto3.util.equals(AccessRequestFilter, a, b);
  }
}

/**
 * AccessCapabilities is a summary of capabilities that a user
 * is granted via their dynamic access privileges which may not be
 * calculable by directly examining the user's own static roles.
 *
 * @generated from message types.AccessCapabilities
 */
export class AccessCapabilities extends Message<AccessCapabilities> {
  /**
   * RequestableRoles is a list of existent roles which the user is allowed to request.
   *
   * @generated from field: repeated string RequestableRoles = 1;
   */
  RequestableRoles: string[] = [];

  /**
   * SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
   *
   * @generated from field: repeated string SuggestedReviewers = 2;
   */
  SuggestedReviewers: string[] = [];

  /**
   * ApplicableRolesForResources is a list of the roles applicable for access to a given set of resources.
   *
   * @generated from field: repeated string ApplicableRolesForResources = 3;
   */
  ApplicableRolesForResources: string[] = [];

  /**
   * RequestPrompt is an optional message which tells users what they aught to request.
   *
   * @generated from field: string RequestPrompt = 4;
   */
  RequestPrompt = "";

  /**
   * RequireReason indicates whether the request strategy is one that requires
   * users to always supply reasons with their requests.
   *
   * @generated from field: bool RequireReason = 5;
   */
  RequireReason = false;

  /**
   * AutoRequest indicates whether the request strategy indicates that a
   * request should be automatically generated on login.
   *
   * @generated from field: bool AutoRequest = 6;
   */
  AutoRequest = false;

  constructor(data?: PartialMessage<AccessCapabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessCapabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RequestableRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "SuggestedReviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ApplicableRolesForResources", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "RequestPrompt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "RequireReason", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "AutoRequest", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessCapabilities {
    return new AccessCapabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessCapabilities {
    return new AccessCapabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessCapabilities {
    return new AccessCapabilities().fromJsonString(jsonString, options);
  }

  static equals(a: AccessCapabilities | PlainMessage<AccessCapabilities> | undefined, b: AccessCapabilities | PlainMessage<AccessCapabilities> | undefined): boolean {
    return proto3.util.equals(AccessCapabilities, a, b);
  }
}

/**
 * AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
 *
 * @generated from message types.AccessCapabilitiesRequest
 */
export class AccessCapabilitiesRequest extends Message<AccessCapabilitiesRequest> {
  /**
   * User is the name of the user whose capabilities we are interested in (defaults to
   * the caller's own username).
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * RequestableRoles is a flag indicating that we would like to view the list of roles
   * that the user is able to request.
   *
   * @generated from field: bool RequestableRoles = 2;
   */
  RequestableRoles = false;

  /**
   * SuggestedReviewers is a flag indicating that we would like to view the list of all
   * reviewers which are suggested by the user's roles.
   *
   * @generated from field: bool SuggestedReviewers = 3;
   */
  SuggestedReviewers = false;

  /**
   * ResourceIDs is the list of the ResourceIDs of the resources we would like to view
   * the necessary roles for.
   *
   * @generated from field: repeated types.ResourceID ResourceIDs = 4;
   */
  ResourceIDs: ResourceID[] = [];

  /**
   * Login is the host login the user is requesting access for.
   *
   * @generated from field: string Login = 5;
   */
  Login = "";

  /**
   * FilterRequestableRolesByResource is a flag indicating that the returned
   * list of roles that the user can request should be filtered to only include
   * roles that allow access to the provided ResourceIDs.
   *
   * @generated from field: bool FilterRequestableRolesByResource = 6;
   */
  FilterRequestableRolesByResource = false;

  constructor(data?: PartialMessage<AccessCapabilitiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessCapabilitiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "RequestableRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "SuggestedReviewers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "ResourceIDs", kind: "message", T: ResourceID, repeated: true },
    { no: 5, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "FilterRequestableRolesByResource", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessCapabilitiesRequest {
    return new AccessCapabilitiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessCapabilitiesRequest {
    return new AccessCapabilitiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessCapabilitiesRequest {
    return new AccessCapabilitiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccessCapabilitiesRequest | PlainMessage<AccessCapabilitiesRequest> | undefined, b: AccessCapabilitiesRequest | PlainMessage<AccessCapabilitiesRequest> | undefined): boolean {
    return proto3.util.equals(AccessCapabilitiesRequest, a, b);
  }
}

/**
 * ResourceID is a unique identifier for a teleport resource.
 *
 * @generated from message types.ResourceID
 */
export class ResourceID extends Message<ResourceID> {
  /**
   * ClusterName is the name of the cluster the resource is in.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 2;
   */
  Kind = "";

  /**
   * Name is the name of the specific resource.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * SubResourceName is the resource belonging to resource identified by "Name"
   * that the user is allowed to access to.
   * When granting access to a subresource, access to other resources is limited.
   * Currently it just supports resources of Kind=pod and the format is the following
   * "<kube_namespace>/<kube_pod>".
   *
   * @generated from field: string SubResourceName = 4;
   */
  SubResourceName = "";

  constructor(data?: PartialMessage<ResourceID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "SubResourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceID {
    return new ResourceID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceID {
    return new ResourceID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceID {
    return new ResourceID().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceID | PlainMessage<ResourceID> | undefined, b: ResourceID | PlainMessage<ResourceID> | undefined): boolean {
    return proto3.util.equals(ResourceID, a, b);
  }
}

/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from message types.PluginDataV3
 */
export class PluginDataV3 extends Message<PluginDataV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is PluginData metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a PluginData specification
   *
   * @generated from field: types.PluginDataSpecV3 Spec = 5;
   */
  Spec?: PluginDataSpecV3;

  constructor(data?: PartialMessage<PluginDataV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDataV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: PluginDataSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataV3 {
    return new PluginDataV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataV3 {
    return new PluginDataV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataV3 {
    return new PluginDataV3().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataV3 | PlainMessage<PluginDataV3> | undefined, b: PluginDataV3 | PlainMessage<PluginDataV3> | undefined): boolean {
    return proto3.util.equals(PluginDataV3, a, b);
  }
}

/**
 * PluginDataEntry wraps a mapping of arbitrary string values used by
 * plugins to store per-resource information.
 *
 * @generated from message types.PluginDataEntry
 */
export class PluginDataEntry extends Message<PluginDataEntry> {
  /**
   * Data is a mapping of arbitrary string values.
   *
   * @generated from field: map<string, string> Data = 1;
   */
  Data: { [key: string]: string } = {};

  constructor(data?: PartialMessage<PluginDataEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDataEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Data", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataEntry {
    return new PluginDataEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataEntry {
    return new PluginDataEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataEntry {
    return new PluginDataEntry().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataEntry | PlainMessage<PluginDataEntry> | undefined, b: PluginDataEntry | PlainMessage<PluginDataEntry> | undefined): boolean {
    return proto3.util.equals(PluginDataEntry, a, b);
  }
}

/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from message types.PluginDataSpecV3
 */
export class PluginDataSpecV3 extends Message<PluginDataSpecV3> {
  /**
   * Entries is a collection of PluginData values organized by plugin name.
   *
   * @generated from field: map<string, types.PluginDataEntry> Entries = 1;
   */
  Entries: { [key: string]: PluginDataEntry } = {};

  constructor(data?: PartialMessage<PluginDataSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDataSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Entries", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PluginDataEntry} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataSpecV3 {
    return new PluginDataSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataSpecV3 {
    return new PluginDataSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataSpecV3 {
    return new PluginDataSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataSpecV3 | PlainMessage<PluginDataSpecV3> | undefined, b: PluginDataSpecV3 | PlainMessage<PluginDataSpecV3> | undefined): boolean {
    return proto3.util.equals(PluginDataSpecV3, a, b);
  }
}

/**
 * PluginDataFilter encodes filter params for plugin data.
 *
 * @generated from message types.PluginDataFilter
 */
export class PluginDataFilter extends Message<PluginDataFilter> {
  /**
   * Kind is the kind of resource that the target plugin data
   * is associated with.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * Resource matches a specific resource name if set.
   *
   * @generated from field: string Resource = 2;
   */
  Resource = "";

  /**
   * Plugin matches a specific plugin name if set.
   *
   * @generated from field: string Plugin = 3;
   */
  Plugin = "";

  constructor(data?: PartialMessage<PluginDataFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDataFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Plugin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataFilter {
    return new PluginDataFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataFilter {
    return new PluginDataFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataFilter {
    return new PluginDataFilter().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataFilter | PlainMessage<PluginDataFilter> | undefined, b: PluginDataFilter | PlainMessage<PluginDataFilter> | undefined): boolean {
    return proto3.util.equals(PluginDataFilter, a, b);
  }
}

/**
 * PluginDataUpdateParams encodes parameters for updating a PluginData field.
 *
 * @generated from message types.PluginDataUpdateParams
 */
export class PluginDataUpdateParams extends Message<PluginDataUpdateParams> {
  /**
   * Kind is the kind of resource that the target plugin data
   * is associated with.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * Resource indicates the name of the target resource.
   *
   * @generated from field: string Resource = 2;
   */
  Resource = "";

  /**
   * Plugin is the name of the plugin that owns the data.
   *
   * @generated from field: string Plugin = 3;
   */
  Plugin = "";

  /**
   * Set indicates the fields which should be set by this operation.
   *
   * @generated from field: map<string, string> Set = 4;
   */
  Set: { [key: string]: string } = {};

  /**
   * Expect optionally indicates the expected state of fields prior to this update.
   *
   * @generated from field: map<string, string> Expect = 5;
   */
  Expect: { [key: string]: string } = {};

  constructor(data?: PartialMessage<PluginDataUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDataUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Plugin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Set", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "Expect", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataUpdateParams {
    return new PluginDataUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataUpdateParams {
    return new PluginDataUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataUpdateParams {
    return new PluginDataUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataUpdateParams | PlainMessage<PluginDataUpdateParams> | undefined, b: PluginDataUpdateParams | PlainMessage<PluginDataUpdateParams> | undefined): boolean {
    return proto3.util.equals(PluginDataUpdateParams, a, b);
  }
}

/**
 * RoleFilter matches role resources.
 *
 * @generated from message types.RoleFilter
 */
export class RoleFilter extends Message<RoleFilter> {
  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 1;
   */
  SearchKeywords: string[] = [];

  /**
   * SkipSystemRoles filters out teleport system roles from the results.
   *
   * @generated from field: bool SkipSystemRoles = 2;
   */
  SkipSystemRoles = false;

  constructor(data?: PartialMessage<RoleFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "SkipSystemRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleFilter {
    return new RoleFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleFilter {
    return new RoleFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleFilter {
    return new RoleFilter().fromJsonString(jsonString, options);
  }

  static equals(a: RoleFilter | PlainMessage<RoleFilter> | undefined, b: RoleFilter | PlainMessage<RoleFilter> | undefined): boolean {
    return proto3.util.equals(RoleFilter, a, b);
  }
}

/**
 * RoleV6 represents role resource specification
 *
 * @generated from message types.RoleV6
 */
export class RoleV6 extends Message<RoleV6> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`, `v4`, `v5`, `v6`, `v7`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a role specification
   *
   * @generated from field: types.RoleSpecV6 Spec = 5;
   */
  Spec?: RoleSpecV6;

  constructor(data?: PartialMessage<RoleV6>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleV6";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: RoleSpecV6 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleV6 {
    return new RoleV6().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleV6 {
    return new RoleV6().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleV6 {
    return new RoleV6().fromJsonString(jsonString, options);
  }

  static equals(a: RoleV6 | PlainMessage<RoleV6> | undefined, b: RoleV6 | PlainMessage<RoleV6> | undefined): boolean {
    return proto3.util.equals(RoleV6, a, b);
  }
}

/**
 * RoleSpecV6 is role specification for RoleV6.
 *
 * @generated from message types.RoleSpecV6
 */
export class RoleSpecV6 extends Message<RoleSpecV6> {
  /**
   * Options is for OpenSSH options like agent forwarding.
   *
   * @generated from field: types.RoleOptions Options = 1;
   */
  Options?: RoleOptions;

  /**
   * Allow is the set of conditions evaluated to grant access.
   *
   * @generated from field: types.RoleConditions Allow = 2;
   */
  Allow?: RoleConditions;

  /**
   * Deny is the set of conditions evaluated to deny access. Deny takes priority
   * over allow.
   *
   * @generated from field: types.RoleConditions Deny = 3;
   */
  Deny?: RoleConditions;

  constructor(data?: PartialMessage<RoleSpecV6>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleSpecV6";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Options", kind: "message", T: RoleOptions },
    { no: 2, name: "Allow", kind: "message", T: RoleConditions },
    { no: 3, name: "Deny", kind: "message", T: RoleConditions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleSpecV6 {
    return new RoleSpecV6().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleSpecV6 {
    return new RoleSpecV6().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleSpecV6 {
    return new RoleSpecV6().fromJsonString(jsonString, options);
  }

  static equals(a: RoleSpecV6 | PlainMessage<RoleSpecV6> | undefined, b: RoleSpecV6 | PlainMessage<RoleSpecV6> | undefined): boolean {
    return proto3.util.equals(RoleSpecV6, a, b);
  }
}

/**
 * RoleOptions is a set of role options
 *
 * @generated from message types.RoleOptions
 */
export class RoleOptions extends Message<RoleOptions> {
  /**
   * ForwardAgent is SSH agent forwarding.
   *
   * @generated from field: bool ForwardAgent = 1;
   */
  ForwardAgent = false;

  /**
   * MaxSessionTTL defines how long a SSH session can last for.
   *
   * @generated from field: int64 MaxSessionTTL = 2;
   */
  MaxSessionTTL = protoInt64.zero;

  /**
   * PortForwarding defines if the certificate will have
   * "permit-port-forwarding"
   * in the certificate. PortForwarding is "yes" if not set,
   * that's why this is a pointer
   *
   * @generated from field: types.BoolValue PortForwarding = 3;
   */
  PortForwarding?: BoolValue;

  /**
   * CertificateFormat defines the format of the user certificate to allow
   * compatibility with older versions of OpenSSH.
   *
   * @generated from field: string CertificateFormat = 4;
   */
  CertificateFormat = "";

  /**
   * ClientIdleTimeout sets disconnect clients on idle timeout behavior,
   * if set to 0 means do not disconnect, otherwise is set to the idle
   * duration.
   *
   * @generated from field: int64 ClientIdleTimeout = 5;
   */
  ClientIdleTimeout = protoInt64.zero;

  /**
   * DisconnectExpiredCert sets disconnect clients on expired certificates.
   *
   * @generated from field: bool DisconnectExpiredCert = 6;
   */
  DisconnectExpiredCert = false;

  /**
   * BPF defines what events to record for the BPF-based session recorder.
   *
   * @generated from field: repeated string BPF = 7;
   */
  BPF: string[] = [];

  /**
   * PermitX11Forwarding authorizes use of X11 forwarding.
   *
   * @generated from field: bool PermitX11Forwarding = 8;
   */
  PermitX11Forwarding = false;

  /**
   * MaxConnections defines the maximum number of
   * concurrent connections a user may hold.
   *
   * @generated from field: int64 MaxConnections = 9;
   */
  MaxConnections = protoInt64.zero;

  /**
   * MaxSessions defines the maximum number of
   * concurrent sessions per connection.
   *
   * @generated from field: int64 MaxSessions = 10;
   */
  MaxSessions = protoInt64.zero;

  /**
   * RequestAccess defines the request strategy (optional|note|always)
   * where optional is the default.
   *
   * @generated from field: string RequestAccess = 11;
   */
  RequestAccess = "";

  /**
   * RequestPrompt is an optional message which tells users what they aught to request.
   *
   * @generated from field: string RequestPrompt = 12;
   */
  RequestPrompt = "";

  /**
   * Lock specifies the locking mode (strict|best_effort) to be applied with
   * the role.
   *
   * @generated from field: string Lock = 14;
   */
  Lock = "";

  /**
   * RecordDesktopSession indicates whether desktop access sessions should be recorded.
   * It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.RecordSession RecordSession = 15;
   */
  RecordSession?: RecordSession;

  /**
   * DesktopClipboard indicates whether clipboard sharing is allowed between the user's
   * workstation and the remote desktop. It defaults to true unless explicitly set to
   * false.
   *
   * @generated from field: types.BoolValue DesktopClipboard = 16;
   */
  DesktopClipboard?: BoolValue;

  /**
   * CertExtensions specifies the key/values
   *
   * @generated from field: repeated types.CertExtension CertExtensions = 17;
   */
  CertExtensions: CertExtension[] = [];

  /**
   * MaxKubernetesConnections defines the maximum number of concurrent
   * Kubernetes sessions a user may hold.
   *
   * @generated from field: int64 MaxKubernetesConnections = 18;
   */
  MaxKubernetesConnections = protoInt64.zero;

  /**
   * DesktopDirectorySharing indicates whether directory sharing is allowed between the user's
   * workstation and the remote desktop. It defaults to false unless explicitly set to
   * true.
   *
   * @generated from field: types.BoolValue DesktopDirectorySharing = 19;
   */
  DesktopDirectorySharing?: BoolValue;

  /**
   * CreateHostUser allows users to be automatically created on a host
   *
   * @generated from field: types.BoolValue CreateHostUser = 20;
   */
  CreateHostUser?: BoolValue;

  /**
   * PinSourceIP forces the same client IP for certificate generation and usage
   *
   * @generated from field: bool PinSourceIP = 21;
   */
  PinSourceIP = false;

  /**
   * SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed
   * over an SSH session. It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.BoolValue SSHFileCopy = 22;
   */
  SSHFileCopy?: BoolValue;

  /**
   * RequireMFAType is the type of MFA requirement enforced for this user.
   * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
   * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
   *
   * @generated from field: types.RequireMFAType RequireMFAType = 23;
   */
  RequireMFAType = RequireMFAType.OFF;

  /**
   * DeviceTrustMode is the device authorization mode used for the resources
   * associated with the role.
   * See DeviceTrust.Mode.
   *
   * @generated from field: string DeviceTrustMode = 24;
   */
  DeviceTrustMode = "";

  /**
   * IDP is a set of options related to accessing IdPs within Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.IdPOptions IDP = 25;
   */
  IDP?: IdPOptions;

  /**
   * CreateDesktopUser allows users to be automatically created on a Windows desktop
   *
   * @generated from field: types.BoolValue CreateDesktopUser = 26;
   */
  CreateDesktopUser?: BoolValue;

  /**
   * CreateDatabaseUser enabled automatic database user creation.
   *
   * @generated from field: types.BoolValue CreateDatabaseUser = 27;
   */
  CreateDatabaseUser?: BoolValue;

  /**
   * CreateHostUserMode allows users to be automatically created on a
   * host when not set to off.
   * 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above),
   * 3 is "keep"; 4 is "insecure-drop".
   *
   * @generated from field: types.CreateHostUserMode CreateHostUserMode = 28;
   */
  CreateHostUserMode = CreateHostUserMode.HOST_USER_MODE_UNSPECIFIED;

  /**
   * CreateDatabaseUserMode allows users to be automatically created on a
   * database when not set to off.
   * 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
   *
   * @generated from field: types.CreateDatabaseUserMode CreateDatabaseUserMode = 29;
   */
  CreateDatabaseUserMode = CreateDatabaseUserMode.DB_USER_MODE_UNSPECIFIED;

  /**
   * MFAVerificationInterval optionally defines the maximum duration that can elapse
   * between successive MFA verifications. This variable is used to ensure
   * that users are periodically prompted to verify their identity, enhancing
   * security by preventing prolonged sessions without re-authentication when using
   * tsh proxy * derivatives.
   * It's only effective if the session requires MFA.
   * If not set, defaults to `max_session_ttl`.
   *
   * @generated from field: google.protobuf.Duration MFAVerificationInterval = 30;
   */
  MFAVerificationInterval?: Duration;

  /**
   * CreateHostUserDefaultShell is used to configure the default shell for newly provisioned host users.
   *
   * @generated from field: string CreateHostUserDefaultShell = 31;
   */
  CreateHostUserDefaultShell = "";

  constructor(data?: PartialMessage<RoleOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ForwardAgent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "MaxSessionTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "PortForwarding", kind: "message", T: BoolValue },
    { no: 4, name: "CertificateFormat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ClientIdleTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "DisconnectExpiredCert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "BPF", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "PermitX11Forwarding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "MaxConnections", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "MaxSessions", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "RequestAccess", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "RequestPrompt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "Lock", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "RecordSession", kind: "message", T: RecordSession },
    { no: 16, name: "DesktopClipboard", kind: "message", T: BoolValue },
    { no: 17, name: "CertExtensions", kind: "message", T: CertExtension, repeated: true },
    { no: 18, name: "MaxKubernetesConnections", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 19, name: "DesktopDirectorySharing", kind: "message", T: BoolValue },
    { no: 20, name: "CreateHostUser", kind: "message", T: BoolValue },
    { no: 21, name: "PinSourceIP", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "SSHFileCopy", kind: "message", T: BoolValue },
    { no: 23, name: "RequireMFAType", kind: "enum", T: proto3.getEnumType(RequireMFAType) },
    { no: 24, name: "DeviceTrustMode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 25, name: "IDP", kind: "message", T: IdPOptions },
    { no: 26, name: "CreateDesktopUser", kind: "message", T: BoolValue },
    { no: 27, name: "CreateDatabaseUser", kind: "message", T: BoolValue },
    { no: 28, name: "CreateHostUserMode", kind: "enum", T: proto3.getEnumType(CreateHostUserMode) },
    { no: 29, name: "CreateDatabaseUserMode", kind: "enum", T: proto3.getEnumType(CreateDatabaseUserMode) },
    { no: 30, name: "MFAVerificationInterval", kind: "message", T: Duration },
    { no: 31, name: "CreateHostUserDefaultShell", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleOptions {
    return new RoleOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleOptions {
    return new RoleOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleOptions {
    return new RoleOptions().fromJsonString(jsonString, options);
  }

  static equals(a: RoleOptions | PlainMessage<RoleOptions> | undefined, b: RoleOptions | PlainMessage<RoleOptions> | undefined): boolean {
    return proto3.util.equals(RoleOptions, a, b);
  }
}

/**
 * @generated from message types.RecordSession
 */
export class RecordSession extends Message<RecordSession> {
  /**
   * Desktop indicates whether desktop sessions should be recorded.
   * It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.BoolValue Desktop = 1;
   */
  Desktop?: BoolValue;

  /**
   * Default indicates the default value for the services.
   *
   * @generated from field: string Default = 2;
   */
  Default = "";

  /**
   * SSH indicates the session mode used on SSH sessions.
   *
   * @generated from field: string SSH = 3;
   */
  SSH = "";

  constructor(data?: PartialMessage<RecordSession>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RecordSession";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Desktop", kind: "message", T: BoolValue },
    { no: 2, name: "Default", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SSH", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordSession {
    return new RecordSession().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordSession {
    return new RecordSession().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordSession {
    return new RecordSession().fromJsonString(jsonString, options);
  }

  static equals(a: RecordSession | PlainMessage<RecordSession> | undefined, b: RecordSession | PlainMessage<RecordSession> | undefined): boolean {
    return proto3.util.equals(RecordSession, a, b);
  }
}

/**
 * CertExtension represents a key/value for a certificate extension
 *
 * @generated from message types.CertExtension
 */
export class CertExtension extends Message<CertExtension> {
  /**
   * Type represents the certificate type being extended, only ssh
   * is supported at this time.
   * 0 is "ssh".
   *
   * @generated from field: types.CertExtensionType Type = 1;
   */
  Type = CertExtensionType.SSH;

  /**
   * Mode is the type of extension to be used -- currently
   * critical-option is not supported.
   * 0 is "extension".
   *
   * @generated from field: types.CertExtensionMode Mode = 2;
   */
  Mode = CertExtensionMode.EXTENSION;

  /**
   * Name specifies the key to be used in the cert extension.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * Value specifies the value to be used in the cert extension.
   *
   * @generated from field: string Value = 4;
   */
  Value = "";

  constructor(data?: PartialMessage<CertExtension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CertExtension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "enum", T: proto3.getEnumType(CertExtensionType) },
    { no: 2, name: "Mode", kind: "enum", T: proto3.getEnumType(CertExtensionMode) },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertExtension {
    return new CertExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertExtension {
    return new CertExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertExtension {
    return new CertExtension().fromJsonString(jsonString, options);
  }

  static equals(a: CertExtension | PlainMessage<CertExtension> | undefined, b: CertExtension | PlainMessage<CertExtension> | undefined): boolean {
    return proto3.util.equals(CertExtension, a, b);
  }
}

/**
 * RoleConditions is a set of conditions that must all match to be allowed or
 * denied access.
 *
 * @generated from message types.RoleConditions
 */
export class RoleConditions extends Message<RoleConditions> {
  /**
   * Logins is a list of *nix system logins.
   *
   * @generated from field: repeated string Logins = 1;
   */
  Logins: string[] = [];

  /**
   * Namespaces is a list of namespaces (used to partition a cluster). The
   * field should be called "namespaces" when it returns in Teleport 2.4.
   *
   * @generated from field: repeated string Namespaces = 2;
   */
  Namespaces: string[] = [];

  /**
   * NodeLabels is a map of node labels (used to dynamically grant access to
   * nodes).
   *
   * @generated from field: wrappers.LabelValues NodeLabels = 3;
   */
  NodeLabels?: LabelValues;

  /**
   * Rules is a list of rules and their access levels. Rules are a high level
   * construct used for access control.
   *
   * @generated from field: repeated types.Rule Rules = 4;
   */
  Rules: Rule[] = [];

  /**
   * KubeGroups is a list of kubernetes groups
   *
   * @generated from field: repeated string KubeGroups = 5;
   */
  KubeGroups: string[] = [];

  /**
   * @generated from field: types.AccessRequestConditions Request = 6;
   */
  Request?: AccessRequestConditions;

  /**
   * KubeUsers is an optional kubernetes users to impersonate
   *
   * @generated from field: repeated string KubeUsers = 7;
   */
  KubeUsers: string[] = [];

  /**
   * AppLabels is a map of labels used as part of the RBAC system.
   *
   * @generated from field: wrappers.LabelValues AppLabels = 8;
   */
  AppLabels?: LabelValues;

  /**
   * ClusterLabels is a map of node labels (used to dynamically grant access to
   * clusters).
   *
   * @generated from field: wrappers.LabelValues ClusterLabels = 9;
   */
  ClusterLabels?: LabelValues;

  /**
   * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
   *
   * @generated from field: wrappers.LabelValues KubernetesLabels = 10;
   */
  KubernetesLabels?: LabelValues;

  /**
   * DatabaseLabels are used in RBAC system to allow/deny access to databases.
   *
   * @generated from field: wrappers.LabelValues DatabaseLabels = 11;
   */
  DatabaseLabels?: LabelValues;

  /**
   * DatabaseNames is a list of database names this role is allowed to connect to.
   *
   * @generated from field: repeated string DatabaseNames = 12;
   */
  DatabaseNames: string[] = [];

  /**
   * DatabaseUsers is a list of databases users this role is allowed to connect as.
   *
   * @generated from field: repeated string DatabaseUsers = 13;
   */
  DatabaseUsers: string[] = [];

  /**
   * Impersonate specifies what users and roles this role is allowed to impersonate
   * by issuing certificates or other possible means.
   *
   * @generated from field: types.ImpersonateConditions Impersonate = 14;
   */
  Impersonate?: ImpersonateConditions;

  /**
   * ReviewRequests defines conditions for submitting access reviews.
   *
   * @generated from field: types.AccessReviewConditions ReviewRequests = 15;
   */
  ReviewRequests?: AccessReviewConditions;

  /**
   * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
   *
   * @generated from field: repeated string AWSRoleARNs = 16;
   */
  AWSRoleARNs: string[] = [];

  /**
   * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
   *
   * @generated from field: repeated string WindowsDesktopLogins = 17;
   */
  WindowsDesktopLogins: string[] = [];

  /**
   * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
   *
   * @generated from field: wrappers.LabelValues WindowsDesktopLabels = 18;
   */
  WindowsDesktopLabels?: LabelValues;

  /**
   * RequireSessionJoin specifies policies for required users to start a session.
   *
   * @generated from field: repeated types.SessionRequirePolicy RequireSessionJoin = 19;
   */
  RequireSessionJoin: SessionRequirePolicy[] = [];

  /**
   * JoinSessions specifies policies to allow users to join other sessions.
   *
   * @generated from field: repeated types.SessionJoinPolicy JoinSessions = 20;
   */
  JoinSessions: SessionJoinPolicy[] = [];

  /**
   * HostGroups is a list of groups for created users to be added to
   *
   * @generated from field: repeated string HostGroups = 21;
   */
  HostGroups: string[] = [];

  /**
   * HostSudoers is a list of entries to include in a users sudoer file
   *
   * @generated from field: repeated string HostSudoers = 22;
   */
  HostSudoers: string[] = [];

  /**
   * AzureIdentities is a list of Azure identities this role is allowed to assume.
   *
   * @generated from field: repeated string AzureIdentities = 23;
   */
  AzureIdentities: string[] = [];

  /**
   * KubernetesResources is the Kubernetes Resources this Role grants access to.
   *
   * @generated from field: repeated types.KubernetesResource KubernetesResources = 24;
   */
  KubernetesResources: KubernetesResource[] = [];

  /**
   * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
   *
   * @generated from field: repeated string GCPServiceAccounts = 25;
   */
  GCPServiceAccounts: string[] = [];

  /**
   * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
   *
   * @generated from field: wrappers.LabelValues DatabaseServiceLabels = 26;
   */
  DatabaseServiceLabels?: LabelValues;

  /**
   * GroupLabels is a map of labels used as part of the RBAC system.
   *
   * @generated from field: wrappers.LabelValues GroupLabels = 27;
   */
  GroupLabels?: LabelValues;

  /**
   * DesktopGroups is a list of groups for created desktop users to be added to
   *
   * @generated from field: repeated string DesktopGroups = 28;
   */
  DesktopGroups: string[] = [];

  /**
   * DatabaseRoles is a list of databases roles for automatic user creation.
   *
   * @generated from field: repeated string DatabaseRoles = 29;
   */
  DatabaseRoles: string[] = [];

  /**
   * NodeLabelsExpression is a predicate expression used to allow/deny access to
   * SSH nodes.
   *
   * @generated from field: string NodeLabelsExpression = 30;
   */
  NodeLabelsExpression = "";

  /**
   * AppLabelsExpression is a predicate expression used to allow/deny access to
   * Apps.
   *
   * @generated from field: string AppLabelsExpression = 31;
   */
  AppLabelsExpression = "";

  /**
   * ClusterLabelsExpression is a predicate expression used to allow/deny access
   * to remote Teleport clusters.
   *
   * @generated from field: string ClusterLabelsExpression = 32;
   */
  ClusterLabelsExpression = "";

  /**
   * KubernetesLabelsExpression is a predicate expression used to allow/deny
   * access to kubernetes clusters.
   *
   * @generated from field: string KubernetesLabelsExpression = 33;
   */
  KubernetesLabelsExpression = "";

  /**
   * DatabaseLabelsExpression is a predicate expression used to allow/deny
   * access to Databases.
   *
   * @generated from field: string DatabaseLabelsExpression = 34;
   */
  DatabaseLabelsExpression = "";

  /**
   * DatabaseServiceLabelsExpression is a predicate expression used to
   * allow/deny access to Database Services.
   *
   * @generated from field: string DatabaseServiceLabelsExpression = 35;
   */
  DatabaseServiceLabelsExpression = "";

  /**
   * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny
   * access to Windows desktops.
   *
   * @generated from field: string WindowsDesktopLabelsExpression = 36;
   */
  WindowsDesktopLabelsExpression = "";

  /**
   * GroupLabelsExpression is a predicate expression used to allow/deny
   * access to user groups.
   *
   * @generated from field: string GroupLabelsExpression = 37;
   */
  GroupLabelsExpression = "";

  /**
   * DatabasePermissions specifies a set of permissions that will be granted
   * to the database user when using automatic database user provisioning.
   *
   * @generated from field: repeated types.DatabasePermission DatabasePermissions = 38;
   */
  DatabasePermissions: DatabasePermission[] = [];

  /**
   * SPIFFE is used to allow or deny access to a role holder to generating a
   * SPIFFE SVID.
   *
   * @generated from field: repeated types.SPIFFERoleCondition SPIFFE = 39;
   */
  SPIFFE: SPIFFERoleCondition[] = [];

  constructor(data?: PartialMessage<RoleConditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RoleConditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Namespaces", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "NodeLabels", kind: "message", T: LabelValues },
    { no: 4, name: "Rules", kind: "message", T: Rule, repeated: true },
    { no: 5, name: "KubeGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "Request", kind: "message", T: AccessRequestConditions },
    { no: 7, name: "KubeUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "AppLabels", kind: "message", T: LabelValues },
    { no: 9, name: "ClusterLabels", kind: "message", T: LabelValues },
    { no: 10, name: "KubernetesLabels", kind: "message", T: LabelValues },
    { no: 11, name: "DatabaseLabels", kind: "message", T: LabelValues },
    { no: 12, name: "DatabaseNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "DatabaseUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "Impersonate", kind: "message", T: ImpersonateConditions },
    { no: 15, name: "ReviewRequests", kind: "message", T: AccessReviewConditions },
    { no: 16, name: "AWSRoleARNs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 17, name: "WindowsDesktopLogins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 18, name: "WindowsDesktopLabels", kind: "message", T: LabelValues },
    { no: 19, name: "RequireSessionJoin", kind: "message", T: SessionRequirePolicy, repeated: true },
    { no: 20, name: "JoinSessions", kind: "message", T: SessionJoinPolicy, repeated: true },
    { no: 21, name: "HostGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 22, name: "HostSudoers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 23, name: "AzureIdentities", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 24, name: "KubernetesResources", kind: "message", T: KubernetesResource, repeated: true },
    { no: 25, name: "GCPServiceAccounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 26, name: "DatabaseServiceLabels", kind: "message", T: LabelValues },
    { no: 27, name: "GroupLabels", kind: "message", T: LabelValues },
    { no: 28, name: "DesktopGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 29, name: "DatabaseRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 30, name: "NodeLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 31, name: "AppLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 32, name: "ClusterLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 33, name: "KubernetesLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 34, name: "DatabaseLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 35, name: "DatabaseServiceLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 36, name: "WindowsDesktopLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 37, name: "GroupLabelsExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 38, name: "DatabasePermissions", kind: "message", T: DatabasePermission, repeated: true },
    { no: 39, name: "SPIFFE", kind: "message", T: SPIFFERoleCondition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleConditions {
    return new RoleConditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleConditions {
    return new RoleConditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleConditions {
    return new RoleConditions().fromJsonString(jsonString, options);
  }

  static equals(a: RoleConditions | PlainMessage<RoleConditions> | undefined, b: RoleConditions | PlainMessage<RoleConditions> | undefined): boolean {
    return proto3.util.equals(RoleConditions, a, b);
  }
}

/**
 * SPIFFERoleCondition sets out which SPIFFE identities this role is allowed or
 * denied to generate. The Path matcher is required, and is evaluated first. If,
 * the Path does not match then the other matcher fields are not evaluated.
 *
 * @generated from message types.SPIFFERoleCondition
 */
export class SPIFFERoleCondition extends Message<SPIFFERoleCondition> {
  /**
   * Path specifies a matcher for the SPIFFE ID path. It should not include the
   * trust domain and should start with a leading slash.
   *
   * The matcher by default allows '*' to be used to indicate zero or more of
   * any character. Prepend '^' and append '$' to instead switch to matching
   * using the Go regex syntax.
   *
   * Example:
   * - /svc/foo/*\/bar would match /svc/foo/baz/bar
   * - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
   *
   * @generated from field: string Path = 1;
   */
  Path = "";

  /**
   * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.
   *
   * Each requested DNS SAN is compared against all matchers configured and if
   * any match, the condition is considered to be met.
   *
   * The matcher by default allows '*' to be used to indicate zero or more of
   * any character. Prepend '^' and append '$' to instead switch to matching
   * using the Go regex syntax.
   *
   * Example: *.example.com would match foo.example.com
   *
   * @generated from field: repeated string DNSSANs = 2;
   */
  DNSSANs: string[] = [];

  /**
   * IPSANs specifies matchers for the SPIFFE ID IP SANs.
   *
   * Each requested IP SAN is compared against all matchers configured and if
   * any match, the condition is considered to be met.
   *
   * The matchers should be specified using CIDR notation, it supports IPv4 and
   * IPv6.
   *
   * Examples:
   * - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255
   * - 10.0.0.42/32 would match only 10.0.0.42
   *
   * @generated from field: repeated string IPSANs = 3;
   */
  IPSANs: string[] = [];

  constructor(data?: PartialMessage<SPIFFERoleCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SPIFFERoleCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DNSSANs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "IPSANs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SPIFFERoleCondition {
    return new SPIFFERoleCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SPIFFERoleCondition {
    return new SPIFFERoleCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SPIFFERoleCondition {
    return new SPIFFERoleCondition().fromJsonString(jsonString, options);
  }

  static equals(a: SPIFFERoleCondition | PlainMessage<SPIFFERoleCondition> | undefined, b: SPIFFERoleCondition | PlainMessage<SPIFFERoleCondition> | undefined): boolean {
    return proto3.util.equals(SPIFFERoleCondition, a, b);
  }
}

/**
 * DatabasePermission specifies the database object permission for the user.
 *
 * @generated from message types.DatabasePermission
 */
export class DatabasePermission extends Message<DatabasePermission> {
  /**
   * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
   *
   * @generated from field: repeated string Permissions = 1;
   */
  Permissions: string[] = [];

  /**
   * Match is a list of object labels that must be matched for the permission to be granted.
   *
   * @generated from field: wrappers.LabelValues Match = 2;
   */
  Match?: LabelValues;

  constructor(data?: PartialMessage<DatabasePermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabasePermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Permissions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Match", kind: "message", T: LabelValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabasePermission {
    return new DatabasePermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabasePermission {
    return new DatabasePermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabasePermission {
    return new DatabasePermission().fromJsonString(jsonString, options);
  }

  static equals(a: DatabasePermission | PlainMessage<DatabasePermission> | undefined, b: DatabasePermission | PlainMessage<DatabasePermission> | undefined): boolean {
    return proto3.util.equals(DatabasePermission, a, b);
  }
}

/**
 * KubernetesResource is the Kubernetes resource identifier.
 *
 * @generated from message types.KubernetesResource
 */
export class KubernetesResource extends Message<KubernetesResource> {
  /**
   * Kind specifies the Kubernetes Resource type.
   * At the moment only "pod" is supported.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * Namespace is the resource namespace.
   * It supports wildcards.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace = "";

  /**
   * Name is the resource name.
   * It supports wildcards.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * Verbs are the allowed Kubernetes verbs for the following resource.
   *
   * @generated from field: repeated string Verbs = 4;
   */
  Verbs: string[] = [];

  constructor(data?: PartialMessage<KubernetesResource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesResource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Verbs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesResource {
    return new KubernetesResource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesResource {
    return new KubernetesResource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesResource {
    return new KubernetesResource().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesResource | PlainMessage<KubernetesResource> | undefined, b: KubernetesResource | PlainMessage<KubernetesResource> | undefined): boolean {
    return proto3.util.equals(KubernetesResource, a, b);
  }
}

/**
 * SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.
 *
 * @generated from message types.SessionRequirePolicy
 */
export class SessionRequirePolicy extends Message<SessionRequirePolicy> {
  /**
   * Name is the name of the policy.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Filter is a predicate that determines what users count towards this policy.
   *
   * @generated from field: string Filter = 2;
   */
  Filter = "";

  /**
   * Kinds are the session kinds this policy applies to.
   *
   * @generated from field: repeated string Kinds = 3;
   */
  Kinds: string[] = [];

  /**
   * Count is the amount of people that need to be matched for this policy to be fulfilled.
   *
   * @generated from field: int32 Count = 4;
   */
  Count = 0;

  /**
   * Modes is the list of modes that may be used to fulfill this policy.
   *
   * @generated from field: repeated string Modes = 5;
   */
  Modes: string[] = [];

  /**
   * OnLeave is the behaviour that's used when the policy is no longer fulfilled
   * for a live session.
   *
   * @generated from field: string OnLeave = 6;
   */
  OnLeave = "";

  constructor(data?: PartialMessage<SessionRequirePolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionRequirePolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "Count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "Modes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "OnLeave", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionRequirePolicy {
    return new SessionRequirePolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionRequirePolicy {
    return new SessionRequirePolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionRequirePolicy {
    return new SessionRequirePolicy().fromJsonString(jsonString, options);
  }

  static equals(a: SessionRequirePolicy | PlainMessage<SessionRequirePolicy> | undefined, b: SessionRequirePolicy | PlainMessage<SessionRequirePolicy> | undefined): boolean {
    return proto3.util.equals(SessionRequirePolicy, a, b);
  }
}

/**
 * SessionJoinPolicy defines a policy that allows a user to join sessions.
 *
 * @generated from message types.SessionJoinPolicy
 */
export class SessionJoinPolicy extends Message<SessionJoinPolicy> {
  /**
   * Name is the name of the policy.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Roles is a list of roles that you can join the session of.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * Kinds are the session kinds this policy applies to.
   *
   * @generated from field: repeated string Kinds = 3;
   */
  Kinds: string[] = [];

  /**
   * Modes is a list of permitted participant modes for this policy.
   *
   * @generated from field: repeated string Modes = 4;
   */
  Modes: string[] = [];

  constructor(data?: PartialMessage<SessionJoinPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionJoinPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "Modes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionJoinPolicy {
    return new SessionJoinPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionJoinPolicy {
    return new SessionJoinPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionJoinPolicy {
    return new SessionJoinPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: SessionJoinPolicy | PlainMessage<SessionJoinPolicy> | undefined, b: SessionJoinPolicy | PlainMessage<SessionJoinPolicy> | undefined): boolean {
    return proto3.util.equals(SessionJoinPolicy, a, b);
  }
}

/**
 * AccessRequestConditions is a matcher for allow/deny restrictions on
 * access-requests.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from message types.AccessRequestConditions
 */
export class AccessRequestConditions extends Message<AccessRequestConditions> {
  /**
   * Roles is the name of roles which will match the request rule.
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[] = [];

  /**
   * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 2;
   */
  ClaimsToRoles: ClaimMapping[] = [];

  /**
   * Annotations is a collection of annotations to be programmatically
   * appended to pending access requests at the time of their creation.
   * These annotations serve as a mechanism to propagate extra information
   * to plugins.  Since these annotations support variable interpolation
   * syntax, they also offer a mechanism for forwarding claims from an
   * external identity provider, to a plugin via `{{external.trait_name}}`
   * style substitutions.
   *
   * @generated from field: wrappers.LabelValues Annotations = 3;
   */
  Annotations?: LabelValues;

  /**
   * Thresholds is a list of thresholds, one of which must be met in order for reviews
   * to trigger a state-transition.  If no thresholds are provided, a default threshold
   * of 1 for approval and denial is used.
   *
   * @generated from field: repeated types.AccessReviewThreshold Thresholds = 4;
   */
  Thresholds: AccessReviewThreshold[] = [];

  /**
   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
   * that is not a requirement.
   *
   * @generated from field: repeated string SuggestedReviewers = 5;
   */
  SuggestedReviewers: string[] = [];

  /**
   * SearchAsRoles is a list of extra roles which should apply to a user while
   * they are searching for resources as part of a Resource Access Request, and
   * defines the underlying roles which will be requested as part of any
   * Resource Access Request.
   *
   * @generated from field: repeated string SearchAsRoles = 6;
   */
  SearchAsRoles: string[] = [];

  /**
   * MaxDuration is the amount of time the access will be granted for.
   * If this is zero, the default duration is used.
   *
   * @generated from field: int64 MaxDuration = 7;
   */
  MaxDuration = protoInt64.zero;

  constructor(data?: PartialMessage<AccessRequestConditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestConditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "ClaimsToRoles", kind: "message", T: ClaimMapping, repeated: true },
    { no: 3, name: "Annotations", kind: "message", T: LabelValues },
    { no: 4, name: "Thresholds", kind: "message", T: AccessReviewThreshold, repeated: true },
    { no: 5, name: "SuggestedReviewers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "SearchAsRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "MaxDuration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestConditions {
    return new AccessRequestConditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestConditions {
    return new AccessRequestConditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestConditions {
    return new AccessRequestConditions().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestConditions | PlainMessage<AccessRequestConditions> | undefined, b: AccessRequestConditions | PlainMessage<AccessRequestConditions> | undefined): boolean {
    return proto3.util.equals(AccessRequestConditions, a, b);
  }
}

/**
 * AccessReviewConditions is a matcher for allow/deny restrictions on
 * access reviews.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from message types.AccessReviewConditions
 */
export class AccessReviewConditions extends Message<AccessReviewConditions> {
  /**
   * Roles is the name of roles which may be reviewed.
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[] = [];

  /**
   * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 2;
   */
  ClaimsToRoles: ClaimMapping[] = [];

  /**
   * Where is an optional predicate which further limits which requests are
   * reviewable.
   *
   * @generated from field: string Where = 3;
   */
  Where = "";

  /**
   * PreviewAsRoles is a list of extra roles which should apply to a reviewer
   * while they are viewing a Resource Access Request for the purposes of
   * viewing details such as the hostname and labels of requested resources.
   *
   * @generated from field: repeated string PreviewAsRoles = 4;
   */
  PreviewAsRoles: string[] = [];

  constructor(data?: PartialMessage<AccessReviewConditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessReviewConditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "ClaimsToRoles", kind: "message", T: ClaimMapping, repeated: true },
    { no: 3, name: "Where", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "PreviewAsRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessReviewConditions {
    return new AccessReviewConditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessReviewConditions {
    return new AccessReviewConditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessReviewConditions {
    return new AccessReviewConditions().fromJsonString(jsonString, options);
  }

  static equals(a: AccessReviewConditions | PlainMessage<AccessReviewConditions> | undefined, b: AccessReviewConditions | PlainMessage<AccessReviewConditions> | undefined): boolean {
    return proto3.util.equals(AccessReviewConditions, a, b);
  }
}

/**
 * AccessRequestAllowedPromotion describes an allowed promotion to an access list.
 *
 * @generated from message types.AccessRequestAllowedPromotion
 */
export class AccessRequestAllowedPromotion extends Message<AccessRequestAllowedPromotion> {
  /**
   * associated access list
   *
   * @generated from field: string accessListName = 1;
   */
  accessListName = "";

  constructor(data?: PartialMessage<AccessRequestAllowedPromotion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestAllowedPromotion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accessListName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestAllowedPromotion {
    return new AccessRequestAllowedPromotion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotion {
    return new AccessRequestAllowedPromotion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotion {
    return new AccessRequestAllowedPromotion().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestAllowedPromotion | PlainMessage<AccessRequestAllowedPromotion> | undefined, b: AccessRequestAllowedPromotion | PlainMessage<AccessRequestAllowedPromotion> | undefined): boolean {
    return proto3.util.equals(AccessRequestAllowedPromotion, a, b);
  }
}

/**
 * AccessRequestAllowedPromotions describes an valid promotion from an access request
 * to an access list.
 *
 * @generated from message types.AccessRequestAllowedPromotions
 */
export class AccessRequestAllowedPromotions extends Message<AccessRequestAllowedPromotions> {
  /**
   * suggestions is a list of allowed access lists promotions.
   *
   * @generated from field: repeated types.AccessRequestAllowedPromotion promotions = 1;
   */
  promotions: AccessRequestAllowedPromotion[] = [];

  constructor(data?: PartialMessage<AccessRequestAllowedPromotions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessRequestAllowedPromotions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "promotions", kind: "message", T: AccessRequestAllowedPromotion, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestAllowedPromotions {
    return new AccessRequestAllowedPromotions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotions {
    return new AccessRequestAllowedPromotions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotions {
    return new AccessRequestAllowedPromotions().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestAllowedPromotions | PlainMessage<AccessRequestAllowedPromotions> | undefined, b: AccessRequestAllowedPromotions | PlainMessage<AccessRequestAllowedPromotions> | undefined): boolean {
    return proto3.util.equals(AccessRequestAllowedPromotions, a, b);
  }
}

/**
 * ClaimMapping maps a claim to teleport roles.
 *
 * @generated from message types.ClaimMapping
 */
export class ClaimMapping extends Message<ClaimMapping> {
  /**
   * Claim is a claim name.
   *
   * @generated from field: string Claim = 1;
   */
  Claim = "";

  /**
   * Value is a claim value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value = "";

  /**
   * Roles is a list of static teleport roles to match.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<ClaimMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClaimMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Claim", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClaimMapping {
    return new ClaimMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClaimMapping {
    return new ClaimMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClaimMapping {
    return new ClaimMapping().fromJsonString(jsonString, options);
  }

  static equals(a: ClaimMapping | PlainMessage<ClaimMapping> | undefined, b: ClaimMapping | PlainMessage<ClaimMapping> | undefined): boolean {
    return proto3.util.equals(ClaimMapping, a, b);
  }
}

/**
 * TraitMapping maps a trait to teleport roles.
 *
 * @generated from message types.TraitMapping
 */
export class TraitMapping extends Message<TraitMapping> {
  /**
   * Trait is a trait name.
   *
   * @generated from field: string Trait = 1;
   */
  Trait = "";

  /**
   * Value is a trait value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value = "";

  /**
   * Roles is a list of static teleport roles to match.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<TraitMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TraitMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Trait", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TraitMapping {
    return new TraitMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TraitMapping {
    return new TraitMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TraitMapping {
    return new TraitMapping().fromJsonString(jsonString, options);
  }

  static equals(a: TraitMapping | PlainMessage<TraitMapping> | undefined, b: TraitMapping | PlainMessage<TraitMapping> | undefined): boolean {
    return proto3.util.equals(TraitMapping, a, b);
  }
}

/**
 * Rule represents allow or deny rule that is executed to check
 * if user or service have access to resource
 *
 * @generated from message types.Rule
 */
export class Rule extends Message<Rule> {
  /**
   * Resources is a list of resources
   *
   * @generated from field: repeated string Resources = 1;
   */
  Resources: string[] = [];

  /**
   * Verbs is a list of verbs
   *
   * @generated from field: repeated string Verbs = 2;
   */
  Verbs: string[] = [];

  /**
   * Where specifies optional advanced matcher
   *
   * @generated from field: string Where = 3;
   */
  Where = "";

  /**
   * Actions specifies optional actions taken when this rule matches
   *
   * @generated from field: repeated string Actions = 4;
   */
  Actions: string[] = [];

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Resources", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Verbs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Where", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Actions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 * ImpersonateConditions specifies whether users are allowed
 * to issue certificates for other users or groups.
 *
 * @generated from message types.ImpersonateConditions
 */
export class ImpersonateConditions extends Message<ImpersonateConditions> {
  /**
   * Users is a list of resources this role is allowed to impersonate,
   * could be an empty list or a Wildcard pattern
   *
   * @generated from field: repeated string Users = 1;
   */
  Users: string[] = [];

  /**
   * Roles is a list of resources this role is allowed to impersonate
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * Where specifies optional advanced matcher
   *
   * @generated from field: string Where = 3;
   */
  Where = "";

  constructor(data?: PartialMessage<ImpersonateConditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ImpersonateConditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Users", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Where", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImpersonateConditions {
    return new ImpersonateConditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImpersonateConditions {
    return new ImpersonateConditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImpersonateConditions {
    return new ImpersonateConditions().fromJsonString(jsonString, options);
  }

  static equals(a: ImpersonateConditions | PlainMessage<ImpersonateConditions> | undefined, b: ImpersonateConditions | PlainMessage<ImpersonateConditions> | undefined): boolean {
    return proto3.util.equals(ImpersonateConditions, a, b);
  }
}

/**
 * BoolValue is a wrapper around bool, used in cases
 * whenever bool value can have different default value when missing
 *
 * @generated from message types.BoolValue
 */
export class BoolValue extends Message<BoolValue> {
  /**
   * @generated from field: bool Value = 1;
   */
  Value = false;

  constructor(data?: PartialMessage<BoolValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.BoolValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolValue {
    return new BoolValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolValue {
    return new BoolValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolValue {
    return new BoolValue().fromJsonString(jsonString, options);
  }

  static equals(a: BoolValue | PlainMessage<BoolValue> | undefined, b: BoolValue | PlainMessage<BoolValue> | undefined): boolean {
    return proto3.util.equals(BoolValue, a, b);
  }
}

/**
 * UserFilter matches user resources.
 *
 * @generated from message types.UserFilter
 */
export class UserFilter extends Message<UserFilter> {
  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 1;
   */
  SearchKeywords: string[] = [];

  constructor(data?: PartialMessage<UserFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserFilter {
    return new UserFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserFilter {
    return new UserFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserFilter {
    return new UserFilter().fromJsonString(jsonString, options);
  }

  static equals(a: UserFilter | PlainMessage<UserFilter> | undefined, b: UserFilter | PlainMessage<UserFilter> | undefined): boolean {
    return proto3.util.equals(UserFilter, a, b);
  }
}

/**
 * UserV2 is version 2 resource spec of the user
 *
 * @generated from message types.UserV2
 */
export class UserV2 extends Message<UserV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a user specification
   *
   * @generated from field: types.UserSpecV2 Spec = 5;
   */
  Spec?: UserSpecV2;

  /**
   * @generated from field: types.UserStatusV2 Status = 6;
   */
  Status?: UserStatusV2;

  constructor(data?: PartialMessage<UserV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: UserSpecV2 },
    { no: 6, name: "Status", kind: "message", T: UserStatusV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserV2 {
    return new UserV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserV2 {
    return new UserV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserV2 {
    return new UserV2().fromJsonString(jsonString, options);
  }

  static equals(a: UserV2 | PlainMessage<UserV2> | undefined, b: UserV2 | PlainMessage<UserV2> | undefined): boolean {
    return proto3.util.equals(UserV2, a, b);
  }
}

/**
 * UserStatusV2 is a dynamic state of UserV2.
 *
 * @generated from message types.UserStatusV2
 */
export class UserStatusV2 extends Message<UserStatusV2> {
  /**
   * password_state reflects what the system knows about the user's password.
   * Note that this is a "best effort" property, in that it can be UNSPECIFIED
   * for users who were created before this property was introduced and didn't
   * perform any password-related activity since then. See RFD 0159 for
   * details. Do NOT use this value for authentication purposes!
   *
   * @generated from field: types.PasswordState password_state = 1;
   */
  passwordState = PasswordState.UNSPECIFIED;

  constructor(data?: PartialMessage<UserStatusV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserStatusV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "password_state", kind: "enum", T: proto3.getEnumType(PasswordState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserStatusV2 {
    return new UserStatusV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserStatusV2 {
    return new UserStatusV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserStatusV2 {
    return new UserStatusV2().fromJsonString(jsonString, options);
  }

  static equals(a: UserStatusV2 | PlainMessage<UserStatusV2> | undefined, b: UserStatusV2 | PlainMessage<UserStatusV2> | undefined): boolean {
    return proto3.util.equals(UserStatusV2, a, b);
  }
}

/**
 * UserSpecV2 is a specification for V2 user
 *
 * @generated from message types.UserSpecV2
 */
export class UserSpecV2 extends Message<UserSpecV2> {
  /**
   * OIDCIdentities lists associated OpenID Connect identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity OIDCIdentities = 1;
   */
  OIDCIdentities: ExternalIdentity[] = [];

  /**
   * SAMLIdentities lists associated SAML identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity SAMLIdentities = 2;
   */
  SAMLIdentities: ExternalIdentity[] = [];

  /**
   * GithubIdentities list associated Github OAuth2 identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity GithubIdentities = 3;
   */
  GithubIdentities: ExternalIdentity[] = [];

  /**
   * Roles is a list of roles assigned to user
   *
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[] = [];

  /**
   * Traits are key/value pairs received from an identity provider (through
   * OIDC claims or SAML assertions) or from a system administrator for local
   * accounts. Traits are used to populate role variables.
   *
   * @generated from field: wrappers.LabelValues Traits = 5;
   */
  Traits?: LabelValues;

  /**
   * Status is a login status of the user
   *
   * @generated from field: types.LoginStatus Status = 6;
   */
  Status?: LoginStatus;

  /**
   * Expires if set sets TTL on the user
   *
   * @generated from field: google.protobuf.Timestamp Expires = 7;
   */
  Expires?: Timestamp;

  /**
   * CreatedBy holds information about agent or person created this user
   *
   * @generated from field: types.CreatedBy CreatedBy = 8;
   */
  CreatedBy?: CreatedBy;

  /**
   * LocalAuth holds sensitive data necessary for performing local
   * authentication
   *
   * @generated from field: types.LocalAuthSecrets LocalAuth = 9;
   */
  LocalAuth?: LocalAuthSecrets;

  /**
   * TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.
   *
   * Note that SSO users are transient and thus may contain an empty
   * TrustedDeviceIDs field, even though the user->device association exists
   * under the Device Trust subsystem. Do not rely on this field to determine
   * device associations or ownership, it exists for legacy/informative purposes
   * only.
   *
   * Managed by the Device Trust subsystem, avoid manual edits.
   *
   * @generated from field: repeated string TrustedDeviceIDs = 10;
   */
  TrustedDeviceIDs: string[] = [];

  constructor(data?: PartialMessage<UserSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "OIDCIdentities", kind: "message", T: ExternalIdentity, repeated: true },
    { no: 2, name: "SAMLIdentities", kind: "message", T: ExternalIdentity, repeated: true },
    { no: 3, name: "GithubIdentities", kind: "message", T: ExternalIdentity, repeated: true },
    { no: 4, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Traits", kind: "message", T: LabelValues },
    { no: 6, name: "Status", kind: "message", T: LoginStatus },
    { no: 7, name: "Expires", kind: "message", T: Timestamp },
    { no: 8, name: "CreatedBy", kind: "message", T: CreatedBy },
    { no: 9, name: "LocalAuth", kind: "message", T: LocalAuthSecrets },
    { no: 10, name: "TrustedDeviceIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSpecV2 {
    return new UserSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSpecV2 {
    return new UserSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSpecV2 {
    return new UserSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: UserSpecV2 | PlainMessage<UserSpecV2> | undefined, b: UserSpecV2 | PlainMessage<UserSpecV2> | undefined): boolean {
    return proto3.util.equals(UserSpecV2, a, b);
  }
}

/**
 * ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
 * to particular user and connector and lets user to log in using external
 * credentials, e.g. google
 *
 * @generated from message types.ExternalIdentity
 */
export class ExternalIdentity extends Message<ExternalIdentity> {
  /**
   * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID = "";

  /**
   * Username is username supplied by external identity provider
   *
   * @generated from field: string Username = 2;
   */
  Username = "";

  /**
   * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
   *
   * @generated from field: string SAMLSingleLogoutURL = 3;
   */
  SAMLSingleLogoutURL = "";

  constructor(data?: PartialMessage<ExternalIdentity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ExternalIdentity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ConnectorID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SAMLSingleLogoutURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalIdentity {
    return new ExternalIdentity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalIdentity {
    return new ExternalIdentity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalIdentity {
    return new ExternalIdentity().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalIdentity | PlainMessage<ExternalIdentity> | undefined, b: ExternalIdentity | PlainMessage<ExternalIdentity> | undefined): boolean {
    return proto3.util.equals(ExternalIdentity, a, b);
  }
}

/**
 * LoginStatus is a login status of the user
 *
 * @generated from message types.LoginStatus
 */
export class LoginStatus extends Message<LoginStatus> {
  /**
   * IsLocked tells us if user is locked
   *
   * @generated from field: bool IsLocked = 1;
   */
  IsLocked = false;

  /**
   * LockedMessage contains the message in case if user is locked
   *
   * @generated from field: string LockedMessage = 2;
   */
  LockedMessage = "";

  /**
   * LockedTime contains time when user was locked
   *
   * @generated from field: google.protobuf.Timestamp LockedTime = 3;
   */
  LockedTime?: Timestamp;

  /**
   * LockExpires contains time when this lock will expire
   *
   * @generated from field: google.protobuf.Timestamp LockExpires = 4;
   */
  LockExpires?: Timestamp;

  constructor(data?: PartialMessage<LoginStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.LoginStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "IsLocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "LockedMessage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "LockedTime", kind: "message", T: Timestamp },
    { no: 4, name: "LockExpires", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginStatus {
    return new LoginStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginStatus {
    return new LoginStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginStatus {
    return new LoginStatus().fromJsonString(jsonString, options);
  }

  static equals(a: LoginStatus | PlainMessage<LoginStatus> | undefined, b: LoginStatus | PlainMessage<LoginStatus> | undefined): boolean {
    return proto3.util.equals(LoginStatus, a, b);
  }
}

/**
 * CreatedBy holds information about the person or agent who created the user
 *
 * @generated from message types.CreatedBy
 */
export class CreatedBy extends Message<CreatedBy> {
  /**
   * Identity if present means that user was automatically created by identity
   *
   * @generated from field: types.ConnectorRef Connector = 1;
   */
  Connector?: ConnectorRef;

  /**
   * Time specifies when user was created
   *
   * @generated from field: google.protobuf.Timestamp Time = 2;
   */
  Time?: Timestamp;

  /**
   * User holds information about user
   *
   * @generated from field: types.UserRef User = 3;
   */
  User?: UserRef;

  constructor(data?: PartialMessage<CreatedBy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CreatedBy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: ConnectorRef },
    { no: 2, name: "Time", kind: "message", T: Timestamp },
    { no: 3, name: "User", kind: "message", T: UserRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatedBy {
    return new CreatedBy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatedBy {
    return new CreatedBy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatedBy {
    return new CreatedBy().fromJsonString(jsonString, options);
  }

  static equals(a: CreatedBy | PlainMessage<CreatedBy> | undefined, b: CreatedBy | PlainMessage<CreatedBy> | undefined): boolean {
    return proto3.util.equals(CreatedBy, a, b);
  }
}

/**
 * LocalAuthSecrets holds sensitive data used to authenticate a local user.
 *
 * @generated from message types.LocalAuthSecrets
 */
export class LocalAuthSecrets extends Message<LocalAuthSecrets> {
  /**
   * PasswordHash encodes a combined salt & hash for password verification.
   *
   * @generated from field: bytes PasswordHash = 1;
   */
  PasswordHash = new Uint8Array(0);

  /**
   * Deprecated 2nd factor fields, use MFA below instead.
   *
   * @generated from field: string TOTPKey = 2;
   */
  TOTPKey = "";

  /**
   * @generated from field: repeated types.MFADevice MFA = 5;
   */
  MFA: MFADevice[] = [];

  /**
   * Webauthn holds settings necessary for webauthn local auth.
   * May be null for legacy users or users that haven't yet used webauthn as
   * their second factor.
   *
   * @generated from field: types.WebauthnLocalAuth Webauthn = 6;
   */
  Webauthn?: WebauthnLocalAuth;

  constructor(data?: PartialMessage<LocalAuthSecrets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.LocalAuthSecrets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PasswordHash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "TOTPKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "MFA", kind: "message", T: MFADevice, repeated: true },
    { no: 6, name: "Webauthn", kind: "message", T: WebauthnLocalAuth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalAuthSecrets {
    return new LocalAuthSecrets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalAuthSecrets {
    return new LocalAuthSecrets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalAuthSecrets {
    return new LocalAuthSecrets().fromJsonString(jsonString, options);
  }

  static equals(a: LocalAuthSecrets | PlainMessage<LocalAuthSecrets> | undefined, b: LocalAuthSecrets | PlainMessage<LocalAuthSecrets> | undefined): boolean {
    return proto3.util.equals(LocalAuthSecrets, a, b);
  }
}

/**
 * MFADevice is a multi-factor authentication device, such as a security key or
 * an OTP app.
 *
 * @generated from message types.MFADevice
 */
export class MFADevice extends Message<MFADevice> {
  /**
   * Boilerplate for implementing the Resource interface.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * @generated from field: string sub_kind = 2;
   */
  subKind = "";

  /**
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * @generated from field: types.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * ID is a UUID of this device.
   *
   * @generated from field: string id = 5;
   */
  id = "";

  /**
   * @generated from field: google.protobuf.Timestamp added_at = 6;
   */
  addedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_used = 7;
   */
  lastUsed?: Timestamp;

  /**
   * @generated from oneof types.MFADevice.device
   */
  device: {
    /**
     * @generated from field: types.TOTPDevice totp = 8;
     */
    value: TOTPDevice;
    case: "totp";
  } | {
    /**
     * @generated from field: types.U2FDevice u2f = 9;
     */
    value: U2FDevice;
    case: "u2f";
  } | {
    /**
     * @generated from field: types.WebauthnDevice webauthn = 10;
     */
    value: WebauthnDevice;
    case: "webauthn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MFADevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MFADevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "added_at", kind: "message", T: Timestamp },
    { no: 7, name: "last_used", kind: "message", T: Timestamp },
    { no: 8, name: "totp", kind: "message", T: TOTPDevice, oneof: "device" },
    { no: 9, name: "u2f", kind: "message", T: U2FDevice, oneof: "device" },
    { no: 10, name: "webauthn", kind: "message", T: WebauthnDevice, oneof: "device" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFADevice {
    return new MFADevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFADevice {
    return new MFADevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFADevice {
    return new MFADevice().fromJsonString(jsonString, options);
  }

  static equals(a: MFADevice | PlainMessage<MFADevice> | undefined, b: MFADevice | PlainMessage<MFADevice> | undefined): boolean {
    return proto3.util.equals(MFADevice, a, b);
  }
}

/**
 * TOTPDevice holds the TOTP-specific fields of MFADevice.
 *
 * @generated from message types.TOTPDevice
 */
export class TOTPDevice extends Message<TOTPDevice> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<TOTPDevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TOTPDevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTPDevice {
    return new TOTPDevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTPDevice {
    return new TOTPDevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTPDevice {
    return new TOTPDevice().fromJsonString(jsonString, options);
  }

  static equals(a: TOTPDevice | PlainMessage<TOTPDevice> | undefined, b: TOTPDevice | PlainMessage<TOTPDevice> | undefined): boolean {
    return proto3.util.equals(TOTPDevice, a, b);
  }
}

/**
 * U2FDevice holds the U2F-specific fields of MFADevice.
 *
 * @generated from message types.U2FDevice
 */
export class U2FDevice extends Message<U2FDevice> {
  /**
   * KeyHandle uniquely identifies a key on a device
   *
   * @generated from field: bytes key_handle = 1;
   */
  keyHandle = new Uint8Array(0);

  /**
   * PubKey is an DER encoded ecdsa public key
   *
   * @generated from field: bytes pub_key = 2;
   */
  pubKey = new Uint8Array(0);

  /**
   * Counter is the latest seen value of the U2F usage counter.
   *
   * @generated from field: uint32 counter = 3;
   */
  counter = 0;

  constructor(data?: PartialMessage<U2FDevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.U2FDevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_handle", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "pub_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "counter", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): U2FDevice {
    return new U2FDevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): U2FDevice {
    return new U2FDevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): U2FDevice {
    return new U2FDevice().fromJsonString(jsonString, options);
  }

  static equals(a: U2FDevice | PlainMessage<U2FDevice> | undefined, b: U2FDevice | PlainMessage<U2FDevice> | undefined): boolean {
    return proto3.util.equals(U2FDevice, a, b);
  }
}

/**
 * WebauthnDevice holds Webauthn-specific fields of MFADevice.
 *
 * @generated from message types.WebauthnDevice
 */
export class WebauthnDevice extends Message<WebauthnDevice> {
  /**
   * Credential ID for the authenticator.
   *
   * @generated from field: bytes credential_id = 1;
   */
  credentialId = new Uint8Array(0);

  /**
   * Public key encoded in CBOR format.
   * Webauthn support various key algorithms; CBOR encoding is used to reflect
   * those choices.
   * See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
   * reference.
   *
   * @generated from field: bytes public_key_cbor = 2;
   */
  publicKeyCbor = new Uint8Array(0);

  /**
   * Attestation format used by the authenticator, if any.
   *
   * @generated from field: string attestation_type = 3;
   */
  attestationType = "";

  /**
   * AAGUID is the globally unique identifier of the authenticator model.
   * Zeroed for U2F devices.
   *
   * @generated from field: bytes aaguid = 4;
   */
  aaguid = new Uint8Array(0);

  /**
   * Signature counter for login operations.
   * Actual counter values received from the authenticator are expected to be
   * higher than the previously-stored value.
   *
   * @generated from field: uint32 signature_counter = 5;
   */
  signatureCounter = 0;

  /**
   * Raw attestation object, as returned by the authentication during
   * registration.
   * Absent for legacy entries (Teleport 8.x).
   *
   * @generated from field: bytes attestation_object = 6;
   */
  attestationObject = new Uint8Array(0);

  /**
   * True if a resident key was requested during registration.
   * Marks passwordless-capable devices.
   * (Note that resident_key=true represents the server-side / Relying Party
   * view of the registration process; the authenticator alone can determine
   * if a key is truly resident.)
   *
   * @generated from field: bool resident_key = 7;
   */
  residentKey = false;

  /**
   * Relying Party ID used by the credential.
   * Recorded on registration for new credentials, or on first successful
   * authentication for "old" credentials (created before the field existed).
   * Ideally, this is always the same as the configured RPID.
   * If an RPID change does happen, this helps Teleport detect it and react
   * accordingly.
   *
   * @generated from field: string credential_rp_id = 8;
   */
  credentialRpId = "";

  /**
   * Authenticator Backup Eligibility (BE) bit, recorded during registration or
   * backfill (for older authenticators).
   * https://w3c.github.io/webauthn/#authdata-flags-be
   *
   * @generated from field: google.protobuf.BoolValue credential_backup_eligible = 9;
   */
  credentialBackupEligible?: boolean;

  /**
   * Authenticator Backup State (BS) bit, recorded during registration or
   * backfill (for older authenticators).
   * https://w3c.github.io/webauthn/#authdata-flags-bs
   *
   * @generated from field: google.protobuf.BoolValue credential_backed_up = 10;
   */
  credentialBackedUp?: boolean;

  constructor(data?: PartialMessage<WebauthnDevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebauthnDevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "credential_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "public_key_cbor", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "attestation_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "aaguid", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "signature_counter", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "attestation_object", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "resident_key", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "credential_rp_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "credential_backup_eligible", kind: "message", T: BoolValue$1 },
    { no: 10, name: "credential_backed_up", kind: "message", T: BoolValue$1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebauthnDevice {
    return new WebauthnDevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebauthnDevice {
    return new WebauthnDevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebauthnDevice {
    return new WebauthnDevice().fromJsonString(jsonString, options);
  }

  static equals(a: WebauthnDevice | PlainMessage<WebauthnDevice> | undefined, b: WebauthnDevice | PlainMessage<WebauthnDevice> | undefined): boolean {
    return proto3.util.equals(WebauthnDevice, a, b);
  }
}

/**
 * WebauthnLocalAuth holds settings necessary for local webauthn use.
 *
 * @generated from message types.WebauthnLocalAuth
 */
export class WebauthnLocalAuth extends Message<WebauthnLocalAuth> {
  /**
   * UserID is the random user handle generated for the user.
   * See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
   *
   * @generated from field: bytes UserID = 1;
   */
  UserID = new Uint8Array(0);

  constructor(data?: PartialMessage<WebauthnLocalAuth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebauthnLocalAuth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UserID", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebauthnLocalAuth {
    return new WebauthnLocalAuth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebauthnLocalAuth {
    return new WebauthnLocalAuth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebauthnLocalAuth {
    return new WebauthnLocalAuth().fromJsonString(jsonString, options);
  }

  static equals(a: WebauthnLocalAuth | PlainMessage<WebauthnLocalAuth> | undefined, b: WebauthnLocalAuth | PlainMessage<WebauthnLocalAuth> | undefined): boolean {
    return proto3.util.equals(WebauthnLocalAuth, a, b);
  }
}

/**
 * ConnectorRef holds information about OIDC connector
 *
 * @generated from message types.ConnectorRef
 */
export class ConnectorRef extends Message<ConnectorRef> {
  /**
   * Type is connector type
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * ID is connector ID
   *
   * @generated from field: string ID = 2;
   */
  ID = "";

  /**
   * Identity is external identity of the user
   *
   * @generated from field: string Identity = 3;
   */
  Identity = "";

  constructor(data?: PartialMessage<ConnectorRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ConnectorRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectorRef {
    return new ConnectorRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectorRef {
    return new ConnectorRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectorRef {
    return new ConnectorRef().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectorRef | PlainMessage<ConnectorRef> | undefined, b: ConnectorRef | PlainMessage<ConnectorRef> | undefined): boolean {
    return proto3.util.equals(ConnectorRef, a, b);
  }
}

/**
 * UserRef holds references to user
 *
 * @generated from message types.UserRef
 */
export class UserRef extends Message<UserRef> {
  /**
   * Name is name of the user
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<UserRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserRef {
    return new UserRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserRef {
    return new UserRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserRef {
    return new UserRef().fromJsonString(jsonString, options);
  }

  static equals(a: UserRef | PlainMessage<UserRef> | undefined, b: UserRef | PlainMessage<UserRef> | undefined): boolean {
    return proto3.util.equals(UserRef, a, b);
  }
}

/**
 * ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
 *
 * @generated from message types.ReverseTunnelV2
 */
export class ReverseTunnelV2 extends Message<ReverseTunnelV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is a resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a reverse tunnel specification
   *
   * @generated from field: types.ReverseTunnelSpecV2 Spec = 5;
   */
  Spec?: ReverseTunnelSpecV2;

  constructor(data?: PartialMessage<ReverseTunnelV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ReverseTunnelV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ReverseTunnelSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReverseTunnelV2 {
    return new ReverseTunnelV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReverseTunnelV2 {
    return new ReverseTunnelV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReverseTunnelV2 {
    return new ReverseTunnelV2().fromJsonString(jsonString, options);
  }

  static equals(a: ReverseTunnelV2 | PlainMessage<ReverseTunnelV2> | undefined, b: ReverseTunnelV2 | PlainMessage<ReverseTunnelV2> | undefined): boolean {
    return proto3.util.equals(ReverseTunnelV2, a, b);
  }
}

/**
 * ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
 *
 * @generated from message types.ReverseTunnelSpecV2
 */
export class ReverseTunnelSpecV2 extends Message<ReverseTunnelSpecV2> {
  /**
   * ClusterName is a domain name of remote cluster we are connecting to
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * DialAddrs is a list of remote address to establish a connection to
   * it's always SSH over TCP
   *
   * @generated from field: repeated string DialAddrs = 2;
   */
  DialAddrs: string[] = [];

  /**
   * Type is the type of reverse tunnel, either proxy or node.
   *
   * @generated from field: string Type = 3;
   */
  Type = "";

  constructor(data?: PartialMessage<ReverseTunnelSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ReverseTunnelSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DialAddrs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReverseTunnelSpecV2 {
    return new ReverseTunnelSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReverseTunnelSpecV2 {
    return new ReverseTunnelSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReverseTunnelSpecV2 {
    return new ReverseTunnelSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: ReverseTunnelSpecV2 | PlainMessage<ReverseTunnelSpecV2> | undefined, b: ReverseTunnelSpecV2 | PlainMessage<ReverseTunnelSpecV2> | undefined): boolean {
    return proto3.util.equals(ReverseTunnelSpecV2, a, b);
  }
}

/**
 * TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
 *
 * @generated from message types.TunnelConnectionV2
 */
export class TunnelConnectionV2 extends Message<TunnelConnectionV2> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is a resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a tunnel specification
   *
   * @generated from field: types.TunnelConnectionSpecV2 Spec = 5;
   */
  Spec?: TunnelConnectionSpecV2;

  constructor(data?: PartialMessage<TunnelConnectionV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TunnelConnectionV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: TunnelConnectionSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TunnelConnectionV2 {
    return new TunnelConnectionV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TunnelConnectionV2 {
    return new TunnelConnectionV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TunnelConnectionV2 {
    return new TunnelConnectionV2().fromJsonString(jsonString, options);
  }

  static equals(a: TunnelConnectionV2 | PlainMessage<TunnelConnectionV2> | undefined, b: TunnelConnectionV2 | PlainMessage<TunnelConnectionV2> | undefined): boolean {
    return proto3.util.equals(TunnelConnectionV2, a, b);
  }
}

/**
 * TunnelConnectionSpecV2 is a specification for V2 tunnel connection
 *
 * @generated from message types.TunnelConnectionSpecV2
 */
export class TunnelConnectionSpecV2 extends Message<TunnelConnectionSpecV2> {
  /**
   * ClusterName is a name of the cluster
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * ProxyName is the name of the proxy server
   *
   * @generated from field: string ProxyName = 2;
   */
  ProxyName = "";

  /**
   * LastHeartbeat is a time of the last heartbeat
   *
   * @generated from field: google.protobuf.Timestamp LastHeartbeat = 3;
   */
  LastHeartbeat?: Timestamp;

  /**
   * Type is the type of reverse tunnel, either proxy or node.
   *
   * @generated from field: string Type = 4;
   */
  Type = "";

  constructor(data?: PartialMessage<TunnelConnectionSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TunnelConnectionSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ProxyName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "LastHeartbeat", kind: "message", T: Timestamp },
    { no: 4, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TunnelConnectionSpecV2 {
    return new TunnelConnectionSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TunnelConnectionSpecV2 {
    return new TunnelConnectionSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TunnelConnectionSpecV2 {
    return new TunnelConnectionSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: TunnelConnectionSpecV2 | PlainMessage<TunnelConnectionSpecV2> | undefined, b: TunnelConnectionSpecV2 | PlainMessage<TunnelConnectionSpecV2> | undefined): boolean {
    return proto3.util.equals(TunnelConnectionSpecV2, a, b);
  }
}

/**
 * SemaphoreFilter encodes semaphore filtering params.
 * A semaphore filter matches a semaphore if all nonzero fields
 * match the corresponding semaphore fields (e.g. a filter which
 * specifies only `kind=foo` would match all semaphores of
 * kind `foo`).
 *
 * @generated from message types.SemaphoreFilter
 */
export class SemaphoreFilter extends Message<SemaphoreFilter> {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind = "";

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName = "";

  constructor(data?: PartialMessage<SemaphoreFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SemaphoreFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SemaphoreKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SemaphoreName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemaphoreFilter {
    return new SemaphoreFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemaphoreFilter {
    return new SemaphoreFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemaphoreFilter {
    return new SemaphoreFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SemaphoreFilter | PlainMessage<SemaphoreFilter> | undefined, b: SemaphoreFilter | PlainMessage<SemaphoreFilter> | undefined): boolean {
    return proto3.util.equals(SemaphoreFilter, a, b);
  }
}

/**
 * AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
 *
 * @generated from message types.AcquireSemaphoreRequest
 */
export class AcquireSemaphoreRequest extends Message<AcquireSemaphoreRequest> {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind = "";

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName = "";

  /**
   * MaxLeases is the maximum number of concurrent leases.  If acquisition
   * would cause more than MaxLeases to exist, acquisition must fail.
   *
   * @generated from field: int64 MaxLeases = 3;
   */
  MaxLeases = protoInt64.zero;

  /**
   * Expires is the time at which this lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  /**
   * Holder identifies the entity holding the lease.
   *
   * @generated from field: string Holder = 5;
   */
  Holder = "";

  constructor(data?: PartialMessage<AcquireSemaphoreRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AcquireSemaphoreRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SemaphoreKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SemaphoreName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "MaxLeases", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "Expires", kind: "message", T: Timestamp },
    { no: 5, name: "Holder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AcquireSemaphoreRequest {
    return new AcquireSemaphoreRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AcquireSemaphoreRequest {
    return new AcquireSemaphoreRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AcquireSemaphoreRequest {
    return new AcquireSemaphoreRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AcquireSemaphoreRequest | PlainMessage<AcquireSemaphoreRequest> | undefined, b: AcquireSemaphoreRequest | PlainMessage<AcquireSemaphoreRequest> | undefined): boolean {
    return proto3.util.equals(AcquireSemaphoreRequest, a, b);
  }
}

/**
 * SemaphoreLease represents lease acquired for semaphore
 *
 * @generated from message types.SemaphoreLease
 */
export class SemaphoreLease extends Message<SemaphoreLease> {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind = "";

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName = "";

  /**
   * LeaseID uniquely identifies this lease.
   *
   * @generated from field: string LeaseID = 3;
   */
  LeaseID = "";

  /**
   * Expires is the time at which this lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;

  constructor(data?: PartialMessage<SemaphoreLease>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SemaphoreLease";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SemaphoreKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SemaphoreName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "LeaseID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Expires", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemaphoreLease {
    return new SemaphoreLease().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemaphoreLease {
    return new SemaphoreLease().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemaphoreLease {
    return new SemaphoreLease().fromJsonString(jsonString, options);
  }

  static equals(a: SemaphoreLease | PlainMessage<SemaphoreLease> | undefined, b: SemaphoreLease | PlainMessage<SemaphoreLease> | undefined): boolean {
    return proto3.util.equals(SemaphoreLease, a, b);
  }
}

/**
 * SemaphoreLeaseRef identifies an existent lease.
 *
 * @generated from message types.SemaphoreLeaseRef
 */
export class SemaphoreLeaseRef extends Message<SemaphoreLeaseRef> {
  /**
   * LeaseID is the unique ID of the lease.
   *
   * @generated from field: string LeaseID = 1;
   */
  LeaseID = "";

  /**
   * Expires is the time at which the lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 2;
   */
  Expires?: Timestamp;

  /**
   * Holder identifies the lease holder.
   *
   * @generated from field: string Holder = 3;
   */
  Holder = "";

  constructor(data?: PartialMessage<SemaphoreLeaseRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SemaphoreLeaseRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "LeaseID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Expires", kind: "message", T: Timestamp },
    { no: 3, name: "Holder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemaphoreLeaseRef {
    return new SemaphoreLeaseRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemaphoreLeaseRef {
    return new SemaphoreLeaseRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemaphoreLeaseRef {
    return new SemaphoreLeaseRef().fromJsonString(jsonString, options);
  }

  static equals(a: SemaphoreLeaseRef | PlainMessage<SemaphoreLeaseRef> | undefined, b: SemaphoreLeaseRef | PlainMessage<SemaphoreLeaseRef> | undefined): boolean {
    return proto3.util.equals(SemaphoreLeaseRef, a, b);
  }
}

/**
 * SemaphoreV3 implements Semaphore interface
 *
 * @generated from message types.SemaphoreV3
 */
export class SemaphoreV3 extends Message<SemaphoreV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is Semaphore metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a lease V3 spec
   *
   * @generated from field: types.SemaphoreSpecV3 Spec = 5;
   */
  Spec?: SemaphoreSpecV3;

  constructor(data?: PartialMessage<SemaphoreV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SemaphoreV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: SemaphoreSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemaphoreV3 {
    return new SemaphoreV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemaphoreV3 {
    return new SemaphoreV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemaphoreV3 {
    return new SemaphoreV3().fromJsonString(jsonString, options);
  }

  static equals(a: SemaphoreV3 | PlainMessage<SemaphoreV3> | undefined, b: SemaphoreV3 | PlainMessage<SemaphoreV3> | undefined): boolean {
    return proto3.util.equals(SemaphoreV3, a, b);
  }
}

/**
 * SemaphoreSpecV3 contains the data about lease
 *
 * @generated from message types.SemaphoreSpecV3
 */
export class SemaphoreSpecV3 extends Message<SemaphoreSpecV3> {
  /**
   * Leases is a list of all currently acquired leases.
   *
   * @generated from field: repeated types.SemaphoreLeaseRef Leases = 1;
   */
  Leases: SemaphoreLeaseRef[] = [];

  constructor(data?: PartialMessage<SemaphoreSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SemaphoreSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Leases", kind: "message", T: SemaphoreLeaseRef, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemaphoreSpecV3 {
    return new SemaphoreSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemaphoreSpecV3 {
    return new SemaphoreSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemaphoreSpecV3 {
    return new SemaphoreSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: SemaphoreSpecV3 | PlainMessage<SemaphoreSpecV3> | undefined, b: SemaphoreSpecV3 | PlainMessage<SemaphoreSpecV3> | undefined): boolean {
    return proto3.util.equals(SemaphoreSpecV3, a, b);
  }
}

/**
 * WebSessionV2 represents an application or UI web session.
 *
 * @generated from message types.WebSessionV2
 */
export class WebSessionV2 extends Message<WebSessionV2> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is a resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a tunnel specification.
   *
   * @generated from field: types.WebSessionSpecV2 Spec = 5;
   */
  Spec?: WebSessionSpecV2;

  constructor(data?: PartialMessage<WebSessionV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebSessionV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: WebSessionSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebSessionV2 {
    return new WebSessionV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebSessionV2 {
    return new WebSessionV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebSessionV2 {
    return new WebSessionV2().fromJsonString(jsonString, options);
  }

  static equals(a: WebSessionV2 | PlainMessage<WebSessionV2> | undefined, b: WebSessionV2 | PlainMessage<WebSessionV2> | undefined): boolean {
    return proto3.util.equals(WebSessionV2, a, b);
  }
}

/**
 * WebSessionSpecV2 is a specification for web session.
 *
 * @generated from message types.WebSessionSpecV2
 */
export class WebSessionSpecV2 extends Message<WebSessionSpecV2> {
  /**
   * User is the identity of the user to which the web session belongs.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Pub is the SSH certificate for the user, marshaled in the authorized key
   * format.
   *
   * @generated from field: bytes Pub = 2;
   */
  Pub = new Uint8Array(0);

  /**
   * Priv is the SSH private key for the user, in PEM-encoded PKCS#1 or PKCS#8
   * format. If TLSPriv is unset, this is also the TLS private key.
   *
   * @generated from field: bytes Priv = 3;
   */
  Priv = new Uint8Array(0);

  /**
   * TLSCert is the X.509 certificate for the user (PEM-encoded).
   *
   * @generated from field: bytes TLSCert = 4;
   */
  TLSCert = new Uint8Array(0);

  /**
   * BearerToken is a token that is paired with the session cookie for
   * authentication. It is periodically rotated so a stolen cookie itself
   * is not enough to steal a session. In addition it is used for CSRF
   * mitigation.
   *
   * @generated from field: string BearerToken = 5;
   */
  BearerToken = "";

  /**
   * BearerTokenExpires is the absolute time when the token expires.
   *
   * @generated from field: google.protobuf.Timestamp BearerTokenExpires = 6;
   */
  BearerTokenExpires?: Timestamp;

  /**
   * Expires is the absolute time when the session expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 7;
   */
  Expires?: Timestamp;

  /**
   * LoginTime is the time this user recently logged in.
   *
   * @generated from field: google.protobuf.Timestamp LoginTime = 8;
   */
  LoginTime?: Timestamp;

  /**
   * IdleTimeout is the max time a user can be inactive in a session.
   *
   * @generated from field: int64 IdleTimeout = 9;
   */
  IdleTimeout = protoInt64.zero;

  /**
   * ConsumedAccessRequestID is the ID of the access request from which additional roles to assume
   * were obtained.
   *
   * @generated from field: string ConsumedAccessRequestID = 10;
   */
  ConsumedAccessRequestID = "";

  /**
   * SAMLSession is data associated with a SAML IdP session.
   *
   * @generated from field: types.SAMLSessionData SAMLSession = 11;
   */
  SAMLSession?: SAMLSessionData;

  /**
   * Device trust web authentication token.
   * May be exchanged for a single on-behalf-of device authentication attempt
   * (typically performed by Connect).
   * Only present if on-behalf-of device authentication is possible.
   *
   * @generated from field: types.DeviceWebToken DeviceWebToken = 12;
   */
  DeviceWebToken?: DeviceWebToken;

  /**
   * HasDeviceExtensions is true if the session's TLS and SSH certificates are
   * augmented with device extensions.
   *
   * @generated from field: bool HasDeviceExtensions = 13;
   */
  HasDeviceExtensions = false;

  /**
   * TrustedDeviceRequirement indicates whether access may be hindered by the
   * lack of a trusted device.
   *
   * If during login a device is required and DeviceWebToken is nil, then it's
   * likely the user needs to enroll their device to avoid impacting access.
   *
   * @generated from field: types.TrustedDeviceRequirement TrustedDeviceRequirement = 14;
   */
  TrustedDeviceRequirement = TrustedDeviceRequirement.UNSPECIFIED;

  /**
   * TLSPriv is the TLS private key for the user, in PEM-encoded PKCS#1 or PKCS#8
   * format. If unset, then Priv is used as both the SSH and TLS private key.
   *
   * @generated from field: bytes TLSPriv = 15;
   */
  TLSPriv = new Uint8Array(0);

  constructor(data?: PartialMessage<WebSessionSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebSessionSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Pub", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "Priv", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "TLSCert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "BearerToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "BearerTokenExpires", kind: "message", T: Timestamp },
    { no: 7, name: "Expires", kind: "message", T: Timestamp },
    { no: 8, name: "LoginTime", kind: "message", T: Timestamp },
    { no: 9, name: "IdleTimeout", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "ConsumedAccessRequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "SAMLSession", kind: "message", T: SAMLSessionData },
    { no: 12, name: "DeviceWebToken", kind: "message", T: DeviceWebToken },
    { no: 13, name: "HasDeviceExtensions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "TrustedDeviceRequirement", kind: "enum", T: proto3.getEnumType(TrustedDeviceRequirement) },
    { no: 15, name: "TLSPriv", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebSessionSpecV2 {
    return new WebSessionSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebSessionSpecV2 {
    return new WebSessionSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebSessionSpecV2 {
    return new WebSessionSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: WebSessionSpecV2 | PlainMessage<WebSessionSpecV2> | undefined, b: WebSessionSpecV2 | PlainMessage<WebSessionSpecV2> | undefined): boolean {
    return proto3.util.equals(WebSessionSpecV2, a, b);
  }
}

/**
 * Web-focused view of teleport.devicetrust.v1.DeviceWebToken.
 *
 * @generated from message types.DeviceWebToken
 */
export class DeviceWebToken extends Message<DeviceWebToken> {
  /**
   * Opaque token identifier.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Opaque device web token, in plaintext, encoded in base64.RawURLEncoding
   * (so it is inherently safe for URl use).
   *
   * @generated from field: string token = 2;
   */
  token = "";

  constructor(data?: PartialMessage<DeviceWebToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DeviceWebToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceWebToken {
    return new DeviceWebToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceWebToken {
    return new DeviceWebToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceWebToken {
    return new DeviceWebToken().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceWebToken | PlainMessage<DeviceWebToken> | undefined, b: DeviceWebToken | PlainMessage<DeviceWebToken> | undefined): boolean {
    return proto3.util.equals(DeviceWebToken, a, b);
  }
}

/**
 * WebSessionFilter encodes cache watch parameters for filtering web sessions.
 *
 * @generated from message types.WebSessionFilter
 */
export class WebSessionFilter extends Message<WebSessionFilter> {
  /**
   * User is the username to filter web sessions for.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  constructor(data?: PartialMessage<WebSessionFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebSessionFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebSessionFilter {
    return new WebSessionFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebSessionFilter {
    return new WebSessionFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebSessionFilter {
    return new WebSessionFilter().fromJsonString(jsonString, options);
  }

  static equals(a: WebSessionFilter | PlainMessage<WebSessionFilter> | undefined, b: WebSessionFilter | PlainMessage<WebSessionFilter> | undefined): boolean {
    return proto3.util.equals(WebSessionFilter, a, b);
  }
}

/**
 * SAMLSessionData contains data for a SAML session.
 * Based on crewjam/saml's session object: https://github.com/crewjam/saml/blob/main/identity_provider.go
 *
 * @generated from message types.SAMLSessionData
 */
export class SAMLSessionData extends Message<SAMLSessionData> {
  /**
   * ID is the identifier for the SAML session.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * CreateTime is the time that the session was created.
   *
   * @generated from field: google.protobuf.Timestamp CreateTime = 2;
   */
  CreateTime?: Timestamp;

  /**
   * ExpireTime is the time that the session will expire.
   *
   * @generated from field: google.protobuf.Timestamp ExpireTime = 3;
   */
  ExpireTime?: Timestamp;

  /**
   * Index is the session index that allows the IdP to uniquely identify a session.
   *
   * @generated from field: string Index = 4;
   */
  Index = "";

  /**
   * NameID an identifier for the session.
   *
   * @generated from field: string NameID = 5;
   */
  NameID = "";

  /**
   * NameIDFormat is the format of the Name ID.
   *
   * @generated from field: string NameIDFormat = 6;
   */
  NameIDFormat = "";

  /**
   * SubjectID is the identifier for the subject of the session.
   *
   * @generated from field: string SubjectID = 7;
   */
  SubjectID = "";

  /**
   * Groups is a list of groups that the user has access to.
   *
   * @generated from field: repeated string Groups = 8;
   */
  Groups: string[] = [];

  /**
   * UserName is the user's name.
   *
   * @generated from field: string UserName = 9;
   */
  UserName = "";

  /**
   * UserEmail is the user's e-mail.
   *
   * @generated from field: string UserEmail = 10;
   */
  UserEmail = "";

  /**
   * UserCommonName is the user's common name.
   *
   * @generated from field: string UserCommonName = 11;
   */
  UserCommonName = "";

  /**
   * UserSurname is the user's surname.
   *
   * @generated from field: string UserSurname = 12;
   */
  UserSurname = "";

  /**
   * UserGivenName is the user's given name.
   *
   * @generated from field: string UserGivenName = 13;
   */
  UserGivenName = "";

  /**
   * UserScopedAffiliation is the user's scoped affiliation.
   *
   * @generated from field: string UserScopedAffiliation = 14;
   */
  UserScopedAffiliation = "";

  /**
   * CustomAttributes are any custom attributes associated with the request.
   *
   * @generated from field: repeated types.SAMLAttribute CustomAttributes = 15;
   */
  CustomAttributes: SAMLAttribute[] = [];

  constructor(data?: PartialMessage<SAMLSessionData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLSessionData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "CreateTime", kind: "message", T: Timestamp },
    { no: 3, name: "ExpireTime", kind: "message", T: Timestamp },
    { no: 4, name: "Index", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "NameID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "NameIDFormat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "SubjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Groups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "UserName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "UserEmail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "UserCommonName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "UserSurname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "UserGivenName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "UserScopedAffiliation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "CustomAttributes", kind: "message", T: SAMLAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLSessionData {
    return new SAMLSessionData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLSessionData {
    return new SAMLSessionData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLSessionData {
    return new SAMLSessionData().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLSessionData | PlainMessage<SAMLSessionData> | undefined, b: SAMLSessionData | PlainMessage<SAMLSessionData> | undefined): boolean {
    return proto3.util.equals(SAMLSessionData, a, b);
  }
}

/**
 * SAMLAttribute contains an attribute name and associated values.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLAttribute
 */
export class SAMLAttribute extends Message<SAMLAttribute> {
  /**
   * FriendlyName is a user readable name for the attribute.
   *
   * @generated from field: string FriendlyName = 1;
   */
  FriendlyName = "";

  /**
   * Name is a full name for the attribute, typically an OID value.
   *
   * @generated from field: string Name = 2;
   */
  Name = "";

  /**
   * NameFormat is the format of the name.
   *
   * @generated from field: string NameFormat = 3;
   */
  NameFormat = "";

  /**
   * Values is a list of attribute values.
   *
   * @generated from field: repeated types.SAMLAttributeValue Values = 4;
   */
  Values: SAMLAttributeValue[] = [];

  constructor(data?: PartialMessage<SAMLAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "FriendlyName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "NameFormat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Values", kind: "message", T: SAMLAttributeValue, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLAttribute {
    return new SAMLAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLAttribute {
    return new SAMLAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLAttribute {
    return new SAMLAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLAttribute | PlainMessage<SAMLAttribute> | undefined, b: SAMLAttribute | PlainMessage<SAMLAttribute> | undefined): boolean {
    return proto3.util.equals(SAMLAttribute, a, b);
  }
}

/**
 * SAMLAttributeValues contains a type, value, and an associated name ID block.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLAttributeValue
 */
export class SAMLAttributeValue extends Message<SAMLAttributeValue> {
  /**
   * Type is the type of value this attribute represents.
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  /**
   * Value is the value of the attribute.
   *
   * @generated from field: string Value = 2;
   */
  Value = "";

  /**
   * NameID is a more restrictive identifier for the attribute value.
   *
   * @generated from field: types.SAMLNameID NameID = 3;
   */
  NameID?: SAMLNameID;

  constructor(data?: PartialMessage<SAMLAttributeValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLAttributeValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "NameID", kind: "message", T: SAMLNameID },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLAttributeValue {
    return new SAMLAttributeValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLAttributeValue {
    return new SAMLAttributeValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLAttributeValue {
    return new SAMLAttributeValue().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLAttributeValue | PlainMessage<SAMLAttributeValue> | undefined, b: SAMLAttributeValue | PlainMessage<SAMLAttributeValue> | undefined): boolean {
    return proto3.util.equals(SAMLAttributeValue, a, b);
  }
}

/**
 * SAMLNameID is a more restrictive identifier for an object in SAML.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLNameID
 */
export class SAMLNameID extends Message<SAMLNameID> {
  /**
   * NameQualifier is the domain that qualifies the identifier.
   *
   * @generated from field: string NameQualifier = 1;
   */
  NameQualifier = "";

  /**
   * SPNameQualifier qualifies the identifier with the name of the service provider.
   *
   * @generated from field: string SPNameQualifier = 2;
   */
  SPNameQualifier = "";

  /**
   * Format is the format of the identifier.
   *
   * @generated from field: string Format = 3;
   */
  Format = "";

  /**
   * SPProvidedID is an identifier established by the service provider.
   *
   * @generated from field: string SPProvidedID = 4;
   */
  SPProvidedID = "";

  /**
   * Value is the value of the name ID.
   *
   * @generated from field: string Value = 5;
   */
  Value = "";

  constructor(data?: PartialMessage<SAMLNameID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLNameID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "NameQualifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SPNameQualifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "SPProvidedID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLNameID {
    return new SAMLNameID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLNameID {
    return new SAMLNameID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLNameID {
    return new SAMLNameID().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLNameID | PlainMessage<SAMLNameID> | undefined, b: SAMLNameID | PlainMessage<SAMLNameID> | undefined): boolean {
    return proto3.util.equals(SAMLNameID, a, b);
  }
}

/**
 * RemoteClusterV3 represents remote cluster resource specification
 *
 * @generated from message types.RemoteClusterV3
 */
export class RemoteClusterV3 extends Message<RemoteClusterV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is resource API version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Status is a remote cluster status
   *
   * @generated from field: types.RemoteClusterStatusV3 Status = 5;
   */
  Status?: RemoteClusterStatusV3;

  constructor(data?: PartialMessage<RemoteClusterV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RemoteClusterV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Status", kind: "message", T: RemoteClusterStatusV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoteClusterV3 {
    return new RemoteClusterV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoteClusterV3 {
    return new RemoteClusterV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoteClusterV3 {
    return new RemoteClusterV3().fromJsonString(jsonString, options);
  }

  static equals(a: RemoteClusterV3 | PlainMessage<RemoteClusterV3> | undefined, b: RemoteClusterV3 | PlainMessage<RemoteClusterV3> | undefined): boolean {
    return proto3.util.equals(RemoteClusterV3, a, b);
  }
}

/**
 * RemoteClusterStatusV3 represents status of the remote cluster
 *
 * @generated from message types.RemoteClusterStatusV3
 */
export class RemoteClusterStatusV3 extends Message<RemoteClusterStatusV3> {
  /**
   * Connection represents connection status, online or offline
   *
   * @generated from field: string Connection = 1;
   */
  Connection = "";

  /**
   * LastHeartbeat records last heartbeat of the cluster
   *
   * @generated from field: google.protobuf.Timestamp LastHeartbeat = 2;
   */
  LastHeartbeat?: Timestamp;

  constructor(data?: PartialMessage<RemoteClusterStatusV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RemoteClusterStatusV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connection", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "LastHeartbeat", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoteClusterStatusV3 {
    return new RemoteClusterStatusV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoteClusterStatusV3 {
    return new RemoteClusterStatusV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoteClusterStatusV3 {
    return new RemoteClusterStatusV3().fromJsonString(jsonString, options);
  }

  static equals(a: RemoteClusterStatusV3 | PlainMessage<RemoteClusterStatusV3> | undefined, b: RemoteClusterStatusV3 | PlainMessage<RemoteClusterStatusV3> | undefined): boolean {
    return proto3.util.equals(RemoteClusterStatusV3, a, b);
  }
}

/**
 * KubernetesCluster is a named kubernetes API endpoint handled by a Server.
 *
 * TODO: deprecate and convert all usage to KubernetesClusterV3
 *
 * @generated from message types.KubernetesCluster
 */
export class KubernetesCluster extends Message<KubernetesCluster> {
  /**
   * Name is the name of this kubernetes cluster.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * StaticLabels is map of static labels associated with this cluster.
   * Used for RBAC.
   *
   * @generated from field: map<string, string> StaticLabels = 2;
   */
  StaticLabels: { [key: string]: string } = {};

  /**
   * DynamicLabels is map of dynamic labels associated with this cluster.
   * Used for RBAC.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 3;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 } = {};

  constructor(data?: PartialMessage<KubernetesCluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesCluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "StaticLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "DynamicLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CommandLabelV2} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesCluster {
    return new KubernetesCluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesCluster {
    return new KubernetesCluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesCluster {
    return new KubernetesCluster().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesCluster | PlainMessage<KubernetesCluster> | undefined, b: KubernetesCluster | PlainMessage<KubernetesCluster> | undefined): boolean {
    return proto3.util.equals(KubernetesCluster, a, b);
  }
}

/**
 * KubernetesClusterV3 represents a named kubernetes API endpoint.
 *
 * @generated from message types.KubernetesClusterV3
 */
export class KubernetesClusterV3 extends Message<KubernetesClusterV3> {
  /**
   * Kind is the cluster resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.KubernetesClusterSpecV3 Spec = 5;
   */
  Spec?: KubernetesClusterSpecV3;

  constructor(data?: PartialMessage<KubernetesClusterV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesClusterV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: KubernetesClusterSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterV3 {
    return new KubernetesClusterV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterV3 {
    return new KubernetesClusterV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterV3 {
    return new KubernetesClusterV3().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterV3 | PlainMessage<KubernetesClusterV3> | undefined, b: KubernetesClusterV3 | PlainMessage<KubernetesClusterV3> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterV3, a, b);
  }
}

/**
 * KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
 *
 * @generated from message types.KubernetesClusterSpecV3
 */
export class KubernetesClusterSpecV3 extends Message<KubernetesClusterSpecV3> {
  /**
   * DynamicLabels are the cluster's dynamic labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 1;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 } = {};

  /**
   * Kubeconfig is the kubeconfig file payload that grants access to the cluster.
   * If multiple contexts are specified, the first will be selected.
   *
   * @generated from field: bytes Kubeconfig = 2;
   */
  Kubeconfig = new Uint8Array(0);

  /**
   * Azure holds the required Azure information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeAzure Azure = 3;
   */
  Azure?: KubeAzure;

  /**
   * AWS holds the required AWS information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeAWS AWS = 4;
   */
  AWS?: KubeAWS;

  /**
   * GCP holds the required GCP information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeGCP GCP = 5;
   */
  GCP?: KubeGCP;

  constructor(data?: PartialMessage<KubernetesClusterSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesClusterSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DynamicLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: CommandLabelV2} },
    { no: 2, name: "Kubeconfig", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "Azure", kind: "message", T: KubeAzure },
    { no: 4, name: "AWS", kind: "message", T: KubeAWS },
    { no: 5, name: "GCP", kind: "message", T: KubeGCP },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterSpecV3 {
    return new KubernetesClusterSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterSpecV3 {
    return new KubernetesClusterSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterSpecV3 {
    return new KubernetesClusterSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterSpecV3 | PlainMessage<KubernetesClusterSpecV3> | undefined, b: KubernetesClusterSpecV3 | PlainMessage<KubernetesClusterSpecV3> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterSpecV3, a, b);
  }
}

/**
 * KubeAzure contains the Azure information about the cluster.
 *
 * @generated from message types.KubeAzure
 */
export class KubeAzure extends Message<KubeAzure> {
  /**
   * ResourceName is the AKS cluster name.
   *
   * @generated from field: string ResourceName = 1;
   */
  ResourceName = "";

  /**
   * ResourceGroup is the Azure resource group name.
   *
   * @generated from field: string ResourceGroup = 2;
   */
  ResourceGroup = "";

  /**
   * TenantID is the AKS cluster Tenant ID.
   *
   * @generated from field: string TenantID = 3;
   */
  TenantID = "";

  /**
   * SubscriptionID is the AKS cluster SubscriptionID.
   *
   * @generated from field: string SubscriptionID = 4;
   */
  SubscriptionID = "";

  constructor(data?: PartialMessage<KubeAzure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubeAzure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ResourceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ResourceGroup", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TenantID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "SubscriptionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubeAzure {
    return new KubeAzure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubeAzure {
    return new KubeAzure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubeAzure {
    return new KubeAzure().fromJsonString(jsonString, options);
  }

  static equals(a: KubeAzure | PlainMessage<KubeAzure> | undefined, b: KubeAzure | PlainMessage<KubeAzure> | undefined): boolean {
    return proto3.util.equals(KubeAzure, a, b);
  }
}

/**
 * KubeAWS contains the AWS information about the cluster.
 *
 * @generated from message types.KubeAWS
 */
export class KubeAWS extends Message<KubeAWS> {
  /**
   * Region is a AWS cloud region.
   *
   * @generated from field: string Region = 1;
   */
  Region = "";

  /**
   * AccountID is a AWS Account ID.
   *
   * @generated from field: string AccountID = 2;
   */
  AccountID = "";

  /**
   * Name is a AWS EKS cluster name.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  constructor(data?: PartialMessage<KubeAWS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubeAWS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AccountID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubeAWS {
    return new KubeAWS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubeAWS {
    return new KubeAWS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubeAWS {
    return new KubeAWS().fromJsonString(jsonString, options);
  }

  static equals(a: KubeAWS | PlainMessage<KubeAWS> | undefined, b: KubeAWS | PlainMessage<KubeAWS> | undefined): boolean {
    return proto3.util.equals(KubeAWS, a, b);
  }
}

/**
 * KubeGCP contains the GCP information about the cluster.
 *
 * @generated from message types.KubeGCP
 */
export class KubeGCP extends Message<KubeGCP> {
  /**
   * Location is a GKE cluster location.
   *
   * @generated from field: string Location = 1;
   */
  Location = "";

  /**
   * ProjectID is the GKE Project ID.
   *
   * @generated from field: string ProjectID = 2;
   */
  ProjectID = "";

  /**
   * Name is a GCP GKE cluster name.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  constructor(data?: PartialMessage<KubeGCP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubeGCP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ProjectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubeGCP {
    return new KubeGCP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubeGCP {
    return new KubeGCP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubeGCP {
    return new KubeGCP().fromJsonString(jsonString, options);
  }

  static equals(a: KubeGCP | PlainMessage<KubeGCP> | undefined, b: KubeGCP | PlainMessage<KubeGCP> | undefined): boolean {
    return proto3.util.equals(KubeGCP, a, b);
  }
}

/**
 * KubernetesClusterV3List represents a list of kubernetes clusters.
 *
 * @generated from message types.KubernetesClusterV3List
 */
export class KubernetesClusterV3List extends Message<KubernetesClusterV3List> {
  /**
   * KubernetesClusters is a list of kubernetes clusters resources.
   *
   * @generated from field: repeated types.KubernetesClusterV3 KubernetesClusters = 1;
   */
  KubernetesClusters: KubernetesClusterV3[] = [];

  constructor(data?: PartialMessage<KubernetesClusterV3List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesClusterV3List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KubernetesClusters", kind: "message", T: KubernetesClusterV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesClusterV3List {
    return new KubernetesClusterV3List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesClusterV3List {
    return new KubernetesClusterV3List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesClusterV3List {
    return new KubernetesClusterV3List().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesClusterV3List | PlainMessage<KubernetesClusterV3List> | undefined, b: KubernetesClusterV3List | PlainMessage<KubernetesClusterV3List> | undefined): boolean {
    return proto3.util.equals(KubernetesClusterV3List, a, b);
  }
}

/**
 * KubernetesServerV3 represents a Kubernetes server.
 *
 * @generated from message types.KubernetesServerV3
 */
export class KubernetesServerV3 extends Message<KubernetesServerV3> {
  /**
   * Kind is the Kubernetes server resource kind. Always "kube_server".
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the Kubernetes server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the Kubernetes server spec.
   *
   * @generated from field: types.KubernetesServerSpecV3 Spec = 5;
   */
  Spec?: KubernetesServerSpecV3;

  constructor(data?: PartialMessage<KubernetesServerV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesServerV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: KubernetesServerSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesServerV3 {
    return new KubernetesServerV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesServerV3 {
    return new KubernetesServerV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesServerV3 {
    return new KubernetesServerV3().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesServerV3 | PlainMessage<KubernetesServerV3> | undefined, b: KubernetesServerV3 | PlainMessage<KubernetesServerV3> | undefined): boolean {
    return proto3.util.equals(KubernetesServerV3, a, b);
  }
}

/**
 * KubernetesServerSpecV3 is the Kubernetes server spec.
 *
 * @generated from message types.KubernetesServerSpecV3
 */
export class KubernetesServerSpecV3 extends Message<KubernetesServerSpecV3> {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 1;
   */
  Version = "";

  /**
   * Hostname is the Kubernetes server hostname.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname = "";

  /**
   * HostID is the Kubernetes server host uuid.
   *
   * @generated from field: string HostID = 3;
   */
  HostID = "";

  /**
   * Rotation contains the Kubernetes server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 4;
   */
  Rotation?: Rotation;

  /**
   * Cluster is a Kubernetes Cluster proxied by this Kubernetes server.
   *
   * @generated from field: types.KubernetesClusterV3 Cluster = 5;
   */
  Cluster?: KubernetesClusterV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 6;
   */
  ProxyIDs: string[] = [];

  constructor(data?: PartialMessage<KubernetesServerSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesServerSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Rotation", kind: "message", T: Rotation },
    { no: 5, name: "Cluster", kind: "message", T: KubernetesClusterV3 },
    { no: 6, name: "ProxyIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesServerSpecV3 {
    return new KubernetesServerSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesServerSpecV3 {
    return new KubernetesServerSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesServerSpecV3 {
    return new KubernetesServerSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesServerSpecV3 | PlainMessage<KubernetesServerSpecV3> | undefined, b: KubernetesServerSpecV3 | PlainMessage<KubernetesServerSpecV3> | undefined): boolean {
    return proto3.util.equals(KubernetesServerSpecV3, a, b);
  }
}

/**
 * WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
 * to the client.
 * Initially bound to a web session, these have been factored out into a separate resource to
 * enable separate lifecycle management.
 *
 * @generated from message types.WebTokenV3
 */
export class WebTokenV3 extends Message<WebTokenV3> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec defines the web token
   *
   * @generated from field: types.WebTokenSpecV3 Spec = 5;
   */
  Spec?: WebTokenSpecV3;

  constructor(data?: PartialMessage<WebTokenV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebTokenV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: WebTokenSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebTokenV3 {
    return new WebTokenV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebTokenV3 {
    return new WebTokenV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebTokenV3 {
    return new WebTokenV3().fromJsonString(jsonString, options);
  }

  static equals(a: WebTokenV3 | PlainMessage<WebTokenV3> | undefined, b: WebTokenV3 | PlainMessage<WebTokenV3> | undefined): boolean {
    return proto3.util.equals(WebTokenV3, a, b);
  }
}

/**
 * WebTokenSpecV3 is a unique time-limited token bound to a user's web session
 *
 * @generated from message types.WebTokenSpecV3
 */
export class WebTokenSpecV3 extends Message<WebTokenSpecV3> {
  /**
   * User specifies the user the token is bound to.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Token specifies the token's value.
   *
   * @generated from field: string Token = 2;
   */
  Token = "";

  constructor(data?: PartialMessage<WebTokenSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WebTokenSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebTokenSpecV3 {
    return new WebTokenSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebTokenSpecV3 {
    return new WebTokenSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebTokenSpecV3 {
    return new WebTokenSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: WebTokenSpecV3 | PlainMessage<WebTokenSpecV3> | undefined, b: WebTokenSpecV3 | PlainMessage<WebTokenSpecV3> | undefined): boolean {
    return proto3.util.equals(WebTokenSpecV3, a, b);
  }
}

/**
 * GetWebSessionRequest describes a request to query a web session
 *
 * @generated from message types.GetWebSessionRequest
 */
export class GetWebSessionRequest extends Message<GetWebSessionRequest> {
  /**
   * User specifies the user the web session is for.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * SessionID specifies the web session ID.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID = "";

  constructor(data?: PartialMessage<GetWebSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GetWebSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebSessionRequest {
    return new GetWebSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebSessionRequest {
    return new GetWebSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebSessionRequest {
    return new GetWebSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebSessionRequest | PlainMessage<GetWebSessionRequest> | undefined, b: GetWebSessionRequest | PlainMessage<GetWebSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetWebSessionRequest, a, b);
  }
}

/**
 * DeleteWebSessionRequest describes a request to delete a web session
 *
 * @generated from message types.DeleteWebSessionRequest
 */
export class DeleteWebSessionRequest extends Message<DeleteWebSessionRequest> {
  /**
   * User specifies the user the session is bound to
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * SessionID specifies the web session ID to delete.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID = "";

  constructor(data?: PartialMessage<DeleteWebSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DeleteWebSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWebSessionRequest {
    return new DeleteWebSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWebSessionRequest {
    return new DeleteWebSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWebSessionRequest {
    return new DeleteWebSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWebSessionRequest | PlainMessage<DeleteWebSessionRequest> | undefined, b: DeleteWebSessionRequest | PlainMessage<DeleteWebSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWebSessionRequest, a, b);
  }
}

/**
 * GetWebTokenRequest describes a request to query a web token
 *
 * @generated from message types.GetWebTokenRequest
 */
export class GetWebTokenRequest extends Message<GetWebTokenRequest> {
  /**
   * User specifies the user the token is for.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Token specifies the token to get.
   *
   * @generated from field: string Token = 2;
   */
  Token = "";

  constructor(data?: PartialMessage<GetWebTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GetWebTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebTokenRequest {
    return new GetWebTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebTokenRequest {
    return new GetWebTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebTokenRequest {
    return new GetWebTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebTokenRequest | PlainMessage<GetWebTokenRequest> | undefined, b: GetWebTokenRequest | PlainMessage<GetWebTokenRequest> | undefined): boolean {
    return proto3.util.equals(GetWebTokenRequest, a, b);
  }
}

/**
 * DeleteWebTokenRequest describes a request to delete a web token
 *
 * @generated from message types.DeleteWebTokenRequest
 */
export class DeleteWebTokenRequest extends Message<DeleteWebTokenRequest> {
  /**
   * User specifies the user the token is for.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Token specifies the token to delete.
   *
   * @generated from field: string Token = 2;
   */
  Token = "";

  constructor(data?: PartialMessage<DeleteWebTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DeleteWebTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWebTokenRequest {
    return new DeleteWebTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWebTokenRequest {
    return new DeleteWebTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWebTokenRequest {
    return new DeleteWebTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWebTokenRequest | PlainMessage<DeleteWebTokenRequest> | undefined, b: DeleteWebTokenRequest | PlainMessage<DeleteWebTokenRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWebTokenRequest, a, b);
  }
}

/**
 * ResourceRequest is a request relating to a named resource.
 *
 * @generated from message types.ResourceRequest
 */
export class ResourceRequest extends Message<ResourceRequest> {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<ResourceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceRequest {
    return new ResourceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceRequest {
    return new ResourceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceRequest {
    return new ResourceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceRequest | PlainMessage<ResourceRequest> | undefined, b: ResourceRequest | PlainMessage<ResourceRequest> | undefined): boolean {
    return proto3.util.equals(ResourceRequest, a, b);
  }
}

/**
 * ResourceWithSecretsRequest is a request relating to a named resource with secrets.
 *
 * @generated from message types.ResourceWithSecretsRequest
 */
export class ResourceWithSecretsRequest extends Message<ResourceWithSecretsRequest> {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 2;
   */
  WithSecrets = false;

  constructor(data?: PartialMessage<ResourceWithSecretsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceWithSecretsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "WithSecrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceWithSecretsRequest {
    return new ResourceWithSecretsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceWithSecretsRequest {
    return new ResourceWithSecretsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceWithSecretsRequest {
    return new ResourceWithSecretsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceWithSecretsRequest | PlainMessage<ResourceWithSecretsRequest> | undefined, b: ResourceWithSecretsRequest | PlainMessage<ResourceWithSecretsRequest> | undefined): boolean {
    return proto3.util.equals(ResourceWithSecretsRequest, a, b);
  }
}

/**
 * ResourcesWithSecretsRequest is a request relating to resources with secrets.
 *
 * @generated from message types.ResourcesWithSecretsRequest
 */
export class ResourcesWithSecretsRequest extends Message<ResourcesWithSecretsRequest> {
  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 1;
   */
  WithSecrets = false;

  constructor(data?: PartialMessage<ResourcesWithSecretsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourcesWithSecretsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "WithSecrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourcesWithSecretsRequest {
    return new ResourcesWithSecretsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourcesWithSecretsRequest {
    return new ResourcesWithSecretsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourcesWithSecretsRequest {
    return new ResourcesWithSecretsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResourcesWithSecretsRequest | PlainMessage<ResourcesWithSecretsRequest> | undefined, b: ResourcesWithSecretsRequest | PlainMessage<ResourcesWithSecretsRequest> | undefined): boolean {
    return proto3.util.equals(ResourcesWithSecretsRequest, a, b);
  }
}

/**
 * ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
 *
 * @generated from message types.ResourceInNamespaceRequest
 */
export class ResourceInNamespaceRequest extends Message<ResourceInNamespaceRequest> {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace = "";

  constructor(data?: PartialMessage<ResourceInNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceInNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceInNamespaceRequest {
    return new ResourceInNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceInNamespaceRequest {
    return new ResourceInNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceInNamespaceRequest {
    return new ResourceInNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceInNamespaceRequest | PlainMessage<ResourceInNamespaceRequest> | undefined, b: ResourceInNamespaceRequest | PlainMessage<ResourceInNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(ResourceInNamespaceRequest, a, b);
  }
}

/**
 * ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
 *
 * @generated from message types.ResourcesInNamespaceRequest
 */
export class ResourcesInNamespaceRequest extends Message<ResourcesInNamespaceRequest> {
  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  constructor(data?: PartialMessage<ResourcesInNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourcesInNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourcesInNamespaceRequest {
    return new ResourcesInNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourcesInNamespaceRequest {
    return new ResourcesInNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourcesInNamespaceRequest {
    return new ResourcesInNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ResourcesInNamespaceRequest | PlainMessage<ResourcesInNamespaceRequest> | undefined, b: ResourcesInNamespaceRequest | PlainMessage<ResourcesInNamespaceRequest> | undefined): boolean {
    return proto3.util.equals(ResourcesInNamespaceRequest, a, b);
  }
}

/**
 * OIDCConnectorV3 represents an OIDC connector.
 *
 * @generated from message types.OIDCConnectorV3
 */
export class OIDCConnectorV3 extends Message<OIDCConnectorV3> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an OIDC connector specification.
   *
   * @generated from field: types.OIDCConnectorSpecV3 Spec = 5;
   */
  Spec?: OIDCConnectorSpecV3;

  constructor(data?: PartialMessage<OIDCConnectorV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OIDCConnectorV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: OIDCConnectorSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorV3 {
    return new OIDCConnectorV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorV3 {
    return new OIDCConnectorV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorV3 {
    return new OIDCConnectorV3().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorV3 | PlainMessage<OIDCConnectorV3> | undefined, b: OIDCConnectorV3 | PlainMessage<OIDCConnectorV3> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorV3, a, b);
  }
}

/**
 * OIDCConnectorV3List is a list of OIDC connectors.
 *
 * @generated from message types.OIDCConnectorV3List
 */
export class OIDCConnectorV3List extends Message<OIDCConnectorV3List> {
  /**
   * OIDCConnectors is a list of OIDC connectors.
   *
   * @generated from field: repeated types.OIDCConnectorV3 OIDCConnectors = 1;
   */
  OIDCConnectors: OIDCConnectorV3[] = [];

  constructor(data?: PartialMessage<OIDCConnectorV3List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OIDCConnectorV3List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "OIDCConnectors", kind: "message", T: OIDCConnectorV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorV3List {
    return new OIDCConnectorV3List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorV3List {
    return new OIDCConnectorV3List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorV3List {
    return new OIDCConnectorV3List().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorV3List | PlainMessage<OIDCConnectorV3List> | undefined, b: OIDCConnectorV3List | PlainMessage<OIDCConnectorV3List> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorV3List, a, b);
  }
}

/**
 * OIDCConnectorSpecV3 is an OIDC connector specification.
 *
 * It specifies configuration for Open ID Connect compatible external
 * identity provider: https://openid.net/specs/openid-connect-core-1_0.html
 *
 * @generated from message types.OIDCConnectorSpecV3
 */
export class OIDCConnectorSpecV3 extends Message<OIDCConnectorSpecV3> {
  /**
   * IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
   *
   * @generated from field: string IssuerURL = 1;
   */
  IssuerURL = "";

  /**
   * ClientID is the id of the authentication client (Teleport Auth server).
   *
   * @generated from field: string ClientID = 2;
   */
  ClientID = "";

  /**
   * ClientSecret is used to authenticate the client.
   *
   * @generated from field: string ClientSecret = 3;
   */
  ClientSecret = "";

  /**
   * ACR is an Authentication Context Class Reference value. The meaning of the ACR
   * value is context-specific and varies for identity providers.
   *
   * @generated from field: string ACR = 5;
   */
  ACR = "";

  /**
   * Provider is the external identity provider.
   *
   * @generated from field: string Provider = 6;
   */
  Provider = "";

  /**
   * Display is the friendly name for this provider.
   *
   * @generated from field: string Display = 7;
   */
  Display = "";

  /**
   * Scope specifies additional scopes set by provider.
   *
   * @generated from field: repeated string Scope = 8;
   */
  Scope: string[] = [];

  /**
   * Prompt is an optional OIDC prompt. An empty string omits prompt.
   * If not specified, it defaults to select_account for backwards compatibility.
   *
   * @generated from field: string Prompt = 9;
   */
  Prompt = "";

  /**
   * ClaimsToRoles specifies a dynamic mapping from claims to roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 10;
   */
  ClaimsToRoles: ClaimMapping[] = [];

  /**
   * GoogleServiceAccountURI is a path to a google service account uri.
   *
   * @generated from field: string GoogleServiceAccountURI = 11;
   */
  GoogleServiceAccountURI = "";

  /**
   * GoogleServiceAccount is a string containing google service account credentials.
   *
   * @generated from field: string GoogleServiceAccount = 12;
   */
  GoogleServiceAccount = "";

  /**
   * GoogleAdminEmail is the email of a google admin to impersonate.
   *
   * @generated from field: string GoogleAdminEmail = 13;
   */
  GoogleAdminEmail = "";

  /**
   * RedirectURLs is a list of callback URLs which the identity provider can use
   * to redirect the client back to the Teleport Proxy to complete authentication.
   * This list should match the URLs on the provider's side. The URL used for a
   * given auth request will be chosen to match the requesting Proxy's public
   * address. If there is no match, the first url in the list will be used.
   *
   * @generated from field: wrappers.StringValues RedirectURLs = 14;
   */
  RedirectURLs?: StringValues;

  /**
   * AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
   *
   * @generated from field: bool AllowUnverifiedEmail = 15;
   */
  AllowUnverifiedEmail = false;

  /**
   * UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
   *
   * @generated from field: string UsernameClaim = 16;
   */
  UsernameClaim = "";

  /**
   * MaxAge is the amount of time that user logins are
   * valid for. If a user logs in, but then does not login again
   * within this time period, they will be forced to re-authenticate.
   *
   * @generated from field: types.MaxAge MaxAge = 17;
   */
  MaxAge?: MaxAge;

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 18;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;

  constructor(data?: PartialMessage<OIDCConnectorSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OIDCConnectorSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "IssuerURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ClientSecret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ACR", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Display", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Scope", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "Prompt", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "ClaimsToRoles", kind: "message", T: ClaimMapping, repeated: true },
    { no: 11, name: "GoogleServiceAccountURI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "GoogleServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "GoogleAdminEmail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "RedirectURLs", kind: "message", T: StringValues },
    { no: 15, name: "AllowUnverifiedEmail", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "UsernameClaim", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "MaxAge", kind: "message", T: MaxAge },
    { no: 18, name: "ClientRedirectSettings", kind: "message", T: SSOClientRedirectSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCConnectorSpecV3 {
    return new OIDCConnectorSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCConnectorSpecV3 {
    return new OIDCConnectorSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCConnectorSpecV3 {
    return new OIDCConnectorSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCConnectorSpecV3 | PlainMessage<OIDCConnectorSpecV3> | undefined, b: OIDCConnectorSpecV3 | PlainMessage<OIDCConnectorSpecV3> | undefined): boolean {
    return proto3.util.equals(OIDCConnectorSpecV3, a, b);
  }
}

/**
 * MaxAge allows the max_age parameter to be nullable to preserve backwards
 * compatibility. The duration is stored as nanoseconds.
 *
 * @generated from message types.MaxAge
 */
export class MaxAge extends Message<MaxAge> {
  /**
   * @generated from field: int64 Value = 1;
   */
  Value = protoInt64.zero;

  constructor(data?: PartialMessage<MaxAge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MaxAge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxAge {
    return new MaxAge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxAge {
    return new MaxAge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxAge {
    return new MaxAge().fromJsonString(jsonString, options);
  }

  static equals(a: MaxAge | PlainMessage<MaxAge> | undefined, b: MaxAge | PlainMessage<MaxAge> | undefined): boolean {
    return proto3.util.equals(MaxAge, a, b);
  }
}

/**
 * SSOClientRedirectSettings contains settings to define which additional client
 * redirect URLs should be allowed for non-browser SSO logins.
 *
 * @generated from message types.SSOClientRedirectSettings
 */
export class SSOClientRedirectSettings extends Message<SSOClientRedirectSettings> {
  /**
   * a list of hostnames allowed for https client redirect URLs
   *
   * @generated from field: repeated string allowed_https_hostnames = 1;
   */
  allowedHttpsHostnames: string[] = [];

  /**
   * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
   *
   * @generated from field: repeated string insecure_allowed_cidr_ranges = 2;
   */
  insecureAllowedCidrRanges: string[] = [];

  constructor(data?: PartialMessage<SSOClientRedirectSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SSOClientRedirectSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_https_hostnames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "insecure_allowed_cidr_ranges", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSOClientRedirectSettings {
    return new SSOClientRedirectSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSOClientRedirectSettings {
    return new SSOClientRedirectSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSOClientRedirectSettings {
    return new SSOClientRedirectSettings().fromJsonString(jsonString, options);
  }

  static equals(a: SSOClientRedirectSettings | PlainMessage<SSOClientRedirectSettings> | undefined, b: SSOClientRedirectSettings | PlainMessage<SSOClientRedirectSettings> | undefined): boolean {
    return proto3.util.equals(SSOClientRedirectSettings, a, b);
  }
}

/**
 * OIDCAuthRequest is a request to authenticate with OIDC
 * provider, the state about request is managed by auth server
 *
 * @generated from message types.OIDCAuthRequest
 */
export class OIDCAuthRequest extends Message<OIDCAuthRequest> {
  /**
   * ConnectorID is ID of OIDC connector this request uses
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID = "";

  /**
   * Type is opaque string that helps callbacks identify the request type
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * CheckUser tells validator if it should expect and check user
   *
   * @generated from field: bool CheckUser = 3;
   */
  CheckUser = false;

  /**
   * StateToken is generated by service and is used to validate
   * request coming from
   *
   * @generated from field: string StateToken = 4;
   */
  StateToken = "";

  /**
   * CSRFToken is associated with user web session token
   *
   * @generated from field: string CSRFToken = 5;
   */
  CSRFToken = "";

  /**
   * RedirectURL will be used to route the user back to a
   * Teleport Proxy after the oidc login attempt in the browser.
   *
   * @generated from field: string RedirectURL = 6;
   */
  RedirectURL = "";

  /**
   * PublicKey is an optional public key, users want these keys to be signed by
   * auth servers user CA in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 7 [deprecated = true];
   * @deprecated
   */
  PublicKey = new Uint8Array(0);

  /**
   * CertTTL is the TTL of the certificate user wants to get
   *
   * @generated from field: int64 CertTTL = 8;
   */
  CertTTL = protoInt64.zero;

  /**
   * CreateWebSession indicates if user wants to generate a web
   * session after successful authentication
   *
   * @generated from field: bool CreateWebSession = 9;
   */
  CreateWebSession = false;

  /**
   * ClientRedirectURL is a URL client wants to be redirected
   * after successful authentication
   *
   * @generated from field: string ClientRedirectURL = 10;
   */
  ClientRedirectURL = "";

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 11;
   */
  Compatibility = "";

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster = "";

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster = "";

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow = false;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.OIDCConnectorSpecV3 ConnectorSpec = 15;
   */
  ConnectorSpec?: OIDCConnectorSpecV3;

  /**
   * ProxyAddress is an optional address which can be used to
   * find a redirect url from the OIDC connector which matches
   * the address. If there is no match, the default redirect
   * url will be used.
   *
   * @generated from field: string ProxyAddress = 16;
   */
  ProxyAddress = "";

  /**
   * attestation_statement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 17 [deprecated = true];
   * @deprecated
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 18;
   */
  ClientLoginIP = "";

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing a
   * DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 19;
   */
  ClientUserAgent = "";

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 20;
   */
  sshPublicKey = new Uint8Array(0);

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 21;
   */
  tlsPublicKey = new Uint8Array(0);

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 22;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 23;
   */
  tlsAttestationStatement?: AttestationStatement;

  constructor(data?: PartialMessage<OIDCAuthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OIDCAuthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ConnectorID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "CheckUser", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "StateToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "CSRFToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "CertTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "CreateWebSession", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "ClientRedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "Compatibility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "RouteToCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "SSOTestFlow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "ConnectorSpec", kind: "message", T: OIDCConnectorSpecV3 },
    { no: 16, name: "ProxyAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "attestation_statement", kind: "message", T: AttestationStatement },
    { no: 18, name: "ClientLoginIP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "ClientUserAgent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "ssh_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 21, name: "tls_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 22, name: "ssh_attestation_statement", kind: "message", T: AttestationStatement },
    { no: 23, name: "tls_attestation_statement", kind: "message", T: AttestationStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OIDCAuthRequest {
    return new OIDCAuthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OIDCAuthRequest {
    return new OIDCAuthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OIDCAuthRequest {
    return new OIDCAuthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OIDCAuthRequest | PlainMessage<OIDCAuthRequest> | undefined, b: OIDCAuthRequest | PlainMessage<OIDCAuthRequest> | undefined): boolean {
    return proto3.util.equals(OIDCAuthRequest, a, b);
  }
}

/**
 * SAMLConnectorV2 represents a SAML connector.
 *
 * @generated from message types.SAMLConnectorV2
 */
export class SAMLConnectorV2 extends Message<SAMLConnectorV2> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an SAML connector specification.
   *
   * @generated from field: types.SAMLConnectorSpecV2 Spec = 5;
   */
  Spec?: SAMLConnectorSpecV2;

  constructor(data?: PartialMessage<SAMLConnectorV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLConnectorV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: SAMLConnectorSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorV2 {
    return new SAMLConnectorV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorV2 {
    return new SAMLConnectorV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorV2 {
    return new SAMLConnectorV2().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorV2 | PlainMessage<SAMLConnectorV2> | undefined, b: SAMLConnectorV2 | PlainMessage<SAMLConnectorV2> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorV2, a, b);
  }
}

/**
 * SAMLConnectorV2List is a list of SAML connectors.
 *
 * @generated from message types.SAMLConnectorV2List
 */
export class SAMLConnectorV2List extends Message<SAMLConnectorV2List> {
  /**
   * SAMLConnectors is a list of SAML connectors.
   *
   * @generated from field: repeated types.SAMLConnectorV2 SAMLConnectors = 1;
   */
  SAMLConnectors: SAMLConnectorV2[] = [];

  constructor(data?: PartialMessage<SAMLConnectorV2List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLConnectorV2List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SAMLConnectors", kind: "message", T: SAMLConnectorV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorV2List {
    return new SAMLConnectorV2List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorV2List {
    return new SAMLConnectorV2List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorV2List {
    return new SAMLConnectorV2List().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorV2List | PlainMessage<SAMLConnectorV2List> | undefined, b: SAMLConnectorV2List | PlainMessage<SAMLConnectorV2List> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorV2List, a, b);
  }
}

/**
 * SAMLConnectorSpecV2 is a SAML connector specification.
 *
 * @generated from message types.SAMLConnectorSpecV2
 */
export class SAMLConnectorSpecV2 extends Message<SAMLConnectorSpecV2> {
  /**
   * Issuer is the identity provider issuer.
   *
   * @generated from field: string Issuer = 1;
   */
  Issuer = "";

  /**
   * SSO is the URL of the identity provider's SSO service.
   *
   * @generated from field: string SSO = 2;
   */
  SSO = "";

  /**
   * Cert is the identity provider certificate PEM.
   * IDP signs `<Response>` responses using this certificate.
   *
   * @generated from field: string Cert = 3;
   */
  Cert = "";

  /**
   * Display controls how this connector is displayed.
   *
   * @generated from field: string Display = 4;
   */
  Display = "";

  /**
   * AssertionConsumerService is a URL for assertion consumer service
   * on the service provider (Teleport's side).
   *
   * @generated from field: string AssertionConsumerService = 5;
   */
  AssertionConsumerService = "";

  /**
   * Audience uniquely identifies our service provider.
   *
   * @generated from field: string Audience = 6;
   */
  Audience = "";

  /**
   * ServiceProviderIssuer is the issuer of the service provider (Teleport).
   *
   * @generated from field: string ServiceProviderIssuer = 7;
   */
  ServiceProviderIssuer = "";

  /**
   * EntityDescriptor is XML with descriptor. It can be used to supply configuration
   * parameters in one XML file rather than supplying them in the individual elements.
   *
   * @generated from field: string EntityDescriptor = 8;
   */
  EntityDescriptor = "";

  /**
   * EntityDescriptorURL is a URL that supplies a configuration XML.
   *
   * @generated from field: string EntityDescriptorURL = 9;
   */
  EntityDescriptorURL = "";

  /**
   * AttributesToRoles is a list of mappings of attribute statements to roles.
   *
   * @generated from field: repeated types.AttributeMapping AttributesToRoles = 10;
   */
  AttributesToRoles: AttributeMapping[] = [];

  /**
   * SigningKeyPair is an x509 key pair used to sign AuthnRequest.
   *
   * @generated from field: types.AsymmetricKeyPair SigningKeyPair = 11;
   */
  SigningKeyPair?: AsymmetricKeyPair;

  /**
   * Provider is the external identity provider.
   *
   * @generated from field: string Provider = 12;
   */
  Provider = "";

  /**
   * EncryptionKeyPair is a key pair used for decrypting SAML assertions.
   *
   * @generated from field: types.AsymmetricKeyPair EncryptionKeyPair = 13;
   */
  EncryptionKeyPair?: AsymmetricKeyPair;

  /**
   * AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated
   * logins.
   *
   * @generated from field: bool AllowIDPInitiated = 14;
   */
  AllowIDPInitiated = false;

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 15;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;

  /**
   * SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
   *
   * @generated from field: string SingleLogoutURL = 16;
   */
  SingleLogoutURL = "";

  constructor(data?: PartialMessage<SAMLConnectorSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLConnectorSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Issuer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SSO", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Cert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Display", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AssertionConsumerService", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Audience", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ServiceProviderIssuer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "EntityDescriptor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "EntityDescriptorURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "AttributesToRoles", kind: "message", T: AttributeMapping, repeated: true },
    { no: 11, name: "SigningKeyPair", kind: "message", T: AsymmetricKeyPair },
    { no: 12, name: "Provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "EncryptionKeyPair", kind: "message", T: AsymmetricKeyPair },
    { no: 14, name: "AllowIDPInitiated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "ClientRedirectSettings", kind: "message", T: SSOClientRedirectSettings },
    { no: 16, name: "SingleLogoutURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLConnectorSpecV2 {
    return new SAMLConnectorSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLConnectorSpecV2 {
    return new SAMLConnectorSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLConnectorSpecV2 {
    return new SAMLConnectorSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLConnectorSpecV2 | PlainMessage<SAMLConnectorSpecV2> | undefined, b: SAMLConnectorSpecV2 | PlainMessage<SAMLConnectorSpecV2> | undefined): boolean {
    return proto3.util.equals(SAMLConnectorSpecV2, a, b);
  }
}

/**
 * SAMLAuthRequest is a request to authenticate with SAML
 * provider, the state about request is managed by auth server.
 *
 * @generated from message types.SAMLAuthRequest
 */
export class SAMLAuthRequest extends Message<SAMLAuthRequest> {
  /**
   * ID is a unique request ID.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * ConnectorID is ID of OIDC connector this request uses.
   *
   * @generated from field: string ConnectorID = 2;
   */
  ConnectorID = "";

  /**
   * Type is opaque string that helps callbacks identify the request type.
   *
   * @generated from field: string Type = 3;
   */
  Type = "";

  /**
   * CheckUser tells validator if it should expect and check user.
   *
   * @generated from field: bool CheckUser = 4;
   */
  CheckUser = false;

  /**
   * RedirectURL will be used by browser.
   *
   * @generated from field: string RedirectURL = 5;
   */
  RedirectURL = "";

  /**
   * PublicKey is an optional public key, users want these
   * keys to be signed by auth servers user CA in case
   * of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 6 [deprecated = true];
   * @deprecated
   */
  PublicKey = new Uint8Array(0);

  /**
   * CertTTL is the TTL of the certificate user wants to get.
   *
   * @generated from field: int64 CertTTL = 7;
   */
  CertTTL = protoInt64.zero;

  /**
   * CSRFToken is associated with user web session token.
   *
   * @generated from field: string CSRFToken = 8;
   */
  CSRFToken = "";

  /**
   * CreateWebSession indicates if user wants to generate a web
   * session after successful authentication.
   *
   * @generated from field: bool CreateWebSession = 9;
   */
  CreateWebSession = false;

  /**
   * ClientRedirectURL is a URL client wants to be redirected
   * after successful authentication.
   *
   * @generated from field: string ClientRedirectURL = 10;
   */
  ClientRedirectURL = "";

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 11;
   */
  Compatibility = "";

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster = "";

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster = "";

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow = false;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.SAMLConnectorSpecV2 ConnectorSpec = 15;
   */
  ConnectorSpec?: SAMLConnectorSpecV2;

  /**
   * attestation_statement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 16;
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 17;
   */
  ClientLoginIP = "";

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing a
   * DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 18;
   */
  ClientUserAgent = "";

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 19;
   */
  sshPublicKey = new Uint8Array(0);

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 20;
   */
  tlsPublicKey = new Uint8Array(0);

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
   */
  tlsAttestationStatement?: AttestationStatement;

  constructor(data?: PartialMessage<SAMLAuthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLAuthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ConnectorID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "CheckUser", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "RedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "CertTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "CSRFToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "CreateWebSession", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "ClientRedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "Compatibility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "RouteToCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "SSOTestFlow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "ConnectorSpec", kind: "message", T: SAMLConnectorSpecV2 },
    { no: 16, name: "attestation_statement", kind: "message", T: AttestationStatement },
    { no: 17, name: "ClientLoginIP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "ClientUserAgent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "ssh_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "tls_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 21, name: "ssh_attestation_statement", kind: "message", T: AttestationStatement },
    { no: 22, name: "tls_attestation_statement", kind: "message", T: AttestationStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLAuthRequest {
    return new SAMLAuthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLAuthRequest {
    return new SAMLAuthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLAuthRequest {
    return new SAMLAuthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLAuthRequest | PlainMessage<SAMLAuthRequest> | undefined, b: SAMLAuthRequest | PlainMessage<SAMLAuthRequest> | undefined): boolean {
    return proto3.util.equals(SAMLAuthRequest, a, b);
  }
}

/**
 * AttributeMapping maps a SAML attribute statement to teleport roles.
 *
 * @generated from message types.AttributeMapping
 */
export class AttributeMapping extends Message<AttributeMapping> {
  /**
   * Name is an attribute statement name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Value is an attribute statement value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value = "";

  /**
   * Roles is a list of static teleport roles to map to.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<AttributeMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AttributeMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttributeMapping {
    return new AttributeMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttributeMapping {
    return new AttributeMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttributeMapping {
    return new AttributeMapping().fromJsonString(jsonString, options);
  }

  static equals(a: AttributeMapping | PlainMessage<AttributeMapping> | undefined, b: AttributeMapping | PlainMessage<AttributeMapping> | undefined): boolean {
    return proto3.util.equals(AttributeMapping, a, b);
  }
}

/**
 * AsymmetricKeyPair is a combination of a public certificate and
 * private key that can be used for encryption and signing.
 *
 * @generated from message types.AsymmetricKeyPair
 */
export class AsymmetricKeyPair extends Message<AsymmetricKeyPair> {
  /**
   * PrivateKey is a PEM encoded x509 private key.
   *
   * @generated from field: string PrivateKey = 1;
   */
  PrivateKey = "";

  /**
   * Cert is a PEM-encoded x509 certificate.
   *
   * @generated from field: string Cert = 2;
   */
  Cert = "";

  constructor(data?: PartialMessage<AsymmetricKeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AsymmetricKeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PrivateKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Cert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AsymmetricKeyPair {
    return new AsymmetricKeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AsymmetricKeyPair {
    return new AsymmetricKeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AsymmetricKeyPair {
    return new AsymmetricKeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: AsymmetricKeyPair | PlainMessage<AsymmetricKeyPair> | undefined, b: AsymmetricKeyPair | PlainMessage<AsymmetricKeyPair> | undefined): boolean {
    return proto3.util.equals(AsymmetricKeyPair, a, b);
  }
}

/**
 * GithubConnectorV3 represents a Github connector.
 *
 * @generated from message types.GithubConnectorV3
 */
export class GithubConnectorV3 extends Message<GithubConnectorV3> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an Github connector specification.
   *
   * @generated from field: types.GithubConnectorSpecV3 Spec = 5;
   */
  Spec?: GithubConnectorSpecV3;

  constructor(data?: PartialMessage<GithubConnectorV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubConnectorV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: GithubConnectorSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorV3 {
    return new GithubConnectorV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorV3 {
    return new GithubConnectorV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorV3 {
    return new GithubConnectorV3().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorV3 | PlainMessage<GithubConnectorV3> | undefined, b: GithubConnectorV3 | PlainMessage<GithubConnectorV3> | undefined): boolean {
    return proto3.util.equals(GithubConnectorV3, a, b);
  }
}

/**
 * GithubConnectorV3List is a list of Github connectors.
 *
 * @generated from message types.GithubConnectorV3List
 */
export class GithubConnectorV3List extends Message<GithubConnectorV3List> {
  /**
   * GithubConnectors is a list of Github connectors.
   *
   * @generated from field: repeated types.GithubConnectorV3 GithubConnectors = 1;
   */
  GithubConnectors: GithubConnectorV3[] = [];

  constructor(data?: PartialMessage<GithubConnectorV3List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubConnectorV3List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "GithubConnectors", kind: "message", T: GithubConnectorV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorV3List {
    return new GithubConnectorV3List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorV3List {
    return new GithubConnectorV3List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorV3List {
    return new GithubConnectorV3List().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorV3List | PlainMessage<GithubConnectorV3List> | undefined, b: GithubConnectorV3List | PlainMessage<GithubConnectorV3List> | undefined): boolean {
    return proto3.util.equals(GithubConnectorV3List, a, b);
  }
}

/**
 * GithubConnectorSpecV3 is a Github connector specification.
 *
 * @generated from message types.GithubConnectorSpecV3
 */
export class GithubConnectorSpecV3 extends Message<GithubConnectorSpecV3> {
  /**
   * ClientID is the Github OAuth app client ID.
   *
   * @generated from field: string ClientID = 1;
   */
  ClientID = "";

  /**
   * ClientSecret is the Github OAuth app client secret.
   *
   * @generated from field: string ClientSecret = 2;
   */
  ClientSecret = "";

  /**
   * RedirectURL is the authorization callback URL.
   *
   * @generated from field: string RedirectURL = 3;
   */
  RedirectURL = "";

  /**
   * TeamsToLogins maps Github team memberships onto allowed logins/roles.
   *
   * DELETE IN 11.0.0
   * Deprecated: use GithubTeamsToRoles instead.
   *
   * @generated from field: repeated types.TeamMapping TeamsToLogins = 4;
   */
  TeamsToLogins: TeamMapping[] = [];

  /**
   * Display is the connector display name.
   *
   * @generated from field: string Display = 5;
   */
  Display = "";

  /**
   * TeamsToRoles maps Github team memberships onto allowed roles.
   *
   * @generated from field: repeated types.TeamRolesMapping TeamsToRoles = 6;
   */
  TeamsToRoles: TeamRolesMapping[] = [];

  /**
   * EndpointURL is the URL of the GitHub instance this connector is for.
   *
   * @generated from field: string EndpointURL = 7;
   */
  EndpointURL = "";

  /**
   * APIEndpointURL is the URL of the API endpoint of the Github instance
   * this connector is for.
   *
   * @generated from field: string APIEndpointURL = 8;
   */
  APIEndpointURL = "";

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 9;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;

  constructor(data?: PartialMessage<GithubConnectorSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubConnectorSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClientSecret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "RedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "TeamsToLogins", kind: "message", T: TeamMapping, repeated: true },
    { no: 5, name: "Display", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "TeamsToRoles", kind: "message", T: TeamRolesMapping, repeated: true },
    { no: 7, name: "EndpointURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "APIEndpointURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ClientRedirectSettings", kind: "message", T: SSOClientRedirectSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubConnectorSpecV3 {
    return new GithubConnectorSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubConnectorSpecV3 {
    return new GithubConnectorSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubConnectorSpecV3 {
    return new GithubConnectorSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: GithubConnectorSpecV3 | PlainMessage<GithubConnectorSpecV3> | undefined, b: GithubConnectorSpecV3 | PlainMessage<GithubConnectorSpecV3> | undefined): boolean {
    return proto3.util.equals(GithubConnectorSpecV3, a, b);
  }
}

/**
 * GithubAuthRequest is the request to start Github OAuth2 flow.
 *
 * @generated from message types.GithubAuthRequest
 */
export class GithubAuthRequest extends Message<GithubAuthRequest> {
  /**
   * ConnectorID is the name of the connector to use.
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID = "";

  /**
   * Type is opaque string that helps callbacks identify the request type.
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * StateToken is used to validate the request.
   *
   * @generated from field: string StateToken = 3;
   */
  StateToken = "";

  /**
   * CSRFToken is used to protect against CSRF attacks.
   *
   * @generated from field: string CSRFToken = 4;
   */
  CSRFToken = "";

  /**
   * PublicKey is an optional public key to sign in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 5 [deprecated = true];
   * @deprecated
   */
  PublicKey = new Uint8Array(0);

  /**
   * CertTTL is TTL of the cert that's generated in case of successful auth.
   *
   * @generated from field: int64 CertTTL = 6;
   */
  CertTTL = protoInt64.zero;

  /**
   * CreateWebSession indicates that a user wants to generate a web session
   * after successful authentication.
   *
   * @generated from field: bool CreateWebSession = 7;
   */
  CreateWebSession = false;

  /**
   * RedirectURL will be used by browser.
   *
   * @generated from field: string RedirectURL = 8;
   */
  RedirectURL = "";

  /**
   * ClientRedirectURL is the URL where client will be redirected after
   * successful auth.
   *
   * @generated from field: string ClientRedirectURL = 9;
   */
  ClientRedirectURL = "";

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 10;
   */
  Compatibility = "";

  /**
   * Expires is a global expiry time header can be set on any resource in the system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 11;
   */
  Expires?: Timestamp;

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster = "";

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster = "";

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow = false;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.GithubConnectorSpecV3 ConnectorSpec = 15;
   */
  ConnectorSpec?: GithubConnectorSpecV3;

  /**
   * AttestationStatement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 16 [deprecated = true];
   * @deprecated
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 17;
   */
  ClientLoginIP = "";

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing
   * a DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 18;
   */
  ClientUserAgent = "";

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 19;
   */
  sshPublicKey = new Uint8Array(0);

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 20;
   */
  tlsPublicKey = new Uint8Array(0);

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
   */
  tlsAttestationStatement?: AttestationStatement;

  constructor(data?: PartialMessage<GithubAuthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubAuthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ConnectorID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "StateToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "CSRFToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "CertTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "CreateWebSession", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "RedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ClientRedirectURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Compatibility", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "Expires", kind: "message", T: Timestamp },
    { no: 12, name: "RouteToCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "SSOTestFlow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "ConnectorSpec", kind: "message", T: GithubConnectorSpecV3 },
    { no: 16, name: "attestation_statement", kind: "message", T: AttestationStatement },
    { no: 17, name: "ClientLoginIP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "ClientUserAgent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "ssh_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "tls_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 21, name: "ssh_attestation_statement", kind: "message", T: AttestationStatement },
    { no: 22, name: "tls_attestation_statement", kind: "message", T: AttestationStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubAuthRequest {
    return new GithubAuthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubAuthRequest {
    return new GithubAuthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubAuthRequest {
    return new GithubAuthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GithubAuthRequest | PlainMessage<GithubAuthRequest> | undefined, b: GithubAuthRequest | PlainMessage<GithubAuthRequest> | undefined): boolean {
    return proto3.util.equals(GithubAuthRequest, a, b);
  }
}

/**
 * SSOWarnings conveys a user-facing main message along with auxiliary warnings.
 *
 * @generated from message types.SSOWarnings
 */
export class SSOWarnings extends Message<SSOWarnings> {
  /**
   * Message is main user-facing message to be shown.
   *
   * @generated from field: string Message = 1;
   */
  Message = "";

  /**
   * Warnings is a set of distinct warnings to be reported.
   *
   * @generated from field: repeated string Warnings = 2;
   */
  Warnings: string[] = [];

  constructor(data?: PartialMessage<SSOWarnings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SSOWarnings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Warnings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSOWarnings {
    return new SSOWarnings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSOWarnings {
    return new SSOWarnings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSOWarnings {
    return new SSOWarnings().fromJsonString(jsonString, options);
  }

  static equals(a: SSOWarnings | PlainMessage<SSOWarnings> | undefined, b: SSOWarnings | PlainMessage<SSOWarnings> | undefined): boolean {
    return proto3.util.equals(SSOWarnings, a, b);
  }
}

/**
 * CreateUserParams represents the user creation parameters as called during SSO login flow.
 *
 * @generated from message types.CreateUserParams
 */
export class CreateUserParams extends Message<CreateUserParams> {
  /**
   * ConnectorName is the name of the connector used for SSO login flow.
   *
   * @generated from field: string ConnectorName = 1;
   */
  ConnectorName = "";

  /**
   * Username is the name of the user to be created.
   *
   * @generated from field: string Username = 2;
   */
  Username = "";

  /**
   * Logins is a list of available unix logins.
   *
   * @generated from field: repeated string Logins = 3;
   */
  Logins: string[] = [];

  /**
   * KubeGroups is a list of assigned kube groups.
   *
   * @generated from field: repeated string KubeGroups = 4;
   */
  KubeGroups: string[] = [];

  /**
   * KubeUsers is a list of available kube users.
   *
   * @generated from field: repeated string KubeUsers = 5;
   */
  KubeUsers: string[] = [];

  /**
   * Roles is a list of assigned roles.
   *
   * @generated from field: repeated string Roles = 6;
   */
  Roles: string[] = [];

  /**
   * Traits is the set of traits the user is assigned.
   *
   * @generated from field: wrappers.LabelValues Traits = 7;
   */
  Traits?: LabelValues;

  /**
   * SessionTTL determines the TTL.
   *
   * @generated from field: int64 SessionTTL = 8;
   */
  SessionTTL = protoInt64.zero;

  constructor(data?: PartialMessage<CreateUserParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.CreateUserParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ConnectorName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "KubeGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "KubeUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "Traits", kind: "message", T: LabelValues },
    { no: 8, name: "SessionTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateUserParams {
    return new CreateUserParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateUserParams {
    return new CreateUserParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateUserParams {
    return new CreateUserParams().fromJsonString(jsonString, options);
  }

  static equals(a: CreateUserParams | PlainMessage<CreateUserParams> | undefined, b: CreateUserParams | PlainMessage<CreateUserParams> | undefined): boolean {
    return proto3.util.equals(CreateUserParams, a, b);
  }
}

/**
 * SSODiagnosticInfo is a single SSO diagnostic info entry.
 *
 * @generated from message types.SSODiagnosticInfo
 */
export class SSODiagnosticInfo extends Message<SSODiagnosticInfo> {
  /**
   * TestFlow indicates the SSO flow was a test one.
   *
   * @generated from field: bool TestFlow = 1;
   */
  TestFlow = false;

  /**
   * Error stores user-friendly error message.
   *
   * @generated from field: string Error = 2;
   */
  Error = "";

  /**
   * Success if present, marks the flow as finished with success.
   *
   * @generated from field: bool Success = 3;
   */
  Success = false;

  /**
   * CreateUserParams represents the user creation parameters as called during SSO login flow.
   *
   * @generated from field: types.CreateUserParams CreateUserParams = 4;
   */
  CreateUserParams?: CreateUserParams;

  /**
   * SAMLAttributesToRoles represents mapping from attributes to roles, as used during SAML SSO
   * login flow.
   *
   * @generated from field: repeated types.AttributeMapping SAMLAttributesToRoles = 10;
   */
  SAMLAttributesToRoles: AttributeMapping[] = [];

  /**
   * SAMLAttributesToRolesWarnings contains warnings produced during the process of mapping the
   * SAML attributes to roles.
   *
   * @generated from field: types.SSOWarnings SAMLAttributesToRolesWarnings = 11;
   */
  SAMLAttributesToRolesWarnings?: SSOWarnings;

  /**
   * SAMLAttributeStatements represents SAML attribute statements.
   *
   * @generated from field: wrappers.LabelValues SAMLAttributeStatements = 12;
   */
  SAMLAttributeStatements?: LabelValues;

  /**
   * SAMLAssertionInfo represents raw SAML assertion info as returned by IdP during SAML flow.
   *
   * @generated from field: wrappers.CustomType SAMLAssertionInfo = 13;
   */
  SAMLAssertionInfo?: CustomType;

  /**
   * SAMLTraitsFromAssertions represents traits translated from SAML assertions.
   *
   * @generated from field: wrappers.LabelValues SAMLTraitsFromAssertions = 14;
   */
  SAMLTraitsFromAssertions?: LabelValues;

  /**
   * SAMLConnectorTraitMapping represents connector-specific trait mapping.
   *
   * @generated from field: repeated types.TraitMapping SAMLConnectorTraitMapping = 15;
   */
  SAMLConnectorTraitMapping: TraitMapping[] = [];

  /**
   * OIDCClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping OIDCClaimsToRoles = 20;
   */
  OIDCClaimsToRoles: ClaimMapping[] = [];

  /**
   * OIDCClaimsToRolesWarnings contains warnings produced during the process of mapping the
   * OIDC claims to roles.
   *
   * @generated from field: types.SSOWarnings OIDCClaimsToRolesWarnings = 21;
   */
  OIDCClaimsToRolesWarnings?: SSOWarnings;

  /**
   * OIDCClaims represents OIDC claims.
   *
   * @generated from field: wrappers.CustomType OIDCClaims = 22;
   */
  OIDCClaims?: CustomType;

  /**
   * OIDCIdentity represents mapped OIDC Identity.
   *
   * @generated from field: wrappers.CustomType OIDCIdentity = 23;
   */
  OIDCIdentity?: CustomType;

  /**
   * OIDCTraitsFromClaims represents traits translated from OIDC claims.
   *
   * @generated from field: wrappers.LabelValues OIDCTraitsFromClaims = 24;
   */
  OIDCTraitsFromClaims?: LabelValues;

  /**
   * OIDCConnectorTraitMapping represents connector-specific trait mapping.
   *
   * @generated from field: repeated types.TraitMapping OIDCConnectorTraitMapping = 25;
   */
  OIDCConnectorTraitMapping: TraitMapping[] = [];

  /**
   * GithubClaims represents Github user information obtained during OAuth2 flow.
   *
   * @generated from field: types.GithubClaims GithubClaims = 30;
   */
  GithubClaims?: GithubClaims;

  /**
   * GithubTeamsToLogins is TeamsToLogins mapping from Github connector used in the SSO flow.
   *
   * @generated from field: repeated types.TeamMapping GithubTeamsToLogins = 31;
   */
  GithubTeamsToLogins: TeamMapping[] = [];

  /**
   * GithubTeamsToRoles is TeamRolesMapping mapping from Github connector used in the SSO flow.
   *
   * @generated from field: repeated types.TeamRolesMapping GithubTeamsToRoles = 32;
   */
  GithubTeamsToRoles: TeamRolesMapping[] = [];

  /**
   * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
   *
   * @generated from field: types.GithubTokenInfo GithubTokenInfo = 33;
   */
  GithubTokenInfo?: GithubTokenInfo;

  /**
   * AppliedLoginRules stores the name of each login rule that was applied.
   *
   * @generated from field: repeated string AppliedLoginRules = 34;
   */
  AppliedLoginRules: string[] = [];

  constructor(data?: PartialMessage<SSODiagnosticInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SSODiagnosticInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TestFlow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "CreateUserParams", kind: "message", T: CreateUserParams },
    { no: 10, name: "SAMLAttributesToRoles", kind: "message", T: AttributeMapping, repeated: true },
    { no: 11, name: "SAMLAttributesToRolesWarnings", kind: "message", T: SSOWarnings },
    { no: 12, name: "SAMLAttributeStatements", kind: "message", T: LabelValues },
    { no: 13, name: "SAMLAssertionInfo", kind: "message", T: CustomType },
    { no: 14, name: "SAMLTraitsFromAssertions", kind: "message", T: LabelValues },
    { no: 15, name: "SAMLConnectorTraitMapping", kind: "message", T: TraitMapping, repeated: true },
    { no: 20, name: "OIDCClaimsToRoles", kind: "message", T: ClaimMapping, repeated: true },
    { no: 21, name: "OIDCClaimsToRolesWarnings", kind: "message", T: SSOWarnings },
    { no: 22, name: "OIDCClaims", kind: "message", T: CustomType },
    { no: 23, name: "OIDCIdentity", kind: "message", T: CustomType },
    { no: 24, name: "OIDCTraitsFromClaims", kind: "message", T: LabelValues },
    { no: 25, name: "OIDCConnectorTraitMapping", kind: "message", T: TraitMapping, repeated: true },
    { no: 30, name: "GithubClaims", kind: "message", T: GithubClaims },
    { no: 31, name: "GithubTeamsToLogins", kind: "message", T: TeamMapping, repeated: true },
    { no: 32, name: "GithubTeamsToRoles", kind: "message", T: TeamRolesMapping, repeated: true },
    { no: 33, name: "GithubTokenInfo", kind: "message", T: GithubTokenInfo },
    { no: 34, name: "AppliedLoginRules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSODiagnosticInfo {
    return new SSODiagnosticInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSODiagnosticInfo {
    return new SSODiagnosticInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSODiagnosticInfo {
    return new SSODiagnosticInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SSODiagnosticInfo | PlainMessage<SSODiagnosticInfo> | undefined, b: SSODiagnosticInfo | PlainMessage<SSODiagnosticInfo> | undefined): boolean {
    return proto3.util.equals(SSODiagnosticInfo, a, b);
  }
}

/**
 * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
 * The token itself is secret and therefore not included.
 *
 * @generated from message types.GithubTokenInfo
 */
export class GithubTokenInfo extends Message<GithubTokenInfo> {
  /**
   * @generated from field: string TokenType = 1;
   */
  TokenType = "";

  /**
   * @generated from field: int64 Expires = 2;
   */
  Expires = protoInt64.zero;

  /**
   * @generated from field: string Scope = 3;
   */
  Scope = "";

  constructor(data?: PartialMessage<GithubTokenInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubTokenInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Expires", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "Scope", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubTokenInfo {
    return new GithubTokenInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubTokenInfo {
    return new GithubTokenInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubTokenInfo {
    return new GithubTokenInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GithubTokenInfo | PlainMessage<GithubTokenInfo> | undefined, b: GithubTokenInfo | PlainMessage<GithubTokenInfo> | undefined): boolean {
    return proto3.util.equals(GithubTokenInfo, a, b);
  }
}

/**
 * GithubClaims represents Github user information obtained during OAuth2 flow
 *
 * @generated from message types.GithubClaims
 */
export class GithubClaims extends Message<GithubClaims> {
  /**
   * Username is the user's username
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * OrganizationToTeams is the user's organization and team membership
   *
   * @generated from field: wrappers.LabelValues OrganizationToTeams = 2;
   */
  OrganizationToTeams?: LabelValues;

  /**
   * Teams is the users team membership
   *
   * @generated from field: repeated string Teams = 3;
   */
  Teams: string[] = [];

  constructor(data?: PartialMessage<GithubClaims>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GithubClaims";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "OrganizationToTeams", kind: "message", T: LabelValues },
    { no: 3, name: "Teams", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GithubClaims {
    return new GithubClaims().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GithubClaims {
    return new GithubClaims().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GithubClaims {
    return new GithubClaims().fromJsonString(jsonString, options);
  }

  static equals(a: GithubClaims | PlainMessage<GithubClaims> | undefined, b: GithubClaims | PlainMessage<GithubClaims> | undefined): boolean {
    return proto3.util.equals(GithubClaims, a, b);
  }
}

/**
 * TeamMapping represents a single team membership mapping.
 *
 * DELETE IN 11.0.0
 *
 * @generated from message types.TeamMapping
 */
export class TeamMapping extends Message<TeamMapping> {
  /**
   * Organization is a Github organization a user belongs to.
   *
   * @generated from field: string Organization = 1;
   */
  Organization = "";

  /**
   * Team is a team within the organization a user belongs to.
   *
   * @generated from field: string Team = 2;
   */
  Team = "";

  /**
   * Logins is a list of allowed logins for this org/team.
   *
   * @generated from field: repeated string Logins = 3;
   */
  Logins: string[] = [];

  /**
   * KubeGroups is a list of allowed kubernetes groups for this org/team.
   *
   * @generated from field: repeated string KubeGroups = 4;
   */
  KubeGroups: string[] = [];

  /**
   * KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
   *
   * @generated from field: repeated string KubeUsers = 5;
   */
  KubeUsers: string[] = [];

  constructor(data?: PartialMessage<TeamMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TeamMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Organization", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Team", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "KubeGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "KubeUsers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TeamMapping {
    return new TeamMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TeamMapping {
    return new TeamMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TeamMapping {
    return new TeamMapping().fromJsonString(jsonString, options);
  }

  static equals(a: TeamMapping | PlainMessage<TeamMapping> | undefined, b: TeamMapping | PlainMessage<TeamMapping> | undefined): boolean {
    return proto3.util.equals(TeamMapping, a, b);
  }
}

/**
 * TeamRolesMapping represents a single team membership mapping.
 *
 * @generated from message types.TeamRolesMapping
 */
export class TeamRolesMapping extends Message<TeamRolesMapping> {
  /**
   * Organization is a Github organization a user belongs to.
   *
   * @generated from field: string Organization = 1;
   */
  Organization = "";

  /**
   * Team is a team within the organization a user belongs to.
   *
   * @generated from field: string Team = 2;
   */
  Team = "";

  /**
   * Roles is a list of allowed logins for this org/team.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<TeamRolesMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TeamRolesMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Organization", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Team", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TeamRolesMapping {
    return new TeamRolesMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TeamRolesMapping {
    return new TeamRolesMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TeamRolesMapping {
    return new TeamRolesMapping().fromJsonString(jsonString, options);
  }

  static equals(a: TeamRolesMapping | PlainMessage<TeamRolesMapping> | undefined, b: TeamRolesMapping | PlainMessage<TeamRolesMapping> | undefined): boolean {
    return proto3.util.equals(TeamRolesMapping, a, b);
  }
}

/**
 * TrustedClusterV2 represents a Trusted Cluster.
 *
 * @generated from message types.TrustedClusterV2
 */
export class TrustedClusterV2 extends Message<TrustedClusterV2> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a Trusted Cluster specification.
   *
   * @generated from field: types.TrustedClusterSpecV2 Spec = 5;
   */
  Spec?: TrustedClusterSpecV2;

  constructor(data?: PartialMessage<TrustedClusterV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TrustedClusterV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: TrustedClusterSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterV2 {
    return new TrustedClusterV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterV2 {
    return new TrustedClusterV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterV2 {
    return new TrustedClusterV2().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterV2 | PlainMessage<TrustedClusterV2> | undefined, b: TrustedClusterV2 | PlainMessage<TrustedClusterV2> | undefined): boolean {
    return proto3.util.equals(TrustedClusterV2, a, b);
  }
}

/**
 * TrustedClusterV2List is a list of trusted cluster.
 *
 * @generated from message types.TrustedClusterV2List
 */
export class TrustedClusterV2List extends Message<TrustedClusterV2List> {
  /**
   * TrustedClusters is a list of trusted cluster.
   *
   * @generated from field: repeated types.TrustedClusterV2 TrustedClusters = 1;
   */
  TrustedClusters: TrustedClusterV2[] = [];

  constructor(data?: PartialMessage<TrustedClusterV2List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TrustedClusterV2List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TrustedClusters", kind: "message", T: TrustedClusterV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterV2List {
    return new TrustedClusterV2List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterV2List {
    return new TrustedClusterV2List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterV2List {
    return new TrustedClusterV2List().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterV2List | PlainMessage<TrustedClusterV2List> | undefined, b: TrustedClusterV2List | PlainMessage<TrustedClusterV2List> | undefined): boolean {
    return proto3.util.equals(TrustedClusterV2List, a, b);
  }
}

/**
 * TrustedClusterSpecV2 is a Trusted Cluster specification.
 *
 * @generated from message types.TrustedClusterSpecV2
 */
export class TrustedClusterSpecV2 extends Message<TrustedClusterSpecV2> {
  /**
   * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
   * Setting Enabled to false has a side effect of deleting the user and host certificate
   * authority (CA).
   *
   * @generated from field: bool Enabled = 1;
   */
  Enabled = false;

  /**
   * Roles is a list of roles that users will be assuming when connecting to this cluster.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * Token is the authorization token provided by another cluster needed by this cluster to join.
   *
   * @generated from field: string Token = 3;
   */
  Token = "";

  /**
   * ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
   * it is derived from `<metadata.name>:<default web proxy server port>`.
   *
   * @generated from field: string ProxyAddress = 4;
   */
  ProxyAddress = "";

  /**
   * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
   * not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
   *
   * @generated from field: string ReverseTunnelAddress = 5;
   */
  ReverseTunnelAddress = "";

  /**
   * RoleMap specifies role mappings to remote roles.
   *
   * @generated from field: repeated types.RoleMapping RoleMap = 6;
   */
  RoleMap: RoleMapping[] = [];

  constructor(data?: PartialMessage<TrustedClusterSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.TrustedClusterSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ProxyAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ReverseTunnelAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RoleMap", kind: "message", T: RoleMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrustedClusterSpecV2 {
    return new TrustedClusterSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrustedClusterSpecV2 {
    return new TrustedClusterSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrustedClusterSpecV2 {
    return new TrustedClusterSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: TrustedClusterSpecV2 | PlainMessage<TrustedClusterSpecV2> | undefined, b: TrustedClusterSpecV2 | PlainMessage<TrustedClusterSpecV2> | undefined): boolean {
    return proto3.util.equals(TrustedClusterSpecV2, a, b);
  }
}

/**
 * LockV2 represents a lock.
 * Locks are used to restrict access to a Teleport environment by disabling
 * interactions involving a user, an RBAC role, a node, etc.
 * See rfd/0009-locking.md for more details.
 *
 * @generated from message types.LockV2
 */
export class LockV2 extends Message<LockV2> {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a Lock specification.
   *
   * @generated from field: types.LockSpecV2 Spec = 5;
   */
  Spec?: LockSpecV2;

  constructor(data?: PartialMessage<LockV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.LockV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: LockSpecV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockV2 {
    return new LockV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockV2 {
    return new LockV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockV2 {
    return new LockV2().fromJsonString(jsonString, options);
  }

  static equals(a: LockV2 | PlainMessage<LockV2> | undefined, b: LockV2 | PlainMessage<LockV2> | undefined): boolean {
    return proto3.util.equals(LockV2, a, b);
  }
}

/**
 * LockSpecV2 is a Lock specification.
 *
 * @generated from message types.LockSpecV2
 */
export class LockSpecV2 extends Message<LockSpecV2> {
  /**
   * Target describes the set of interactions that the lock applies to.
   *
   * @generated from field: types.LockTarget Target = 1;
   */
  Target?: LockTarget;

  /**
   * Message is the message displayed to locked-out users.
   *
   * @generated from field: string Message = 2;
   */
  Message = "";

  /**
   * Expires if set specifies when the lock ceases to be in force.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 3;
   */
  Expires?: Timestamp;

  /**
   * CreatedAt is the date time that the lock was created.
   *
   * @generated from field: google.protobuf.Timestamp CreatedAt = 4;
   */
  CreatedAt?: Timestamp;

  /**
   * CreatedBy is the username of the author of the lock.
   *
   * @generated from field: string CreatedBy = 5;
   */
  CreatedBy = "";

  constructor(data?: PartialMessage<LockSpecV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.LockSpecV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Target", kind: "message", T: LockTarget },
    { no: 2, name: "Message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Expires", kind: "message", T: Timestamp },
    { no: 4, name: "CreatedAt", kind: "message", T: Timestamp },
    { no: 5, name: "CreatedBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockSpecV2 {
    return new LockSpecV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockSpecV2 {
    return new LockSpecV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockSpecV2 {
    return new LockSpecV2().fromJsonString(jsonString, options);
  }

  static equals(a: LockSpecV2 | PlainMessage<LockSpecV2> | undefined, b: LockSpecV2 | PlainMessage<LockSpecV2> | undefined): boolean {
    return proto3.util.equals(LockSpecV2, a, b);
  }
}

/**
 * LockTarget lists the attributes of interactions to be disabled.
 *
 * @generated from message types.LockTarget
 */
export class LockTarget extends Message<LockTarget> {
  /**
   * User specifies the name of a Teleport user.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Role specifies the name of an RBAC role known to the root cluster.
   * In remote clusters, this constraint is evaluated before translating to local roles.
   *
   * @generated from field: string Role = 2;
   */
  Role = "";

  /**
   * Login specifies the name of a local UNIX user.
   *
   * @generated from field: string Login = 3;
   */
  Login = "";

  /**
   * Node specifies the UUID of a Teleport node.
   * A matching node is also prevented from heartbeating to the auth server.
   * DEPRECATED: use ServerID instead.
   *
   * @generated from field: string Node = 4 [deprecated = true];
   * @deprecated
   */
  Node = "";

  /**
   * MFADevice specifies the UUID of a user MFA device.
   *
   * @generated from field: string MFADevice = 5;
   */
  MFADevice = "";

  /**
   * WindowsDesktop specifies the name of a Windows desktop.
   *
   * @generated from field: string WindowsDesktop = 6;
   */
  WindowsDesktop = "";

  /**
   * AccessRequest specifies the UUID of an access request.
   *
   * @generated from field: string AccessRequest = 7;
   */
  AccessRequest = "";

  /**
   * Device is the device ID of a trusted device.
   * Requires Teleport Enterprise.
   *
   * @generated from field: string Device = 8;
   */
  Device = "";

  /**
   * ServerID is the host id of the Teleport instance.
   *
   * @generated from field: string ServerID = 9;
   */
  ServerID = "";

  constructor(data?: PartialMessage<LockTarget>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.LockTarget";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Node", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "MFADevice", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "WindowsDesktop", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "AccessRequest", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Device", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LockTarget {
    return new LockTarget().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LockTarget {
    return new LockTarget().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LockTarget {
    return new LockTarget().fromJsonString(jsonString, options);
  }

  static equals(a: LockTarget | PlainMessage<LockTarget> | undefined, b: LockTarget | PlainMessage<LockTarget> | undefined): boolean {
    return proto3.util.equals(LockTarget, a, b);
  }
}

/**
 * AddressCondition represents a set of addresses. Presently the addresses are specified
 * exclusively in terms of IPv4/IPv6 ranges.
 *
 * @generated from message types.AddressCondition
 */
export class AddressCondition extends Message<AddressCondition> {
  /**
   * CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
   * "fe::/8") or a single IP address (e.g "10.1.2.3")
   *
   * @generated from field: string CIDR = 1;
   */
  CIDR = "";

  constructor(data?: PartialMessage<AddressCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AddressCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CIDR", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddressCondition {
    return new AddressCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddressCondition {
    return new AddressCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddressCondition {
    return new AddressCondition().fromJsonString(jsonString, options);
  }

  static equals(a: AddressCondition | PlainMessage<AddressCondition> | undefined, b: AddressCondition | PlainMessage<AddressCondition> | undefined): boolean {
    return proto3.util.equals(AddressCondition, a, b);
  }
}

/**
 * @generated from message types.NetworkRestrictionsSpecV4
 */
export class NetworkRestrictionsSpecV4 extends Message<NetworkRestrictionsSpecV4> {
  /**
   * Allow lists the addresses that should be allowed.
   *
   * @generated from field: repeated types.AddressCondition Allow = 1;
   */
  Allow: AddressCondition[] = [];

  /**
   * Deny lists the addresses that should be denied even if they're allowed by Allow condition.
   *
   * @generated from field: repeated types.AddressCondition Deny = 2;
   */
  Deny: AddressCondition[] = [];

  constructor(data?: PartialMessage<NetworkRestrictionsSpecV4>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.NetworkRestrictionsSpecV4";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Allow", kind: "message", T: AddressCondition, repeated: true },
    { no: 2, name: "Deny", kind: "message", T: AddressCondition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkRestrictionsSpecV4 {
    return new NetworkRestrictionsSpecV4().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkRestrictionsSpecV4 {
    return new NetworkRestrictionsSpecV4().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkRestrictionsSpecV4 {
    return new NetworkRestrictionsSpecV4().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkRestrictionsSpecV4 | PlainMessage<NetworkRestrictionsSpecV4> | undefined, b: NetworkRestrictionsSpecV4 | PlainMessage<NetworkRestrictionsSpecV4> | undefined): boolean {
    return proto3.util.equals(NetworkRestrictionsSpecV4, a, b);
  }
}

/**
 * NetworkRestrictions specifies a list of addresses to restrict (block). The deny
 * list is checked first and the allow lists overrides it. Thus an empty allow
 * list does not mean that no addresses will be allowed, that will only be the
 * case if the deny list covers the whole address range.
 *
 * @generated from message types.NetworkRestrictionsV4
 */
export class NetworkRestrictionsV4 extends Message<NetworkRestrictionsV4> {
  /**
   * Kind is the network restrictions resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the network restrictions metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains the network restrictions data
   *
   * @generated from field: types.NetworkRestrictionsSpecV4 Spec = 5;
   */
  Spec?: NetworkRestrictionsSpecV4;

  constructor(data?: PartialMessage<NetworkRestrictionsV4>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.NetworkRestrictionsV4";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: NetworkRestrictionsSpecV4 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkRestrictionsV4 {
    return new NetworkRestrictionsV4().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkRestrictionsV4 {
    return new NetworkRestrictionsV4().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkRestrictionsV4 {
    return new NetworkRestrictionsV4().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkRestrictionsV4 | PlainMessage<NetworkRestrictionsV4> | undefined, b: NetworkRestrictionsV4 | PlainMessage<NetworkRestrictionsV4> | undefined): boolean {
    return proto3.util.equals(NetworkRestrictionsV4, a, b);
  }
}

/**
 * WindowsDesktopServiceV3 represents a windows desktop access service.
 *
 * @generated from message types.WindowsDesktopServiceV3
 */
export class WindowsDesktopServiceV3 extends Message<WindowsDesktopServiceV3> {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the windows desktop service spec.
   *
   * @generated from field: types.WindowsDesktopServiceSpecV3 Spec = 2;
   */
  Spec?: WindowsDesktopServiceSpecV3;

  constructor(data?: PartialMessage<WindowsDesktopServiceV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WindowsDesktopServiceV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: WindowsDesktopServiceSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopServiceV3 {
    return new WindowsDesktopServiceV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopServiceV3 {
    return new WindowsDesktopServiceV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopServiceV3 {
    return new WindowsDesktopServiceV3().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopServiceV3 | PlainMessage<WindowsDesktopServiceV3> | undefined, b: WindowsDesktopServiceV3 | PlainMessage<WindowsDesktopServiceV3> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopServiceV3, a, b);
  }
}

/**
 * WindowsDesktopServiceSpecV3 is the windows desktop service spec.
 *
 * @generated from message types.WindowsDesktopServiceSpecV3
 */
export class WindowsDesktopServiceSpecV3 extends Message<WindowsDesktopServiceSpecV3> {
  /**
   * Addr is the address that this service can be reached at.
   *
   * @generated from field: string Addr = 1;
   */
  Addr = "";

  /**
   * TeleportVersion is teleport binary version running this service.
   *
   * @generated from field: string TeleportVersion = 2;
   */
  TeleportVersion = "";

  /**
   * Hostname is the desktop service hostname.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname = "";

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 4;
   */
  ProxyIDs: string[] = [];

  constructor(data?: PartialMessage<WindowsDesktopServiceSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WindowsDesktopServiceSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "TeleportVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ProxyIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopServiceSpecV3 {
    return new WindowsDesktopServiceSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopServiceSpecV3 {
    return new WindowsDesktopServiceSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopServiceSpecV3 {
    return new WindowsDesktopServiceSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopServiceSpecV3 | PlainMessage<WindowsDesktopServiceSpecV3> | undefined, b: WindowsDesktopServiceSpecV3 | PlainMessage<WindowsDesktopServiceSpecV3> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopServiceSpecV3, a, b);
  }
}

/**
 * WindowsDesktopFilter are filters to apply when searching for windows desktops.
 *
 * @generated from message types.WindowsDesktopFilter
 */
export class WindowsDesktopFilter extends Message<WindowsDesktopFilter> {
  /**
   * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
   *
   * @generated from field: string HostID = 1;
   */
  HostID = "";

  /**
   * Name is the name of the desktop.
   *
   * @generated from field: string Name = 2;
   */
  Name = "";

  constructor(data?: PartialMessage<WindowsDesktopFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WindowsDesktopFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopFilter {
    return new WindowsDesktopFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopFilter {
    return new WindowsDesktopFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopFilter {
    return new WindowsDesktopFilter().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopFilter | PlainMessage<WindowsDesktopFilter> | undefined, b: WindowsDesktopFilter | PlainMessage<WindowsDesktopFilter> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopFilter, a, b);
  }
}

/**
 * WindowsDesktopV3 represents a Windows host for desktop access.
 *
 * @generated from message types.WindowsDesktopV3
 */
export class WindowsDesktopV3 extends Message<WindowsDesktopV3> {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the Windows host spec.
   *
   * @generated from field: types.WindowsDesktopSpecV3 Spec = 2;
   */
  Spec?: WindowsDesktopSpecV3;

  constructor(data?: PartialMessage<WindowsDesktopV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WindowsDesktopV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: WindowsDesktopSpecV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopV3 {
    return new WindowsDesktopV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopV3 {
    return new WindowsDesktopV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopV3 {
    return new WindowsDesktopV3().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopV3 | PlainMessage<WindowsDesktopV3> | undefined, b: WindowsDesktopV3 | PlainMessage<WindowsDesktopV3> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopV3, a, b);
  }
}

/**
 * WindowsDesktopSpecV3 is the Windows host spec.
 *
 * @generated from message types.WindowsDesktopSpecV3
 */
export class WindowsDesktopSpecV3 extends Message<WindowsDesktopSpecV3> {
  /**
   * Addr is the address that this host can be reached at.
   *
   * @generated from field: string Addr = 1;
   */
  Addr = "";

  /**
   * Domain is the ActiveDirectory domain that this host belongs to.
   *
   * @generated from field: string Domain = 2;
   */
  Domain = "";

  /**
   * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
   *
   * @generated from field: string HostID = 3;
   */
  HostID = "";

  /**
   * NonAD marks this desktop as a standalone host that is
   * not joined to an Active Directory domain.
   *
   * @generated from field: bool NonAD = 4;
   */
  NonAD = false;

  /**
   * ScreenSize specifies the size of the screen to use for sessions
   * on this host. In most cases this should be unspecified, in which
   * case Teleport will fill the browser window.
   *
   * @generated from field: types.Resolution ScreenSize = 5;
   */
  ScreenSize?: Resolution;

  constructor(data?: PartialMessage<WindowsDesktopSpecV3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WindowsDesktopSpecV3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Domain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "NonAD", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "ScreenSize", kind: "message", T: Resolution },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopSpecV3 {
    return new WindowsDesktopSpecV3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopSpecV3 {
    return new WindowsDesktopSpecV3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopSpecV3 {
    return new WindowsDesktopSpecV3().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopSpecV3 | PlainMessage<WindowsDesktopSpecV3> | undefined, b: WindowsDesktopSpecV3 | PlainMessage<WindowsDesktopSpecV3> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopSpecV3, a, b);
  }
}

/**
 * @generated from message types.Resolution
 */
export class Resolution extends Message<Resolution> {
  /**
   * @generated from field: uint32 Width = 1;
   */
  Width = 0;

  /**
   * @generated from field: uint32 Height = 2;
   */
  Height = 0;

  constructor(data?: PartialMessage<Resolution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Resolution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Width", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "Height", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Resolution {
    return new Resolution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Resolution {
    return new Resolution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Resolution {
    return new Resolution().fromJsonString(jsonString, options);
  }

  static equals(a: Resolution | PlainMessage<Resolution> | undefined, b: Resolution | PlainMessage<Resolution> | undefined): boolean {
    return proto3.util.equals(Resolution, a, b);
  }
}

/**
 * RegisterUsingTokenRequest is a request to register with the auth server using
 * an authentication token
 *
 * @generated from message types.RegisterUsingTokenRequest
 */
export class RegisterUsingTokenRequest extends Message<RegisterUsingTokenRequest> {
  /**
   * HostID is a unique host ID, usually a UUID
   *
   * @generated from field: string HostID = 1;
   */
  HostID = "";

  /**
   * NodeName is a node name
   *
   * @generated from field: string NodeName = 2;
   */
  NodeName = "";

  /**
   * Role is a system role, e.g. Proxy
   *
   * @generated from field: string Role = 3;
   */
  Role = "";

  /**
   * Token is the name of an authentication token
   *
   * @generated from field: string Token = 4;
   */
  Token = "";

  /**
   * AdditionalPrincipals is a list of additional principals
   *
   * @generated from field: repeated string AdditionalPrincipals = 5;
   */
  AdditionalPrincipals: string[] = [];

  /**
   * DNSNames is a list of DNS names to include in the x509 client certificate
   *
   * @generated from field: repeated string DNSNames = 6;
   */
  DNSNames: string[] = [];

  /**
   * PublicTLSKey is a PEM encoded public key
   * used for TLS setup
   *
   * @generated from field: bytes PublicTLSKey = 7;
   */
  PublicTLSKey = new Uint8Array(0);

  /**
   * PublicSSHKey is a SSH encoded public key,
   * if present will be signed as a return value
   * otherwise, new public/private key pair will be generated
   *
   * @generated from field: bytes PublicSSHKey = 8;
   */
  PublicSSHKey = new Uint8Array(0);

  /**
   * RemoteAddr is the remote address of the host requesting a host certificate.
   * It is used to replace 0.0.0.0 in the list of additional principals.
   *
   * @generated from field: string RemoteAddr = 9;
   */
  RemoteAddr = "";

  /**
   * EC2IdentityDocument is used for the EC2 join method to prove the identity
   * of a joining EC2 instance.
   *
   * @generated from field: bytes EC2IdentityDocument = 10;
   */
  EC2IdentityDocument = new Uint8Array(0);

  /**
   * IDToken is a token provided by a workload identity provider as part of
   * OIDC join types such as GitHub.
   *
   * @generated from field: string IDToken = 11;
   */
  IDToken = "";

  /**
   * Expires is a desired time of the expiry of user certificates returned by
   * registration. This only applies to bot joining, and will be ignored by
   * node joining.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 12;
   */
  Expires?: Timestamp;

  /**
   * BotInstanceID is a trusted instance identifier for a Machine ID bot,
   * provided when rejoining. This parameters may only be provided by the join
   * service and is ignored otherwise; bots should otherwise rejoin with their
   * existing client certificate to prove their instance identity.
   *
   * @generated from field: string BotInstanceID = 13;
   */
  BotInstanceID = "";

  /**
   * BotGeneration is a trusted generation counter value for Machine ID bots,
   * provided to Auth by the Join Service when bots rejoin via a streamed/gRPC
   * join method. Rejoining bots supply this value via a client certificate
   * extension; it is ignored from other sources.
   *
   * @generated from field: int32 BotGeneration = 14;
   */
  BotGeneration = 0;

  constructor(data?: PartialMessage<RegisterUsingTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RegisterUsingTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "NodeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AdditionalPrincipals", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "DNSNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "PublicTLSKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "PublicSSHKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "RemoteAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "EC2IdentityDocument", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "IDToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "Expires", kind: "message", T: Timestamp },
    { no: 13, name: "BotInstanceID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "BotGeneration", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterUsingTokenRequest {
    return new RegisterUsingTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterUsingTokenRequest {
    return new RegisterUsingTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterUsingTokenRequest {
    return new RegisterUsingTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterUsingTokenRequest | PlainMessage<RegisterUsingTokenRequest> | undefined, b: RegisterUsingTokenRequest | PlainMessage<RegisterUsingTokenRequest> | undefined): boolean {
    return proto3.util.equals(RegisterUsingTokenRequest, a, b);
  }
}

/**
 * RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
 * access to their account by restoring their lost password or second factor. Once a recovery code
 * is successfully verified, the code is mark used (which invalidates it), and lets the user begin
 * the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
 * of codes that will replace all the previous ones.
 *
 * @generated from message types.RecoveryCodesV1
 */
export class RecoveryCodesV1 extends Message<RecoveryCodesV1> {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.RecoveryCodesSpecV1 Spec = 5;
   */
  Spec?: RecoveryCodesSpecV1;

  constructor(data?: PartialMessage<RecoveryCodesV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RecoveryCodesV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: RecoveryCodesSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCodesV1 {
    return new RecoveryCodesV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCodesV1 {
    return new RecoveryCodesV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCodesV1 {
    return new RecoveryCodesV1().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCodesV1 | PlainMessage<RecoveryCodesV1> | undefined, b: RecoveryCodesV1 | PlainMessage<RecoveryCodesV1> | undefined): boolean {
    return proto3.util.equals(RecoveryCodesV1, a, b);
  }
}

/**
 * RecoveryCodesSpecV1 is the recovery codes spec.
 *
 * @generated from message types.RecoveryCodesSpecV1
 */
export class RecoveryCodesSpecV1 extends Message<RecoveryCodesSpecV1> {
  /**
   * Codes hold a list of numOfRecoveryCodes.
   *
   * @generated from field: repeated types.RecoveryCode Codes = 1;
   */
  Codes: RecoveryCode[] = [];

  /**
   * Created is when the set of recovery codes were generated. Updated when a new set of recovery
   * codes are inserted.
   *
   * @generated from field: google.protobuf.Timestamp Created = 2;
   */
  Created?: Timestamp;

  constructor(data?: PartialMessage<RecoveryCodesSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RecoveryCodesSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Codes", kind: "message", T: RecoveryCode, repeated: true },
    { no: 2, name: "Created", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCodesSpecV1 {
    return new RecoveryCodesSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCodesSpecV1 {
    return new RecoveryCodesSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCodesSpecV1 {
    return new RecoveryCodesSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCodesSpecV1 | PlainMessage<RecoveryCodesSpecV1> | undefined, b: RecoveryCodesSpecV1 | PlainMessage<RecoveryCodesSpecV1> | undefined): boolean {
    return proto3.util.equals(RecoveryCodesSpecV1, a, b);
  }
}

/**
 * RecoveryCode describes a recovery code.
 *
 * @generated from message types.RecoveryCode
 */
export class RecoveryCode extends Message<RecoveryCode> {
  /**
   * HashedCode is a bcrypt hash of this recovery code.
   *
   * @generated from field: bytes HashedCode = 1;
   */
  HashedCode = new Uint8Array(0);

  /**
   * IsUsed determines if this recovery code was used.
   *
   * @generated from field: bool IsUsed = 2;
   */
  IsUsed = false;

  constructor(data?: PartialMessage<RecoveryCode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.RecoveryCode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "HashedCode", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "IsUsed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCode {
    return new RecoveryCode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCode {
    return new RecoveryCode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCode {
    return new RecoveryCode().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCode | PlainMessage<RecoveryCode> | undefined, b: RecoveryCode | PlainMessage<RecoveryCode> | undefined): boolean {
    return proto3.util.equals(RecoveryCode, a, b);
  }
}

/**
 * @generated from message types.NullableSessionState
 */
export class NullableSessionState extends Message<NullableSessionState> {
  /**
   * @generated from field: types.SessionState State = 1;
   */
  State = SessionState.SessionStatePending;

  constructor(data?: PartialMessage<NullableSessionState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.NullableSessionState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "State", kind: "enum", T: proto3.getEnumType(SessionState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableSessionState {
    return new NullableSessionState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableSessionState {
    return new NullableSessionState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableSessionState {
    return new NullableSessionState().fromJsonString(jsonString, options);
  }

  static equals(a: NullableSessionState | PlainMessage<NullableSessionState> | undefined, b: NullableSessionState | PlainMessage<NullableSessionState> | undefined): boolean {
    return proto3.util.equals(NullableSessionState, a, b);
  }
}

/**
 * SessionTrackerFilter are filters to apply when searching for session trackers.
 *
 * @generated from message types.SessionTrackerFilter
 */
export class SessionTrackerFilter extends Message<SessionTrackerFilter> {
  /**
   * Kind describes what kind of session this is.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * State is the current state of this session.
   *
   * @generated from field: types.NullableSessionState State = 2;
   */
  State?: NullableSessionState;

  /**
   * DesktopName is the windows desktop server this session belongs to.
   *
   * @generated from field: string DesktopName = 3;
   */
  DesktopName = "";

  constructor(data?: PartialMessage<SessionTrackerFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionTrackerFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "State", kind: "message", T: NullableSessionState },
    { no: 3, name: "DesktopName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerFilter {
    return new SessionTrackerFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerFilter {
    return new SessionTrackerFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerFilter {
    return new SessionTrackerFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerFilter | PlainMessage<SessionTrackerFilter> | undefined, b: SessionTrackerFilter | PlainMessage<SessionTrackerFilter> | undefined): boolean {
    return proto3.util.equals(SessionTrackerFilter, a, b);
  }
}

/**
 * SessionTrackerV1 represents a live session resource.
 *
 * @generated from message types.SessionTrackerV1
 */
export class SessionTrackerV1 extends Message<SessionTrackerV1> {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is a session specification.
   *
   * @generated from field: types.SessionTrackerSpecV1 Spec = 2;
   */
  Spec?: SessionTrackerSpecV1;

  constructor(data?: PartialMessage<SessionTrackerV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionTrackerV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: SessionTrackerSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerV1 {
    return new SessionTrackerV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerV1 {
    return new SessionTrackerV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerV1 {
    return new SessionTrackerV1().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerV1 | PlainMessage<SessionTrackerV1> | undefined, b: SessionTrackerV1 | PlainMessage<SessionTrackerV1> | undefined): boolean {
    return proto3.util.equals(SessionTrackerV1, a, b);
  }
}

/**
 * SessionTrackerSpecV1 is the specification for a live session.
 *
 * @generated from message types.SessionTrackerSpecV1
 */
export class SessionTrackerSpecV1 extends Message<SessionTrackerSpecV1> {
  /**
   * SessionID is unique identifier of this session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * Kind describes what kind of session this is.
   *
   * @generated from field: string Kind = 2;
   */
  Kind = "";

  /**
   * State is the current state of this session.
   *
   * @generated from field: types.SessionState State = 3;
   */
  State = SessionState.SessionStatePending;

  /**
   * Created encodes the time at which the session was registered with the auth
   * server.
   *
   * This should match the timestamp in the corresponding `session.create` event.
   * It's thus up to the tracker creator to set the correct timestamp.
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;

  /**
   * Expires encodes the time at which this session expires and becomes invalid.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;

  /**
   * AttachedData is arbitrary attached JSON serialized metadata.
   *
   * @generated from field: string AttachedData = 6;
   */
  AttachedData = "";

  /**
   * Reason is an arbitrary string that may be used to describe the session and/or it's
   * purpose.
   *
   * @generated from field: string Reason = 7;
   */
  Reason = "";

  /**
   * Invited is a list of invited users, this field can be used by
   * clients to deliver notifications to invited users.
   *
   * @generated from field: repeated string Invited = 8;
   */
  Invited: string[] = [];

  /**
   * Hostname identifies the target this session is connected to.
   *
   * @generated from field: string Hostname = 9;
   */
  Hostname = "";

  /**
   * Address is the address of the target this session is connected to.
   *
   * @generated from field: string Address = 10;
   */
  Address = "";

  /**
   * ClusterName is the name of the Teleport cluster that this session belongs to.
   *
   * @generated from field: string ClusterName = 11;
   */
  ClusterName = "";

  /**
   * Login is the local login/user on the target used by the session.
   *
   * @generated from field: string Login = 12;
   */
  Login = "";

  /**
   * Participants is a list of session participants.
   *
   * @generated from field: repeated types.Participant Participants = 13;
   */
  Participants: Participant[] = [];

  /**
   * The Kubernetes cluster this session belongs to.
   *
   * @generated from field: string KubernetesCluster = 14;
   */
  KubernetesCluster = "";

  /**
   * HostUser is the user regarded as the owner of this session, RBAC checks are performed
   * against the require policies of this user.
   *
   * This refers to the Teleport user but may not be the same as the sessions initiator.
   *
   * @generated from field: string HostUser = 15;
   */
  HostUser = "";

  /**
   * HostPolicies is a list of RBAC policy sets held by the host user at the time of session
   * creation.
   *
   * @generated from field: repeated types.SessionTrackerPolicySet HostPolicies = 16;
   */
  HostPolicies: SessionTrackerPolicySet[] = [];

  /**
   * DatabaseName is the database server this session belongs to.
   *
   * @generated from field: string DatabaseName = 17;
   */
  DatabaseName = "";

  /**
   * AppName is the app server this session belongs to.
   *
   * @generated from field: string AppName = 18;
   */
  AppName = "";

  /**
   * AppSessionID is the unique ID of the app access certificate used to start this app session.
   *
   * @generated from field: string AppSessionID = 19;
   */
  AppSessionID = "";

  /**
   * DesktopName is the windows desktop server this session belongs to.
   *
   * @generated from field: string DesktopName = 20;
   */
  DesktopName = "";

  /**
   * HostID is the target host id that created the session tracker.
   * It's useful for Kubernetes moderated sessions when running in high availabilty
   * otherwise kube proxy is not able to know which agent runs the session.
   *
   * @generated from field: string HostID = 21;
   */
  HostID = "";

  /**
   * TargetSubKind is the sub kind of the target server.
   *
   * @generated from field: string TargetSubKind = 22;
   */
  TargetSubKind = "";

  /**
   * InitialCommand is the command that was executed to start this session.
   *
   * @generated from field: repeated string InitialCommand = 23;
   */
  InitialCommand: string[] = [];

  constructor(data?: PartialMessage<SessionTrackerSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionTrackerSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "State", kind: "enum", T: proto3.getEnumType(SessionState) },
    { no: 4, name: "Created", kind: "message", T: Timestamp },
    { no: 5, name: "Expires", kind: "message", T: Timestamp },
    { no: 6, name: "AttachedData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "Invited", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "Participants", kind: "message", T: Participant, repeated: true },
    { no: 14, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "HostUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "HostPolicies", kind: "message", T: SessionTrackerPolicySet, repeated: true },
    { no: 17, name: "DatabaseName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "AppName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "AppSessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "DesktopName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "TargetSubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "InitialCommand", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerSpecV1 {
    return new SessionTrackerSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerSpecV1 {
    return new SessionTrackerSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerSpecV1 {
    return new SessionTrackerSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerSpecV1 | PlainMessage<SessionTrackerSpecV1> | undefined, b: SessionTrackerSpecV1 | PlainMessage<SessionTrackerSpecV1> | undefined): boolean {
    return proto3.util.equals(SessionTrackerSpecV1, a, b);
  }
}

/**
 * SessionTrackerPolicySet is a set of RBAC policies held by the session tracker
 * that contain additional metadata from the originating role.
 *
 * @generated from message types.SessionTrackerPolicySet
 */
export class SessionTrackerPolicySet extends Message<SessionTrackerPolicySet> {
  /**
   * Name is name of the role this policy set originates from.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Version is version of the role this policy set originates from.
   *
   * @generated from field: string Version = 2;
   */
  Version = "";

  /**
   * RequireSessionJoin specifies policies for required users to start a session.
   *
   * @generated from field: repeated types.SessionRequirePolicy RequireSessionJoin = 3;
   */
  RequireSessionJoin: SessionRequirePolicy[] = [];

  constructor(data?: PartialMessage<SessionTrackerPolicySet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SessionTrackerPolicySet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "RequireSessionJoin", kind: "message", T: SessionRequirePolicy, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerPolicySet {
    return new SessionTrackerPolicySet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerPolicySet {
    return new SessionTrackerPolicySet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerPolicySet {
    return new SessionTrackerPolicySet().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerPolicySet | PlainMessage<SessionTrackerPolicySet> | undefined, b: SessionTrackerPolicySet | PlainMessage<SessionTrackerPolicySet> | undefined): boolean {
    return proto3.util.equals(SessionTrackerPolicySet, a, b);
  }
}

/**
 * Participant stores information about a participant in the session.
 *
 * @generated from message types.Participant
 */
export class Participant extends Message<Participant> {
  /**
   * ID is a unique UUID of this participant for a given session.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * User is the canonical name of the Teleport user controlling this participant.
   *
   * @generated from field: string User = 2;
   */
  User = "";

  /**
   * Mode is the participant mode.
   *
   * @generated from field: string Mode = 3;
   */
  Mode = "";

  /**
   * LastActive is the last time this party was active in the session.
   *
   * @generated from field: google.protobuf.Timestamp LastActive = 4;
   */
  LastActive?: Timestamp;

  constructor(data?: PartialMessage<Participant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Participant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Mode", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "LastActive", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Participant {
    return new Participant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Participant {
    return new Participant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Participant {
    return new Participant().fromJsonString(jsonString, options);
  }

  static equals(a: Participant | PlainMessage<Participant> | undefined, b: Participant | PlainMessage<Participant> | undefined): boolean {
    return proto3.util.equals(Participant, a, b);
  }
}

/**
 * UIConfigV1 represents the configuration for the web UI served by the proxy service
 *
 * @generated from message types.UIConfigV1
 */
export class UIConfigV1 extends Message<UIConfigV1> {
  /**
   * Header is the resource header for the UI configuration.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.UIConfigSpecV1 Spec = 5;
   */
  Spec?: UIConfigSpecV1;

  constructor(data?: PartialMessage<UIConfigV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UIConfigV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 5, name: "Spec", kind: "message", T: UIConfigSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UIConfigV1 {
    return new UIConfigV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UIConfigV1 {
    return new UIConfigV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UIConfigV1 {
    return new UIConfigV1().fromJsonString(jsonString, options);
  }

  static equals(a: UIConfigV1 | PlainMessage<UIConfigV1> | undefined, b: UIConfigV1 | PlainMessage<UIConfigV1> | undefined): boolean {
    return proto3.util.equals(UIConfigV1, a, b);
  }
}

/**
 * UIConfigSpecV1 is the specification for a UIConfig
 *
 * @generated from message types.UIConfigSpecV1
 */
export class UIConfigSpecV1 extends Message<UIConfigSpecV1> {
  /**
   * ScrollbackLines is the max number of lines the UI terminal can display in its history.
   *
   * @generated from field: int32 ScrollbackLines = 1;
   */
  ScrollbackLines = 0;

  /**
   * ShowResources determines which resources are shown in the web UI. Default if unset is "requestable"
   * which means resources the user has access to and resources they can request will be shown in the
   * resources UI. If set to `accessible_only`, only resources the user already has access to will be shown.
   *
   * @generated from field: string ShowResources = 2;
   */
  ShowResources = "";

  constructor(data?: PartialMessage<UIConfigSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UIConfigSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ScrollbackLines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "ShowResources", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UIConfigSpecV1 {
    return new UIConfigSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UIConfigSpecV1 {
    return new UIConfigSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UIConfigSpecV1 {
    return new UIConfigSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: UIConfigSpecV1 | PlainMessage<UIConfigSpecV1> | undefined, b: UIConfigSpecV1 | PlainMessage<UIConfigSpecV1> | undefined): boolean {
    return proto3.util.equals(UIConfigSpecV1, a, b);
  }
}

/**
 * InstallerV1 represents an installer script resource. Used to
 * provide a script to install teleport on discovered nodes.
 *
 * @generated from message types.InstallerV1
 */
export class InstallerV1 extends Message<InstallerV1> {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.InstallerSpecV1 Spec = 5;
   */
  Spec?: InstallerSpecV1;

  constructor(data?: PartialMessage<InstallerV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstallerV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: InstallerSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstallerV1 {
    return new InstallerV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstallerV1 {
    return new InstallerV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstallerV1 {
    return new InstallerV1().fromJsonString(jsonString, options);
  }

  static equals(a: InstallerV1 | PlainMessage<InstallerV1> | undefined, b: InstallerV1 | PlainMessage<InstallerV1> | undefined): boolean {
    return proto3.util.equals(InstallerV1, a, b);
  }
}

/**
 * InstallerSpecV1 is the specification for an Installer
 *
 * @generated from message types.InstallerSpecV1
 */
export class InstallerSpecV1 extends Message<InstallerSpecV1> {
  /**
   * Script represents the contents of a installer shell script
   *
   * @generated from field: string Script = 1;
   */
  Script = "";

  constructor(data?: PartialMessage<InstallerSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstallerSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstallerSpecV1 {
    return new InstallerSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstallerSpecV1 {
    return new InstallerSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstallerSpecV1 {
    return new InstallerSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: InstallerSpecV1 | PlainMessage<InstallerSpecV1> | undefined, b: InstallerSpecV1 | PlainMessage<InstallerSpecV1> | undefined): boolean {
    return proto3.util.equals(InstallerSpecV1, a, b);
  }
}

/**
 * InstallerV1List represents a list of installer resources.
 *
 * @generated from message types.InstallerV1List
 */
export class InstallerV1List extends Message<InstallerV1List> {
  /**
   * Installers is a list of installer resources.
   *
   * @generated from field: repeated types.InstallerV1 installers = 1;
   */
  installers: InstallerV1[] = [];

  constructor(data?: PartialMessage<InstallerV1List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstallerV1List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "installers", kind: "message", T: InstallerV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstallerV1List {
    return new InstallerV1List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstallerV1List {
    return new InstallerV1List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstallerV1List {
    return new InstallerV1List().fromJsonString(jsonString, options);
  }

  static equals(a: InstallerV1List | PlainMessage<InstallerV1List> | undefined, b: InstallerV1List | PlainMessage<InstallerV1List> | undefined): boolean {
    return proto3.util.equals(InstallerV1List, a, b);
  }
}

/**
 * SortBy defines a sort criteria.
 *
 * @generated from message types.SortBy
 */
export class SortBy extends Message<SortBy> {
  /**
   * IsDesc is a sort direction flag where if true the direction is descending, else ascending.
   *
   * @generated from field: bool IsDesc = 1;
   */
  IsDesc = false;

  /**
   * Field is the name of an objects field to sort by.
   *
   * @generated from field: string Field = 2;
   */
  Field = "";

  constructor(data?: PartialMessage<SortBy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SortBy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "IsDesc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "Field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortBy {
    return new SortBy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortBy {
    return new SortBy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortBy {
    return new SortBy().fromJsonString(jsonString, options);
  }

  static equals(a: SortBy | PlainMessage<SortBy> | undefined, b: SortBy | PlainMessage<SortBy> | undefined): boolean {
    return proto3.util.equals(SortBy, a, b);
  }
}

/**
 * ConnectionDiagnosticV1 is the result of testing a connection.
 * When setting up a new resource in Teleport, it's useful to know if we can connect to it.
 * This can be done using the test connection feature.
 * The user can then receive the result as feedback using the UI
 *
 * @generated from message types.ConnectionDiagnosticV1
 */
export class ConnectionDiagnosticV1 extends Message<ConnectionDiagnosticV1> {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.ConnectionDiagnosticSpecV1 Spec = 5;
   */
  Spec?: ConnectionDiagnosticSpecV1;

  constructor(data?: PartialMessage<ConnectionDiagnosticV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ConnectionDiagnosticV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 5, name: "Spec", kind: "message", T: ConnectionDiagnosticSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionDiagnosticV1 {
    return new ConnectionDiagnosticV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionDiagnosticV1 {
    return new ConnectionDiagnosticV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionDiagnosticV1 {
    return new ConnectionDiagnosticV1().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionDiagnosticV1 | PlainMessage<ConnectionDiagnosticV1> | undefined, b: ConnectionDiagnosticV1 | PlainMessage<ConnectionDiagnosticV1> | undefined): boolean {
    return proto3.util.equals(ConnectionDiagnosticV1, a, b);
  }
}

/**
 * ConnectionDiagnosticSpecV1 is the ConnectionDiagnostic Spec.
 * It contains the result of testing a connection.
 * It has the overall result of the connection and then a list of traces.
 * Each trace contains checkpoints of the connection attempt and its result.
 *
 * @generated from message types.ConnectionDiagnosticSpecV1
 */
export class ConnectionDiagnosticSpecV1 extends Message<ConnectionDiagnosticSpecV1> {
  /**
   * Success describes whether the connection was a success or a failure.
   *
   * @generated from field: bool Success = 1;
   */
  Success = false;

  /**
   * Message may contain some user friendly message to let the user know whether it was
   * successful or a failure.
   *
   * @generated from field: string Message = 2;
   */
  Message = "";

  /**
   * Traces contain a list of checkpoints defined by
   *
   * @generated from field: repeated types.ConnectionDiagnosticTrace Traces = 3;
   */
  Traces: ConnectionDiagnosticTrace[] = [];

  constructor(data?: PartialMessage<ConnectionDiagnosticSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ConnectionDiagnosticSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "Message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Traces", kind: "message", T: ConnectionDiagnosticTrace, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionDiagnosticSpecV1 {
    return new ConnectionDiagnosticSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionDiagnosticSpecV1 {
    return new ConnectionDiagnosticSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionDiagnosticSpecV1 {
    return new ConnectionDiagnosticSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionDiagnosticSpecV1 | PlainMessage<ConnectionDiagnosticSpecV1> | undefined, b: ConnectionDiagnosticSpecV1 | PlainMessage<ConnectionDiagnosticSpecV1> | undefined): boolean {
    return proto3.util.equals(ConnectionDiagnosticSpecV1, a, b);
  }
}

/**
 * ConnectionDiagnosticTrace describes a trace of a connection diagnostic
 *
 * @generated from message types.ConnectionDiagnosticTrace
 */
export class ConnectionDiagnosticTrace extends Message<ConnectionDiagnosticTrace> {
  /**
   * @generated from field: types.ConnectionDiagnosticTrace.TraceType Type = 1;
   */
  Type = ConnectionDiagnosticTrace_TraceType.TRACE_TYPE_UNSPECIFIED;

  /**
   * @generated from field: types.ConnectionDiagnosticTrace.StatusType Status = 2;
   */
  Status = ConnectionDiagnosticTrace_StatusType.STATUS_UNSPECIFIED;

  /**
   * Details contains a User friendly message of the check's result.
   *
   * @generated from field: string Details = 3;
   */
  Details = "";

  /**
   * Error contains the low level error message in case of a failure.
   *
   * @generated from field: string Error = 4;
   */
  Error = "";

  constructor(data?: PartialMessage<ConnectionDiagnosticTrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ConnectionDiagnosticTrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "enum", T: proto3.getEnumType(ConnectionDiagnosticTrace_TraceType) },
    { no: 2, name: "Status", kind: "enum", T: proto3.getEnumType(ConnectionDiagnosticTrace_StatusType) },
    { no: 3, name: "Details", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionDiagnosticTrace {
    return new ConnectionDiagnosticTrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionDiagnosticTrace {
    return new ConnectionDiagnosticTrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionDiagnosticTrace {
    return new ConnectionDiagnosticTrace().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionDiagnosticTrace | PlainMessage<ConnectionDiagnosticTrace> | undefined, b: ConnectionDiagnosticTrace | PlainMessage<ConnectionDiagnosticTrace> | undefined): boolean {
    return proto3.util.equals(ConnectionDiagnosticTrace, a, b);
  }
}

/**
 * TraceType is an identification of the checkpoint.
 *
 * @generated from enum types.ConnectionDiagnosticTrace.TraceType
 */
export enum ConnectionDiagnosticTrace_TraceType {
  /**
   * @generated from enum value: TRACE_TYPE_UNSPECIFIED = 0;
   */
  TRACE_TYPE_UNSPECIFIED = 0,

  /**
   * UNKNOWN_ERROR is used when we don't know the error.
   * It's not always possible to offer guidance based on the received error.
   * This trace type should be used when the error is too generic given the context we
   * have.
   *
   * @generated from enum value: UNKNOWN_ERROR = 1;
   */
  UNKNOWN_ERROR = 1,

  /**
   * RBAC_NODE is for RBAC checks for the node.
   *
   * @generated from enum value: RBAC_NODE = 2;
   */
  RBAC_NODE = 2,

  /**
   * CONNECTIVITY is for network connectivity checks.
   *
   * @generated from enum value: CONNECTIVITY = 3;
   */
  CONNECTIVITY = 3,

  /**
   * RBAC_PRINCIPAL is used when checking if the principal is allowed per RBAC rules.
   *
   * @generated from enum value: RBAC_PRINCIPAL = 4;
   */
  RBAC_PRINCIPAL = 4,

  /**
   * NODE_PRINCIPAL is used when checking if the Node has the requested principal.
   *
   * @generated from enum value: NODE_PRINCIPAL = 5;
   */
  NODE_PRINCIPAL = 5,

  /**
   * RBAC_KUBE is for RBAC checks to kubernetes the cluster.
   *
   * @generated from enum value: RBAC_KUBE = 6;
   */
  RBAC_KUBE = 6,

  /**
   * KUBE_PRINCIPAL is used when checking if the Kube Cluster has at least one user principals.
   *
   * @generated from enum value: KUBE_PRINCIPAL = 7;
   */
  KUBE_PRINCIPAL = 7,

  /**
   * RBAC_DATABASE is for RBAC checks to database access (db_labels).
   *
   * @generated from enum value: RBAC_DATABASE = 8;
   */
  RBAC_DATABASE = 8,

  /**
   * RBAC_DATABASE_LOGIN is for RBAC checks to database login (db_name and db_user).
   *
   * @generated from enum value: RBAC_DATABASE_LOGIN = 9;
   */
  RBAC_DATABASE_LOGIN = 9,

  /**
   * DATABASE_DB_USER is used when checking whether the Database has the requested Database User.
   *
   * @generated from enum value: DATABASE_DB_USER = 10;
   */
  DATABASE_DB_USER = 10,

  /**
   * DATABASE_DB_NAME is used when checking whether the Database has the requested Database Name.
   *
   * @generated from enum value: DATABASE_DB_NAME = 11;
   */
  DATABASE_DB_NAME = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionDiagnosticTrace_TraceType)
proto3.util.setEnumType(ConnectionDiagnosticTrace_TraceType, "types.ConnectionDiagnosticTrace.TraceType", [
  { no: 0, name: "TRACE_TYPE_UNSPECIFIED" },
  { no: 1, name: "UNKNOWN_ERROR" },
  { no: 2, name: "RBAC_NODE" },
  { no: 3, name: "CONNECTIVITY" },
  { no: 4, name: "RBAC_PRINCIPAL" },
  { no: 5, name: "NODE_PRINCIPAL" },
  { no: 6, name: "RBAC_KUBE" },
  { no: 7, name: "KUBE_PRINCIPAL" },
  { no: 8, name: "RBAC_DATABASE" },
  { no: 9, name: "RBAC_DATABASE_LOGIN" },
  { no: 10, name: "DATABASE_DB_USER" },
  { no: 11, name: "DATABASE_DB_NAME" },
]);

/**
 * StatusType describes whether this was a success or a failure.
 *
 * @generated from enum types.ConnectionDiagnosticTrace.StatusType
 */
export enum ConnectionDiagnosticTrace_StatusType {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionDiagnosticTrace_StatusType)
proto3.util.setEnumType(ConnectionDiagnosticTrace_StatusType, "types.ConnectionDiagnosticTrace.StatusType", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "SUCCESS" },
  { no: 2, name: "FAILED" },
]);

/**
 * DatabaseServiceV1 is the representation of a DatabaseService (agent) process.
 *
 * @generated from message types.DatabaseServiceV1
 */
export class DatabaseServiceV1 extends Message<DatabaseServiceV1> {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.DatabaseServiceSpecV1 Spec = 2;
   */
  Spec?: DatabaseServiceSpecV1;

  constructor(data?: PartialMessage<DatabaseServiceV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseServiceV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: DatabaseServiceSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseServiceV1 {
    return new DatabaseServiceV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseServiceV1 {
    return new DatabaseServiceV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseServiceV1 {
    return new DatabaseServiceV1().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseServiceV1 | PlainMessage<DatabaseServiceV1> | undefined, b: DatabaseServiceV1 | PlainMessage<DatabaseServiceV1> | undefined): boolean {
    return proto3.util.equals(DatabaseServiceV1, a, b);
  }
}

/**
 * DatabaseServiceSpecV1 is the DatabaseService Spec.
 *
 * @generated from message types.DatabaseServiceSpecV1
 */
export class DatabaseServiceSpecV1 extends Message<DatabaseServiceSpecV1> {
  /**
   * ResourceMatchers is the configured match for Database resources.
   *
   * @generated from field: repeated types.DatabaseResourceMatcher ResourceMatchers = 1;
   */
  ResourceMatchers: DatabaseResourceMatcher[] = [];

  /**
   * Hostname is the hostname where this service is running.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname = "";

  constructor(data?: PartialMessage<DatabaseServiceSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseServiceSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ResourceMatchers", kind: "message", T: DatabaseResourceMatcher, repeated: true },
    { no: 2, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseServiceSpecV1 {
    return new DatabaseServiceSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseServiceSpecV1 {
    return new DatabaseServiceSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseServiceSpecV1 {
    return new DatabaseServiceSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseServiceSpecV1 | PlainMessage<DatabaseServiceSpecV1> | undefined, b: DatabaseServiceSpecV1 | PlainMessage<DatabaseServiceSpecV1> | undefined): boolean {
    return proto3.util.equals(DatabaseServiceSpecV1, a, b);
  }
}

/**
 * DatabaseResourceMatcher is a set of properties that is used to match on resources.
 *
 * @generated from message types.DatabaseResourceMatcher
 */
export class DatabaseResourceMatcher extends Message<DatabaseResourceMatcher> {
  /**
   * @generated from field: wrappers.LabelValues Labels = 1;
   */
  Labels?: LabelValues;

  /**
   * @generated from field: types.ResourceMatcherAWS AWS = 2;
   */
  AWS?: ResourceMatcherAWS;

  constructor(data?: PartialMessage<DatabaseResourceMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DatabaseResourceMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Labels", kind: "message", T: LabelValues },
    { no: 2, name: "AWS", kind: "message", T: ResourceMatcherAWS },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseResourceMatcher {
    return new DatabaseResourceMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseResourceMatcher {
    return new DatabaseResourceMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseResourceMatcher {
    return new DatabaseResourceMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseResourceMatcher | PlainMessage<DatabaseResourceMatcher> | undefined, b: DatabaseResourceMatcher | PlainMessage<DatabaseResourceMatcher> | undefined): boolean {
    return proto3.util.equals(DatabaseResourceMatcher, a, b);
  }
}

/**
 * ResourceMatcherAWS contains AWS specific settings for resource matcher.
 *
 * @generated from message types.ResourceMatcherAWS
 */
export class ResourceMatcherAWS extends Message<ResourceMatcherAWS> {
  /**
   * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
   *
   * @generated from field: string AssumeRoleARN = 1;
   */
  AssumeRoleARN = "";

  /**
   * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
   *
   * @generated from field: string ExternalID = 2;
   */
  ExternalID = "";

  constructor(data?: PartialMessage<ResourceMatcherAWS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ResourceMatcherAWS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AssumeRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ExternalID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMatcherAWS {
    return new ResourceMatcherAWS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMatcherAWS {
    return new ResourceMatcherAWS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMatcherAWS {
    return new ResourceMatcherAWS().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceMatcherAWS | PlainMessage<ResourceMatcherAWS> | undefined, b: ResourceMatcherAWS | PlainMessage<ResourceMatcherAWS> | undefined): boolean {
    return proto3.util.equals(ResourceMatcherAWS, a, b);
  }
}

/**
 * ClusterAlert is a cluster-level alert message.
 *
 * @generated from message types.ClusterAlert
 */
export class ClusterAlert extends Message<ClusterAlert> {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.ClusterAlertSpec Spec = 2;
   */
  Spec?: ClusterAlertSpec;

  constructor(data?: PartialMessage<ClusterAlert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterAlert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: ClusterAlertSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterAlert {
    return new ClusterAlert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterAlert {
    return new ClusterAlert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterAlert {
    return new ClusterAlert().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterAlert | PlainMessage<ClusterAlert> | undefined, b: ClusterAlert | PlainMessage<ClusterAlert> | undefined): boolean {
    return proto3.util.equals(ClusterAlert, a, b);
  }
}

/**
 * ClusterAlertSpec is a cluster alert specification.
 *
 * @generated from message types.ClusterAlertSpec
 */
export class ClusterAlertSpec extends Message<ClusterAlertSpec> {
  /**
   * Severity represents how problematic/urgent the alert is.
   *
   * @generated from field: types.AlertSeverity Severity = 1;
   */
  Severity = AlertSeverity.LOW;

  /**
   * Message is the user-facing message associated with the alert.
   *
   * @generated from field: string Message = 2;
   */
  Message = "";

  /**
   * Created is the time at which the alert was generated.
   *
   * @generated from field: google.protobuf.Timestamp Created = 3;
   */
  Created?: Timestamp;

  constructor(data?: PartialMessage<ClusterAlertSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterAlertSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Severity", kind: "enum", T: proto3.getEnumType(AlertSeverity) },
    { no: 2, name: "Message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Created", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterAlertSpec {
    return new ClusterAlertSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterAlertSpec {
    return new ClusterAlertSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterAlertSpec {
    return new ClusterAlertSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterAlertSpec | PlainMessage<ClusterAlertSpec> | undefined, b: ClusterAlertSpec | PlainMessage<ClusterAlertSpec> | undefined): boolean {
    return proto3.util.equals(ClusterAlertSpec, a, b);
  }
}

/**
 * GetClusterAlertsRequest matches cluster alerts.
 *
 * @generated from message types.GetClusterAlertsRequest
 */
export class GetClusterAlertsRequest extends Message<GetClusterAlertsRequest> {
  /**
   * Severity is an optional minimum severity.
   *
   * @generated from field: types.AlertSeverity Severity = 1;
   */
  Severity = AlertSeverity.LOW;

  /**
   * AlertID optionally specifies the ID of the alert being requested.
   *
   * @generated from field: string AlertID = 2;
   */
  AlertID = "";

  /**
   * Labels is an optional label selector.
   *
   * @generated from field: map<string, string> Labels = 3;
   */
  Labels: { [key: string]: string } = {};

  /**
   * WithSuperseded includes superseded alerts in the output of the request.
   *
   * @generated from field: bool WithSuperseded = 4;
   */
  WithSuperseded = false;

  /**
   * WithAcknowledged includes acknowledged alerts in the output of the request.
   *
   * @generated from field: bool WithAcknowledged = 5;
   */
  WithAcknowledged = false;

  /**
   * WithUntargeted requests that alerts be included even if they are not specifically
   * targeted toward the caller. This has no effect unless the caller has `cluster_alert:list`.
   *
   * @generated from field: bool WithUntargeted = 6;
   */
  WithUntargeted = false;

  constructor(data?: PartialMessage<GetClusterAlertsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GetClusterAlertsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Severity", kind: "enum", T: proto3.getEnumType(AlertSeverity) },
    { no: 2, name: "AlertID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "WithSuperseded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "WithAcknowledged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "WithUntargeted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterAlertsRequest {
    return new GetClusterAlertsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterAlertsRequest {
    return new GetClusterAlertsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterAlertsRequest {
    return new GetClusterAlertsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterAlertsRequest | PlainMessage<GetClusterAlertsRequest> | undefined, b: GetClusterAlertsRequest | PlainMessage<GetClusterAlertsRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterAlertsRequest, a, b);
  }
}

/**
 * AlertAcknowledgement marks a cluster alert as having been "acknowledged".
 * This causes the alert to no longer be displayed in 'tsh login', UI banners,
 * etc. Acknowledgements must have an expiry and a message describing why the
 * alert can be considered acknowledged.
 *
 * @generated from message types.AlertAcknowledgement
 */
export class AlertAcknowledgement extends Message<AlertAcknowledgement> {
  /**
   * AlertID is the ID of the alert being acknowledged.
   *
   * @generated from field: string AlertID = 1;
   */
  AlertID = "";

  /**
   * Reason describes the reason why the alert can be considered
   * acknowledged (e.g. 'alice will fix next week').
   *
   * @generated from field: string Reason = 2;
   */
  Reason = "";

  /**
   * Expires is the time after which the acknowledgement expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  constructor(data?: PartialMessage<AlertAcknowledgement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AlertAcknowledgement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AlertID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Expires", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertAcknowledgement {
    return new AlertAcknowledgement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertAcknowledgement {
    return new AlertAcknowledgement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertAcknowledgement {
    return new AlertAcknowledgement().fromJsonString(jsonString, options);
  }

  static equals(a: AlertAcknowledgement | PlainMessage<AlertAcknowledgement> | undefined, b: AlertAcknowledgement | PlainMessage<AlertAcknowledgement> | undefined): boolean {
    return proto3.util.equals(AlertAcknowledgement, a, b);
  }
}

/**
 * Release correspond to a Teleport Enterprise releases
 *
 * @generated from message types.Release
 */
export class Release extends Message<Release> {
  /**
   * NotesMD is the notes of the release in markdown
   *
   * @generated from field: string NotesMD = 1;
   */
  NotesMD = "";

  /**
   * Product is the release product, teleport or teleport-ent
   *
   * @generated from field: string Product = 2;
   */
  Product = "";

  /**
   * ReleaseID is the ID of the product
   *
   * @generated from field: string ReleaseID = 3;
   */
  ReleaseID = "";

  /**
   * Status is the status of the release
   *
   * @generated from field: string Status = 4;
   */
  Status = "";

  /**
   * Version is the version of the release
   *
   * @generated from field: string Version = 5;
   */
  Version = "";

  /**
   * Assets is a list of assets related to the release
   *
   * @generated from field: repeated types.Asset Assets = 6;
   */
  Assets: Asset[] = [];

  constructor(data?: PartialMessage<Release>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Release";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "NotesMD", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Product", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ReleaseID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Assets", kind: "message", T: Asset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Release {
    return new Release().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Release {
    return new Release().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Release {
    return new Release().fromJsonString(jsonString, options);
  }

  static equals(a: Release | PlainMessage<Release> | undefined, b: Release | PlainMessage<Release> | undefined): boolean {
    return proto3.util.equals(Release, a, b);
  }
}

/**
 * Asset represents a release asset
 *
 * @generated from message types.Asset
 */
export class Asset extends Message<Asset> {
  /**
   * Arch is the architecture of the asset
   *
   * @generated from field: string Arch = 1;
   */
  Arch = "";

  /**
   * Description is the description of the asset
   *
   * @generated from field: string Description = 2;
   */
  Description = "";

  /**
   * Name is the name of the asset
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * OS is which OS the asset is built for
   *
   * @generated from field: string OS = 4;
   */
  OS = "";

  /**
   * SHA256 is the sha256 of the asset
   *
   * @generated from field: string SHA256 = 5;
   */
  SHA256 = "";

  /**
   * Size is the size of the release in bytes
   *
   * @generated from field: int64 AssetSize = 6;
   */
  AssetSize = protoInt64.zero;

  /**
   * DisplaySize is the human-readable size of the asset
   *
   * @generated from field: string DisplaySize = 7;
   */
  DisplaySize = "";

  /**
   * ReleaseIDs is a list of releases that have the asset included
   *
   * @generated from field: repeated string ReleaseIDs = 8;
   */
  ReleaseIDs: string[] = [];

  /**
   * PublicURL is the public URL used to download the asset
   *
   * @generated from field: string PublicURL = 9;
   */
  PublicURL = "";

  constructor(data?: PartialMessage<Asset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.Asset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Arch", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "OS", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "SHA256", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AssetSize", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "DisplaySize", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "ReleaseIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "PublicURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Asset {
    return new Asset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJsonString(jsonString, options);
  }

  static equals(a: Asset | PlainMessage<Asset> | undefined, b: Asset | PlainMessage<Asset> | undefined): boolean {
    return proto3.util.equals(Asset, a, b);
  }
}

/**
 * Plugin describes a single instance of a Teleport Plugin
 *
 * @generated from message types.PluginV1
 */
export class PluginV1 extends Message<PluginV1> {
  /**
   * kind is the plugin resource kind.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * sub_kind is an optional resource subkind.
   *
   * @generated from field: string sub_kind = 2;
   */
  subKind = "";

  /**
   * version is the resource version.
   *
   * @generated from field: string version = 3;
   */
  version = "";

  /**
   * metadata is the resource metadata.
   *
   * @generated from field: types.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * @generated from field: types.PluginSpecV1 spec = 5;
   */
  spec?: PluginSpecV1;

  /**
   * @generated from field: types.PluginStatusV1 status = 6;
   */
  status?: PluginStatusV1;

  /**
   * credentials are "live" credentials to the 3rd party API.
   * These are considered secrets.
   *
   * @generated from field: types.PluginCredentialsV1 credentials = 7;
   */
  credentials?: PluginCredentialsV1;

  constructor(data?: PartialMessage<PluginV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sub_kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "spec", kind: "message", T: PluginSpecV1 },
    { no: 6, name: "status", kind: "message", T: PluginStatusV1 },
    { no: 7, name: "credentials", kind: "message", T: PluginCredentialsV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginV1 {
    return new PluginV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginV1 {
    return new PluginV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginV1 {
    return new PluginV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginV1 | PlainMessage<PluginV1> | undefined, b: PluginV1 | PlainMessage<PluginV1> | undefined): boolean {
    return proto3.util.equals(PluginV1, a, b);
  }
}

/**
 * @generated from message types.PluginSpecV1
 */
export class PluginSpecV1 extends Message<PluginSpecV1> {
  /**
   * settings contain provider-specific plugin options.
   *
   * @generated from oneof types.PluginSpecV1.settings
   */
  settings: {
    /**
     * Settings for the Slack access plugin
     *
     * @generated from field: types.PluginSlackAccessSettings slack_access_plugin = 1;
     */
    value: PluginSlackAccessSettings;
    case: "slackAccessPlugin";
  } | {
    /**
     * Settings for the Opsgenie access plugin
     *
     * @generated from field: types.PluginOpsgenieAccessSettings opsgenie = 2;
     */
    value: PluginOpsgenieAccessSettings;
    case: "opsgenie";
  } | {
    /**
     * Settings for OpenAI plugin
     *
     * @generated from field: types.PluginOpenAISettings openai = 3;
     */
    value: PluginOpenAISettings;
    case: "openai";
  } | {
    /**
     * Settings for the Okta plugin
     *
     * @generated from field: types.PluginOktaSettings okta = 4;
     */
    value: PluginOktaSettings;
    case: "okta";
  } | {
    /**
     * Settings for device trust jamf plugin
     *
     * @generated from field: types.PluginJamfSettings jamf = 5;
     */
    value: PluginJamfSettings;
    case: "jamf";
  } | {
    /**
     * Settings for the PagerDuty plugin
     *
     * @generated from field: types.PluginPagerDutySettings pager_duty = 6;
     */
    value: PluginPagerDutySettings;
    case: "pagerDuty";
  } | {
    /**
     * Settings for the Mattermost plugin
     *
     * @generated from field: types.PluginMattermostSettings mattermost = 7;
     */
    value: PluginMattermostSettings;
    case: "mattermost";
  } | {
    /**
     * Settings for the JIRA plugin
     *
     * @generated from field: types.PluginJiraSettings jira = 8;
     */
    value: PluginJiraSettings;
    case: "jira";
  } | {
    /**
     * Settings for the Discord plugin
     *
     * @generated from field: types.PluginDiscordSettings discord = 9;
     */
    value: PluginDiscordSettings;
    case: "discord";
  } | {
    /**
     * Settings for the ServiceNow plugin
     *
     * @generated from field: types.PluginServiceNowSettings serviceNow = 10;
     */
    value: PluginServiceNowSettings;
    case: "serviceNow";
  } | {
    /**
     * Settings for the Gitlab plugin.
     *
     * @generated from field: types.PluginGitlabSettings gitlab = 12;
     */
    value: PluginGitlabSettings;
    case: "gitlab";
  } | {
    /**
     * Settings for the Entra ID plugin
     *
     * @generated from field: types.PluginEntraIDSettings entra_id = 13;
     */
    value: PluginEntraIDSettings;
    case: "entraId";
  } | {
    /**
     * Settings for the SCIM plugin
     *
     * @generated from field: types.PluginSCIMSettings scim = 14;
     */
    value: PluginSCIMSettings;
    case: "scim";
  } | {
    /**
     * Settings for the Datadog Incident Management plugin
     *
     * @generated from field: types.PluginDatadogAccessSettings datadog = 15;
     */
    value: PluginDatadogAccessSettings;
    case: "datadog";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * generation contains a unique ID that should:
   * - Be created by the backend on plugin creation.
   * - Be updated by the backend if the plugin is updated in any way.
   *
   * For older plugins, it's possible for this to be empty.
   *
   * @generated from field: string generation = 11;
   */
  generation = "";

  constructor(data?: PartialMessage<PluginSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slack_access_plugin", kind: "message", T: PluginSlackAccessSettings, oneof: "settings" },
    { no: 2, name: "opsgenie", kind: "message", T: PluginOpsgenieAccessSettings, oneof: "settings" },
    { no: 3, name: "openai", kind: "message", T: PluginOpenAISettings, oneof: "settings" },
    { no: 4, name: "okta", kind: "message", T: PluginOktaSettings, oneof: "settings" },
    { no: 5, name: "jamf", kind: "message", T: PluginJamfSettings, oneof: "settings" },
    { no: 6, name: "pager_duty", kind: "message", T: PluginPagerDutySettings, oneof: "settings" },
    { no: 7, name: "mattermost", kind: "message", T: PluginMattermostSettings, oneof: "settings" },
    { no: 8, name: "jira", kind: "message", T: PluginJiraSettings, oneof: "settings" },
    { no: 9, name: "discord", kind: "message", T: PluginDiscordSettings, oneof: "settings" },
    { no: 10, name: "serviceNow", kind: "message", T: PluginServiceNowSettings, oneof: "settings" },
    { no: 12, name: "gitlab", kind: "message", T: PluginGitlabSettings, oneof: "settings" },
    { no: 13, name: "entra_id", kind: "message", T: PluginEntraIDSettings, oneof: "settings" },
    { no: 14, name: "scim", kind: "message", T: PluginSCIMSettings, oneof: "settings" },
    { no: 15, name: "datadog", kind: "message", T: PluginDatadogAccessSettings, oneof: "settings" },
    { no: 11, name: "generation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginSpecV1 {
    return new PluginSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginSpecV1 {
    return new PluginSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginSpecV1 {
    return new PluginSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginSpecV1 | PlainMessage<PluginSpecV1> | undefined, b: PluginSpecV1 | PlainMessage<PluginSpecV1> | undefined): boolean {
    return proto3.util.equals(PluginSpecV1, a, b);
  }
}

/**
 * @generated from message types.PluginSlackAccessSettings
 */
export class PluginSlackAccessSettings extends Message<PluginSlackAccessSettings> {
  /**
   * @generated from field: string fallback_channel = 1;
   */
  fallbackChannel = "";

  constructor(data?: PartialMessage<PluginSlackAccessSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginSlackAccessSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fallback_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginSlackAccessSettings {
    return new PluginSlackAccessSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginSlackAccessSettings {
    return new PluginSlackAccessSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginSlackAccessSettings {
    return new PluginSlackAccessSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginSlackAccessSettings | PlainMessage<PluginSlackAccessSettings> | undefined, b: PluginSlackAccessSettings | PlainMessage<PluginSlackAccessSettings> | undefined): boolean {
    return proto3.util.equals(PluginSlackAccessSettings, a, b);
  }
}

/**
 * @generated from message types.PluginGitlabSettings
 */
export class PluginGitlabSettings extends Message<PluginGitlabSettings> {
  /**
   * APIEndpoint is the address of Gitlab API.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint = "";

  constructor(data?: PartialMessage<PluginGitlabSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginGitlabSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginGitlabSettings {
    return new PluginGitlabSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginGitlabSettings {
    return new PluginGitlabSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginGitlabSettings {
    return new PluginGitlabSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginGitlabSettings | PlainMessage<PluginGitlabSettings> | undefined, b: PluginGitlabSettings | PlainMessage<PluginGitlabSettings> | undefined): boolean {
    return proto3.util.equals(PluginGitlabSettings, a, b);
  }
}

/**
 * @generated from message types.PluginOpsgenieAccessSettings
 */
export class PluginOpsgenieAccessSettings extends Message<PluginOpsgenieAccessSettings> {
  /**
   * Priority to create Opsgenie alerts with
   *
   * @generated from field: string priority = 2;
   */
  priority = "";

  /**
   * List of tags to be added to alerts created in Opsgenie
   *
   * @generated from field: repeated string alert_tags = 3;
   */
  alertTags: string[] = [];

  /**
   * Default on-call schedules to check if none are provided in the access request annotations
   *
   * @generated from field: repeated string default_schedules = 4;
   */
  defaultSchedules: string[] = [];

  /**
   * APIEndpoint is the address of Opsgenie API.
   *
   * @generated from field: string api_endpoint = 5;
   */
  apiEndpoint = "";

  constructor(data?: PartialMessage<PluginOpsgenieAccessSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOpsgenieAccessSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "priority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "alert_tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "default_schedules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOpsgenieAccessSettings {
    return new PluginOpsgenieAccessSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOpsgenieAccessSettings {
    return new PluginOpsgenieAccessSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOpsgenieAccessSettings {
    return new PluginOpsgenieAccessSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOpsgenieAccessSettings | PlainMessage<PluginOpsgenieAccessSettings> | undefined, b: PluginOpsgenieAccessSettings | PlainMessage<PluginOpsgenieAccessSettings> | undefined): boolean {
    return proto3.util.equals(PluginOpsgenieAccessSettings, a, b);
  }
}

/**
 * PluginServiceNowSettings are the settings for the serviceNow plugin
 *
 * @generated from message types.PluginServiceNowSettings
 */
export class PluginServiceNowSettings extends Message<PluginServiceNowSettings> {
  /**
   * ApiEndpoint is the ServiceNow API endpoint.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint = "";

  /**
   * Username is the ServiceNow API username.
   *
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * Password is the ServiceNow API password.
   *
   * @generated from field: string password = 3;
   */
  password = "";

  /**
   * CloseCode is the close code that ServiceNow incidents will use.
   *
   * @generated from field: string close_code = 4;
   */
  closeCode = "";

  constructor(data?: PartialMessage<PluginServiceNowSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginServiceNowSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "close_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginServiceNowSettings {
    return new PluginServiceNowSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginServiceNowSettings {
    return new PluginServiceNowSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginServiceNowSettings {
    return new PluginServiceNowSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginServiceNowSettings | PlainMessage<PluginServiceNowSettings> | undefined, b: PluginServiceNowSettings | PlainMessage<PluginServiceNowSettings> | undefined): boolean {
    return proto3.util.equals(PluginServiceNowSettings, a, b);
  }
}

/**
 * @generated from message types.PluginPagerDutySettings
 */
export class PluginPagerDutySettings extends Message<PluginPagerDutySettings> {
  /**
   * UserEmail is the email address of the PagerDuty user that will be
   * listed as the reporter source of incidents, comments, etc
   * within PagerDuty. Should usually be the same user the API key
   * represents.
   *
   * @generated from field: string user_email = 1;
   */
  userEmail = "";

  /**
   * APIEndpoint is the address of PagerDuty API.
   *
   * @generated from field: string api_endpoint = 2;
   */
  apiEndpoint = "";

  constructor(data?: PartialMessage<PluginPagerDutySettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginPagerDutySettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginPagerDutySettings {
    return new PluginPagerDutySettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginPagerDutySettings {
    return new PluginPagerDutySettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginPagerDutySettings {
    return new PluginPagerDutySettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginPagerDutySettings | PlainMessage<PluginPagerDutySettings> | undefined, b: PluginPagerDutySettings | PlainMessage<PluginPagerDutySettings> | undefined): boolean {
    return proto3.util.equals(PluginPagerDutySettings, a, b);
  }
}

/**
 * @generated from message types.PluginJiraSettings
 */
export class PluginJiraSettings extends Message<PluginJiraSettings> {
  /**
   * ServerURL is the address of the target JIRA Server instance.
   *
   * @generated from field: string server_url = 1;
   */
  serverUrl = "";

  /**
   * ProjectKey is the key of the Jira project that will receive
   * notifications and issues from the plugin.
   *
   * @generated from field: string project_key = 2;
   */
  projectKey = "";

  /**
   * IssueType is the type of Jira Issue that the plugin will create
   *
   * @generated from field: string issue_type = 3;
   */
  issueType = "";

  constructor(data?: PartialMessage<PluginJiraSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginJiraSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "project_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "issue_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginJiraSettings {
    return new PluginJiraSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginJiraSettings {
    return new PluginJiraSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginJiraSettings {
    return new PluginJiraSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginJiraSettings | PlainMessage<PluginJiraSettings> | undefined, b: PluginJiraSettings | PlainMessage<PluginJiraSettings> | undefined): boolean {
    return proto3.util.equals(PluginJiraSettings, a, b);
  }
}

/**
 * Defines settings for the OpenAI plugin. Currently there are no settings.
 *
 * @generated from message types.PluginOpenAISettings
 */
export class PluginOpenAISettings extends Message<PluginOpenAISettings> {
  constructor(data?: PartialMessage<PluginOpenAISettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOpenAISettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOpenAISettings {
    return new PluginOpenAISettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOpenAISettings {
    return new PluginOpenAISettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOpenAISettings {
    return new PluginOpenAISettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOpenAISettings | PlainMessage<PluginOpenAISettings> | undefined, b: PluginOpenAISettings | PlainMessage<PluginOpenAISettings> | undefined): boolean {
    return proto3.util.equals(PluginOpenAISettings, a, b);
  }
}

/**
 * Defines settings for the Mattermost plugin.
 *
 * @generated from message types.PluginMattermostSettings
 */
export class PluginMattermostSettings extends Message<PluginMattermostSettings> {
  /**
   * serverURL is the URL to access Mattermost.
   *
   * @generated from field: string server_url = 1;
   */
  serverUrl = "";

  /**
   * team is the Mattermost workspace.
   *
   * @generated from field: string team = 2;
   */
  team = "";

  /**
   * channel is the Mattermost channel in the workspace
   * (team) to send notifications to.
   *
   * @generated from field: string channel = 3;
   */
  channel = "";

  /**
   * report_to_email is an optional email address of a Mattermost user
   * to notify via a direct message when the plugin receives an
   * Access Request event.
   *
   * @generated from field: string report_to_email = 4;
   */
  reportToEmail = "";

  constructor(data?: PartialMessage<PluginMattermostSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginMattermostSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "server_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "team", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "report_to_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginMattermostSettings {
    return new PluginMattermostSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginMattermostSettings {
    return new PluginMattermostSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginMattermostSettings {
    return new PluginMattermostSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginMattermostSettings | PlainMessage<PluginMattermostSettings> | undefined, b: PluginMattermostSettings | PlainMessage<PluginMattermostSettings> | undefined): boolean {
    return proto3.util.equals(PluginMattermostSettings, a, b);
  }
}

/**
 * Defines settings for Jamf plugin.
 *
 * @generated from message types.PluginJamfSettings
 */
export class PluginJamfSettings extends Message<PluginJamfSettings> {
  /**
   * Jamf service spec
   *
   * @generated from field: types.JamfSpecV1 jamf_spec = 1;
   */
  jamfSpec?: JamfSpecV1;

  constructor(data?: PartialMessage<PluginJamfSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginJamfSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jamf_spec", kind: "message", T: JamfSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginJamfSettings {
    return new PluginJamfSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginJamfSettings {
    return new PluginJamfSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginJamfSettings {
    return new PluginJamfSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginJamfSettings | PlainMessage<PluginJamfSettings> | undefined, b: PluginJamfSettings | PlainMessage<PluginJamfSettings> | undefined): boolean {
    return proto3.util.equals(PluginJamfSettings, a, b);
  }
}

/**
 * Defines settings for the Okta plugin.
 *
 * @generated from message types.PluginOktaSettings
 */
export class PluginOktaSettings extends Message<PluginOktaSettings> {
  /**
   * OrgUrl is the Okta organization URL to use for API communication.
   *
   * @generated from field: string org_url = 1;
   */
  orgUrl = "";

  /**
   * EnableUserSync controls the user sync in the Okta integration service. Deprecated.
   * TODO(mdwn): Remove once e changes have been made.
   *
   * @generated from field: bool enable_user_sync = 2;
   */
  enableUserSync = false;

  /**
   * SSOConnectorID (deprecated)
   * TODO(mdwn): Remove once e changes have been made.
   *
   * @generated from field: string sso_connector_id = 3;
   */
  ssoConnectorId = "";

  /**
   * Sync settings controls the user and access list sync settings for Okta.
   *
   * @generated from field: types.PluginOktaSyncSettings sync_settings = 4;
   */
  syncSettings?: PluginOktaSyncSettings;

  constructor(data?: PartialMessage<PluginOktaSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "org_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enable_user_sync", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "sso_connector_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "sync_settings", kind: "message", T: PluginOktaSyncSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaSettings {
    return new PluginOktaSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaSettings {
    return new PluginOktaSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaSettings {
    return new PluginOktaSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaSettings | PlainMessage<PluginOktaSettings> | undefined, b: PluginOktaSettings | PlainMessage<PluginOktaSettings> | undefined): boolean {
    return proto3.util.equals(PluginOktaSettings, a, b);
  }
}

/**
 * Defines settings for syncing users and access lists from Okta.
 *
 * @generated from message types.PluginOktaSyncSettings
 */
export class PluginOktaSyncSettings extends Message<PluginOktaSyncSettings> {
  /**
   * SyncUsers controls the user sync in the Okta integration service.
   *
   * @generated from field: bool sync_users = 1;
   */
  syncUsers = false;

  /**
   * SSOConnectorID is the name of the Teleport SSO connector created and used by the Okta plugin
   *
   * @generated from field: string sso_connector_id = 2;
   */
  ssoConnectorId = "";

  /**
   * SyncAccessLists controls the access list sync in the Okta integration service.
   *
   * @generated from field: bool sync_access_lists = 3;
   */
  syncAccessLists = false;

  /**
   * DefaultOwners are the default owners for all imported access lists.
   *
   * @generated from field: repeated string default_owners = 4;
   */
  defaultOwners: string[] = [];

  /**
   * AppID is the Okta-assigned ID of the Okta App that Teleport uses as a
   * gateway to interact with Okta for SAML login, SCIM provisioning and user
   * sync. When set, user sync will pull users from the assignment list for this
   * app. When empty the plugin will fall back to the legacy behaviour of syncing
   * users from the entre organization.
   *
   * @generated from field: string app_id = 5;
   */
  appId = "";

  /**
   * GroupFilters are filters for which Okta groups to synchronize as access lists.
   * Filters can be globs, for example:
   *   group*
   *   *service*
   * Or regexes if they're prefixed and suffixed with ^ and $, for example:
   *   ^group.*$
   *   ^.*service.*$
   *
   * @generated from field: repeated string group_filters = 6;
   */
  groupFilters: string[] = [];

  /**
   * AppFilters are filters for which Okta applications to synchronize as access lists.
   * Filters can be globs, for example:
   *   app*
   *   *service*
   * Or regexes if they're prefixed and suffixed with ^ and $, for example:
   *   ^app.*$
   *   ^.*service.*$
   *
   * @generated from field: repeated string app_filters = 7;
   */
  appFilters: string[] = [];

  /**
   * AppName is the Okta-assigned unique name of the Okta App that Teleport uses
   * as a gateway to interact with Okta for SAML login, SCIM provisioning and user
   * sync. May be missing for old Okta integration installs.
   *
   * @generated from field: string app_name = 8;
   */
  appName = "";

  /**
   * DisableSyncAppGroups disables syncing of app groups from Okta.
   * This is useful when the app groups are not needed in Teleport.
   * and integration with Okta is only used for user sync.
   *
   * @generated from field: bool disable_sync_app_groups = 9;
   */
  disableSyncAppGroups = false;

  constructor(data?: PartialMessage<PluginOktaSyncSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaSyncSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_users", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "sso_connector_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sync_access_lists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "default_owners", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "group_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "app_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "app_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "disable_sync_app_groups", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaSyncSettings {
    return new PluginOktaSyncSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaSyncSettings {
    return new PluginOktaSyncSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaSyncSettings {
    return new PluginOktaSyncSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaSyncSettings | PlainMessage<PluginOktaSyncSettings> | undefined, b: PluginOktaSyncSettings | PlainMessage<PluginOktaSyncSettings> | undefined): boolean {
    return proto3.util.equals(PluginOktaSyncSettings, a, b);
  }
}

/**
 * Defines a set of discord channel IDs
 *
 * @generated from message types.DiscordChannels
 */
export class DiscordChannels extends Message<DiscordChannels> {
  /**
   * @generated from field: repeated string channel_ids = 1;
   */
  channelIds: string[] = [];

  constructor(data?: PartialMessage<DiscordChannels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.DiscordChannels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "channel_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscordChannels {
    return new DiscordChannels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscordChannels {
    return new DiscordChannels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscordChannels {
    return new DiscordChannels().fromJsonString(jsonString, options);
  }

  static equals(a: DiscordChannels | PlainMessage<DiscordChannels> | undefined, b: DiscordChannels | PlainMessage<DiscordChannels> | undefined): boolean {
    return proto3.util.equals(DiscordChannels, a, b);
  }
}

/**
 * Defines settings for the discord plugin
 *
 * @generated from message types.PluginDiscordSettings
 */
export class PluginDiscordSettings extends Message<PluginDiscordSettings> {
  /**
   * RoleToRecipients maps Teleport roles (by name) to the set of Discord
   * channel IDs that will receive notifications and requests regarding that
   * that Role.
   *
   * @generated from field: map<string, types.DiscordChannels> role_to_recipients = 1;
   */
  roleToRecipients: { [key: string]: DiscordChannels } = {};

  constructor(data?: PartialMessage<PluginDiscordSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDiscordSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role_to_recipients", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: DiscordChannels} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDiscordSettings {
    return new PluginDiscordSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDiscordSettings {
    return new PluginDiscordSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDiscordSettings {
    return new PluginDiscordSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDiscordSettings | PlainMessage<PluginDiscordSettings> | undefined, b: PluginDiscordSettings | PlainMessage<PluginDiscordSettings> | undefined): boolean {
    return proto3.util.equals(PluginDiscordSettings, a, b);
  }
}

/**
 * PluginEntraIDSettings defines settings for the Entra ID sync plugin
 *
 * @generated from message types.PluginEntraIDSettings
 */
export class PluginEntraIDSettings extends Message<PluginEntraIDSettings> {
  /**
   * SyncSettings controls the user and access list sync settings for EntraID.
   *
   * @generated from field: types.PluginEntraIDSyncSettings sync_settings = 1;
   */
  syncSettings?: PluginEntraIDSyncSettings;

  /**
   * AccessGraphSettings controls settings for syncing access graph specific data.
   * When this is null, Entra ID integration with Access Graph is disabled.
   *
   * @generated from field: types.PluginEntraIDAccessGraphSettings access_graph_settings = 2;
   */
  accessGraphSettings?: PluginEntraIDAccessGraphSettings;

  constructor(data?: PartialMessage<PluginEntraIDSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginEntraIDSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_settings", kind: "message", T: PluginEntraIDSyncSettings },
    { no: 2, name: "access_graph_settings", kind: "message", T: PluginEntraIDAccessGraphSettings },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginEntraIDSettings {
    return new PluginEntraIDSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginEntraIDSettings {
    return new PluginEntraIDSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginEntraIDSettings {
    return new PluginEntraIDSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginEntraIDSettings | PlainMessage<PluginEntraIDSettings> | undefined, b: PluginEntraIDSettings | PlainMessage<PluginEntraIDSettings> | undefined): boolean {
    return proto3.util.equals(PluginEntraIDSettings, a, b);
  }
}

/**
 * Defines settings for syncing users and access lists from Entra ID.
 *
 * @generated from message types.PluginEntraIDSyncSettings
 */
export class PluginEntraIDSyncSettings extends Message<PluginEntraIDSyncSettings> {
  /**
   * DefaultOwners are the default owners for all imported access lists.
   *
   * @generated from field: repeated string default_owners = 1;
   */
  defaultOwners: string[] = [];

  /**
   * SSOConnectorID is the name of the Teleport SSO connector created and used by the Entra ID plugin
   *
   * @generated from field: string sso_connector_id = 2;
   */
  ssoConnectorId = "";

  constructor(data?: PartialMessage<PluginEntraIDSyncSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginEntraIDSyncSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "default_owners", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "sso_connector_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginEntraIDSyncSettings {
    return new PluginEntraIDSyncSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginEntraIDSyncSettings {
    return new PluginEntraIDSyncSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginEntraIDSyncSettings {
    return new PluginEntraIDSyncSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginEntraIDSyncSettings | PlainMessage<PluginEntraIDSyncSettings> | undefined, b: PluginEntraIDSyncSettings | PlainMessage<PluginEntraIDSyncSettings> | undefined): boolean {
    return proto3.util.equals(PluginEntraIDSyncSettings, a, b);
  }
}

/**
 * AccessGraphSettings controls settings for syncing access graph specific data.
 *
 * @generated from message types.PluginEntraIDAccessGraphSettings
 */
export class PluginEntraIDAccessGraphSettings extends Message<PluginEntraIDAccessGraphSettings> {
  /**
   * AppSsoSettingsCache is an array of single sign-on settings for Entra enterprise applications.
   *
   * This data is stored here because it is not available through traditional methods (MS Graph API).
   * Instead, it is fetched once during the plugin's set up using the user's credentials to connect to Azure's private API.
   *
   * @generated from field: repeated types.PluginEntraIDAppSSOSettings app_sso_settings_cache = 1;
   */
  appSsoSettingsCache: PluginEntraIDAppSSOSettings[] = [];

  constructor(data?: PartialMessage<PluginEntraIDAccessGraphSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginEntraIDAccessGraphSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_sso_settings_cache", kind: "message", T: PluginEntraIDAppSSOSettings, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginEntraIDAccessGraphSettings {
    return new PluginEntraIDAccessGraphSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginEntraIDAccessGraphSettings {
    return new PluginEntraIDAccessGraphSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginEntraIDAccessGraphSettings {
    return new PluginEntraIDAccessGraphSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginEntraIDAccessGraphSettings | PlainMessage<PluginEntraIDAccessGraphSettings> | undefined, b: PluginEntraIDAccessGraphSettings | PlainMessage<PluginEntraIDAccessGraphSettings> | undefined): boolean {
    return proto3.util.equals(PluginEntraIDAccessGraphSettings, a, b);
  }
}

/**
 * PluginEntraIDAppSSOSettings is a container for a single Entra ID enterprise application's
 * cached SSO settings.
 * As this data is only parsed by TAG, each value is stored as an opaque JSON blob.
 *
 * @generated from message types.PluginEntraIDAppSSOSettings
 */
export class PluginEntraIDAppSSOSettings extends Message<PluginEntraIDAppSSOSettings> {
  /**
   * AppID is the `AppID` property of Entra application.
   *
   * @generated from field: string app_id = 1;
   */
  appId = "";

  /**
   * FederatedSSOV2 contains the cached, gzip-compressed payload from the /ApplicationSso/{servicePrincipalId}/FederatedSSOV2 endpoint.
   *
   * @generated from field: bytes federated_sso_v2 = 2;
   */
  federatedSsoV2 = new Uint8Array(0);

  constructor(data?: PartialMessage<PluginEntraIDAppSSOSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginEntraIDAppSSOSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "federated_sso_v2", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginEntraIDAppSSOSettings {
    return new PluginEntraIDAppSSOSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginEntraIDAppSSOSettings {
    return new PluginEntraIDAppSSOSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginEntraIDAppSSOSettings {
    return new PluginEntraIDAppSSOSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginEntraIDAppSSOSettings | PlainMessage<PluginEntraIDAppSSOSettings> | undefined, b: PluginEntraIDAppSSOSettings | PlainMessage<PluginEntraIDAppSSOSettings> | undefined): boolean {
    return proto3.util.equals(PluginEntraIDAppSSOSettings, a, b);
  }
}

/**
 * PluginSCIMSettings defines the settings for a SCIM integration plugin
 *
 * @generated from message types.PluginSCIMSettings
 */
export class PluginSCIMSettings extends Message<PluginSCIMSettings> {
  /**
   * SamlConnectorName is the name of the SAML Connector that users provisioned
   * by this SCIM plugin will use to log in to Teleport.
   *
   * @generated from field: string saml_connector_name = 1;
   */
  samlConnectorName = "";

  /**
   * DefaultRole is the default role assigned to users provisioned by this
   * plugin.
   *
   * @generated from field: string default_role = 2;
   */
  defaultRole = "";

  constructor(data?: PartialMessage<PluginSCIMSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginSCIMSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "saml_connector_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "default_role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginSCIMSettings {
    return new PluginSCIMSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginSCIMSettings {
    return new PluginSCIMSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginSCIMSettings {
    return new PluginSCIMSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginSCIMSettings | PlainMessage<PluginSCIMSettings> | undefined, b: PluginSCIMSettings | PlainMessage<PluginSCIMSettings> | undefined): boolean {
    return proto3.util.equals(PluginSCIMSettings, a, b);
  }
}

/**
 * PluginDatadogAccessSettings defines the settings for a Datadog Incident Management plugin
 *
 * @generated from message types.PluginDatadogAccessSettings
 */
export class PluginDatadogAccessSettings extends Message<PluginDatadogAccessSettings> {
  /**
   * ApiEndpoint is the Datadog API endpoint.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint = "";

  /**
   * FallbackRecipient specifies the default recipient.
   *
   * @generated from field: string fallback_recipient = 2;
   */
  fallbackRecipient = "";

  constructor(data?: PartialMessage<PluginDatadogAccessSettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginDatadogAccessSettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fallback_recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDatadogAccessSettings {
    return new PluginDatadogAccessSettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDatadogAccessSettings {
    return new PluginDatadogAccessSettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDatadogAccessSettings {
    return new PluginDatadogAccessSettings().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDatadogAccessSettings | PlainMessage<PluginDatadogAccessSettings> | undefined, b: PluginDatadogAccessSettings | PlainMessage<PluginDatadogAccessSettings> | undefined): boolean {
    return proto3.util.equals(PluginDatadogAccessSettings, a, b);
  }
}

/**
 * @generated from message types.PluginBootstrapCredentialsV1
 */
export class PluginBootstrapCredentialsV1 extends Message<PluginBootstrapCredentialsV1> {
  /**
   * @generated from oneof types.PluginBootstrapCredentialsV1.credentials
   */
  credentials: {
    /**
     * @generated from field: types.PluginOAuth2AuthorizationCodeCredentials oauth2_authorization_code = 1;
     */
    value: PluginOAuth2AuthorizationCodeCredentials;
    case: "oauth2AuthorizationCode";
  } | {
    /**
     * @generated from field: types.PluginBearerTokenCredentials bearer_token = 2;
     */
    value: PluginBearerTokenCredentials;
    case: "bearerToken";
  } | {
    /**
     * @generated from field: types.PluginIdSecretCredential id_secret = 3;
     */
    value: PluginIdSecretCredential;
    case: "idSecret";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PluginBootstrapCredentialsV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginBootstrapCredentialsV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "oauth2_authorization_code", kind: "message", T: PluginOAuth2AuthorizationCodeCredentials, oneof: "credentials" },
    { no: 2, name: "bearer_token", kind: "message", T: PluginBearerTokenCredentials, oneof: "credentials" },
    { no: 3, name: "id_secret", kind: "message", T: PluginIdSecretCredential, oneof: "credentials" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginBootstrapCredentialsV1 {
    return new PluginBootstrapCredentialsV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginBootstrapCredentialsV1 {
    return new PluginBootstrapCredentialsV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginBootstrapCredentialsV1 {
    return new PluginBootstrapCredentialsV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginBootstrapCredentialsV1 | PlainMessage<PluginBootstrapCredentialsV1> | undefined, b: PluginBootstrapCredentialsV1 | PlainMessage<PluginBootstrapCredentialsV1> | undefined): boolean {
    return proto3.util.equals(PluginBootstrapCredentialsV1, a, b);
  }
}

/**
 * PluginIdSecretCredential can be OAuth2-like client_id and client_secret or username and password.
 *
 * @generated from message types.PluginIdSecretCredential
 */
export class PluginIdSecretCredential extends Message<PluginIdSecretCredential> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string secret = 2;
   */
  secret = "";

  constructor(data?: PartialMessage<PluginIdSecretCredential>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginIdSecretCredential";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginIdSecretCredential {
    return new PluginIdSecretCredential().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginIdSecretCredential {
    return new PluginIdSecretCredential().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginIdSecretCredential {
    return new PluginIdSecretCredential().fromJsonString(jsonString, options);
  }

  static equals(a: PluginIdSecretCredential | PlainMessage<PluginIdSecretCredential> | undefined, b: PluginIdSecretCredential | PlainMessage<PluginIdSecretCredential> | undefined): boolean {
    return proto3.util.equals(PluginIdSecretCredential, a, b);
  }
}

/**
 * @generated from message types.PluginOAuth2AuthorizationCodeCredentials
 */
export class PluginOAuth2AuthorizationCodeCredentials extends Message<PluginOAuth2AuthorizationCodeCredentials> {
  /**
   * @generated from field: string authorization_code = 1;
   */
  authorizationCode = "";

  /**
   * @generated from field: string redirect_uri = 2;
   */
  redirectUri = "";

  constructor(data?: PartialMessage<PluginOAuth2AuthorizationCodeCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOAuth2AuthorizationCodeCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authorization_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "redirect_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOAuth2AuthorizationCodeCredentials {
    return new PluginOAuth2AuthorizationCodeCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOAuth2AuthorizationCodeCredentials {
    return new PluginOAuth2AuthorizationCodeCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOAuth2AuthorizationCodeCredentials {
    return new PluginOAuth2AuthorizationCodeCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOAuth2AuthorizationCodeCredentials | PlainMessage<PluginOAuth2AuthorizationCodeCredentials> | undefined, b: PluginOAuth2AuthorizationCodeCredentials | PlainMessage<PluginOAuth2AuthorizationCodeCredentials> | undefined): boolean {
    return proto3.util.equals(PluginOAuth2AuthorizationCodeCredentials, a, b);
  }
}

/**
 * PluginStatus is the user-facing status for the plugin instance.
 *
 * @generated from message types.PluginStatusV1
 */
export class PluginStatusV1 extends Message<PluginStatusV1> {
  /**
   * @generated from field: types.PluginStatusCode code = 1;
   */
  code = PluginStatusCode.UNKNOWN;

  /**
   * error_message is a human-readable error message that can be displayed to the user.
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage = "";

  /**
   * last_sync_time is the last time the plugin was run.
   *
   * @generated from field: google.protobuf.Timestamp last_sync_time = 3;
   */
  lastSyncTime?: Timestamp;

  /**
   * details contains provider-specific plugin status details.
   *
   * @generated from oneof types.PluginStatusV1.details
   */
  details: {
    /**
     * gitlab is the status details for the Gitlab plugin.
     *
     * @generated from field: types.PluginGitlabStatusV1 gitlab = 4;
     */
    value: PluginGitlabStatusV1;
    case: "gitlab";
  } | {
    /**
     * @generated from field: types.PluginEntraIDStatusV1 entra_id = 5;
     */
    value: PluginEntraIDStatusV1;
    case: "entraId";
  } | {
    /**
     * Okta holds status details for the Okta plugin
     *
     * @generated from field: types.PluginOktaStatusV1 okta = 7;
     */
    value: PluginOktaStatusV1;
    case: "okta";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * last_raw_error variable stores the most recent raw error message received from an API or service.
   * It is intended to capture the original error message without any modifications or formatting.
   * This can be useful for debugging purposes, providing detailed information about what went wrong
   * in the interaction with the external service.
   *
   * @generated from field: string last_raw_error = 6;
   */
  lastRawError = "";

  constructor(data?: PartialMessage<PluginStatusV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStatusV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(PluginStatusCode) },
    { no: 2, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_sync_time", kind: "message", T: Timestamp },
    { no: 4, name: "gitlab", kind: "message", T: PluginGitlabStatusV1, oneof: "details" },
    { no: 5, name: "entra_id", kind: "message", T: PluginEntraIDStatusV1, oneof: "details" },
    { no: 7, name: "okta", kind: "message", T: PluginOktaStatusV1, oneof: "details" },
    { no: 6, name: "last_raw_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStatusV1 {
    return new PluginStatusV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStatusV1 {
    return new PluginStatusV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStatusV1 {
    return new PluginStatusV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStatusV1 | PlainMessage<PluginStatusV1> | undefined, b: PluginStatusV1 | PlainMessage<PluginStatusV1> | undefined): boolean {
    return proto3.util.equals(PluginStatusV1, a, b);
  }
}

/**
 * PluginGitlabStatusV1 is the status details for the Gitlab plugin.
 *
 * @generated from message types.PluginGitlabStatusV1
 */
export class PluginGitlabStatusV1 extends Message<PluginGitlabStatusV1> {
  /**
   * imported_users is the number of users imported from Gitlab.
   *
   * @generated from field: uint32 imported_users = 1;
   */
  importedUsers = 0;

  /**
   * imported_groups is the number of groups imported from Gitlab.
   *
   * @generated from field: uint32 imported_groups = 2;
   */
  importedGroups = 0;

  /**
   * imported_projects is the number of projects imported from Gitlab.
   *
   * @generated from field: uint32 imported_projects = 3;
   */
  importedProjects = 0;

  constructor(data?: PartialMessage<PluginGitlabStatusV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginGitlabStatusV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "imported_users", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "imported_groups", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "imported_projects", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginGitlabStatusV1 {
    return new PluginGitlabStatusV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginGitlabStatusV1 {
    return new PluginGitlabStatusV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginGitlabStatusV1 {
    return new PluginGitlabStatusV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginGitlabStatusV1 | PlainMessage<PluginGitlabStatusV1> | undefined, b: PluginGitlabStatusV1 | PlainMessage<PluginGitlabStatusV1> | undefined): boolean {
    return proto3.util.equals(PluginGitlabStatusV1, a, b);
  }
}

/**
 * PluginEntraIDStatusV1 is the status details for the Entra ID plugin.
 *
 * @generated from message types.PluginEntraIDStatusV1
 */
export class PluginEntraIDStatusV1 extends Message<PluginEntraIDStatusV1> {
  /**
   * imported_users is the number of users imported from Entra ID.
   *
   * @generated from field: uint32 imported_users = 1;
   */
  importedUsers = 0;

  /**
   * imported_groups is the number of groups imported from Entra ID.
   *
   * @generated from field: uint32 imported_groups = 2;
   */
  importedGroups = 0;

  constructor(data?: PartialMessage<PluginEntraIDStatusV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginEntraIDStatusV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "imported_users", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "imported_groups", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginEntraIDStatusV1 {
    return new PluginEntraIDStatusV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginEntraIDStatusV1 {
    return new PluginEntraIDStatusV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginEntraIDStatusV1 {
    return new PluginEntraIDStatusV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginEntraIDStatusV1 | PlainMessage<PluginEntraIDStatusV1> | undefined, b: PluginEntraIDStatusV1 | PlainMessage<PluginEntraIDStatusV1> | undefined): boolean {
    return proto3.util.equals(PluginEntraIDStatusV1, a, b);
  }
}

/**
 * PluginOktaStatusV1 contains the details for the running Okta plugin.
 *
 * @generated from message types.PluginOktaStatusV1
 */
export class PluginOktaStatusV1 extends Message<PluginOktaStatusV1> {
  /**
   * SSODetails are status details relating to SSO.
   *
   * @generated from field: types.PluginOktaStatusDetailsSSO sso_details = 1;
   */
  ssoDetails?: PluginOktaStatusDetailsSSO;

  /**
   * AppGroupSyncDetails are status details relating to synchronizing apps and
   * groups from Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsAppGroupSync app_group_sync_details = 2;
   */
  appGroupSyncDetails?: PluginOktaStatusDetailsAppGroupSync;

  /**
   * UsersSyncDetails are status details relating to synchronizing users from
   * Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsUsersSync users_sync_details = 3;
   */
  usersSyncDetails?: PluginOktaStatusDetailsUsersSync;

  /**
   * ScimDetails are status details relating to SCIM integration with
   * Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsSCIM scim_details = 4;
   */
  scimDetails?: PluginOktaStatusDetailsSCIM;

  /**
   * AccessListSyncDetails are status details relating to synchronizing access
   * lists from Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsAccessListsSync access_lists_sync_details = 5;
   */
  accessListsSyncDetails?: PluginOktaStatusDetailsAccessListsSync;

  constructor(data?: PartialMessage<PluginOktaStatusV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sso_details", kind: "message", T: PluginOktaStatusDetailsSSO },
    { no: 2, name: "app_group_sync_details", kind: "message", T: PluginOktaStatusDetailsAppGroupSync },
    { no: 3, name: "users_sync_details", kind: "message", T: PluginOktaStatusDetailsUsersSync },
    { no: 4, name: "scim_details", kind: "message", T: PluginOktaStatusDetailsSCIM },
    { no: 5, name: "access_lists_sync_details", kind: "message", T: PluginOktaStatusDetailsAccessListsSync },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusV1 {
    return new PluginOktaStatusV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusV1 {
    return new PluginOktaStatusV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusV1 {
    return new PluginOktaStatusV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusV1 | PlainMessage<PluginOktaStatusV1> | undefined, b: PluginOktaStatusV1 | PlainMessage<PluginOktaStatusV1> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusV1, a, b);
  }
}

/**
 * PluginOktaStatusDetailsSSO are details related to the
 * current status of the Okta integration w/r/t SSO.
 *
 * @generated from message types.PluginOktaStatusDetailsSSO
 */
export class PluginOktaStatusDetailsSSO extends Message<PluginOktaStatusDetailsSSO> {
  /**
   * Enabled indicates whether SSO login is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * AppId is the unique Okta application ID of the Okta Applicaion used for
   * SSO login.
   *
   * @generated from field: string app_id = 2;
   */
  appId = "";

  /**
   * AppName is the human-readable name of the Okta Applicaion used for SSO.
   *
   * @generated from field: string app_name = 3;
   */
  appName = "";

  constructor(data?: PartialMessage<PluginOktaStatusDetailsSSO>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusDetailsSSO";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "app_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "app_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusDetailsSSO {
    return new PluginOktaStatusDetailsSSO().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsSSO {
    return new PluginOktaStatusDetailsSSO().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsSSO {
    return new PluginOktaStatusDetailsSSO().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusDetailsSSO | PlainMessage<PluginOktaStatusDetailsSSO> | undefined, b: PluginOktaStatusDetailsSSO | PlainMessage<PluginOktaStatusDetailsSSO> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusDetailsSSO, a, b);
  }
}

/**
 * PluginOktaStatusDetailsAppGroupSync are details related to the
 * current status of the Okta integration w/r/t application and group
 * sync.
 *
 * @generated from message types.PluginOktaStatusDetailsAppGroupSync
 */
export class PluginOktaStatusDetailsAppGroupSync extends Message<PluginOktaStatusDetailsAppGroupSync> {
  /**
   * Enabled is whether the users sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * StatusCode indicates the current state of the App & Group sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode = OktaPluginSyncStatusCode.UNSPECIFIED;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * NumAppsSynced is the total number of apps synchronized.
   *
   * @generated from field: int32 num_apps_synced = 5;
   */
  numAppsSynced = 0;

  /**
   * NumAppsSynced is the total number of groups synchronized.
   *
   * @generated from field: int32 num_groups_synced = 6;
   */
  numGroupsSynced = 0;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 7;
   */
  error = "";

  constructor(data?: PartialMessage<PluginOktaStatusDetailsAppGroupSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusDetailsAppGroupSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "status_code", kind: "enum", T: proto3.getEnumType(OktaPluginSyncStatusCode) },
    { no: 3, name: "last_successful", kind: "message", T: Timestamp },
    { no: 4, name: "last_failed", kind: "message", T: Timestamp },
    { no: 5, name: "num_apps_synced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "num_groups_synced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusDetailsAppGroupSync {
    return new PluginOktaStatusDetailsAppGroupSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsAppGroupSync {
    return new PluginOktaStatusDetailsAppGroupSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsAppGroupSync {
    return new PluginOktaStatusDetailsAppGroupSync().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusDetailsAppGroupSync | PlainMessage<PluginOktaStatusDetailsAppGroupSync> | undefined, b: PluginOktaStatusDetailsAppGroupSync | PlainMessage<PluginOktaStatusDetailsAppGroupSync> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusDetailsAppGroupSync, a, b);
  }
}

/**
 * PluginOktaStatusDetailsUsersSync are details related to the
 * current status of the Okta integration w/r/t users sync.
 *
 * @generated from message types.PluginOktaStatusDetailsUsersSync
 */
export class PluginOktaStatusDetailsUsersSync extends Message<PluginOktaStatusDetailsUsersSync> {
  /**
   * Enabled is whether the users sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * StatusCode indicates the current state of the User sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode = OktaPluginSyncStatusCode.UNSPECIFIED;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * NumUsersSynced is the total number of users synchronized.
   *
   * @generated from field: int32 num_users_synced = 5;
   */
  numUsersSynced = 0;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 6;
   */
  error = "";

  constructor(data?: PartialMessage<PluginOktaStatusDetailsUsersSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusDetailsUsersSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "status_code", kind: "enum", T: proto3.getEnumType(OktaPluginSyncStatusCode) },
    { no: 3, name: "last_successful", kind: "message", T: Timestamp },
    { no: 4, name: "last_failed", kind: "message", T: Timestamp },
    { no: 5, name: "num_users_synced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusDetailsUsersSync {
    return new PluginOktaStatusDetailsUsersSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsUsersSync {
    return new PluginOktaStatusDetailsUsersSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsUsersSync {
    return new PluginOktaStatusDetailsUsersSync().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusDetailsUsersSync | PlainMessage<PluginOktaStatusDetailsUsersSync> | undefined, b: PluginOktaStatusDetailsUsersSync | PlainMessage<PluginOktaStatusDetailsUsersSync> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusDetailsUsersSync, a, b);
  }
}

/**
 * PluginOktaStatusDetailsSCIM are details related to the
 * current status of the Okta integration w/r/t SCIM.
 *
 * @generated from message types.PluginOktaStatusDetailsSCIM
 */
export class PluginOktaStatusDetailsSCIM extends Message<PluginOktaStatusDetailsSCIM> {
  /**
   * Enabled is whether SCIM is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<PluginOktaStatusDetailsSCIM>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusDetailsSCIM";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusDetailsSCIM {
    return new PluginOktaStatusDetailsSCIM().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsSCIM {
    return new PluginOktaStatusDetailsSCIM().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsSCIM {
    return new PluginOktaStatusDetailsSCIM().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusDetailsSCIM | PlainMessage<PluginOktaStatusDetailsSCIM> | undefined, b: PluginOktaStatusDetailsSCIM | PlainMessage<PluginOktaStatusDetailsSCIM> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusDetailsSCIM, a, b);
  }
}

/**
 * PluginOktaStatusDetailsAccessListsSync are details related to the
 * current status of the Okta integration w/r/t access list sync.
 *
 * @generated from message types.PluginOktaStatusDetailsAccessListsSync
 */
export class PluginOktaStatusDetailsAccessListsSync extends Message<PluginOktaStatusDetailsAccessListsSync> {
  /**
   * Enabled is whether access lists sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * StatusCode indicates the current state of the AccessList sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode = OktaPluginSyncStatusCode.UNSPECIFIED;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * AppFilters are the app filters used for the access list sync.
   *
   * @generated from field: repeated string app_filters = 5;
   */
  appFilters: string[] = [];

  /**
   * NumAppsSynced are the number of applications synchronized as access lists.
   *
   * @generated from field: int32 num_apps_synced = 6;
   */
  numAppsSynced = 0;

  /**
   * GroupFilters are the group filters used for the access list sync.
   *
   * @generated from field: repeated string group_filters = 7;
   */
  groupFilters: string[] = [];

  /**
   * NumGroupsSynced are the number of groups synchronized as access lists.
   *
   * @generated from field: int32 num_groups_synced = 8;
   */
  numGroupsSynced = 0;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 9;
   */
  error = "";

  constructor(data?: PartialMessage<PluginOktaStatusDetailsAccessListsSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOktaStatusDetailsAccessListsSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "status_code", kind: "enum", T: proto3.getEnumType(OktaPluginSyncStatusCode) },
    { no: 3, name: "last_successful", kind: "message", T: Timestamp },
    { no: 4, name: "last_failed", kind: "message", T: Timestamp },
    { no: 5, name: "app_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "num_apps_synced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "group_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "num_groups_synced", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOktaStatusDetailsAccessListsSync {
    return new PluginOktaStatusDetailsAccessListsSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsAccessListsSync {
    return new PluginOktaStatusDetailsAccessListsSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOktaStatusDetailsAccessListsSync {
    return new PluginOktaStatusDetailsAccessListsSync().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOktaStatusDetailsAccessListsSync | PlainMessage<PluginOktaStatusDetailsAccessListsSync> | undefined, b: PluginOktaStatusDetailsAccessListsSync | PlainMessage<PluginOktaStatusDetailsAccessListsSync> | undefined): boolean {
    return proto3.util.equals(PluginOktaStatusDetailsAccessListsSync, a, b);
  }
}

/**
 * PluginCredentialsV1 represents "live" credentials
 * that are used by the plugin to authenticate to the 3rd party API.
 *
 * @generated from message types.PluginCredentialsV1
 */
export class PluginCredentialsV1 extends Message<PluginCredentialsV1> {
  /**
   * @generated from oneof types.PluginCredentialsV1.credentials
   */
  credentials: {
    /**
     * @generated from field: types.PluginOAuth2AccessTokenCredentials oauth2_access_token = 1;
     */
    value: PluginOAuth2AccessTokenCredentials;
    case: "oauth2AccessToken";
  } | {
    /**
     * @generated from field: types.PluginBearerTokenCredentials bearer_token = 2;
     */
    value: PluginBearerTokenCredentials;
    case: "bearerToken";
  } | {
    /**
     * @generated from field: types.PluginIdSecretCredential id_secret = 3;
     */
    value: PluginIdSecretCredential;
    case: "idSecret";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsRef static_credentials_ref = 4;
     */
    value: PluginStaticCredentialsRef;
    case: "staticCredentialsRef";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PluginCredentialsV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginCredentialsV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "oauth2_access_token", kind: "message", T: PluginOAuth2AccessTokenCredentials, oneof: "credentials" },
    { no: 2, name: "bearer_token", kind: "message", T: PluginBearerTokenCredentials, oneof: "credentials" },
    { no: 3, name: "id_secret", kind: "message", T: PluginIdSecretCredential, oneof: "credentials" },
    { no: 4, name: "static_credentials_ref", kind: "message", T: PluginStaticCredentialsRef, oneof: "credentials" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginCredentialsV1 {
    return new PluginCredentialsV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginCredentialsV1 {
    return new PluginCredentialsV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginCredentialsV1 {
    return new PluginCredentialsV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginCredentialsV1 | PlainMessage<PluginCredentialsV1> | undefined, b: PluginCredentialsV1 | PlainMessage<PluginCredentialsV1> | undefined): boolean {
    return proto3.util.equals(PluginCredentialsV1, a, b);
  }
}

/**
 * @generated from message types.PluginOAuth2AccessTokenCredentials
 */
export class PluginOAuth2AccessTokenCredentials extends Message<PluginOAuth2AccessTokenCredentials> {
  /**
   * @generated from field: string access_token = 1;
   */
  accessToken = "";

  /**
   * @generated from field: string refresh_token = 2;
   */
  refreshToken = "";

  /**
   * @generated from field: google.protobuf.Timestamp expires = 3;
   */
  expires?: Timestamp;

  constructor(data?: PartialMessage<PluginOAuth2AccessTokenCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginOAuth2AccessTokenCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "refresh_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "expires", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginOAuth2AccessTokenCredentials {
    return new PluginOAuth2AccessTokenCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginOAuth2AccessTokenCredentials {
    return new PluginOAuth2AccessTokenCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginOAuth2AccessTokenCredentials {
    return new PluginOAuth2AccessTokenCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: PluginOAuth2AccessTokenCredentials | PlainMessage<PluginOAuth2AccessTokenCredentials> | undefined, b: PluginOAuth2AccessTokenCredentials | PlainMessage<PluginOAuth2AccessTokenCredentials> | undefined): boolean {
    return proto3.util.equals(PluginOAuth2AccessTokenCredentials, a, b);
  }
}

/**
 * @generated from message types.PluginBearerTokenCredentials
 */
export class PluginBearerTokenCredentials extends Message<PluginBearerTokenCredentials> {
  /**
   * Token is the literal bearer token to be submitted to the 3rd-party API provider.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<PluginBearerTokenCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginBearerTokenCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginBearerTokenCredentials {
    return new PluginBearerTokenCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginBearerTokenCredentials {
    return new PluginBearerTokenCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginBearerTokenCredentials {
    return new PluginBearerTokenCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: PluginBearerTokenCredentials | PlainMessage<PluginBearerTokenCredentials> | undefined, b: PluginBearerTokenCredentials | PlainMessage<PluginBearerTokenCredentials> | undefined): boolean {
    return proto3.util.equals(PluginBearerTokenCredentials, a, b);
  }
}

/**
 * PluginStaticCredentialsRef is a reference to plugin static credentials by labels.
 *
 * @generated from message types.PluginStaticCredentialsRef
 */
export class PluginStaticCredentialsRef extends Message<PluginStaticCredentialsRef> {
  /**
   * Labels is the set of labels to use to match against a set of static credentials.
   *
   * @generated from field: map<string, string> Labels = 1;
   */
  Labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<PluginStaticCredentialsRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStaticCredentialsRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStaticCredentialsRef {
    return new PluginStaticCredentialsRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStaticCredentialsRef {
    return new PluginStaticCredentialsRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStaticCredentialsRef {
    return new PluginStaticCredentialsRef().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStaticCredentialsRef | PlainMessage<PluginStaticCredentialsRef> | undefined, b: PluginStaticCredentialsRef | PlainMessage<PluginStaticCredentialsRef> | undefined): boolean {
    return proto3.util.equals(PluginStaticCredentialsRef, a, b);
  }
}

/**
 * PluginList represents a list of plugin resources
 *
 * @generated from message types.PluginListV1
 */
export class PluginListV1 extends Message<PluginListV1> {
  /**
   * Plugins is a list of plugin resources.
   *
   * @generated from field: repeated types.PluginV1 plugins = 1;
   */
  plugins: PluginV1[] = [];

  constructor(data?: PartialMessage<PluginListV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginListV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugins", kind: "message", T: PluginV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginListV1 {
    return new PluginListV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginListV1 {
    return new PluginListV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginListV1 {
    return new PluginListV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginListV1 | PlainMessage<PluginListV1> | undefined, b: PluginListV1 | PlainMessage<PluginListV1> | undefined): boolean {
    return proto3.util.equals(PluginListV1, a, b);
  }
}

/**
 * PluginStaticCredentialsV1 is a representation of static credentials for plugins.
 *
 * @generated from message types.PluginStaticCredentialsV1
 */
export class PluginStaticCredentialsV1 extends Message<PluginStaticCredentialsV1> {
  /**
   * Header is the resource header for the plugin static credentials object.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec contains the actual credentials for the object.
   *
   * @generated from field: types.PluginStaticCredentialsSpecV1 Spec = 2;
   */
  Spec?: PluginStaticCredentialsSpecV1;

  constructor(data?: PartialMessage<PluginStaticCredentialsV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStaticCredentialsV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: PluginStaticCredentialsSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStaticCredentialsV1 {
    return new PluginStaticCredentialsV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStaticCredentialsV1 {
    return new PluginStaticCredentialsV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStaticCredentialsV1 {
    return new PluginStaticCredentialsV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStaticCredentialsV1 | PlainMessage<PluginStaticCredentialsV1> | undefined, b: PluginStaticCredentialsV1 | PlainMessage<PluginStaticCredentialsV1> | undefined): boolean {
    return proto3.util.equals(PluginStaticCredentialsV1, a, b);
  }
}

/**
 * PluginStaticCredentialsSpecV1 is the specification for the static credentials object.
 *
 * @generated from message types.PluginStaticCredentialsSpecV1
 */
export class PluginStaticCredentialsSpecV1 extends Message<PluginStaticCredentialsSpecV1> {
  /**
   * @generated from oneof types.PluginStaticCredentialsSpecV1.credentials
   */
  credentials: {
    /**
     * @generated from field: string APIToken = 1;
     */
    value: string;
    case: "APIToken";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsBasicAuth BasicAuth = 2;
     */
    value: PluginStaticCredentialsBasicAuth;
    case: "BasicAuth";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsOAuthClientSecret OAuthClientSecret = 3;
     */
    value: PluginStaticCredentialsOAuthClientSecret;
    case: "OAuthClientSecret";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PluginStaticCredentialsSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStaticCredentialsSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "APIToken", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "credentials" },
    { no: 2, name: "BasicAuth", kind: "message", T: PluginStaticCredentialsBasicAuth, oneof: "credentials" },
    { no: 3, name: "OAuthClientSecret", kind: "message", T: PluginStaticCredentialsOAuthClientSecret, oneof: "credentials" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStaticCredentialsSpecV1 {
    return new PluginStaticCredentialsSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStaticCredentialsSpecV1 {
    return new PluginStaticCredentialsSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStaticCredentialsSpecV1 {
    return new PluginStaticCredentialsSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStaticCredentialsSpecV1 | PlainMessage<PluginStaticCredentialsSpecV1> | undefined, b: PluginStaticCredentialsSpecV1 | PlainMessage<PluginStaticCredentialsSpecV1> | undefined): boolean {
    return proto3.util.equals(PluginStaticCredentialsSpecV1, a, b);
  }
}

/**
 * PluginStaticCredentialsBasicAuth represents username and password credentials for a plugin.
 *
 * @generated from message types.PluginStaticCredentialsBasicAuth
 */
export class PluginStaticCredentialsBasicAuth extends Message<PluginStaticCredentialsBasicAuth> {
  /**
   * Username is the username to use for basic auth.
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * Password is the password to use for basic auth.
   *
   * @generated from field: string Password = 2;
   */
  Password = "";

  constructor(data?: PartialMessage<PluginStaticCredentialsBasicAuth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStaticCredentialsBasicAuth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStaticCredentialsBasicAuth {
    return new PluginStaticCredentialsBasicAuth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStaticCredentialsBasicAuth {
    return new PluginStaticCredentialsBasicAuth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStaticCredentialsBasicAuth {
    return new PluginStaticCredentialsBasicAuth().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStaticCredentialsBasicAuth | PlainMessage<PluginStaticCredentialsBasicAuth> | undefined, b: PluginStaticCredentialsBasicAuth | PlainMessage<PluginStaticCredentialsBasicAuth> | undefined): boolean {
    return proto3.util.equals(PluginStaticCredentialsBasicAuth, a, b);
  }
}

/**
 * PluginStaticCredentialsOAuthClientSecret represents an oauth client id and secret.
 *
 * @generated from message types.PluginStaticCredentialsOAuthClientSecret
 */
export class PluginStaticCredentialsOAuthClientSecret extends Message<PluginStaticCredentialsOAuthClientSecret> {
  /**
   * ClientId is the client ID to use for OAuth client secret.
   *
   * @generated from field: string ClientId = 1;
   */
  ClientId = "";

  /**
   * ClientSecret is the client secret to use.
   *
   * @generated from field: string ClientSecret = 2;
   */
  ClientSecret = "";

  constructor(data?: PartialMessage<PluginStaticCredentialsOAuthClientSecret>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.PluginStaticCredentialsOAuthClientSecret";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClientId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClientSecret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginStaticCredentialsOAuthClientSecret {
    return new PluginStaticCredentialsOAuthClientSecret().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginStaticCredentialsOAuthClientSecret {
    return new PluginStaticCredentialsOAuthClientSecret().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginStaticCredentialsOAuthClientSecret {
    return new PluginStaticCredentialsOAuthClientSecret().fromJsonString(jsonString, options);
  }

  static equals(a: PluginStaticCredentialsOAuthClientSecret | PlainMessage<PluginStaticCredentialsOAuthClientSecret> | undefined, b: PluginStaticCredentialsOAuthClientSecret | PlainMessage<PluginStaticCredentialsOAuthClientSecret> | undefined): boolean {
    return proto3.util.equals(PluginStaticCredentialsOAuthClientSecret, a, b);
  }
}

/**
 * SAMLIdPServiceProviderV1 is the representation of a SAML IdP service provider.
 *
 * @generated from message types.SAMLIdPServiceProviderV1
 */
export class SAMLIdPServiceProviderV1 extends Message<SAMLIdPServiceProviderV1> {
  /**
   * Header is the resource header for the SAML IdP service provider.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the SAML IdP service provider spec.
   *
   * @generated from field: types.SAMLIdPServiceProviderSpecV1 Spec = 2;
   */
  Spec?: SAMLIdPServiceProviderSpecV1;

  constructor(data?: PartialMessage<SAMLIdPServiceProviderV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLIdPServiceProviderV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: SAMLIdPServiceProviderSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderV1 {
    return new SAMLIdPServiceProviderV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderV1 {
    return new SAMLIdPServiceProviderV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderV1 {
    return new SAMLIdPServiceProviderV1().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderV1 | PlainMessage<SAMLIdPServiceProviderV1> | undefined, b: SAMLIdPServiceProviderV1 | PlainMessage<SAMLIdPServiceProviderV1> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderV1, a, b);
  }
}

/**
 * SAMLIdPServiceProviderSpecV1 is the SAMLIdPServiceProviderV1 resource spec.
 *
 * @generated from message types.SAMLIdPServiceProviderSpecV1
 */
export class SAMLIdPServiceProviderSpecV1 extends Message<SAMLIdPServiceProviderSpecV1> {
  /**
   * EntityDescriptor is the entity descriptor for the service provider
   *
   * @generated from field: string EntityDescriptor = 1;
   */
  EntityDescriptor = "";

  /**
   * EntityID is the entity ID for the entity descriptor. If entity descriptor is provided,
   * this value is checked that it matches the entity ID in the entity descriptor
   * at upsert time to avoid having to parse the XML blob in the entity descriptor
   * every time we need to use this resource.
   *
   * @generated from field: string EntityID = 2;
   */
  EntityID = "";

  /**
   * ACSURL is the endpoint where SAML authentication response will be redirected.
   *
   * @generated from field: string ACSURL = 3;
   */
  ACSURL = "";

  /**
   * AttributeMapping is used to map service provider requested attributes to
   * username, role and traits in Teleport.
   *
   * @generated from field: repeated types.SAMLAttributeMapping AttributeMapping = 4;
   */
  AttributeMapping: SAMLAttributeMapping[] = [];

  /**
   * Preset is used to define service provider profile that will have a custom behavior
   * processed by Teleport.
   *
   * @generated from field: string Preset = 5;
   */
  Preset = "";

  /**
   * RelayState is used to add custom value in the SAML response as a relay_state HTTP parameter.
   * The value can contain service provider specific redirect URL, static state token etc.
   * The value is only applied in the IdP initiated SSO flow.
   *
   * @generated from field: string RelayState = 6;
   */
  RelayState = "";

  /**
   * LaunchURLs is used to configure custom landing URLs for service provider. It is useful in
   * the following scenarios:
   * 1. If a service provider does not support IdP initiated authentication, launch url can be
   *    configured to launch users directly into the service provider authentication endpoint.
   * 2. If a service provider does support IdP initiated authentication, it can be useful if
   *    that service provider acts as a master authentication service provider for internal services.
   *    In such case, Teleport administrator can configure launch URL, that lets user pick a specific
   *    internal service URL from the Log In tile in the UI, which would take them to that particular
   *    service for authentication instead of directly launching to the master service provider.
   * Each launch URL value must be an HTTPs endpoint.
   *
   * @generated from field: repeated string LaunchURLs = 7;
   */
  LaunchURLs: string[] = [];

  constructor(data?: PartialMessage<SAMLIdPServiceProviderSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLIdPServiceProviderSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "EntityDescriptor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "EntityID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ACSURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AttributeMapping", kind: "message", T: SAMLAttributeMapping, repeated: true },
    { no: 5, name: "Preset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "RelayState", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "LaunchURLs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLIdPServiceProviderSpecV1 {
    return new SAMLIdPServiceProviderSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderSpecV1 {
    return new SAMLIdPServiceProviderSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLIdPServiceProviderSpecV1 {
    return new SAMLIdPServiceProviderSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLIdPServiceProviderSpecV1 | PlainMessage<SAMLIdPServiceProviderSpecV1> | undefined, b: SAMLIdPServiceProviderSpecV1 | PlainMessage<SAMLIdPServiceProviderSpecV1> | undefined): boolean {
    return proto3.util.equals(SAMLIdPServiceProviderSpecV1, a, b);
  }
}

/**
 * SAMLAttributeMapping represents SAML service provider requested attribute
 * name, format and its values.
 *
 * @generated from message types.SAMLAttributeMapping
 */
export class SAMLAttributeMapping extends Message<SAMLAttributeMapping> {
  /**
   *  name is an attribute name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   *  name_format is an attribute name format.
   *
   * @generated from field: string name_format = 2;
   */
  nameFormat = "";

  /**
   *  value is an attribute value definable with predicate expression.
   *
   * @generated from field: string value = 3;
   */
  value = "";

  constructor(data?: PartialMessage<SAMLAttributeMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.SAMLAttributeMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name_format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SAMLAttributeMapping {
    return new SAMLAttributeMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SAMLAttributeMapping {
    return new SAMLAttributeMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SAMLAttributeMapping {
    return new SAMLAttributeMapping().fromJsonString(jsonString, options);
  }

  static equals(a: SAMLAttributeMapping | PlainMessage<SAMLAttributeMapping> | undefined, b: SAMLAttributeMapping | PlainMessage<SAMLAttributeMapping> | undefined): boolean {
    return proto3.util.equals(SAMLAttributeMapping, a, b);
  }
}

/**
 * IdPOptions specify options related to access Teleport IdPs.
 *
 * @generated from message types.IdPOptions
 */
export class IdPOptions extends Message<IdPOptions> {
  /**
   * SAML are options related to the Teleport SAML IdP.
   *
   * @generated from field: types.IdPSAMLOptions SAML = 1;
   */
  SAML?: IdPSAMLOptions;

  constructor(data?: PartialMessage<IdPOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.IdPOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SAML", kind: "message", T: IdPSAMLOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdPOptions {
    return new IdPOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdPOptions {
    return new IdPOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdPOptions {
    return new IdPOptions().fromJsonString(jsonString, options);
  }

  static equals(a: IdPOptions | PlainMessage<IdPOptions> | undefined, b: IdPOptions | PlainMessage<IdPOptions> | undefined): boolean {
    return proto3.util.equals(IdPOptions, a, b);
  }
}

/**
 * IdPSAMLOptions specifies options related to accessing the Teleport SAML IdP.
 *
 * @generated from message types.IdPSAMLOptions
 */
export class IdPSAMLOptions extends Message<IdPSAMLOptions> {
  /**
   * Enabled is set to true if this option allows access to the Teleport SAML IdP.
   *
   * @generated from field: types.BoolValue Enabled = 1;
   */
  Enabled?: BoolValue;

  constructor(data?: PartialMessage<IdPSAMLOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.IdPSAMLOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Enabled", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdPSAMLOptions {
    return new IdPSAMLOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdPSAMLOptions {
    return new IdPSAMLOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdPSAMLOptions {
    return new IdPSAMLOptions().fromJsonString(jsonString, options);
  }

  static equals(a: IdPSAMLOptions | PlainMessage<IdPSAMLOptions> | undefined, b: IdPSAMLOptions | PlainMessage<IdPSAMLOptions> | undefined): boolean {
    return proto3.util.equals(IdPSAMLOptions, a, b);
  }
}

/**
 * KubernetesResourceV1 represents a Kubernetes resource.
 *
 * @generated from message types.KubernetesResourceV1
 */
export class KubernetesResourceV1 extends Message<KubernetesResourceV1> {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is KubernetesResourceV1 metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains the Kubernetes resource data.
   *
   * @generated from field: types.KubernetesResourceSpecV1 Spec = 5;
   */
  Spec?: KubernetesResourceSpecV1;

  constructor(data?: PartialMessage<KubernetesResourceV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesResourceV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: KubernetesResourceSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesResourceV1 {
    return new KubernetesResourceV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesResourceV1 {
    return new KubernetesResourceV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesResourceV1 {
    return new KubernetesResourceV1().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesResourceV1 | PlainMessage<KubernetesResourceV1> | undefined, b: KubernetesResourceV1 | PlainMessage<KubernetesResourceV1> | undefined): boolean {
    return proto3.util.equals(KubernetesResourceV1, a, b);
  }
}

/**
 * KubernetesResourceSpecV1 is the Kubernetes resource spec.
 *
 * @generated from message types.KubernetesResourceSpecV1
 */
export class KubernetesResourceSpecV1 extends Message<KubernetesResourceSpecV1> {
  /**
   * Namespace is the resource namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  constructor(data?: PartialMessage<KubernetesResourceSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesResourceSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesResourceSpecV1 {
    return new KubernetesResourceSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesResourceSpecV1 {
    return new KubernetesResourceSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesResourceSpecV1 {
    return new KubernetesResourceSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesResourceSpecV1 | PlainMessage<KubernetesResourceSpecV1> | undefined, b: KubernetesResourceSpecV1 | PlainMessage<KubernetesResourceSpecV1> | undefined): boolean {
    return proto3.util.equals(KubernetesResourceSpecV1, a, b);
  }
}

/**
 * ClusterMaintenanceConfigV1 is a config singleton used to configure infrequent
 * cluster maintenance operations.
 *
 * @generated from message types.ClusterMaintenanceConfigV1
 */
export class ClusterMaintenanceConfigV1 extends Message<ClusterMaintenanceConfigV1> {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.ClusterMaintenanceConfigSpecV1 Spec = 2;
   */
  Spec?: ClusterMaintenanceConfigSpecV1;

  /**
   * Nonce is used to protect against concurrent modification of the maintenance
   * window. Clients should treat nonces as opaque.
   *
   * @generated from field: uint64 Nonce = 3;
   */
  Nonce = protoInt64.zero;

  constructor(data?: PartialMessage<ClusterMaintenanceConfigV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterMaintenanceConfigV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: ClusterMaintenanceConfigSpecV1 },
    { no: 3, name: "Nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterMaintenanceConfigV1 {
    return new ClusterMaintenanceConfigV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterMaintenanceConfigV1 {
    return new ClusterMaintenanceConfigV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterMaintenanceConfigV1 {
    return new ClusterMaintenanceConfigV1().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterMaintenanceConfigV1 | PlainMessage<ClusterMaintenanceConfigV1> | undefined, b: ClusterMaintenanceConfigV1 | PlainMessage<ClusterMaintenanceConfigV1> | undefined): boolean {
    return proto3.util.equals(ClusterMaintenanceConfigV1, a, b);
  }
}

/**
 * ClusterMaintenanceConfigSpecV1 encodes the parameters of the upgrade window config object.
 *
 * @generated from message types.ClusterMaintenanceConfigSpecV1
 */
export class ClusterMaintenanceConfigSpecV1 extends Message<ClusterMaintenanceConfigSpecV1> {
  /**
   * AgentUpgrades encodes the agent upgrade window.
   *
   * @generated from field: types.AgentUpgradeWindow AgentUpgrades = 1;
   */
  AgentUpgrades?: AgentUpgradeWindow;

  constructor(data?: PartialMessage<ClusterMaintenanceConfigSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ClusterMaintenanceConfigSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AgentUpgrades", kind: "message", T: AgentUpgradeWindow },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterMaintenanceConfigSpecV1 {
    return new ClusterMaintenanceConfigSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterMaintenanceConfigSpecV1 {
    return new ClusterMaintenanceConfigSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterMaintenanceConfigSpecV1 {
    return new ClusterMaintenanceConfigSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterMaintenanceConfigSpecV1 | PlainMessage<ClusterMaintenanceConfigSpecV1> | undefined, b: ClusterMaintenanceConfigSpecV1 | PlainMessage<ClusterMaintenanceConfigSpecV1> | undefined): boolean {
    return proto3.util.equals(ClusterMaintenanceConfigSpecV1, a, b);
  }
}

/**
 * AgentUpgradeWindow is the config object used to determine upcoming agent
 * upgrade windows.
 *
 * @generated from message types.AgentUpgradeWindow
 */
export class AgentUpgradeWindow extends Message<AgentUpgradeWindow> {
  /**
   * UTCStartHour is the start hour of the maintenance window in UTC.
   *
   * @generated from field: uint32 UTCStartHour = 1;
   */
  UTCStartHour = 0;

  /**
   * Weekdays is an optional list of weekdays. If not specified, an agent upgrade window
   * occurs every day.
   *
   * @generated from field: repeated string Weekdays = 2;
   */
  Weekdays: string[] = [];

  constructor(data?: PartialMessage<AgentUpgradeWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AgentUpgradeWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UTCStartHour", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "Weekdays", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentUpgradeWindow {
    return new AgentUpgradeWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentUpgradeWindow {
    return new AgentUpgradeWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentUpgradeWindow {
    return new AgentUpgradeWindow().fromJsonString(jsonString, options);
  }

  static equals(a: AgentUpgradeWindow | PlainMessage<AgentUpgradeWindow> | undefined, b: AgentUpgradeWindow | PlainMessage<AgentUpgradeWindow> | undefined): boolean {
    return proto3.util.equals(AgentUpgradeWindow, a, b);
  }
}

/**
 * ScheduledAgentUpgradeWindow is a derived value representing a single
 * upgrade window. Upgraders deal with discrete start/end times, so we use the
 * agent upgrade window configuration object to generate a sequence of specific
 * scheduled windows.
 *
 * @generated from message types.ScheduledAgentUpgradeWindow
 */
export class ScheduledAgentUpgradeWindow extends Message<ScheduledAgentUpgradeWindow> {
  /**
   * Start is the start time of the upgrade window.
   *
   * @generated from field: google.protobuf.Timestamp Start = 1;
   */
  Start?: Timestamp;

  /**
   * Stop is the stop time of the upgrade window.
   *
   * @generated from field: google.protobuf.Timestamp Stop = 2;
   */
  Stop?: Timestamp;

  constructor(data?: PartialMessage<ScheduledAgentUpgradeWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ScheduledAgentUpgradeWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Start", kind: "message", T: Timestamp },
    { no: 2, name: "Stop", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScheduledAgentUpgradeWindow {
    return new ScheduledAgentUpgradeWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScheduledAgentUpgradeWindow {
    return new ScheduledAgentUpgradeWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScheduledAgentUpgradeWindow {
    return new ScheduledAgentUpgradeWindow().fromJsonString(jsonString, options);
  }

  static equals(a: ScheduledAgentUpgradeWindow | PlainMessage<ScheduledAgentUpgradeWindow> | undefined, b: ScheduledAgentUpgradeWindow | PlainMessage<ScheduledAgentUpgradeWindow> | undefined): boolean {
    return proto3.util.equals(ScheduledAgentUpgradeWindow, a, b);
  }
}

/**
 * AgentUpgradeSchedule is the canonical representation of upcoming
 * agent upgrade windows as generated by the AgentUpgradeWindow config object.
 *
 * @generated from message types.AgentUpgradeSchedule
 */
export class AgentUpgradeSchedule extends Message<AgentUpgradeSchedule> {
  /**
   * Windows is the list of upcoming windows.
   *
   * @generated from field: repeated types.ScheduledAgentUpgradeWindow Windows = 1;
   */
  Windows: ScheduledAgentUpgradeWindow[] = [];

  constructor(data?: PartialMessage<AgentUpgradeSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AgentUpgradeSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Windows", kind: "message", T: ScheduledAgentUpgradeWindow, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentUpgradeSchedule {
    return new AgentUpgradeSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentUpgradeSchedule {
    return new AgentUpgradeSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentUpgradeSchedule {
    return new AgentUpgradeSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: AgentUpgradeSchedule | PlainMessage<AgentUpgradeSchedule> | undefined, b: AgentUpgradeSchedule | PlainMessage<AgentUpgradeSchedule> | undefined): boolean {
    return proto3.util.equals(AgentUpgradeSchedule, a, b);
  }
}

/**
 * UserGroupV1 is a representation of an externally sourced user group.
 *
 * @generated from message types.UserGroupV1
 */
export class UserGroupV1 extends Message<UserGroupV1> {
  /**
   * Header is the resource header for the user group.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the user group resource spec.
   *
   * @generated from field: types.UserGroupSpecV1 Spec = 2;
   */
  Spec?: UserGroupSpecV1;

  constructor(data?: PartialMessage<UserGroupV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserGroupV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: UserGroupSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserGroupV1 {
    return new UserGroupV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserGroupV1 {
    return new UserGroupV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserGroupV1 {
    return new UserGroupV1().fromJsonString(jsonString, options);
  }

  static equals(a: UserGroupV1 | PlainMessage<UserGroupV1> | undefined, b: UserGroupV1 | PlainMessage<UserGroupV1> | undefined): boolean {
    return proto3.util.equals(UserGroupV1, a, b);
  }
}

/**
 * UserGroupSpecV1 is the specification of a user group.
 *
 * @generated from message types.UserGroupSpecV1
 */
export class UserGroupSpecV1 extends Message<UserGroupSpecV1> {
  /**
   * Applications are a list of application IDs belonging to this user group.
   *
   * @generated from field: repeated string Applications = 1;
   */
  Applications: string[] = [];

  constructor(data?: PartialMessage<UserGroupSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.UserGroupSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Applications", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserGroupSpecV1 {
    return new UserGroupSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserGroupSpecV1 {
    return new UserGroupSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserGroupSpecV1 {
    return new UserGroupSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: UserGroupSpecV1 | PlainMessage<UserGroupSpecV1> | undefined, b: UserGroupSpecV1 | PlainMessage<UserGroupSpecV1> | undefined): boolean {
    return proto3.util.equals(UserGroupSpecV1, a, b);
  }
}

/**
 * OktaImportRuleSpecV1 is a Okta import rule specification.
 *
 * @generated from message types.OktaImportRuleSpecV1
 */
export class OktaImportRuleSpecV1 extends Message<OktaImportRuleSpecV1> {
  /**
   * Priority represents the priority of the rule application. Lower numbered rules will be applied first.
   *
   * @generated from field: int32 Priority = 1;
   */
  Priority = 0;

  /**
   * Mappings is a list of matches that will map match conditions to labels.
   *
   * @generated from field: repeated types.OktaImportRuleMappingV1 Mappings = 2;
   */
  Mappings: OktaImportRuleMappingV1[] = [];

  constructor(data?: PartialMessage<OktaImportRuleSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaImportRuleSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Priority", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "Mappings", kind: "message", T: OktaImportRuleMappingV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaImportRuleSpecV1 {
    return new OktaImportRuleSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaImportRuleSpecV1 {
    return new OktaImportRuleSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaImportRuleSpecV1 {
    return new OktaImportRuleSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaImportRuleSpecV1 | PlainMessage<OktaImportRuleSpecV1> | undefined, b: OktaImportRuleSpecV1 | PlainMessage<OktaImportRuleSpecV1> | undefined): boolean {
    return proto3.util.equals(OktaImportRuleSpecV1, a, b);
  }
}

/**
 * OktaImportRuleMappingV1 is a list of matches that map match rules to labels.
 *
 * @generated from message types.OktaImportRuleMappingV1
 */
export class OktaImportRuleMappingV1 extends Message<OktaImportRuleMappingV1> {
  /**
   * Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
   *
   * @generated from field: repeated types.OktaImportRuleMatchV1 Match = 1;
   */
  Match: OktaImportRuleMatchV1[] = [];

  /**
   * AddLabels specifies which labels to add if any of the previous matches match.
   *
   * @generated from field: map<string, string> AddLabels = 2;
   */
  AddLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<OktaImportRuleMappingV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaImportRuleMappingV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Match", kind: "message", T: OktaImportRuleMatchV1, repeated: true },
    { no: 2, name: "AddLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaImportRuleMappingV1 {
    return new OktaImportRuleMappingV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaImportRuleMappingV1 {
    return new OktaImportRuleMappingV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaImportRuleMappingV1 {
    return new OktaImportRuleMappingV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaImportRuleMappingV1 | PlainMessage<OktaImportRuleMappingV1> | undefined, b: OktaImportRuleMappingV1 | PlainMessage<OktaImportRuleMappingV1> | undefined): boolean {
    return proto3.util.equals(OktaImportRuleMappingV1, a, b);
  }
}

/**
 * OktaImportRuleV1 is a representation of labeling rules for importing of Okta objects.
 *
 * @generated from message types.OktaImportRuleV1
 */
export class OktaImportRuleV1 extends Message<OktaImportRuleV1> {
  /**
   * Header is the resource header for the SAML IdP service provider.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the specification for the Okta import rule.
   *
   * @generated from field: types.OktaImportRuleSpecV1 Spec = 2;
   */
  Spec?: OktaImportRuleSpecV1;

  constructor(data?: PartialMessage<OktaImportRuleV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaImportRuleV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: OktaImportRuleSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaImportRuleV1 {
    return new OktaImportRuleV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaImportRuleV1 {
    return new OktaImportRuleV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaImportRuleV1 {
    return new OktaImportRuleV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaImportRuleV1 | PlainMessage<OktaImportRuleV1> | undefined, b: OktaImportRuleV1 | PlainMessage<OktaImportRuleV1> | undefined): boolean {
    return proto3.util.equals(OktaImportRuleV1, a, b);
  }
}

/**
 * OktaImportRuleMatchV1 is a match rule for a mapping.
 *
 * @generated from message types.OktaImportRuleMatchV1
 */
export class OktaImportRuleMatchV1 extends Message<OktaImportRuleMatchV1> {
  /**
   * AppIDs is a list of app IDs to match against.
   *
   * @generated from field: repeated string AppIDs = 1;
   */
  AppIDs: string[] = [];

  /**
   * GroupIDs is a list of group IDs to match against.
   *
   * @generated from field: repeated string GroupIDs = 2;
   */
  GroupIDs: string[] = [];

  /**
   * AppNameRegexes is a list of regexes to match against app names.
   *
   * @generated from field: repeated string AppNameRegexes = 3;
   */
  AppNameRegexes: string[] = [];

  /**
   * GroupNameRegexes is a list of regexes to match against group names.
   *
   * @generated from field: repeated string GroupNameRegexes = 4;
   */
  GroupNameRegexes: string[] = [];

  constructor(data?: PartialMessage<OktaImportRuleMatchV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaImportRuleMatchV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AppIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "GroupIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "AppNameRegexes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "GroupNameRegexes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaImportRuleMatchV1 {
    return new OktaImportRuleMatchV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaImportRuleMatchV1 {
    return new OktaImportRuleMatchV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaImportRuleMatchV1 {
    return new OktaImportRuleMatchV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaImportRuleMatchV1 | PlainMessage<OktaImportRuleMatchV1> | undefined, b: OktaImportRuleMatchV1 | PlainMessage<OktaImportRuleMatchV1> | undefined): boolean {
    return proto3.util.equals(OktaImportRuleMatchV1, a, b);
  }
}

/**
 * OktaAssignmentV1 is a representation of an action or set of actions taken by Teleport to assign Okta users to applications or groups.
 *
 * @generated from message types.OktaAssignmentV1
 */
export class OktaAssignmentV1 extends Message<OktaAssignmentV1> {
  /**
   * Header is the resource header for the Okta assignment.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the specification for the Okta assignment.
   *
   * @generated from field: types.OktaAssignmentSpecV1 Spec = 2;
   */
  Spec?: OktaAssignmentSpecV1;

  constructor(data?: PartialMessage<OktaAssignmentV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaAssignmentV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: OktaAssignmentSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAssignmentV1 {
    return new OktaAssignmentV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAssignmentV1 {
    return new OktaAssignmentV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAssignmentV1 {
    return new OktaAssignmentV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAssignmentV1 | PlainMessage<OktaAssignmentV1> | undefined, b: OktaAssignmentV1 | PlainMessage<OktaAssignmentV1> | undefined): boolean {
    return proto3.util.equals(OktaAssignmentV1, a, b);
  }
}

/**
 * OktaAssignmentSpecV1 is a Okta assignment specification.
 *
 * @generated from message types.OktaAssignmentSpecV1
 */
export class OktaAssignmentSpecV1 extends Message<OktaAssignmentSpecV1> {
  /**
   * User is the user that these actions will be applied to.
   *
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * Targets is a list of Okta targets to take on a user.
   *
   * @generated from field: repeated types.OktaAssignmentTargetV1 Targets = 2;
   */
  Targets: OktaAssignmentTargetV1[] = [];

  /**
   * CleanupTime is an optional field that notes when the assignment should be cleaned up.
   * If absent, the assignment will never be cleaned up.
   *
   * @generated from field: google.protobuf.Timestamp CleanupTime = 3;
   */
  CleanupTime?: Timestamp;

  /**
   * Status is the status of the assignment.
   *
   * @generated from field: types.OktaAssignmentSpecV1.OktaAssignmentStatus status = 4;
   */
  status = OktaAssignmentSpecV1_OktaAssignmentStatus.UNKNOWN;

  /**
   * LastTransition is an optional field that notes when the last state transition
   * occurred for this action. If absent, this object has never transitioned.
   *
   * @generated from field: google.protobuf.Timestamp LastTransition = 5;
   */
  LastTransition?: Timestamp;

  /**
   * Finalized is set when the assignment has been properly cleaned up.
   *
   * @generated from field: bool Finalized = 6;
   */
  Finalized = false;

  constructor(data?: PartialMessage<OktaAssignmentSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaAssignmentSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Targets", kind: "message", T: OktaAssignmentTargetV1, repeated: true },
    { no: 3, name: "CleanupTime", kind: "message", T: Timestamp },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(OktaAssignmentSpecV1_OktaAssignmentStatus) },
    { no: 5, name: "LastTransition", kind: "message", T: Timestamp },
    { no: 6, name: "Finalized", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAssignmentSpecV1 {
    return new OktaAssignmentSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAssignmentSpecV1 {
    return new OktaAssignmentSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAssignmentSpecV1 {
    return new OktaAssignmentSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAssignmentSpecV1 | PlainMessage<OktaAssignmentSpecV1> | undefined, b: OktaAssignmentSpecV1 | PlainMessage<OktaAssignmentSpecV1> | undefined): boolean {
    return proto3.util.equals(OktaAssignmentSpecV1, a, b);
  }
}

/**
 * OktaAssignmentStatus represents the status of an Okta assignment.
 *
 * @generated from enum types.OktaAssignmentSpecV1.OktaAssignmentStatus
 */
export enum OktaAssignmentSpecV1_OktaAssignmentStatus {
  /**
   * UNKNOWN indicates the status is not set.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * PENDING indicates the action has not yet been applied.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * PROCESSSING indicates that the assignment is being applied.
   *
   * @generated from enum value: PROCESSING = 2;
   */
  PROCESSING = 2,

  /**
   * SUCCESSFUL indicates the action was applied successfully.
   *
   * @generated from enum value: SUCCESSFUL = 3;
   */
  SUCCESSFUL = 3,

  /**
   * FAILED indicates the action was not applied successfully. It will be retried.
   *
   * @generated from enum value: FAILED = 4;
   */
  FAILED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(OktaAssignmentSpecV1_OktaAssignmentStatus)
proto3.util.setEnumType(OktaAssignmentSpecV1_OktaAssignmentStatus, "types.OktaAssignmentSpecV1.OktaAssignmentStatus", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "PROCESSING" },
  { no: 3, name: "SUCCESSFUL" },
  { no: 4, name: "FAILED" },
]);

/**
 * OktaAssignmentTargetV1 is a target of an Okta assignment.
 *
 * @generated from message types.OktaAssignmentTargetV1
 */
export class OktaAssignmentTargetV1 extends Message<OktaAssignmentTargetV1> {
  /**
   * Type is the type of Okta resource this assignment is targeting.
   *
   * @generated from field: types.OktaAssignmentTargetV1.OktaAssignmentTargetType type = 1;
   */
  type = OktaAssignmentTargetV1_OktaAssignmentTargetType.UNKNOWN;

  /**
   * ID is the ID of the Okta resource that's being targeted.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<OktaAssignmentTargetV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaAssignmentTargetV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(OktaAssignmentTargetV1_OktaAssignmentTargetType) },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaAssignmentTargetV1 {
    return new OktaAssignmentTargetV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaAssignmentTargetV1 {
    return new OktaAssignmentTargetV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaAssignmentTargetV1 {
    return new OktaAssignmentTargetV1().fromJsonString(jsonString, options);
  }

  static equals(a: OktaAssignmentTargetV1 | PlainMessage<OktaAssignmentTargetV1> | undefined, b: OktaAssignmentTargetV1 | PlainMessage<OktaAssignmentTargetV1> | undefined): boolean {
    return proto3.util.equals(OktaAssignmentTargetV1, a, b);
  }
}

/**
 * OktaAssignmentTargetType is the type of Okta object that an assignment is targeting.
 *
 * @generated from enum types.OktaAssignmentTargetV1.OktaAssignmentTargetType
 */
export enum OktaAssignmentTargetV1_OktaAssignmentTargetType {
  /**
   * UNKNOWN indicates the target is unknown.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * APPLICATION indicates the target is an application.
   *
   * @generated from enum value: APPLICATION = 1;
   */
  APPLICATION = 1,

  /**
   * GROUP indicates the target is a group.
   *
   * @generated from enum value: GROUP = 2;
   */
  GROUP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OktaAssignmentTargetV1_OktaAssignmentTargetType)
proto3.util.setEnumType(OktaAssignmentTargetV1_OktaAssignmentTargetType, "types.OktaAssignmentTargetV1.OktaAssignmentTargetType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "APPLICATION" },
  { no: 2, name: "GROUP" },
]);

/**
 * IntegrationV1 represents a connection between Teleport and some other 3rd party system.
 * This connection allows API access to that service from Teleport.
 * Each Integration instance must have a SubKind defined which identifies the external system.
 *
 * @generated from message types.IntegrationV1
 */
export class IntegrationV1 extends Message<IntegrationV1> {
  /**
   * Header is the resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is an Integration specification.
   *
   * @generated from field: types.IntegrationSpecV1 Spec = 2;
   */
  Spec?: IntegrationSpecV1;

  constructor(data?: PartialMessage<IntegrationV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.IntegrationV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
    { no: 2, name: "Spec", kind: "message", T: IntegrationSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationV1 {
    return new IntegrationV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationV1 {
    return new IntegrationV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationV1 {
    return new IntegrationV1().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationV1 | PlainMessage<IntegrationV1> | undefined, b: IntegrationV1 | PlainMessage<IntegrationV1> | undefined): boolean {
    return proto3.util.equals(IntegrationV1, a, b);
  }
}

/**
 * IntegrationSpecV1 contains properties of all the supported integrations.
 *
 * @generated from message types.IntegrationSpecV1
 */
export class IntegrationSpecV1 extends Message<IntegrationSpecV1> {
  /**
   * @generated from oneof types.IntegrationSpecV1.SubKindSpec
   */
  SubKindSpec: {
    /**
     * AWSOIDC contains the specific fields to handle the AWS OIDC Integration subkind
     *
     * @generated from field: types.AWSOIDCIntegrationSpecV1 AWSOIDC = 1;
     */
    value: AWSOIDCIntegrationSpecV1;
    case: "AWSOIDC";
  } | {
    /**
     * AzureOIDC contains the specific fields to handle the Azure OIDC Integration subkind
     *
     * @generated from field: types.AzureOIDCIntegrationSpecV1 AzureOIDC = 2;
     */
    value: AzureOIDCIntegrationSpecV1;
    case: "AzureOIDC";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IntegrationSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.IntegrationSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AWSOIDC", kind: "message", T: AWSOIDCIntegrationSpecV1, oneof: "SubKindSpec" },
    { no: 2, name: "AzureOIDC", kind: "message", T: AzureOIDCIntegrationSpecV1, oneof: "SubKindSpec" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationSpecV1 {
    return new IntegrationSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationSpecV1 {
    return new IntegrationSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationSpecV1 {
    return new IntegrationSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationSpecV1 | PlainMessage<IntegrationSpecV1> | undefined, b: IntegrationSpecV1 | PlainMessage<IntegrationSpecV1> | undefined): boolean {
    return proto3.util.equals(IntegrationSpecV1, a, b);
  }
}

/**
 * AWSOIDCIntegrationSpecV1 contains the spec properties for the AWS OIDC SubKind Integration.
 *
 * @generated from message types.AWSOIDCIntegrationSpecV1
 */
export class AWSOIDCIntegrationSpecV1 extends Message<AWSOIDCIntegrationSpecV1> {
  /**
   * RoleARN contains the Role ARN used to set up the Integration.
   * This is the AWS Role that Teleport will use to issue tokens for API Calls.
   *
   * @generated from field: string RoleARN = 1;
   */
  RoleARN = "";

  /**
   * IssuerS3URI is the Identity Provider that was configured in AWS.
   * This bucket/prefix/* files must be publicly accessible and contain the following:
   * > .well-known/openid-configuration
   * > .well-known/jwks
   * Format: s3://<bucket>/<prefix>
   * Optional. The proxy's endpoint is used if it is not specified.
   *
   * DEPRECATED: Thumbprint validation requires the issuer to update the IdP in AWS everytime the issuer changes the certificate.
   * Amazon had some whitelisted providers where the thumbprint was ignored. S3 hosted providers was in that list.
   * Amazon is now trusting all the root certificate authorities, and this workaround is no longer needed.
   * DELETE IN 18.0.
   *
   * @generated from field: string IssuerS3URI = 2 [deprecated = true];
   * @deprecated
   */
  IssuerS3URI = "";

  constructor(data?: PartialMessage<AWSOIDCIntegrationSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AWSOIDCIntegrationSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "IssuerS3URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSOIDCIntegrationSpecV1 {
    return new AWSOIDCIntegrationSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSOIDCIntegrationSpecV1 {
    return new AWSOIDCIntegrationSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSOIDCIntegrationSpecV1 {
    return new AWSOIDCIntegrationSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: AWSOIDCIntegrationSpecV1 | PlainMessage<AWSOIDCIntegrationSpecV1> | undefined, b: AWSOIDCIntegrationSpecV1 | PlainMessage<AWSOIDCIntegrationSpecV1> | undefined): boolean {
    return proto3.util.equals(AWSOIDCIntegrationSpecV1, a, b);
  }
}

/**
 * AzureOIDCIntegrationSpecV1 contains the spec properties for the Azure OIDC SubKind Integration.
 *
 * @generated from message types.AzureOIDCIntegrationSpecV1
 */
export class AzureOIDCIntegrationSpecV1 extends Message<AzureOIDCIntegrationSpecV1> {
  /**
   * TenantID specifies the ID of Entra Tenant (Directory)
   * that this plugin integrates with.
   *
   * @generated from field: string TenantID = 1;
   */
  TenantID = "";

  /**
   * ClientID specifies the ID of Azure enterprise application (client)
   * that corresponds to this plugin.
   *
   * @generated from field: string ClientID = 2;
   */
  ClientID = "";

  constructor(data?: PartialMessage<AzureOIDCIntegrationSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AzureOIDCIntegrationSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TenantID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ClientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureOIDCIntegrationSpecV1 {
    return new AzureOIDCIntegrationSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureOIDCIntegrationSpecV1 {
    return new AzureOIDCIntegrationSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureOIDCIntegrationSpecV1 {
    return new AzureOIDCIntegrationSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: AzureOIDCIntegrationSpecV1 | PlainMessage<AzureOIDCIntegrationSpecV1> | undefined, b: AzureOIDCIntegrationSpecV1 | PlainMessage<AzureOIDCIntegrationSpecV1> | undefined): boolean {
    return proto3.util.equals(AzureOIDCIntegrationSpecV1, a, b);
  }
}

/**
 * HeadlessAuthentication holds data for an ongoing headless authentication attempt.
 *
 * @generated from message types.HeadlessAuthentication
 */
export class HeadlessAuthentication extends Message<HeadlessAuthentication> {
  /**
   * Header is the resource header.
   *
   * @generated from field: types.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * User is a teleport user name.
   *
   * @generated from field: string user = 2;
   */
  user = "";

  /**
   * PublicKey is an ssh public key to sign in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes public_key = 3 [deprecated = true];
   * @deprecated
   */
  publicKey = new Uint8Array(0);

  /**
   * State is the headless authentication request state.
   *
   * @generated from field: types.HeadlessAuthenticationState state = 4;
   */
  state = HeadlessAuthenticationState.UNSPECIFIED;

  /**
   * MFADevice is the mfa device used to approve the request in case of successful auth.
   *
   * @generated from field: types.MFADevice mfa_device = 5;
   */
  mfaDevice?: MFADevice;

  /**
   * ClientIPAddress is the IP address of the client being authenticated.
   *
   * @generated from field: string client_ip_address = 6;
   */
  clientIpAddress = "";

  /**
   * SshPublicKey is a public key that will be used as the subject of the issued
   * SSH certificate in case of successful auth. It must be in SSH authorized_keys format.
   *
   * @generated from field: bytes ssh_public_key = 7;
   */
  sshPublicKey = new Uint8Array(0);

  /**
   * TlsPublicKey is a public key that will be used as the subject of the issued
   * TLS certificate in case of successful auth. It must be in PEM-encoded
   * PKCS#1 or PKIX format.
   *
   * @generated from field: bytes tls_public_key = 8;
   */
  tlsPublicKey = new Uint8Array(0);

  constructor(data?: PartialMessage<HeadlessAuthentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.HeadlessAuthentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: ResourceHeader },
    { no: 2, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "state", kind: "enum", T: proto3.getEnumType(HeadlessAuthenticationState) },
    { no: 5, name: "mfa_device", kind: "message", T: MFADevice },
    { no: 6, name: "client_ip_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ssh_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "tls_public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadlessAuthentication {
    return new HeadlessAuthentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadlessAuthentication {
    return new HeadlessAuthentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadlessAuthentication {
    return new HeadlessAuthentication().fromJsonString(jsonString, options);
  }

  static equals(a: HeadlessAuthentication | PlainMessage<HeadlessAuthentication> | undefined, b: HeadlessAuthentication | PlainMessage<HeadlessAuthentication> | undefined): boolean {
    return proto3.util.equals(HeadlessAuthentication, a, b);
  }
}

/**
 * WatchKind specifies resource kind to watch
 * When adding fields to this struct, make sure to review/update WatchKind.Contains method.
 *
 * @generated from message types.WatchKind
 */
export class WatchKind extends Message<WatchKind> {
  /**
   * Kind is a resource kind to watch
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * LoadSecrets specifies whether to load secrets
   *
   * @generated from field: bool LoadSecrets = 2;
   */
  LoadSecrets = false;

  /**
   * Name is an optional specific resource type to watch,
   * if specified only the events with a specific resource
   * name will be sent
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  /**
   * Filter is an optional mapping of custom filter parameters.
   * Valid values vary by resource kind.
   *
   * @generated from field: map<string, string> Filter = 4;
   */
  Filter: { [key: string]: string } = {};

  /**
   * SubKind is a resource subkind to watch
   *
   * @generated from field: string SubKind = 5;
   */
  SubKind = "";

  /**
   * Version optionally specifies the resource version to watch.
   * Currently this field is ignored.
   *
   * @generated from field: string Version = 6;
   */
  Version = "";

  constructor(data?: PartialMessage<WatchKind>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WatchKind";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "LoadSecrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Filter", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchKind {
    return new WatchKind().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchKind {
    return new WatchKind().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchKind {
    return new WatchKind().fromJsonString(jsonString, options);
  }

  static equals(a: WatchKind | PlainMessage<WatchKind> | undefined, b: WatchKind | PlainMessage<WatchKind> | undefined): boolean {
    return proto3.util.equals(WatchKind, a, b);
  }
}

/**
 * WatchStatusV1 is intended to be attached to OpInit events and contain information about a successful WatchEvents call.
 *
 * @generated from message types.WatchStatusV1
 */
export class WatchStatusV1 extends Message<WatchStatusV1> {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.WatchStatusSpecV1 Spec = 5;
   */
  Spec?: WatchStatusSpecV1;

  constructor(data?: PartialMessage<WatchStatusV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WatchStatusV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: WatchStatusSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchStatusV1 {
    return new WatchStatusV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchStatusV1 {
    return new WatchStatusV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchStatusV1 {
    return new WatchStatusV1().fromJsonString(jsonString, options);
  }

  static equals(a: WatchStatusV1 | PlainMessage<WatchStatusV1> | undefined, b: WatchStatusV1 | PlainMessage<WatchStatusV1> | undefined): boolean {
    return proto3.util.equals(WatchStatusV1, a, b);
  }
}

/**
 * WatchStatusSpecV1 contains resource kinds confirmed by WatchEvents to be included in the event stream.
 *
 * @generated from message types.WatchStatusSpecV1
 */
export class WatchStatusSpecV1 extends Message<WatchStatusSpecV1> {
  /**
   * @generated from field: repeated types.WatchKind Kinds = 1;
   */
  Kinds: WatchKind[] = [];

  constructor(data?: PartialMessage<WatchStatusSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.WatchStatusSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kinds", kind: "message", T: WatchKind, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchStatusSpecV1 {
    return new WatchStatusSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchStatusSpecV1 {
    return new WatchStatusSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchStatusSpecV1 {
    return new WatchStatusSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: WatchStatusSpecV1 | PlainMessage<WatchStatusSpecV1> | undefined, b: WatchStatusSpecV1 | PlainMessage<WatchStatusSpecV1> | undefined): boolean {
    return proto3.util.equals(WatchStatusSpecV1, a, b);
  }
}

/**
 * ServerInfoV1 contains info that should be applied to joining Nodes.
 *
 * @generated from message types.ServerInfoV1
 */
export class ServerInfoV1 extends Message<ServerInfoV1> {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind = "";

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind = "";

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version = "";

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.ServerInfoSpecV1 Spec = 5;
   */
  Spec?: ServerInfoSpecV1;

  constructor(data?: PartialMessage<ServerInfoV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ServerInfoV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SubKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Metadata", kind: "message", T: Metadata },
    { no: 5, name: "Spec", kind: "message", T: ServerInfoSpecV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerInfoV1 {
    return new ServerInfoV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerInfoV1 {
    return new ServerInfoV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerInfoV1 {
    return new ServerInfoV1().fromJsonString(jsonString, options);
  }

  static equals(a: ServerInfoV1 | PlainMessage<ServerInfoV1> | undefined, b: ServerInfoV1 | PlainMessage<ServerInfoV1> | undefined): boolean {
    return proto3.util.equals(ServerInfoV1, a, b);
  }
}

/**
 * ServerInfoSpecV1 contains fields used to match Nodes to this ServerInfo.
 *
 * @generated from message types.ServerInfoSpecV1
 */
export class ServerInfoSpecV1 extends Message<ServerInfoSpecV1> {
  /**
   * NewLabels is the set of labels to add to nodes matching this ServerInfo.
   *
   * @generated from field: map<string, string> NewLabels = 2;
   */
  NewLabels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ServerInfoSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.ServerInfoSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "NewLabels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerInfoSpecV1 {
    return new ServerInfoSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerInfoSpecV1 {
    return new ServerInfoSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerInfoSpecV1 {
    return new ServerInfoSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: ServerInfoSpecV1 | PlainMessage<ServerInfoSpecV1> | undefined, b: ServerInfoSpecV1 | PlainMessage<ServerInfoSpecV1> | undefined): boolean {
    return proto3.util.equals(ServerInfoSpecV1, a, b);
  }
}

/**
 * JamfSpecV1 is the base configuration for the Jamf MDM service.
 *
 * @generated from message types.JamfSpecV1
 */
export class JamfSpecV1 extends Message<JamfSpecV1> {
  /**
   * Enabled toggles the service on or off.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Name of the service device source.
   * See the teleport.devicetrust.v1.DeviceSource proto.
   * Defaults to "jamf".
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Initial sync delay for the service.
   * Set to negative to perform syncs immediately on startup.
   * Defaults to a random delay (a few minutes max).
   *
   * @generated from field: int64 sync_delay = 3;
   */
  syncDelay = protoInt64.zero;

  /**
   * Jamf Pro API endpoint.
   * Example: "https://yourtenant.jamfcloud.com/api".
   * Required.
   *
   * @generated from field: string api_endpoint = 4;
   */
  apiEndpoint = "";

  /**
   * Inventory sync entries.
   * If empty a default sync configuration is used.
   *
   * @generated from field: repeated types.JamfInventoryEntry inventory = 7;
   */
  inventory: JamfInventoryEntry[] = [];

  constructor(data?: PartialMessage<JamfSpecV1>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.JamfSpecV1";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sync_delay", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "inventory", kind: "message", T: JamfInventoryEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JamfSpecV1 {
    return new JamfSpecV1().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JamfSpecV1 {
    return new JamfSpecV1().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JamfSpecV1 {
    return new JamfSpecV1().fromJsonString(jsonString, options);
  }

  static equals(a: JamfSpecV1 | PlainMessage<JamfSpecV1> | undefined, b: JamfSpecV1 | PlainMessage<JamfSpecV1> | undefined): boolean {
    return proto3.util.equals(JamfSpecV1, a, b);
  }
}

/**
 * JamfInventoryEntry is an inventory sync entry for [JamfSpecV1].
 *
 * @generated from message types.JamfInventoryEntry
 */
export class JamfInventoryEntry extends Message<JamfInventoryEntry> {
  /**
   * Jamf Pro API RSQL filter, used when querying endpoints like
   * "/api/v1/computers-inventory".
   * See https://developer.jamf.com/jamf-pro/reference/get_v1-computers-inventory.
   *
   * @generated from field: string filter_rsql = 1;
   */
  filterRsql = "";

  /**
   * Sync period for PARTIAL syncs.
   * PARTIAL syncs are scheduled in the time window between FULL syncs, so
   * sync_period_partial must always be smaller than sync_period_full, otherwise
   * it would never trigger.
   * Set to zero or negative to disable PARTIAL syncs.
   *
   * @generated from field: int64 sync_period_partial = 2;
   */
  syncPeriodPartial = protoInt64.zero;

  /**
   * Sync period for FULL syncs.
   * Ideally sync_period_full is a multiple of sync_period_partial, so schedules
   * line up perfectly.
   * Set to zero or negative to disable FULL syncs.
   *
   * @generated from field: int64 sync_period_full = 3;
   */
  syncPeriodFull = protoInt64.zero;

  /**
   * on_missing is the trigger used on devices missing from the MDM view in a
   * FULL sync.
   * Only runs on successful FULL syncs.
   * Corresponds to [teleport.devicetrust.v1.SyncInventoryDeviceAction].
   * Must be either "NOOP" or "DELETE".
   * Defaults to "NOOP".
   *
   * @generated from field: string on_missing = 4;
   */
  onMissing = "";

  /**
   * Custom page size for inventory queries.
   * A server default is used if zeroed or negative.
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<JamfInventoryEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.JamfInventoryEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter_rsql", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sync_period_partial", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "sync_period_full", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "on_missing", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JamfInventoryEntry {
    return new JamfInventoryEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JamfInventoryEntry {
    return new JamfInventoryEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JamfInventoryEntry {
    return new JamfInventoryEntry().fromJsonString(jsonString, options);
  }

  static equals(a: JamfInventoryEntry | PlainMessage<JamfInventoryEntry> | undefined, b: JamfInventoryEntry | PlainMessage<JamfInventoryEntry> | undefined): boolean {
    return proto3.util.equals(JamfInventoryEntry, a, b);
  }
}

/**
 * MessageWithHeader is a message with a resource header. This is used primarily
 * for parsing of resource headers and isn't expected to be used directly by any
 * resources.
 *
 * When using a oneof in a protobuf messages, the existing utils.FastMarshal
 * utility does not work, so using something like protojson or jsonpb is required.
 * However, these do not respect gogoproto's extensions. When using a ResourceHeader,
 * protojson will not recognize that the ResourceHeader is intended to be embedded and
 * the resulting JSON will have the header as a separate field. This means that using
 * utils.FastUnmarshal will not work for extracting a ResourceHeader from the
 * JSON, and we explicitly extract this header to do things like version checking in
 * lib/services.
 *
 * This can be avoided by explicitly embedding the members of the ResourceHeader in
 * a message. However, if we would like to avoid this, we can use this MessageWitHheader
 * to extract the resource header and its elements, which can later be used for the
 * aforementioned processing in lib/services.
 *
 * @generated from message types.MessageWithHeader
 */
export class MessageWithHeader extends Message<MessageWithHeader> {
  /**
   * Header is the resource header for a resource.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  constructor(data?: PartialMessage<MessageWithHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.MessageWithHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Header", kind: "message", T: ResourceHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageWithHeader {
    return new MessageWithHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageWithHeader {
    return new MessageWithHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MessageWithHeader {
    return new MessageWithHeader().fromJsonString(jsonString, options);
  }

  static equals(a: MessageWithHeader | PlainMessage<MessageWithHeader> | undefined, b: MessageWithHeader | PlainMessage<MessageWithHeader> | undefined): boolean {
    return proto3.util.equals(MessageWithHeader, a, b);
  }
}

/**
 * AWSMatcher matches AWS EC2 instances and AWS Databases
 *
 * @generated from message types.AWSMatcher
 */
export class AWSMatcher extends Message<AWSMatcher> {
  /**
   * Types are AWS database types to match, "ec2", "rds", "redshift", "elasticache",
   * or "memorydb".
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[] = [];

  /**
   * Regions are AWS regions to query for databases.
   *
   * @generated from field: repeated string Regions = 2;
   */
  Regions: string[] = [];

  /**
   * AssumeRoleARN is the AWS role to assume for database discovery.
   *
   * @generated from field: types.AssumeRole AssumeRole = 3;
   */
  AssumeRole?: AssumeRole;

  /**
   * Tags are AWS resource Tags to match.
   *
   * @generated from field: wrappers.LabelValues Tags = 4;
   */
  Tags?: LabelValues;

  /**
   * Params sets the join method when installing on discovered EC2 nodes
   *
   * @generated from field: types.InstallerParams Params = 5;
   */
  Params?: InstallerParams;

  /**
   * SSM provides options to use when sending a document command to
   * an EC2 node
   *
   * @generated from field: types.AWSSSM SSM = 6;
   */
  SSM?: AWSSSM;

  /**
   * Integration is the integration name used to generate credentials to interact with AWS APIs.
   * Environment credentials will not be used when this value is set.
   *
   * @generated from field: string Integration = 7;
   */
  Integration = "";

  /**
   * KubeAppDiscovery controls whether Kubernetes App Discovery will be enabled for agents running on
   * discovered clusters, currently only affects AWS EKS discovery in integration mode.
   *
   * @generated from field: bool KubeAppDiscovery = 8;
   */
  KubeAppDiscovery = false;

  /**
   * SetupAccessForARN is the role that the discovery service should create EKS Access Entries for.
   * This value should match the IAM identity that Teleport Kubernetes Service uses.
   * If this value is empty, the discovery service will attempt to set up access for its own identity (self).
   *
   * @generated from field: string SetupAccessForARN = 9;
   */
  SetupAccessForARN = "";

  constructor(data?: PartialMessage<AWSMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AWSMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Regions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "AssumeRole", kind: "message", T: AssumeRole },
    { no: 4, name: "Tags", kind: "message", T: LabelValues },
    { no: 5, name: "Params", kind: "message", T: InstallerParams },
    { no: 6, name: "SSM", kind: "message", T: AWSSSM },
    { no: 7, name: "Integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "KubeAppDiscovery", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "SetupAccessForARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSMatcher {
    return new AWSMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSMatcher {
    return new AWSMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSMatcher {
    return new AWSMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: AWSMatcher | PlainMessage<AWSMatcher> | undefined, b: AWSMatcher | PlainMessage<AWSMatcher> | undefined): boolean {
    return proto3.util.equals(AWSMatcher, a, b);
  }
}

/**
 * AssumeRole provides a role ARN and ExternalID to assume an AWS role
 * when interacting with AWS resources.
 *
 * @generated from message types.AssumeRole
 */
export class AssumeRole extends Message<AssumeRole> {
  /**
   * RoleARN is the fully specified AWS IAM role ARN.
   *
   * @generated from field: string RoleARN = 1;
   */
  RoleARN = "";

  /**
   * ExternalID is the external ID used to assume a role in another account.
   *
   * @generated from field: string ExternalID = 2;
   */
  ExternalID = "";

  constructor(data?: PartialMessage<AssumeRole>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AssumeRole";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ExternalID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssumeRole {
    return new AssumeRole().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssumeRole {
    return new AssumeRole().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssumeRole {
    return new AssumeRole().fromJsonString(jsonString, options);
  }

  static equals(a: AssumeRole | PlainMessage<AssumeRole> | undefined, b: AssumeRole | PlainMessage<AssumeRole> | undefined): boolean {
    return proto3.util.equals(AssumeRole, a, b);
  }
}

/**
 * InstallParams sets join method to use on discovered nodes
 *
 * @generated from message types.InstallerParams
 */
export class InstallerParams extends Message<InstallerParams> {
  /**
   * JoinMethod is the method to use when joining the cluster
   *
   * @generated from field: string JoinMethod = 1;
   */
  JoinMethod = "";

  /**
   * JoinToken is the token to use when joining the cluster
   *
   * @generated from field: string JoinToken = 2;
   */
  JoinToken = "";

  /**
   * ScriptName is the name of the teleport installer script
   * resource for the cloud instance to execute
   *
   * @generated from field: string ScriptName = 3;
   */
  ScriptName = "";

  /**
   * InstallTeleport disables agentless discovery
   *
   * @generated from field: bool InstallTeleport = 4;
   */
  InstallTeleport = false;

  /**
   * SSHDConfig provides the path to write sshd configuration changes
   *
   * @generated from field: string SSHDConfig = 5;
   */
  SSHDConfig = "";

  /**
   * PublicProxyAddr is the address of the proxy the discovered node should use
   * to connect to the cluster.
   *
   * @generated from field: string PublicProxyAddr = 6;
   */
  PublicProxyAddr = "";

  /**
   * Azure is the set of Azure-specific installation parameters.
   *
   * @generated from field: types.AzureInstallerParams Azure = 7;
   */
  Azure?: AzureInstallerParams;

  /**
   * EnrollMode indicates the enrollment mode to be used when adding a node.
   * Valid values:
   * 0: uses eice for EC2 matchers which use an integration and script for all the other methods
   * 1: uses script mode
   * 2: uses eice mode
   *
   * @generated from field: types.InstallParamEnrollMode EnrollMode = 8;
   */
  EnrollMode = InstallParamEnrollMode.UNSPECIFIED;

  constructor(data?: PartialMessage<InstallerParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.InstallerParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "JoinMethod", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "JoinToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ScriptName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "InstallTeleport", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "SSHDConfig", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "PublicProxyAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Azure", kind: "message", T: AzureInstallerParams },
    { no: 8, name: "EnrollMode", kind: "enum", T: proto3.getEnumType(InstallParamEnrollMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstallerParams {
    return new InstallerParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstallerParams {
    return new InstallerParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstallerParams {
    return new InstallerParams().fromJsonString(jsonString, options);
  }

  static equals(a: InstallerParams | PlainMessage<InstallerParams> | undefined, b: InstallerParams | PlainMessage<InstallerParams> | undefined): boolean {
    return proto3.util.equals(InstallerParams, a, b);
  }
}

/**
 * AWSSSM provides options to use when executing SSM documents
 *
 * @generated from message types.AWSSSM
 */
export class AWSSSM extends Message<AWSSSM> {
  /**
   * DocumentName is the name of the document to use when executing an
   * SSM command
   *
   * @generated from field: string DocumentName = 1;
   */
  DocumentName = "";

  constructor(data?: PartialMessage<AWSSSM>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AWSSSM";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DocumentName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSSSM {
    return new AWSSSM().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSSSM {
    return new AWSSSM().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSSSM {
    return new AWSSSM().fromJsonString(jsonString, options);
  }

  static equals(a: AWSSSM | PlainMessage<AWSSSM> | undefined, b: AWSSSM | PlainMessage<AWSSSM> | undefined): boolean {
    return proto3.util.equals(AWSSSM, a, b);
  }
}

/**
 * AzureInstallerParams is the set of Azure-specific installation parameters.
 *
 * @generated from message types.AzureInstallerParams
 */
export class AzureInstallerParams extends Message<AzureInstallerParams> {
  /**
   * ClientID is the client ID of the managed identity discovered nodes
   * should use to join the cluster.
   *
   * @generated from field: string ClientID = 1;
   */
  ClientID = "";

  constructor(data?: PartialMessage<AzureInstallerParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AzureInstallerParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClientID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureInstallerParams {
    return new AzureInstallerParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureInstallerParams {
    return new AzureInstallerParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureInstallerParams {
    return new AzureInstallerParams().fromJsonString(jsonString, options);
  }

  static equals(a: AzureInstallerParams | PlainMessage<AzureInstallerParams> | undefined, b: AzureInstallerParams | PlainMessage<AzureInstallerParams> | undefined): boolean {
    return proto3.util.equals(AzureInstallerParams, a, b);
  }
}

/**
 * AzureMatcher matches Azure resources.
 * It defines which resource types, filters and some configuration params.
 *
 * @generated from message types.AzureMatcher
 */
export class AzureMatcher extends Message<AzureMatcher> {
  /**
   * Subscriptions are Azure subscriptions to query for resources.
   *
   * @generated from field: repeated string Subscriptions = 1;
   */
  Subscriptions: string[] = [];

  /**
   * ResourceGroups are Azure resource groups to query for resources.
   *
   * @generated from field: repeated string ResourceGroups = 2;
   */
  ResourceGroups: string[] = [];

  /**
   * Types are Azure types to match: "mysql", "postgres", "aks", "vm"
   *
   * @generated from field: repeated string Types = 3;
   */
  Types: string[] = [];

  /**
   * Regions are Azure locations to match for databases.
   *
   * @generated from field: repeated string Regions = 4;
   */
  Regions: string[] = [];

  /**
   * ResourceTags are Azure tags on resources to match.
   *
   * @generated from field: wrappers.LabelValues ResourceTags = 5;
   */
  ResourceTags?: LabelValues;

  /**
   * Params sets the join method when installing on
   * discovered Azure nodes.
   *
   * @generated from field: types.InstallerParams Params = 6;
   */
  Params?: InstallerParams;

  constructor(data?: PartialMessage<AzureMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AzureMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Subscriptions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "ResourceGroups", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "Regions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "ResourceTags", kind: "message", T: LabelValues },
    { no: 6, name: "Params", kind: "message", T: InstallerParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureMatcher {
    return new AzureMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureMatcher {
    return new AzureMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureMatcher {
    return new AzureMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: AzureMatcher | PlainMessage<AzureMatcher> | undefined, b: AzureMatcher | PlainMessage<AzureMatcher> | undefined): boolean {
    return proto3.util.equals(AzureMatcher, a, b);
  }
}

/**
 * GCPMatcher matches GCP resources.
 *
 * @generated from message types.GCPMatcher
 */
export class GCPMatcher extends Message<GCPMatcher> {
  /**
   * Types are GKE resource types to match: "gke", "vm".
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[] = [];

  /**
   * Locations are GKE locations to search resources for.
   *
   * @generated from field: repeated string Locations = 2;
   */
  Locations: string[] = [];

  /**
   * Tags is obsolete and only exists for backwards compatibility. Use Labels instead.
   *
   * @generated from field: wrappers.LabelValues Tags = 3;
   */
  Tags?: LabelValues;

  /**
   * ProjectIDs are the GCP project ID where the resources are deployed.
   *
   * @generated from field: repeated string ProjectIDs = 4;
   */
  ProjectIDs: string[] = [];

  /**
   * ServiceAccounts are the emails of service accounts attached to VMs.
   *
   * @generated from field: repeated string ServiceAccounts = 5;
   */
  ServiceAccounts: string[] = [];

  /**
   * Params sets the join method when installing on
   * discovered GCP nodes.
   *
   * @generated from field: types.InstallerParams Params = 6;
   */
  Params?: InstallerParams;

  /**
   * Labels are GCP labels to match.
   *
   * @generated from field: wrappers.LabelValues Labels = 7;
   */
  Labels?: LabelValues;

  constructor(data?: PartialMessage<GCPMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.GCPMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Tags", kind: "message", T: LabelValues },
    { no: 4, name: "ProjectIDs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "ServiceAccounts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "Params", kind: "message", T: InstallerParams },
    { no: 7, name: "Labels", kind: "message", T: LabelValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GCPMatcher {
    return new GCPMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GCPMatcher {
    return new GCPMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GCPMatcher {
    return new GCPMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: GCPMatcher | PlainMessage<GCPMatcher> | undefined, b: GCPMatcher | PlainMessage<GCPMatcher> | undefined): boolean {
    return proto3.util.equals(GCPMatcher, a, b);
  }
}

/**
 * KubernetesMatcher matches Kubernetes services.
 *
 * @generated from message types.KubernetesMatcher
 */
export class KubernetesMatcher extends Message<KubernetesMatcher> {
  /**
   * Types are Kubernetes services types to match. Currently only 'app' is supported.
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[] = [];

  /**
   * Namespaces are Kubernetes namespaces in which to discover services
   *
   * @generated from field: repeated string Namespaces = 2;
   */
  Namespaces: string[] = [];

  /**
   * Labels are Kubernetes services labels to match.
   *
   * @generated from field: wrappers.LabelValues Labels = 3;
   */
  Labels?: LabelValues;

  constructor(data?: PartialMessage<KubernetesMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.KubernetesMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Namespaces", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "Labels", kind: "message", T: LabelValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesMatcher {
    return new KubernetesMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesMatcher {
    return new KubernetesMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesMatcher {
    return new KubernetesMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesMatcher | PlainMessage<KubernetesMatcher> | undefined, b: KubernetesMatcher | PlainMessage<KubernetesMatcher> | undefined): boolean {
    return proto3.util.equals(KubernetesMatcher, a, b);
  }
}

/**
 * OktaOptions specify options related to the Okta service.
 *
 * @generated from message types.OktaOptions
 */
export class OktaOptions extends Message<OktaOptions> {
  /**
   * SyncPeriod is the duration between synchronization calls in nanoseconds.
   *
   * @generated from field: int64 SyncPeriod = 1;
   */
  SyncPeriod = protoInt64.zero;

  constructor(data?: PartialMessage<OktaOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.OktaOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SyncPeriod", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OktaOptions {
    return new OktaOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OktaOptions {
    return new OktaOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OktaOptions {
    return new OktaOptions().fromJsonString(jsonString, options);
  }

  static equals(a: OktaOptions | PlainMessage<OktaOptions> | undefined, b: OktaOptions | PlainMessage<OktaOptions> | undefined): boolean {
    return proto3.util.equals(OktaOptions, a, b);
  }
}

/**
 * AccessGraphSync is a configuration for Access Graph service.
 *
 * @generated from message types.AccessGraphSync
 */
export class AccessGraphSync extends Message<AccessGraphSync> {
  /**
   * AWS is a configuration for AWS Access Graph service poll service.
   *
   * @generated from field: repeated types.AccessGraphAWSSync AWS = 1;
   */
  AWS: AccessGraphAWSSync[] = [];

  constructor(data?: PartialMessage<AccessGraphSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessGraphSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AWS", kind: "message", T: AccessGraphAWSSync, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessGraphSync {
    return new AccessGraphSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessGraphSync {
    return new AccessGraphSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessGraphSync {
    return new AccessGraphSync().fromJsonString(jsonString, options);
  }

  static equals(a: AccessGraphSync | PlainMessage<AccessGraphSync> | undefined, b: AccessGraphSync | PlainMessage<AccessGraphSync> | undefined): boolean {
    return proto3.util.equals(AccessGraphSync, a, b);
  }
}

/**
 * AccessGraphAWSSync is a configuration for AWS Access Graph service poll service.
 *
 * @generated from message types.AccessGraphAWSSync
 */
export class AccessGraphAWSSync extends Message<AccessGraphAWSSync> {
  /**
   * Regions are AWS regions to import resources from.
   *
   * @generated from field: repeated string Regions = 1;
   */
  Regions: string[] = [];

  /**
   * AssumeRoleARN is the AWS role to assume for database discovery.
   *
   * @generated from field: types.AssumeRole AssumeRole = 3;
   */
  AssumeRole?: AssumeRole;

  /**
   * Integration is the integration name used to generate credentials to interact with AWS APIs.
   *
   * @generated from field: string Integration = 4;
   */
  Integration = "";

  constructor(data?: PartialMessage<AccessGraphAWSSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.AccessGraphAWSSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Regions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "AssumeRole", kind: "message", T: AssumeRole },
    { no: 4, name: "Integration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessGraphAWSSync {
    return new AccessGraphAWSSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessGraphAWSSync {
    return new AccessGraphAWSSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessGraphAWSSync {
    return new AccessGraphAWSSync().fromJsonString(jsonString, options);
  }

  static equals(a: AccessGraphAWSSync | PlainMessage<AccessGraphAWSSync> | undefined, b: AccessGraphAWSSync | PlainMessage<AccessGraphAWSSync> | undefined): boolean {
    return proto3.util.equals(AccessGraphAWSSync, a, b);
  }
}

