// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/legacy/client/proto/proxyservice.proto (package proto, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Frame wraps different message types to be sent over a stream.
 *
 * @generated from message proto.Frame
 */
export class Frame extends Message<Frame> {
  /**
   * @generated from oneof proto.Frame.Message
   */
  Message: {
    /**
     * @generated from field: proto.DialRequest DialRequest = 1;
     */
    value: DialRequest;
    case: "DialRequest";
  } | {
    /**
     * @generated from field: proto.ConnectionEstablished ConnectionEstablished = 2;
     */
    value: ConnectionEstablished;
    case: "ConnectionEstablished";
  } | {
    /**
     * @generated from field: proto.Data Data = 3;
     */
    value: Data;
    case: "Data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Frame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Frame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DialRequest", kind: "message", T: DialRequest, oneof: "Message" },
    { no: 2, name: "ConnectionEstablished", kind: "message", T: ConnectionEstablished, oneof: "Message" },
    { no: 3, name: "Data", kind: "message", T: Data, oneof: "Message" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Frame {
    return new Frame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Frame {
    return new Frame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Frame {
    return new Frame().fromJsonString(jsonString, options);
  }

  static equals(a: Frame | PlainMessage<Frame> | undefined, b: Frame | PlainMessage<Frame> | undefined): boolean {
    return proto3.util.equals(Frame, a, b);
  }
}

/**
 * DialRequest contains details for connecting to a node.
 *
 * @generated from message proto.DialRequest
 */
export class DialRequest extends Message<DialRequest> {
  /**
   * NodeID is the {UUID}.{ClusterName} of the node to connect to.
   *
   * @generated from field: string NodeID = 1;
   */
  NodeID = "";

  /**
   * TunnelType is the type of service being accessed. This differentiates agents that
   * create multiple reverse tunnels for different services.
   *
   * @generated from field: string TunnelType = 2;
   */
  TunnelType = "";

  /**
   * Source is the original source address of the client.
   *
   * @generated from field: proto.NetAddr Source = 3;
   */
  Source?: NetAddr;

  /**
   * Destination is the destination address to connect to over the reverse tunnel.
   *
   * @generated from field: proto.NetAddr Destination = 4;
   */
  Destination?: NetAddr;

  constructor(data?: PartialMessage<DialRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DialRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "NodeID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "TunnelType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Source", kind: "message", T: NetAddr },
    { no: 4, name: "Destination", kind: "message", T: NetAddr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DialRequest {
    return new DialRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DialRequest {
    return new DialRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DialRequest {
    return new DialRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DialRequest | PlainMessage<DialRequest> | undefined, b: DialRequest | PlainMessage<DialRequest> | undefined): boolean {
    return proto3.util.equals(DialRequest, a, b);
  }
}

/**
 * Addr is a network address.
 *
 * @generated from message proto.NetAddr
 */
export class NetAddr extends Message<NetAddr> {
  /**
   * Network is the type of network socket. For example tcp or udp.
   *
   * @generated from field: string Network = 1;
   */
  Network = "";

  /**
   * Addr is the host:port address. For example 'localhost:22'
   *
   * @generated from field: string Addr = 2;
   */
  Addr = "";

  constructor(data?: PartialMessage<NetAddr>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.NetAddr";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetAddr {
    return new NetAddr().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetAddr {
    return new NetAddr().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetAddr {
    return new NetAddr().fromJsonString(jsonString, options);
  }

  static equals(a: NetAddr | PlainMessage<NetAddr> | undefined, b: NetAddr | PlainMessage<NetAddr> | undefined): boolean {
    return proto3.util.equals(NetAddr, a, b);
  }
}

/**
 * Data contains the raw bytes of a connection.
 *
 * @generated from message proto.Data
 */
export class Data extends Message<Data> {
  /**
   * @generated from field: bytes Bytes = 1;
   */
  Bytes = new Uint8Array(0);

  constructor(data?: PartialMessage<Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto3.util.equals(Data, a, b);
  }
}

/**
 * ConnectionEstablished signals to the client a connection to the node has been established.
 *
 * @generated from message proto.ConnectionEstablished
 */
export class ConnectionEstablished extends Message<ConnectionEstablished> {
  constructor(data?: PartialMessage<ConnectionEstablished>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ConnectionEstablished";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionEstablished {
    return new ConnectionEstablished().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionEstablished {
    return new ConnectionEstablished().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionEstablished {
    return new ConnectionEstablished().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionEstablished | PlainMessage<ConnectionEstablished> | undefined, b: ConnectionEstablished | PlainMessage<ConnectionEstablished> | undefined): boolean {
    return proto3.util.equals(ConnectionEstablished, a, b);
  }
}

