// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/mfa/v1/mfa.proto (package teleport.mfa.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * ChallengeScope is a scope authorized by an MFA challenge resolution.
 *
 * @generated from enum teleport.mfa.v1.ChallengeScope
 */
export enum ChallengeScope {
  /**
   * Scope unknown or not specified.
   *
   * @generated from enum value: CHALLENGE_SCOPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Standard webauthn login.
   *
   * @generated from enum value: CHALLENGE_SCOPE_LOGIN = 1;
   */
  LOGIN = 1,

  /**
   * Passwordless webauthn login.
   *
   * @generated from enum value: CHALLENGE_SCOPE_PASSWORDLESS_LOGIN = 2;
   */
  PASSWORDLESS_LOGIN = 2,

  /**
   * Headless login.
   *
   * @generated from enum value: CHALLENGE_SCOPE_HEADLESS_LOGIN = 3;
   */
  HEADLESS_LOGIN = 3,

  /**
   * MFA device management.
   *
   * @generated from enum value: CHALLENGE_SCOPE_MANAGE_DEVICES = 4;
   */
  MANAGE_DEVICES = 4,

  /**
   * Account recovery.
   *
   * @generated from enum value: CHALLENGE_SCOPE_ACCOUNT_RECOVERY = 5;
   */
  ACCOUNT_RECOVERY = 5,

  /**
   * Used for per-session MFA and moderated session presence checks.
   *
   * @generated from enum value: CHALLENGE_SCOPE_USER_SESSION = 6;
   */
  USER_SESSION = 6,

  /**
   * Used for various administrative actions, such as adding, updating, or
   * deleting administrative resources (users, roles, etc.).
   *
   * Note: this scope should not be used for new MFA capabilities that have
   * more precise scope. Instead, new scopes should be added. This scope may
   * also be split into multiple smaller scopes in the future.
   *
   * @generated from enum value: CHALLENGE_SCOPE_ADMIN_ACTION = 7;
   */
  ADMIN_ACTION = 7,

  /**
   * Used for changing user's password.
   *
   * @generated from enum value: CHALLENGE_SCOPE_CHANGE_PASSWORD = 8;
   */
  CHANGE_PASSWORD = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(ChallengeScope)
proto3.util.setEnumType(ChallengeScope, "teleport.mfa.v1.ChallengeScope", [
  { no: 0, name: "CHALLENGE_SCOPE_UNSPECIFIED" },
  { no: 1, name: "CHALLENGE_SCOPE_LOGIN" },
  { no: 2, name: "CHALLENGE_SCOPE_PASSWORDLESS_LOGIN" },
  { no: 3, name: "CHALLENGE_SCOPE_HEADLESS_LOGIN" },
  { no: 4, name: "CHALLENGE_SCOPE_MANAGE_DEVICES" },
  { no: 5, name: "CHALLENGE_SCOPE_ACCOUNT_RECOVERY" },
  { no: 6, name: "CHALLENGE_SCOPE_USER_SESSION" },
  { no: 7, name: "CHALLENGE_SCOPE_ADMIN_ACTION" },
  { no: 8, name: "CHALLENGE_SCOPE_CHANGE_PASSWORD" },
]);

/**
 * ChallengeAllowReuse determines whether an MFA challenge response can be used
 * to authenticate the user more than once until the challenge expires.
 *
 * Reuse is only permitted for specific actions by the discretion of the server.
 * See the server implementation for details.
 *
 * @generated from enum teleport.mfa.v1.ChallengeAllowReuse
 */
export enum ChallengeAllowReuse {
  /**
   * Reuse unspecified, treated as CHALLENGE_ALLOW_REUSE_NO.
   *
   * @generated from enum value: CHALLENGE_ALLOW_REUSE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Reuse is permitted.
   *
   * @generated from enum value: CHALLENGE_ALLOW_REUSE_YES = 1;
   */
  YES = 1,

  /**
   * Reuse is not permitted.
   *
   * @generated from enum value: CHALLENGE_ALLOW_REUSE_NO = 2;
   */
  NO = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ChallengeAllowReuse)
proto3.util.setEnumType(ChallengeAllowReuse, "teleport.mfa.v1.ChallengeAllowReuse", [
  { no: 0, name: "CHALLENGE_ALLOW_REUSE_UNSPECIFIED" },
  { no: 1, name: "CHALLENGE_ALLOW_REUSE_YES" },
  { no: 2, name: "CHALLENGE_ALLOW_REUSE_NO" },
]);

/**
 * ChallengeExtensions contains MFA challenge extensions used by Teleport
 * during MFA authentication.
 *
 * @generated from message teleport.mfa.v1.ChallengeExtensions
 */
export class ChallengeExtensions extends Message<ChallengeExtensions> {
  /**
   * Scope is an authorization scope for this MFA challenge.
   * Required.
   *
   * @generated from field: teleport.mfa.v1.ChallengeScope scope = 1;
   */
  scope = ChallengeScope.UNSPECIFIED;

  /**
   * AllowReuse determines whether the MFA challenge allows reuse.
   * Defaults to CHALLENGE_ALLOW_REUSE_NO.
   *
   * Note that reuse is only permitted for specific actions by the discretion
   * of the server. See the server implementation for details.
   *
   * @generated from field: teleport.mfa.v1.ChallengeAllowReuse allow_reuse = 2;
   */
  allowReuse = ChallengeAllowReuse.UNSPECIFIED;

  /**
   * User verification requirement for the challenge.
   *
   * * https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement.
   * * https://pkg.go.dev/github.com/go-webauthn/webauthn/protocol#UserVerificationRequirement.
   *
   * Optional. Empty is equivalent to "discouraged".
   *
   * @generated from field: string user_verification_requirement = 3;
   */
  userVerificationRequirement = "";

  constructor(data?: PartialMessage<ChallengeExtensions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "teleport.mfa.v1.ChallengeExtensions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scope", kind: "enum", T: proto3.getEnumType(ChallengeScope) },
    { no: 2, name: "allow_reuse", kind: "enum", T: proto3.getEnumType(ChallengeAllowReuse) },
    { no: 3, name: "user_verification_requirement", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChallengeExtensions {
    return new ChallengeExtensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChallengeExtensions {
    return new ChallengeExtensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChallengeExtensions {
    return new ChallengeExtensions().fromJsonString(jsonString, options);
  }

  static equals(a: ChallengeExtensions | PlainMessage<ChallengeExtensions> | undefined, b: ChallengeExtensions | PlainMessage<ChallengeExtensions> | undefined): boolean {
    return proto3.util.equals(ChallengeExtensions, a, b);
  }
}

