// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/devicetrust/v1/devicetrust_service.proto (package teleport.devicetrust.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Status } from "../../../google/rpc/status_pb";
import { file_google_rpc_status } from "../../../google/rpc/status_pb";
import type { AuthenticateDeviceChallenge, AuthenticateDeviceChallengeResponse, TPMAuthenticateDeviceChallenge, TPMAuthenticateDeviceChallengeResponse } from "./authenticate_challenge_pb";
import { file_teleport_devicetrust_v1_authenticate_challenge } from "./authenticate_challenge_pb";
import type { Device, DeviceSchema } from "./device_pb";
import { file_teleport_devicetrust_v1_device } from "./device_pb";
import type { DeviceCollectedData } from "./device_collected_data_pb";
import { file_teleport_devicetrust_v1_device_collected_data } from "./device_collected_data_pb";
import type { DeviceConfirmationToken } from "./device_confirmation_token_pb";
import { file_teleport_devicetrust_v1_device_confirmation_token } from "./device_confirmation_token_pb";
import type { DeviceEnrollTokenSchema } from "./device_enroll_token_pb";
import { file_teleport_devicetrust_v1_device_enroll_token } from "./device_enroll_token_pb";
import type { DeviceSource } from "./device_source_pb";
import { file_teleport_devicetrust_v1_device_source } from "./device_source_pb";
import type { DeviceWebToken } from "./device_web_token_pb";
import { file_teleport_devicetrust_v1_device_web_token } from "./device_web_token_pb";
import type { TPMPlatformParameters } from "./tpm_pb";
import { file_teleport_devicetrust_v1_tpm } from "./tpm_pb";
import type { DevicesUsageSchema } from "./usage_pb";
import { file_teleport_devicetrust_v1_usage } from "./usage_pb";
import type { UserCertificates } from "./user_certificates_pb";
import { file_teleport_devicetrust_v1_user_certificates } from "./user_certificates_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/devicetrust/v1/devicetrust_service.proto.
 */
export const file_teleport_devicetrust_v1_devicetrust_service: GenFile = /*@__PURE__*/
  fileDesc("CjF0ZWxlcG9ydC9kZXZpY2V0cnVzdC92MS9kZXZpY2V0cnVzdF9zZXJ2aWNlLnByb3RvEhd0ZWxlcG9ydC5kZXZpY2V0cnVzdC52MSK9AQoTQ3JlYXRlRGV2aWNlUmVxdWVzdBIvCgZkZXZpY2UYASABKAsyHy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2USGwoTY3JlYXRlX2Vucm9sbF90b2tlbhgCIAEoCBIaChJjcmVhdGVfYXNfcmVzb3VyY2UYAyABKAgSPAoYZW5yb2xsX3Rva2VuX2V4cGlyZV90aW1lGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJ3ChNVcGRhdGVEZXZpY2VSZXF1ZXN0Ei8KBmRldmljZRgBIAEoCzIfLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZRIvCgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siYgoTVXBzZXJ0RGV2aWNlUmVxdWVzdBIvCgZkZXZpY2UYASABKAsyHy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2USGgoSY3JlYXRlX2FzX3Jlc291cmNlGAIgASgIIigKE0RlbGV0ZURldmljZVJlcXVlc3QSEQoJZGV2aWNlX2lkGAEgASgJIicKEkZpbmREZXZpY2VzUmVxdWVzdBIRCglpZF9vcl90YWcYASABKAkiRwoTRmluZERldmljZXNSZXNwb25zZRIwCgdkZXZpY2VzGAEgAygLMh8udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlIiUKEEdldERldmljZVJlcXVlc3QSEQoJZGV2aWNlX2lkGAEgASgJIm4KEkxpc3REZXZpY2VzUmVxdWVzdBIRCglwYWdlX3NpemUYASABKAUSEgoKcGFnZV90b2tlbhgCIAEoCRIxCgR2aWV3GAMgASgOMiMudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlVmlldyJgChNMaXN0RGV2aWNlc1Jlc3BvbnNlEjAKB2RldmljZXMYASADKAsyHy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2USFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJImgKGEJ1bGtDcmVhdGVEZXZpY2VzUmVxdWVzdBIwCgdkZXZpY2VzGAEgAygLMh8udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlEhoKEmNyZWF0ZV9hc19yZXNvdXJjZRgCIAEoCCJVChlCdWxrQ3JlYXRlRGV2aWNlc1Jlc3BvbnNlEjgKB2RldmljZXMYASADKAsyJy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VPclN0YXR1cyJRCg5EZXZpY2VPclN0YXR1cxIiCgZzdGF0dXMYASABKAsyEi5nb29nbGUucnBjLlN0YXR1cxIKCgJpZBgCIAEoCRIPCgdkZWxldGVkGAMgASgIIqcBCh5DcmVhdGVEZXZpY2VFbnJvbGxUb2tlblJlcXVlc3QSEQoJZGV2aWNlX2lkGAEgASgJEkEKC2RldmljZV9kYXRhGAIgASgLMiwudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlQ29sbGVjdGVkRGF0YRIvCgtleHBpcmVfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAijQIKE0Vucm9sbERldmljZVJlcXVlc3QSOQoEaW5pdBgBIAEoCzIpLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkVucm9sbERldmljZUluaXRIABJZChhtYWNvc19jaGFsbGVuZ2VfcmVzcG9uc2UYAiABKAsyNS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5NYWNPU0Vucm9sbENoYWxsZW5nZVJlc3BvbnNlSAASVQoWdHBtX2NoYWxsZW5nZV9yZXNwb25zZRgDIAEoCzIzLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlRQTUVucm9sbENoYWxsZW5nZVJlc3BvbnNlSABCCQoHcGF5bG9hZCLyAQoURW5yb2xsRGV2aWNlUmVzcG9uc2USPwoHc3VjY2VzcxgBIAEoCzIsLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkVucm9sbERldmljZVN1Y2Nlc3NIABJICg9tYWNvc19jaGFsbGVuZ2UYAiABKAsyLS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5NYWNPU0Vucm9sbENoYWxsZW5nZUgAEkQKDXRwbV9jaGFsbGVuZ2UYAyABKAsyKy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5UUE1FbnJvbGxDaGFsbGVuZ2VIAEIJCgdwYXlsb2FkIu8BChBFbnJvbGxEZXZpY2VJbml0Eg0KBXRva2VuGAEgASgJEhUKDWNyZWRlbnRpYWxfaWQYAiABKAkSQQoLZGV2aWNlX2RhdGEYAyABKAsyLC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VDb2xsZWN0ZWREYXRhEjoKBW1hY29zGAQgASgLMisudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuTWFjT1NFbnJvbGxQYXlsb2FkEjYKA3RwbRgFIAEoCzIpLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlRQTUVucm9sbFBheWxvYWQiRgoTRW5yb2xsRGV2aWNlU3VjY2VzcxIvCgZkZXZpY2UYASABKAsyHy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2UiLAoSTWFjT1NFbnJvbGxQYXlsb2FkEhYKDnB1YmxpY19rZXlfZGVyGAIgASgMIikKFE1hY09TRW5yb2xsQ2hhbGxlbmdlEhEKCWNoYWxsZW5nZRgBIAEoDCIxChxNYWNPU0Vucm9sbENoYWxsZW5nZVJlc3BvbnNlEhEKCXNpZ25hdHVyZRgCIAEoDCKQAQoQVFBNRW5yb2xsUGF5bG9hZBIRCgdla19jZXJ0GAEgASgMSAASEAoGZWtfa2V5GAIgASgMSAASUQoWYXR0ZXN0YXRpb25fcGFyYW1ldGVycxgDIAEoCzIxLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlRQTUF0dGVzdGF0aW9uUGFyYW1ldGVyc0IECgJlayJ1ChhUUE1BdHRlc3RhdGlvblBhcmFtZXRlcnMSDgoGcHVibGljGAEgASgMEhMKC2NyZWF0ZV9kYXRhGAIgASgMEhoKEmNyZWF0ZV9hdHRlc3RhdGlvbhgDIAEoDBIYChBjcmVhdGVfc2lnbmF0dXJlGAQgASgMIn4KElRQTUVucm9sbENoYWxsZW5nZRJNChRlbmNyeXB0ZWRfY3JlZGVudGlhbBgBIAEoCzIvLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlRQTUVuY3J5cHRlZENyZWRlbnRpYWwSGQoRYXR0ZXN0YXRpb25fbm9uY2UYAiABKAwiQQoWVFBNRW5jcnlwdGVkQ3JlZGVudGlhbBIXCg9jcmVkZW50aWFsX2Jsb2IYASABKAwSDgoGc2VjcmV0GAIgASgMInsKGlRQTUVucm9sbENoYWxsZW5nZVJlc3BvbnNlEhAKCHNvbHV0aW9uGAEgASgMEksKE3BsYXRmb3JtX3BhcmFtZXRlcnMYAiABKAsyLi50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5UUE1QbGF0Zm9ybVBhcmFtZXRlcnMipgIKGUF1dGhlbnRpY2F0ZURldmljZVJlcXVlc3QSPwoEaW5pdBgBIAEoCzIvLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkF1dGhlbnRpY2F0ZURldmljZUluaXRIABJaChJjaGFsbGVuZ2VfcmVzcG9uc2UYAiABKAsyPC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5BdXRoZW50aWNhdGVEZXZpY2VDaGFsbGVuZ2VSZXNwb25zZUgAEmEKFnRwbV9jaGFsbGVuZ2VfcmVzcG9uc2UYAyABKAsyPy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5UUE1BdXRoZW50aWNhdGVEZXZpY2VDaGFsbGVuZ2VSZXNwb25zZUgAQgkKB3BheWxvYWQi3AIKGkF1dGhlbnRpY2F0ZURldmljZVJlc3BvbnNlEkkKCWNoYWxsZW5nZRgBIAEoCzI0LnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkF1dGhlbnRpY2F0ZURldmljZUNoYWxsZW5nZUgAEkYKEXVzZXJfY2VydGlmaWNhdGVzGAIgASgLMikudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuVXNlckNlcnRpZmljYXRlc0gAElAKDXRwbV9jaGFsbGVuZ2UYAyABKAsyNy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5UUE1BdXRoZW50aWNhdGVEZXZpY2VDaGFsbGVuZ2VIABJOChJjb25maXJtYXRpb25fdG9rZW4YBCABKAsyMC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VDb25maXJtYXRpb25Ub2tlbkgAQgkKB3BheWxvYWQi+wEKFkF1dGhlbnRpY2F0ZURldmljZUluaXQSRAoRdXNlcl9jZXJ0aWZpY2F0ZXMYASABKAsyKS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5Vc2VyQ2VydGlmaWNhdGVzEhUKDWNyZWRlbnRpYWxfaWQYAiABKAkSQQoLZGV2aWNlX2RhdGEYAyABKAsyLC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VDb2xsZWN0ZWREYXRhEkEKEGRldmljZV93ZWJfdG9rZW4YBCABKAsyJy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VXZWJUb2tlbiKVAQolQ29uZmlybURldmljZVdlYkF1dGhlbnRpY2F0aW9uUmVxdWVzdBJMChJjb25maXJtYXRpb25fdG9rZW4YASABKAsyMC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VDb25maXJtYXRpb25Ub2tlbhIeChZjdXJyZW50X3dlYl9zZXNzaW9uX2lkGAIgASgJIigKJkNvbmZpcm1EZXZpY2VXZWJBdXRoZW50aWNhdGlvblJlc3BvbnNlIrECChRTeW5jSW52ZW50b3J5UmVxdWVzdBI8CgVzdGFydBgBIAEoCzIrLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlN5bmNJbnZlbnRvcnlTdGFydEgAEjgKA2VuZBgCIAEoCzIpLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlN5bmNJbnZlbnRvcnlFbmRIABJKChFkZXZpY2VzX3RvX3Vwc2VydBgDIAEoCzItLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlN5bmNJbnZlbnRvcnlEZXZpY2VzSAASSgoRZGV2aWNlc190b19yZW1vdmUYBCABKAsyLS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5TeW5jSW52ZW50b3J5RGV2aWNlc0gAQgkKB3BheWxvYWQi7QEKFVN5bmNJbnZlbnRvcnlSZXNwb25zZRI4CgNhY2sYASABKAsyKS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5TeW5jSW52ZW50b3J5QWNrSAASPgoGcmVzdWx0GAIgASgLMiwudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuU3luY0ludmVudG9yeVJlc3VsdEgAEk8KD21pc3NpbmdfZGV2aWNlcxgDIAEoCzI0LnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlN5bmNJbnZlbnRvcnlNaXNzaW5nRGV2aWNlc0gAQgkKB3BheWxvYWQijwEKElN5bmNJbnZlbnRvcnlTdGFydBI1CgZzb3VyY2UYASABKAsyJS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2VTb3VyY2USHQoVdHJhY2tfbWlzc2luZ19kZXZpY2VzGAQgASgISgQIAhADSgQIAxAEUgRtb2RlUhFvbl9taXNzaW5nX2FjdGlvbiIyChBTeW5jSW52ZW50b3J5RW5kSgQIARACUhhleHRlcm5hbF9zeW5jX3N1Y2Nlc3NmdWwiSAoUU3luY0ludmVudG9yeURldmljZXMSMAoHZGV2aWNlcxgBIAMoCzIfLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZSISChBTeW5jSW52ZW50b3J5QWNrIk8KE1N5bmNJbnZlbnRvcnlSZXN1bHQSOAoHZGV2aWNlcxgBIAMoCzInLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZU9yU3RhdHVzIk8KG1N5bmNJbnZlbnRvcnlNaXNzaW5nRGV2aWNlcxIwCgdkZXZpY2VzGAEgAygLMh8udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlIhgKFkdldERldmljZXNVc2FnZVJlcXVlc3QqWQoKRGV2aWNlVmlldxIbChdERVZJQ0VfVklFV19VTlNQRUNJRklFRBAAEhQKEERFVklDRV9WSUVXX0xJU1QQARIYChRERVZJQ0VfVklFV19SRVNPVVJDRRACMq0MChJEZXZpY2VUcnVzdFNlcnZpY2USXQoMQ3JlYXRlRGV2aWNlEiwudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuQ3JlYXRlRGV2aWNlUmVxdWVzdBofLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZRJdCgxVcGRhdGVEZXZpY2USLC50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5VcGRhdGVEZXZpY2VSZXF1ZXN0Gh8udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlEl0KDFVwc2VydERldmljZRIsLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlVwc2VydERldmljZVJlcXVlc3QaHy50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5EZXZpY2USVAoMRGVsZXRlRGV2aWNlEiwudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGVsZXRlRGV2aWNlUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRJoCgtGaW5kRGV2aWNlcxIrLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkZpbmREZXZpY2VzUmVxdWVzdBosLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkZpbmREZXZpY2VzUmVzcG9uc2USVwoJR2V0RGV2aWNlEikudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuR2V0RGV2aWNlUmVxdWVzdBofLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZRJoCgtMaXN0RGV2aWNlcxIrLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkxpc3REZXZpY2VzUmVxdWVzdBosLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkxpc3REZXZpY2VzUmVzcG9uc2USegoRQnVsa0NyZWF0ZURldmljZXMSMS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5CdWxrQ3JlYXRlRGV2aWNlc1JlcXVlc3QaMi50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5CdWxrQ3JlYXRlRGV2aWNlc1Jlc3BvbnNlEn4KF0NyZWF0ZURldmljZUVucm9sbFRva2VuEjcudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuQ3JlYXRlRGV2aWNlRW5yb2xsVG9rZW5SZXF1ZXN0GioudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRGV2aWNlRW5yb2xsVG9rZW4SbwoMRW5yb2xsRGV2aWNlEiwudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuRW5yb2xsRGV2aWNlUmVxdWVzdBotLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkVucm9sbERldmljZVJlc3BvbnNlKAEwARKBAQoSQXV0aGVudGljYXRlRGV2aWNlEjIudGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuQXV0aGVudGljYXRlRGV2aWNlUmVxdWVzdBozLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkF1dGhlbnRpY2F0ZURldmljZVJlc3BvbnNlKAEwARKhAQoeQ29uZmlybURldmljZVdlYkF1dGhlbnRpY2F0aW9uEj4udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuQ29uZmlybURldmljZVdlYkF1dGhlbnRpY2F0aW9uUmVxdWVzdBo/LnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkNvbmZpcm1EZXZpY2VXZWJBdXRoZW50aWNhdGlvblJlc3BvbnNlEnIKDVN5bmNJbnZlbnRvcnkSLS50ZWxlcG9ydC5kZXZpY2V0cnVzdC52MS5TeW5jSW52ZW50b3J5UmVxdWVzdBouLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLlN5bmNJbnZlbnRvcnlSZXNwb25zZSgBMAESbgoPR2V0RGV2aWNlc1VzYWdlEi8udGVsZXBvcnQuZGV2aWNldHJ1c3QudjEuR2V0RGV2aWNlc1VzYWdlUmVxdWVzdBolLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkRldmljZXNVc2FnZSIDiAIBQlpaWGdpdGh1Yi5jb20vZ3Jhdml0YXRpb25hbC90ZWxlcG9ydC9hcGkvZ2VuL3Byb3RvL2dvL3RlbGVwb3J0L2RldmljZXRydXN0L3YxO2RldmljZXRydXN0djFiBnByb3RvMw", [file_google_protobuf_empty, file_google_protobuf_field_mask, file_google_protobuf_timestamp, file_google_rpc_status, file_teleport_devicetrust_v1_authenticate_challenge, file_teleport_devicetrust_v1_device, file_teleport_devicetrust_v1_device_collected_data, file_teleport_devicetrust_v1_device_confirmation_token, file_teleport_devicetrust_v1_device_enroll_token, file_teleport_devicetrust_v1_device_source, file_teleport_devicetrust_v1_device_web_token, file_teleport_devicetrust_v1_tpm, file_teleport_devicetrust_v1_usage, file_teleport_devicetrust_v1_user_certificates]);

/**
 * Request for CreateDevice.
 *
 * @generated from message teleport.devicetrust.v1.CreateDeviceRequest
 */
export type CreateDeviceRequest = Message<"teleport.devicetrust.v1.CreateDeviceRequest"> & {
  /**
   * Device to create.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * If true, a DeviceEnrollToken is created along with the Device.
   *
   * @generated from field: bool create_enroll_token = 2;
   */
  createEnrollToken: boolean;

  /**
   * If true, create the device as a Teleport resource, meaning that fields that
   * are usually considered read-only or system managed are copied as provided
   * to storage.
   * Prefer using non-resource creation semantics if possible.
   *
   * @generated from field: bool create_as_resource = 3;
   */
  createAsResource: boolean;

  /**
   * Custom expiration time for enrollment tokens.
   * A short (for humans) server default is used if unset.
   *
   * @generated from field: google.protobuf.Timestamp enroll_token_expire_time = 4;
   */
  enrollTokenExpireTime?: Timestamp;
};

/**
 * Describes the message teleport.devicetrust.v1.CreateDeviceRequest.
 * Use `create(CreateDeviceRequestSchema)` to create a new message.
 */
export const CreateDeviceRequestSchema: GenMessage<CreateDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 0);

/**
 * Request for UpdateDevice.
 *
 * @generated from message teleport.devicetrust.v1.UpdateDeviceRequest
 */
export type UpdateDeviceRequest = Message<"teleport.devicetrust.v1.UpdateDeviceRequest"> & {
  /**
   * Device to update.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * Update mask applied to the resource.
   * Fields are masked according to their proto name.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message teleport.devicetrust.v1.UpdateDeviceRequest.
 * Use `create(UpdateDeviceRequestSchema)` to create a new message.
 */
export const UpdateDeviceRequestSchema: GenMessage<UpdateDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 1);

/**
 * Request for UpsertDevice.
 *
 * @generated from message teleport.devicetrust.v1.UpsertDeviceRequest
 */
export type UpsertDeviceRequest = Message<"teleport.devicetrust.v1.UpsertDeviceRequest"> & {
  /**
   * Device to create or update.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;

  /**
   * If true, creates the device using resource semantics.
   * Has no effect on device updates.
   * See create_as_resource in CreateDeviceRequest.
   *
   * @generated from field: bool create_as_resource = 2;
   */
  createAsResource: boolean;
};

/**
 * Describes the message teleport.devicetrust.v1.UpsertDeviceRequest.
 * Use `create(UpsertDeviceRequestSchema)` to create a new message.
 */
export const UpsertDeviceRequestSchema: GenMessage<UpsertDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 2);

/**
 * Request for DeleteDevice.
 *
 * @generated from message teleport.devicetrust.v1.DeleteDeviceRequest
 */
export type DeleteDeviceRequest = Message<"teleport.devicetrust.v1.DeleteDeviceRequest"> & {
  /**
   * ID of the Device to delete.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId: string;
};

/**
 * Describes the message teleport.devicetrust.v1.DeleteDeviceRequest.
 * Use `create(DeleteDeviceRequestSchema)` to create a new message.
 */
export const DeleteDeviceRequestSchema: GenMessage<DeleteDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 3);

/**
 * Request for FindDevices.
 *
 * Inspect the returned devices to determine whether the match was by ID or
 * asset tag.
 *
 * @generated from message teleport.devicetrust.v1.FindDevicesRequest
 */
export type FindDevicesRequest = Message<"teleport.devicetrust.v1.FindDevicesRequest"> & {
  /**
   * Device ID or asset tag.
   *
   * @generated from field: string id_or_tag = 1;
   */
  idOrTag: string;
};

/**
 * Describes the message teleport.devicetrust.v1.FindDevicesRequest.
 * Use `create(FindDevicesRequestSchema)` to create a new message.
 */
export const FindDevicesRequestSchema: GenMessage<FindDevicesRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 4);

/**
 * Response for FindDevices.
 *
 * @generated from message teleport.devicetrust.v1.FindDevicesResponse
 */
export type FindDevicesResponse = Message<"teleport.devicetrust.v1.FindDevicesResponse"> & {
  /**
   * Devices that matched the search.
   * The number of resulting devices is expected to be low and may be
   * artificially capped by the server otherwise.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[];
};

/**
 * Describes the message teleport.devicetrust.v1.FindDevicesResponse.
 * Use `create(FindDevicesResponseSchema)` to create a new message.
 */
export const FindDevicesResponseSchema: GenMessage<FindDevicesResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 5);

/**
 * Request for GetDevice.
 *
 * @generated from message teleport.devicetrust.v1.GetDeviceRequest
 */
export type GetDeviceRequest = Message<"teleport.devicetrust.v1.GetDeviceRequest"> & {
  /**
   * ID of the device.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId: string;
};

/**
 * Describes the message teleport.devicetrust.v1.GetDeviceRequest.
 * Use `create(GetDeviceRequestSchema)` to create a new message.
 */
export const GetDeviceRequestSchema: GenMessage<GetDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 6);

/**
 * Request for ListDevices.
 *
 * Follows the pagination semantics of
 * https://cloud.google.com/apis/design/standard_methods#list.
 *
 * @generated from message teleport.devicetrust.v1.ListDevicesRequest
 */
export type ListDevicesRequest = Message<"teleport.devicetrust.v1.ListDevicesRequest"> & {
  /**
   * The maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * The next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Specifies which fields of the resource should be returned in the response.
   * Defaults to DEVICE_VIEW_LIST.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceView view = 3;
   */
  view: DeviceView;
};

/**
 * Describes the message teleport.devicetrust.v1.ListDevicesRequest.
 * Use `create(ListDevicesRequestSchema)` to create a new message.
 */
export const ListDevicesRequestSchema: GenMessage<ListDevicesRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 7);

/**
 * Response for ListDevices.
 *
 * @generated from message teleport.devicetrust.v1.ListDevicesResponse
 */
export type ListDevicesResponse = Message<"teleport.devicetrust.v1.ListDevicesResponse"> & {
  /**
   * Devices that matched the search.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message teleport.devicetrust.v1.ListDevicesResponse.
 * Use `create(ListDevicesResponseSchema)` to create a new message.
 */
export const ListDevicesResponseSchema: GenMessage<ListDevicesResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 8);

/**
 * Request for BulkCreateDevices.
 *
 * @generated from message teleport.devicetrust.v1.BulkCreateDevicesRequest
 */
export type BulkCreateDevicesRequest = Message<"teleport.devicetrust.v1.BulkCreateDevicesRequest"> & {
  /**
   * Devices to create.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[];

  /**
   * If true, create the device as a Teleport resource, meaning that fields that
   * are usually considered read-only or system managed are copied as provided
   * to storage.
   * Prefer using non-resource creation semantics if possible.
   *
   * @generated from field: bool create_as_resource = 2;
   */
  createAsResource: boolean;
};

/**
 * Describes the message teleport.devicetrust.v1.BulkCreateDevicesRequest.
 * Use `create(BulkCreateDevicesRequestSchema)` to create a new message.
 */
export const BulkCreateDevicesRequestSchema: GenMessage<BulkCreateDevicesRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 9);

/**
 * Response for BulkCreateDevices.
 *
 * @generated from message teleport.devicetrust.v1.BulkCreateDevicesResponse
 */
export type BulkCreateDevicesResponse = Message<"teleport.devicetrust.v1.BulkCreateDevicesResponse"> & {
  /**
   * Created devices or a failure reason.
   * Responses are sorted according to the request.
   *
   * @generated from field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
   */
  devices: DeviceOrStatus[];
};

/**
 * Describes the message teleport.devicetrust.v1.BulkCreateDevicesResponse.
 * Use `create(BulkCreateDevicesResponseSchema)` to create a new message.
 */
export const BulkCreateDevicesResponseSchema: GenMessage<BulkCreateDevicesResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 10);

/**
 * DeviceOrStatus contains either a device ID, in case of success, or a status
 * in case of failures.
 *
 * @generated from message teleport.devicetrust.v1.DeviceOrStatus
 */
export type DeviceOrStatus = Message<"teleport.devicetrust.v1.DeviceOrStatus"> & {
  /**
   * Status of the operation.
   * May either be absent or contain the OK code for successes, at the
   * implementation's discretion.
   *
   * @generated from field: google.rpc.Status status = 1;
   */
  status?: Status;

  /**
   * ID of the created device.
   * Only present if the status is OK.
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * If true the action attempted against the device was a delete, instead of a
   * create or update.
   *
   * @generated from field: bool deleted = 3;
   */
  deleted: boolean;
};

/**
 * Describes the message teleport.devicetrust.v1.DeviceOrStatus.
 * Use `create(DeviceOrStatusSchema)` to create a new message.
 */
export const DeviceOrStatusSchema: GenMessage<DeviceOrStatus> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 11);

/**
 * Request for CreateDeviceEnrollToken.
 *
 * @generated from message teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest
 */
export type CreateDeviceEnrollTokenRequest = Message<"teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest"> & {
  /**
   * ID of the device.
   *
   * @generated from field: string device_id = 1;
   */
  deviceId: string;

  /**
   * Device collected data.
   * Used to authorize issuance of device enrollment tokens for auto-enrollment.
   * Not required otherwise.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 2;
   */
  deviceData?: DeviceCollectedData;

  /**
   * Custom expiration time for enrollment tokens.
   * A short (for humans) server default is used if unset.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 3;
   */
  expireTime?: Timestamp;
};

/**
 * Describes the message teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest.
 * Use `create(CreateDeviceEnrollTokenRequestSchema)` to create a new message.
 */
export const CreateDeviceEnrollTokenRequestSchema: GenMessage<CreateDeviceEnrollTokenRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 12);

/**
 * Request for EnrollDevice.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceRequest
 */
export type EnrollDeviceRequest = Message<"teleport.devicetrust.v1.EnrollDeviceRequest"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.EnrollDeviceRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.EnrollDeviceInit init = 1;
     */
    value: EnrollDeviceInit;
    case: "init";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.MacOSEnrollChallengeResponse macos_challenge_response = 2;
     */
    value: MacOSEnrollChallengeResponse;
    case: "macosChallengeResponse";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMEnrollChallengeResponse tpm_challenge_response = 3;
     */
    value: TPMEnrollChallengeResponse;
    case: "tpmChallengeResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.EnrollDeviceRequest.
 * Use `create(EnrollDeviceRequestSchema)` to create a new message.
 */
export const EnrollDeviceRequestSchema: GenMessage<EnrollDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 13);

/**
 * Response for EnrollDevice.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceResponse
 */
export type EnrollDeviceResponse = Message<"teleport.devicetrust.v1.EnrollDeviceResponse"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.EnrollDeviceResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.EnrollDeviceSuccess success = 1;
     */
    value: EnrollDeviceSuccess;
    case: "success";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.MacOSEnrollChallenge macos_challenge = 2;
     */
    value: MacOSEnrollChallenge;
    case: "macosChallenge";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMEnrollChallenge tpm_challenge = 3;
     */
    value: TPMEnrollChallenge;
    case: "tpmChallenge";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.EnrollDeviceResponse.
 * Use `create(EnrollDeviceResponseSchema)` to create a new message.
 */
export const EnrollDeviceResponseSchema: GenMessage<EnrollDeviceResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 14);

/**
 * EnrollDeviceInit initiates the enrollment ceremony.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceInit
 */
export type EnrollDeviceInit = Message<"teleport.devicetrust.v1.EnrollDeviceInit"> & {
  /**
   * Device enrollment token.
   * See CreateDevice or CreateDeviceEnrollToken.
   *
   * @generated from field: string token = 1;
   */
  token: string;

  /**
   * ID of the device credential.
   *
   * @generated from field: string credential_id = 2;
   */
  credentialId: string;

  /**
   * Device collected data.
   * Matched against the device registration information and any previously
   * collected data.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
   */
  deviceData?: DeviceCollectedData;

  /**
   * Payload for macOS-specific data.
   *
   * @generated from field: teleport.devicetrust.v1.MacOSEnrollPayload macos = 4;
   */
  macos?: MacOSEnrollPayload;

  /**
   * Payload for TPM-specific data. Used for Windows/Linux.
   *
   * @generated from field: teleport.devicetrust.v1.TPMEnrollPayload tpm = 5;
   */
  tpm?: TPMEnrollPayload;
};

/**
 * Describes the message teleport.devicetrust.v1.EnrollDeviceInit.
 * Use `create(EnrollDeviceInitSchema)` to create a new message.
 */
export const EnrollDeviceInitSchema: GenMessage<EnrollDeviceInit> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 15);

/**
 * EnrollDeviceSuccess marks a successful device enrollment ceremony.
 *
 * @generated from message teleport.devicetrust.v1.EnrollDeviceSuccess
 */
export type EnrollDeviceSuccess = Message<"teleport.devicetrust.v1.EnrollDeviceSuccess"> & {
  /**
   * The enrolled device.
   *
   * @generated from field: teleport.devicetrust.v1.Device device = 1;
   */
  device?: Device;
};

/**
 * Describes the message teleport.devicetrust.v1.EnrollDeviceSuccess.
 * Use `create(EnrollDeviceSuccessSchema)` to create a new message.
 */
export const EnrollDeviceSuccessSchema: GenMessage<EnrollDeviceSuccess> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 16);

/**
 * MacOSEnrollPayload is the macOS-specific enrollment payload.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollPayload
 */
export type MacOSEnrollPayload = Message<"teleport.devicetrust.v1.MacOSEnrollPayload"> & {
  /**
   * Device public key marshaled as a PKIX, ASN.1 DER.
   *
   * @generated from field: bytes public_key_der = 2;
   */
  publicKeyDer: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.MacOSEnrollPayload.
 * Use `create(MacOSEnrollPayloadSchema)` to create a new message.
 */
export const MacOSEnrollPayloadSchema: GenMessage<MacOSEnrollPayload> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 17);

/**
 * MacOSEnrollChallenge is a macOS enrollment challenge.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollChallenge
 */
export type MacOSEnrollChallenge = Message<"teleport.devicetrust.v1.MacOSEnrollChallenge"> & {
  /**
   * Randomly-generated, opaque challenge to be signed using the device key.
   *
   * @generated from field: bytes challenge = 1;
   */
  challenge: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.MacOSEnrollChallenge.
 * Use `create(MacOSEnrollChallengeSchema)` to create a new message.
 */
export const MacOSEnrollChallengeSchema: GenMessage<MacOSEnrollChallenge> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 18);

/**
 * MacOSEnrollChallengeResponse is a macOS enrollment challenge response.
 *
 * @generated from message teleport.devicetrust.v1.MacOSEnrollChallengeResponse
 */
export type MacOSEnrollChallengeResponse = Message<"teleport.devicetrust.v1.MacOSEnrollChallengeResponse"> & {
  /**
   * Signature over the challenge, using the device key.
   *
   * @generated from field: bytes signature = 2;
   */
  signature: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.MacOSEnrollChallengeResponse.
 * Use `create(MacOSEnrollChallengeResponseSchema)` to create a new message.
 */
export const MacOSEnrollChallengeResponseSchema: GenMessage<MacOSEnrollChallengeResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 19);

/**
 * The payload containing TPM specific information required on device
 * enrollment.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollPayload
 */
export type TPMEnrollPayload = Message<"teleport.devicetrust.v1.TPMEnrollPayload"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.TPMEnrollPayload.ek
   */
  ek: {
    /**
     * The device's endorsement certificate in X509, ASN.1 DER form. This
     * certificate contains the public key of the endorsement key. This is
     * preferred to ek_key.
     *
     * @generated from field: bytes ek_cert = 1;
     */
    value: Uint8Array;
    case: "ekCert";
  } | {
    /**
     * The device's public endorsement key in PKIX, ASN.1 DER form. This is
     * used when a TPM does not contain any endorsement certificates.
     *
     * @generated from field: bytes ek_key = 2;
     */
    value: Uint8Array;
    case: "ekKey";
  } | { case: undefined; value?: undefined };

  /**
   * The attestation key and the parameters necessary to remotely verify it as
   * related to the endorsement key.
   *
   * @generated from field: teleport.devicetrust.v1.TPMAttestationParameters attestation_parameters = 3;
   */
  attestationParameters?: TPMAttestationParameters;
};

/**
 * Describes the message teleport.devicetrust.v1.TPMEnrollPayload.
 * Use `create(TPMEnrollPayloadSchema)` to create a new message.
 */
export const TPMEnrollPayloadSchema: GenMessage<TPMEnrollPayload> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 20);

/**
 * The attestation key and the parameters necessary to remotely verify it as
 * related to the endorsement key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
 * This message excludes the `UseTCSDActivationFormat` field from the link above
 * as it is TMP 1.x specific and always false.
 *
 * @generated from message teleport.devicetrust.v1.TPMAttestationParameters
 */
export type TPMAttestationParameters = Message<"teleport.devicetrust.v1.TPMAttestationParameters"> & {
  /**
   * The encoded TPMT_PUBLIC structure containing the attestation public key
   * and signing parameters.
   *
   * @generated from field: bytes public = 1;
   */
  public: Uint8Array;

  /**
   * The properties of the attestation key, encoded as a TPMS_CREATION_DATA
   * structure.
   *
   * @generated from field: bytes create_data = 2;
   */
  createData: Uint8Array;

  /**
   * An assertion as to the details of the key, encoded as a TPMS_ATTEST
   * structure.
   *
   * @generated from field: bytes create_attestation = 3;
   */
  createAttestation: Uint8Array;

  /**
   * A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
   *
   * @generated from field: bytes create_signature = 4;
   */
  createSignature: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.TPMAttestationParameters.
 * Use `create(TPMAttestationParametersSchema)` to create a new message.
 */
export const TPMAttestationParametersSchema: GenMessage<TPMAttestationParameters> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 21);

/**
 * The challenge sent to the client by the server during enrollment.
 * The challenge involves two parts:
 * - Solving an encrypted credential with `ActivateCredential`.
 * - Producing a platform attestation using the provided nonce.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollChallenge
 */
export type TPMEnrollChallenge = Message<"teleport.devicetrust.v1.TPMEnrollChallenge"> & {
  /**
   * The encrypted credential for the client to prove possession of the EK and
   * AK.
   *
   * @generated from field: teleport.devicetrust.v1.TPMEncryptedCredential encrypted_credential = 1;
   */
  encryptedCredential?: TPMEncryptedCredential;

  /**
   * The nonce to use when producing the quotes over the PCRs with the TPM
   * during the platform attestation.
   *
   * @generated from field: bytes attestation_nonce = 2;
   */
  attestationNonce: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.TPMEnrollChallenge.
 * Use `create(TPMEnrollChallengeSchema)` to create a new message.
 */
export const TPMEnrollChallengeSchema: GenMessage<TPMEnrollChallenge> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 22);

/**
 * These values are used by the TPM2.0 `ActivateCredential` command to produce
 * the solution which proves possession of the EK and AK.
 *
 * For a more in-depth description see:
 * - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
 * - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
 * - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
 * - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
 *
 * @generated from message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export type TPMEncryptedCredential = Message<"teleport.devicetrust.v1.TPMEncryptedCredential"> & {
  /**
   * The `credential_blob` parameter to be used with the `ActivateCredential`
   * command. This is used with the decrypted value of `secret` in a
   * cryptographic process to decrypt the solution.
   *
   * @generated from field: bytes credential_blob = 1;
   */
  credentialBlob: Uint8Array;

  /**
   * The `secret` parameter to be used with `ActivateCredential`. This is a
   * seed which can be decrypted with the EK. The decrypted seed is then used
   * when decrypting `credential_blob`.
   *
   * @generated from field: bytes secret = 2;
   */
  secret: Uint8Array;
};

/**
 * Describes the message teleport.devicetrust.v1.TPMEncryptedCredential.
 * Use `create(TPMEncryptedCredentialSchema)` to create a new message.
 */
export const TPMEncryptedCredentialSchema: GenMessage<TPMEncryptedCredential> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 23);

/**
 * The enrollment challenge response containing the solution returned by
 * calling the TPM2.0 `ActivateCredential` command on the client with the
 * parameters provided in `TPMEnrollChallenge`.
 *
 * @generated from message teleport.devicetrust.v1.TPMEnrollChallengeResponse
 */
export type TPMEnrollChallengeResponse = Message<"teleport.devicetrust.v1.TPMEnrollChallengeResponse"> & {
  /**
   * The client's solution to `TPMEncryptedCredential` included in
   * `TPMEnrollChallenge` using ActivateCredential.
   *
   * @generated from field: bytes solution = 1;
   */
  solution: Uint8Array;

  /**
   * The result of the client's platform attestation with the nonce provided
   * in `TPMEnrollChallenge`.
   *
   * @generated from field: teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2;
   */
  platformParameters?: TPMPlatformParameters;
};

/**
 * Describes the message teleport.devicetrust.v1.TPMEnrollChallengeResponse.
 * Use `create(TPMEnrollChallengeResponseSchema)` to create a new message.
 */
export const TPMEnrollChallengeResponseSchema: GenMessage<TPMEnrollChallengeResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 24);

/**
 * Request for AuthenticateDevice.
 *
 * Authentication ceremony flow:
 * -> AuthenticateDeviceInit (client)
 * <- AuthenticateDeviceChallenge (server)
 * -> AuthenticateDeviceChallengeResponse
 * <- UserCertificates (regular authn) or ConfirmationToken (web authn)
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceRequest
 */
export type AuthenticateDeviceRequest = Message<"teleport.devicetrust.v1.AuthenticateDeviceRequest"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.AuthenticateDeviceRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceInit init = 1;
     */
    value: AuthenticateDeviceInit;
    case: "init";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceChallengeResponse challenge_response = 2;
     */
    value: AuthenticateDeviceChallengeResponse;
    case: "challengeResponse";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallengeResponse tpm_challenge_response = 3;
     */
    value: TPMAuthenticateDeviceChallengeResponse;
    case: "tpmChallengeResponse";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.AuthenticateDeviceRequest.
 * Use `create(AuthenticateDeviceRequestSchema)` to create a new message.
 */
export const AuthenticateDeviceRequestSchema: GenMessage<AuthenticateDeviceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 25);

/**
 * Response for AuthenticateDevice.
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceResponse
 */
export type AuthenticateDeviceResponse = Message<"teleport.devicetrust.v1.AuthenticateDeviceResponse"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.AuthenticateDeviceResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.AuthenticateDeviceChallenge challenge = 1;
     */
    value: AuthenticateDeviceChallenge;
    case: "challenge";
  } | {
    /**
     * User certificates are returned as the result of a successful device
     * authentication attempt ("regular" or non-web authentication).
     *
     * @generated from field: teleport.devicetrust.v1.UserCertificates user_certificates = 2;
     */
    value: UserCertificates;
    case: "userCertificates";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.TPMAuthenticateDeviceChallenge tpm_challenge = 3;
     */
    value: TPMAuthenticateDeviceChallenge;
    case: "tpmChallenge";
  } | {
    /**
     * A confirmation token is returned as the result of a successful device web
     * authentication.
     *
     * See AuthenticateDeviceInit.device_web_token.
     *
     * @generated from field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 4;
     */
    value: DeviceConfirmationToken;
    case: "confirmationToken";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.AuthenticateDeviceResponse.
 * Use `create(AuthenticateDeviceResponseSchema)` to create a new message.
 */
export const AuthenticateDeviceResponseSchema: GenMessage<AuthenticateDeviceResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 26);

/**
 * AuthenticateDeviceInit initiates the device authentication ceremony.
 *
 * @generated from message teleport.devicetrust.v1.AuthenticateDeviceInit
 */
export type AuthenticateDeviceInit = Message<"teleport.devicetrust.v1.AuthenticateDeviceInit"> & {
  /**
   * In-band user certificates to augment with device extensions.
   * - The x509 certificate is acquired from the mTLS connection, thus the
   *   in-band certificate is ignored.
   * - All certificates must be valid and issued by the Teleport CA.
   * - TLS and SSH certificates must match (same Teleport user, plus whatever
   *   additional checks the backend sees fit).
   * - TLS and SSH certificates must either have matching public keys, or
   *   (TPM)AuthenticateDeviceChallengeResponse.SshSignature must be a valid
   *   signature over the challenge by the SSH private key.
   * - Augmented certificates have the same expiration as the original
   *   certificates.
   *
   * @generated from field: teleport.devicetrust.v1.UserCertificates user_certificates = 1;
   */
  userCertificates?: UserCertificates;

  /**
   * ID of the enrolled device credential.
   *
   * @generated from field: string credential_id = 2;
   */
  credentialId: string;

  /**
   * Device collected data.
   * Matched against the device registration information and any previously
   * collected data.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceCollectedData device_data = 3;
   */
  deviceData?: DeviceCollectedData;

  /**
   * If present, on-behalf-of device authentication is performed.
   * The user_certificates input field is ignored and no certificate data is
   * returned to the caller, instead a confirmation_token is returned in
   * the last step.
   *
   * See ConfirmDeviceWebAuthentication.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceWebToken device_web_token = 4;
   */
  deviceWebToken?: DeviceWebToken;
};

/**
 * Describes the message teleport.devicetrust.v1.AuthenticateDeviceInit.
 * Use `create(AuthenticateDeviceInitSchema)` to create a new message.
 */
export const AuthenticateDeviceInitSchema: GenMessage<AuthenticateDeviceInit> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 27);

/**
 * Request for ConfirmDeviceWebAuthentication.
 *
 * @generated from message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest
 */
export type ConfirmDeviceWebAuthenticationRequest = Message<"teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest"> & {
  /**
   * Confirmation token to be spent.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceConfirmationToken confirmation_token = 1;
   */
  confirmationToken?: DeviceConfirmationToken;

  /**
   * Web Session identifier of the session that started this request, via
   * Teleport Proxy.
   *
   * For the request to be successful the Web Session must match the session
   * that started the authentication attempt.
   *
   * @generated from field: string current_web_session_id = 2;
   */
  currentWebSessionId: string;
};

/**
 * Describes the message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationRequest.
 * Use `create(ConfirmDeviceWebAuthenticationRequestSchema)` to create a new message.
 */
export const ConfirmDeviceWebAuthenticationRequestSchema: GenMessage<ConfirmDeviceWebAuthenticationRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 28);

/**
 * Response for ConfirmDeviceWebAuthentication.
 *
 * @generated from message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse
 */
export type ConfirmDeviceWebAuthenticationResponse = Message<"teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse"> & {
};

/**
 * Describes the message teleport.devicetrust.v1.ConfirmDeviceWebAuthenticationResponse.
 * Use `create(ConfirmDeviceWebAuthenticationResponseSchema)` to create a new message.
 */
export const ConfirmDeviceWebAuthenticationResponseSchema: GenMessage<ConfirmDeviceWebAuthenticationResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 29);

/**
 * Request for SyncInventory.
 *
 * A typical message sequence is as follows:
 * (-> means client-to-server, <- means server-to-client)
 * -> SyncInventoryStart
 * <- SyncInventoryAck
 * (loop)
 * -> SyncInventoryDevices (add/remove devices)
 * <- SyncInventoryResult
 * (end loop)
 * -> SyncInventoryEnd
 * (loop until server closes the stream, zero or more times)
 * <- SyncInventoryMissingDevices
 * -> SyncInventoryDevices (removals only)
 * <- SyncInventoryResult
 * (end loop)
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryRequest
 */
export type SyncInventoryRequest = Message<"teleport.devicetrust.v1.SyncInventoryRequest"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.SyncInventoryRequest.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryStart start = 1;
     */
    value: SyncInventoryStart;
    case: "start";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryEnd end = 2;
     */
    value: SyncInventoryEnd;
    case: "end";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_upsert = 3;
     */
    value: SyncInventoryDevices;
    case: "devicesToUpsert";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryDevices devices_to_remove = 4;
     */
    value: SyncInventoryDevices;
    case: "devicesToRemove";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryRequest.
 * Use `create(SyncInventoryRequestSchema)` to create a new message.
 */
export const SyncInventoryRequestSchema: GenMessage<SyncInventoryRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 30);

/**
 * Response for SyncInventory.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryResponse
 */
export type SyncInventoryResponse = Message<"teleport.devicetrust.v1.SyncInventoryResponse"> & {
  /**
   * @generated from oneof teleport.devicetrust.v1.SyncInventoryResponse.payload
   */
  payload: {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryAck ack = 1;
     */
    value: SyncInventoryAck;
    case: "ack";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryResult result = 2;
     */
    value: SyncInventoryResult;
    case: "result";
  } | {
    /**
     * @generated from field: teleport.devicetrust.v1.SyncInventoryMissingDevices missing_devices = 3;
     */
    value: SyncInventoryMissingDevices;
    case: "missingDevices";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryResponse.
 * Use `create(SyncInventoryResponseSchema)` to create a new message.
 */
export const SyncInventoryResponseSchema: GenMessage<SyncInventoryResponse> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 31);

/**
 * SyncInventoryStart starts the inventory sync.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryStart
 */
export type SyncInventoryStart = Message<"teleport.devicetrust.v1.SyncInventoryStart"> & {
  /**
   * Source of the inventory sync.
   * Used for all devices. The `source` field in individual devices is ignored
   * by this RPC.
   *
   * @generated from field: teleport.devicetrust.v1.DeviceSource source = 1;
   */
  source?: DeviceSource;

  /**
   * If true, the server keeps track of the devices upserted during the sync.
   * After receiving the [SyncInventoryEnd] message, the server informs the
   * client of all devices that are present in storage but not observed in the
   * upserts.
   * See [SyncInventoryRequest] and [SyncInventoryMissingDevices] for details.
   *
   * @generated from field: bool track_missing_devices = 4;
   */
  trackMissingDevices: boolean;
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryStart.
 * Use `create(SyncInventoryStartSchema)` to create a new message.
 */
export const SyncInventoryStartSchema: GenMessage<SyncInventoryStart> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 32);

/**
 * SyncInventoryEnd ends the inventory sync, signaling that no more
 * SyncInventoryDevices messages will be sent by the client.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryEnd
 */
export type SyncInventoryEnd = Message<"teleport.devicetrust.v1.SyncInventoryEnd"> & {
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryEnd.
 * Use `create(SyncInventoryEndSchema)` to create a new message.
 */
export const SyncInventoryEndSchema: GenMessage<SyncInventoryEnd> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 33);

/**
 * SyncInventoryDevices transports devices to add/update/remove.
 * Removals only need identifying fields to be set.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryDevices
 */
export type SyncInventoryDevices = Message<"teleport.devicetrust.v1.SyncInventoryDevices"> & {
  /**
   * Devices to sync.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[];
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryDevices.
 * Use `create(SyncInventoryDevicesSchema)` to create a new message.
 */
export const SyncInventoryDevicesSchema: GenMessage<SyncInventoryDevices> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 34);

/**
 * SyncInventoryAck is used to confirm successful processing of messages that
 * lack a more specific response.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryAck
 */
export type SyncInventoryAck = Message<"teleport.devicetrust.v1.SyncInventoryAck"> & {
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryAck.
 * Use `create(SyncInventoryAckSchema)` to create a new message.
 */
export const SyncInventoryAckSchema: GenMessage<SyncInventoryAck> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 35);

/**
 * SyncInventoryResult is the response for SyncInventoryDevices or
 * SyncInventoryEnd
 * It lists all synced/deleted devices.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryResult
 */
export type SyncInventoryResult = Message<"teleport.devicetrust.v1.SyncInventoryResult"> & {
  /**
   * Devices modified, in the same order as the input when applicable.
   *
   * @generated from field: repeated teleport.devicetrust.v1.DeviceOrStatus devices = 1;
   */
  devices: DeviceOrStatus[];
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryResult.
 * Use `create(SyncInventoryResultSchema)` to create a new message.
 */
export const SyncInventoryResultSchema: GenMessage<SyncInventoryResult> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 36);

/**
 * SyncInventoryMissingDevices informs the sync client of all stored devices
 * that were not observed in upserts during the sync.
 *
 * Requires `track_missing_devices` to be set in the [SyncInventoryStart]
 * message.
 *
 * The client must follow up with a [SyncInventoryDevices] message, including
 * any devices to be deleted.
 *
 * @generated from message teleport.devicetrust.v1.SyncInventoryMissingDevices
 */
export type SyncInventoryMissingDevices = Message<"teleport.devicetrust.v1.SyncInventoryMissingDevices"> & {
  /**
   * Devices missing from the client-side sync.
   * Guaranteed to have the following fields: id, os_type, asset_tag and
   * profile.external_id.
   *
   * @generated from field: repeated teleport.devicetrust.v1.Device devices = 1;
   */
  devices: Device[];
};

/**
 * Describes the message teleport.devicetrust.v1.SyncInventoryMissingDevices.
 * Use `create(SyncInventoryMissingDevicesSchema)` to create a new message.
 */
export const SyncInventoryMissingDevicesSchema: GenMessage<SyncInventoryMissingDevices> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 37);

/**
 * Superseded by ResourceUsageService.GetUsage.
 *
 * @generated from message teleport.devicetrust.v1.GetDevicesUsageRequest
 */
export type GetDevicesUsageRequest = Message<"teleport.devicetrust.v1.GetDevicesUsageRequest"> & {
};

/**
 * Describes the message teleport.devicetrust.v1.GetDevicesUsageRequest.
 * Use `create(GetDevicesUsageRequestSchema)` to create a new message.
 */
export const GetDevicesUsageRequestSchema: GenMessage<GetDevicesUsageRequest> = /*@__PURE__*/
  messageDesc(file_teleport_devicetrust_v1_devicetrust_service, 38);

/**
 * DeviceView specifies which fields of returned devices should be present.
 *
 * @generated from enum teleport.devicetrust.v1.DeviceView
 */
export enum DeviceView {
  /**
   * @generated from enum value: DEVICE_VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * View for general device listings, like `tctl devices ls`.
   * Contains only basic information, such as IDs and enrollment status.
   *
   * @generated from enum value: DEVICE_VIEW_LIST = 1;
   */
  LIST = 1,

  /**
   * View for detailed device queries, like `tctl get devices`.
   * Presents a complete view of the device.
   *
   * @generated from enum value: DEVICE_VIEW_RESOURCE = 2;
   */
  RESOURCE = 2,
}

/**
 * Describes the enum teleport.devicetrust.v1.DeviceView.
 */
export const DeviceViewSchema: GenEnum<DeviceView> = /*@__PURE__*/
  enumDesc(file_teleport_devicetrust_v1_devicetrust_service, 0);

/**
 * DeviceTrustService provides methods to manage, enroll and authenticate
 * trusted devices.
 *
 * A trusted device is a device that is registered and enrolled with Teleport,
 * thus allowing the system to provide some guarantees about its provenance and
 * state.
 *
 * Managing devices requires the corresponding CRUD "device" permission.
 * Additionally, creating enrollment tokens requires the "create_enroll_token"
 * permission and enrolling devices requires the "enroll" permission. See
 * CreateDevice, CreateDeviceEnrollToken and EnrollDevice for reference.
 *
 * An authenticated, trusted device allows its user to perform device-aware
 * actions. Such actions include accessing an SSH node, managing sensitive
 * resources via `tctl`, etc. The enforcement mode is defined via cluster-wide
 * and/or per-role toggles. Device authentication is automatic for enrolled
 * devices communicating with Enterprise clusters. See AuthenticateDevice for
 * reference.
 *
 * Device Trust is a Teleport Enterprise feature. Open Source Teleport clusters
 * treat all Device RPCs as unimplemented (which, in fact, they are for OSS.)
 *
 * @generated from service teleport.devicetrust.v1.DeviceTrustService
 */
export const DeviceTrustService: GenService<{
  /**
   * CreateDevice creates a device, effectively registering it on Teleport.
   * Devices need to be registered before they can be enrolled.
   *
   * It is possible to create both a Device and a DeviceEnrollToken in a
   * single invocation, see CreateDeviceRequest.create_enroll_token.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.CreateDevice
   */
  createDevice: {
    methodKind: "unary";
    input: typeof CreateDeviceRequestSchema;
    output: typeof DeviceSchema;
  },
  /**
   * UpdateDevice is a masked device update.
   *
   * Only certain fields may be updated, see Device for details.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.UpdateDevice
   */
  updateDevice: {
    methodKind: "unary";
    input: typeof UpdateDeviceRequestSchema;
    output: typeof DeviceSchema;
  },
  /**
   * UpsertDevice creates or updates a device.
   *
   * UpsertDevice attempts a write of all mutable fields on updates, therefore
   * reading a fresh copy of the device is recommended. Update semantics still
   * apply.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.UpsertDevice
   */
  upsertDevice: {
    methodKind: "unary";
    input: typeof UpsertDeviceRequestSchema;
    output: typeof DeviceSchema;
  },
  /**
   * DeleteDevice hard-deletes a device, removing it and all collected data
   * history from the system.
   *
   * Prefer locking the device instead (see the `tctl lock` command). Deleting a
   * device doesn't invalidate existing device certificates, but does prevent
   * new device authentication ceremonies from occurring.
   *
   * Use with caution.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.DeleteDevice
   */
  deleteDevice: {
    methodKind: "unary";
    input: typeof DeleteDeviceRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * FindDevices retrieves devices by device ID and/or asset tag.
   *
   * It provides an in-between search between fetching a device by ID and
   * listing all devices.
   *
   * ID matches are guaranteed to be present in the response.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.FindDevices
   */
  findDevices: {
    methodKind: "unary";
    input: typeof FindDevicesRequestSchema;
    output: typeof FindDevicesResponseSchema;
  },
  /**
   * GetDevice retrieves a device by ID.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.GetDevice
   */
  getDevice: {
    methodKind: "unary";
    input: typeof GetDeviceRequestSchema;
    output: typeof DeviceSchema;
  },
  /**
   * ListDevices lists all registered devices.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.ListDevices
   */
  listDevices: {
    methodKind: "unary";
    input: typeof ListDevicesRequestSchema;
    output: typeof ListDevicesResponseSchema;
  },
  /**
   * BulkCreateDevices is a bulk variant of CreateDevice.
   *
   * Unlike CreateDevice, it does not support creation of enrollment tokens, as
   * it is meant for bulk inventory registration.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.BulkCreateDevices
   */
  bulkCreateDevices: {
    methodKind: "unary";
    input: typeof BulkCreateDevicesRequestSchema;
    output: typeof BulkCreateDevicesResponseSchema;
  },
  /**
   * CreateDeviceEnrollToken creates a DeviceEnrollToken for a Device.
   * An enrollment token is required for the enrollment ceremony. See
   * EnrollDevice.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.CreateDeviceEnrollToken
   */
  createDeviceEnrollToken: {
    methodKind: "unary";
    input: typeof CreateDeviceEnrollTokenRequestSchema;
    output: typeof DeviceEnrollTokenSchema;
  },
  /**
   * EnrollDevice performs the device enrollment ceremony.
   *
   * Enrollment requires a previously-registered Device and a DeviceEnrollToken,
   * see CreateDevice and CreateDeviceEnrollToken.
   *
   * An enrolled device is allowed, via AuthenticateDevice, to acquire
   * certificates containing device extensions, thus gaining access to
   * device-aware actions.
   *
   * macOS enrollment flow:
   * -> EnrollDeviceInit (client)
   * <- MacOSEnrollChallenge (server)
   * -> MacOSEnrollChallengeResponse
   * <- EnrollDeviceSuccess
   *
   * TPM enrollment flow:
   * -> EnrollDeviceInit (client)
   * <- TPMEnrollChallenge (server)
   * -> TPMEnrollChallengeResponse
   * <- EnrollDeviceSuccess
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.EnrollDevice
   */
  enrollDevice: {
    methodKind: "bidi_streaming";
    input: typeof EnrollDeviceRequestSchema;
    output: typeof EnrollDeviceResponseSchema;
  },
  /**
   * AuthenticateDevice performs the device authentication ceremony.
   *
   * Device authentication exchanges existing user certificates without device
   * extensions for certificates augmented with device extensions. The new
   * certificates allow the user to perform device-aware actions.
   *
   * Only registered and enrolled devices may perform device authentication.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.AuthenticateDevice
   */
  authenticateDevice: {
    methodKind: "bidi_streaming";
    input: typeof AuthenticateDeviceRequestSchema;
    output: typeof AuthenticateDeviceResponseSchema;
  },
  /**
   * ConfirmDeviceWebAuthentication finalizes the device web authentication
   * ceremony started by the creation of a DeviceWebToken and subsequent
   * AuthenticateDevice call.
   *
   * The DeviceConfirmationToken issued by AuthenticateDevice is spent in this
   * method, which consequently augments the corresponding Web Session
   * certificates with device extensions.
   *
   * This method must be called by the Teleport Proxy, and the Proxy itself must
   * be called by the same browser that started the on-behalf-of authentication
   * attempt. See the /webapi/device/webconfirm endpoint.
   *
   * See
   * https://github.com/gravitational/teleport.e/blob/master/rfd/0009e-device-trust-web-support.md#device-web-authentication.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.ConfirmDeviceWebAuthentication
   */
  confirmDeviceWebAuthentication: {
    methodKind: "unary";
    input: typeof ConfirmDeviceWebAuthenticationRequestSchema;
    output: typeof ConfirmDeviceWebAuthenticationResponseSchema;
  },
  /**
   * Syncs device inventory from a source exterior to Teleport, for example an
   * MDM.
   * Allows both partial and full syncs; for the latter, devices missing from
   * the external inventory are handled as specified.
   * Authorized either by a valid MDM service certificate or the appropriate
   * "device" permissions (create/update/delete).
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.SyncInventory
   */
  syncInventory: {
    methodKind: "bidi_streaming";
    input: typeof SyncInventoryRequestSchema;
    output: typeof SyncInventoryResponseSchema;
  },
  /**
   * Superseded by ResourceUsageService.GetUsage.
   *
   * @generated from rpc teleport.devicetrust.v1.DeviceTrustService.GetDevicesUsage
   * @deprecated
   */
  getDevicesUsage: {
    methodKind: "unary";
    input: typeof GetDevicesUsageRequestSchema;
    output: typeof DevicesUsageSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_teleport_devicetrust_v1_devicetrust_service, 0);

