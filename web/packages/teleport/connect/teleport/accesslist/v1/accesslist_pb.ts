// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/accesslist/v1/accesslist.proto (package teleport.accesslist.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ResourceHeader } from "../../header/v1/resourceheader_pb";
import { file_teleport_header_v1_resourceheader } from "../../header/v1/resourceheader_pb";
import type { Trait } from "../../trait/v1/trait_pb";
import { file_teleport_trait_v1_trait } from "../../trait/v1/trait_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/accesslist/v1/accesslist.proto.
 */
export const file_teleport_accesslist_v1_accesslist: GenFile = /*@__PURE__*/
  fileDesc("Cid0ZWxlcG9ydC9hY2Nlc3NsaXN0L3YxL2FjY2Vzc2xpc3QucHJvdG8SFnRlbGVwb3J0LmFjY2Vzc2xpc3QudjEisAEKCkFjY2Vzc0xpc3QSMgoGaGVhZGVyGAEgASgLMiIudGVsZXBvcnQuaGVhZGVyLnYxLlJlc291cmNlSGVhZGVyEjQKBHNwZWMYAiABKAsyJi50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLkFjY2Vzc0xpc3RTcGVjEjgKBnN0YXR1cxgDIAEoCzIoLnRlbGVwb3J0LmFjY2Vzc2xpc3QudjEuQWNjZXNzTGlzdFN0YXR1cyLiAwoOQWNjZXNzTGlzdFNwZWMSEwoLZGVzY3JpcHRpb24YASABKAkSNwoGb3duZXJzGAIgAygLMicudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5BY2Nlc3NMaXN0T3duZXISNgoFYXVkaXQYAyABKAsyJy50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLkFjY2Vzc0xpc3RBdWRpdBJHChNtZW1iZXJzaGlwX3JlcXVpcmVzGAQgASgLMioudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5BY2Nlc3NMaXN0UmVxdWlyZXMSRgoSb3duZXJzaGlwX3JlcXVpcmVzGAUgASgLMioudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5BY2Nlc3NMaXN0UmVxdWlyZXMSOAoGZ3JhbnRzGAYgASgLMigudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5BY2Nlc3NMaXN0R3JhbnRzEg0KBXRpdGxlGAggASgJEj4KDG93bmVyX2dyYW50cxgLIAEoCzIoLnRlbGVwb3J0LmFjY2Vzc2xpc3QudjEuQWNjZXNzTGlzdEdyYW50c0oECAcQCEoECAkQCkoECAoQC1IHbWVtYmVyc1IKbWVtYmVyc2hpcFIJb3duZXJzaGlwInkKD0FjY2Vzc0xpc3RPd25lchIMCgRuYW1lGAEgASgJEhMKC2Rlc2NyaXB0aW9uGAIgASgJEkMKEWluZWxpZ2libGVfc3RhdHVzGAMgASgOMigudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5JbmVsaWdpYmxlU3RhdHVzIs0BCg9BY2Nlc3NMaXN0QXVkaXQSMwoPbmV4dF9hdWRpdF9kYXRlGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI2CgpyZWN1cnJlbmNlGAMgASgLMiIudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5SZWN1cnJlbmNlEjwKDW5vdGlmaWNhdGlvbnMYBCABKAsyJS50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLk5vdGlmaWNhdGlvbnNKBAgBEAJSCWZyZXF1ZW5jeSKIAQoKUmVjdXJyZW5jZRI6CglmcmVxdWVuY3kYASABKA4yJy50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLlJldmlld0ZyZXF1ZW5jeRI+CgxkYXlfb2ZfbW9udGgYAiABKA4yKC50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLlJldmlld0RheU9mTW9udGgiOQoNTm90aWZpY2F0aW9ucxIoCgVzdGFydBgBIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiJNChJBY2Nlc3NMaXN0UmVxdWlyZXMSDQoFcm9sZXMYASADKAkSKAoGdHJhaXRzGAIgAygLMhgudGVsZXBvcnQudHJhaXQudjEuVHJhaXQiSwoQQWNjZXNzTGlzdEdyYW50cxINCgVyb2xlcxgBIAMoCRIoCgZ0cmFpdHMYAiADKAsyGC50ZWxlcG9ydC50cmFpdC52MS5UcmFpdCJuCgZNZW1iZXISMgoGaGVhZGVyGAEgASgLMiIudGVsZXBvcnQuaGVhZGVyLnYxLlJlc291cmNlSGVhZGVyEjAKBHNwZWMYAiABKAsyIi50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLk1lbWJlclNwZWMigQIKCk1lbWJlclNwZWMSEwoLYWNjZXNzX2xpc3QYASABKAkSDAoEbmFtZRgCIAEoCRIqCgZqb2luZWQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEisKB2V4cGlyZXMYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg4KBnJlYXNvbhgFIAEoCRIQCghhZGRlZF9ieRgGIAEoCRJDChFpbmVsaWdpYmxlX3N0YXR1cxgHIAEoDjIoLnRlbGVwb3J0LmFjY2Vzc2xpc3QudjEuSW5lbGlnaWJsZVN0YXR1c0oECAgQCVIKbWVtYmVyc2hpcCJuCgZSZXZpZXcSMgoGaGVhZGVyGAEgASgLMiIudGVsZXBvcnQuaGVhZGVyLnYxLlJlc291cmNlSGVhZGVyEjAKBHNwZWMYAiABKAsyIi50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLlJldmlld1NwZWMirAEKClJldmlld1NwZWMSEwoLYWNjZXNzX2xpc3QYASABKAkSEQoJcmV2aWV3ZXJzGAIgAygJEi8KC3Jldmlld19kYXRlGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBINCgVub3RlcxgEIAEoCRI2CgdjaGFuZ2VzGAUgASgLMiUudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5SZXZpZXdDaGFuZ2VzIrACCg1SZXZpZXdDaGFuZ2VzElMKH21lbWJlcnNoaXBfcmVxdWlyZW1lbnRzX2NoYW5nZWQYAiABKAsyKi50ZWxlcG9ydC5hY2Nlc3NsaXN0LnYxLkFjY2Vzc0xpc3RSZXF1aXJlcxIXCg9yZW1vdmVkX21lbWJlcnMYAyADKAkSSQoYcmV2aWV3X2ZyZXF1ZW5jeV9jaGFuZ2VkGAQgASgOMicudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5SZXZpZXdGcmVxdWVuY3kSTQobcmV2aWV3X2RheV9vZl9tb250aF9jaGFuZ2VkGAUgASgOMigudGVsZXBvcnQuYWNjZXNzbGlzdC52MS5SZXZpZXdEYXlPZk1vbnRoSgQIARACUhFmcmVxdWVuY3lfY2hhbmdlZCI+ChBBY2Nlc3NMaXN0U3RhdHVzEhkKDG1lbWJlcl9jb3VudBgBIAEoDUgAiAEBQg8KDV9tZW1iZXJfY291bnQqtgEKD1Jldmlld0ZyZXF1ZW5jeRIgChxSRVZJRVdfRlJFUVVFTkNZX1VOU1BFQ0lGSUVEEAASHgoaUkVWSUVXX0ZSRVFVRU5DWV9PTkVfTU9OVEgQARIhCh1SRVZJRVdfRlJFUVVFTkNZX1RIUkVFX01PTlRIUxADEh8KG1JFVklFV19GUkVRVUVOQ1lfU0lYX01PTlRIUxAGEh0KGVJFVklFV19GUkVRVUVOQ1lfT05FX1lFQVIQDCqXAQoQUmV2aWV3RGF5T2ZNb250aBIjCh9SRVZJRVdfREFZX09GX01PTlRIX1VOU1BFQ0lGSUVEEAASHQoZUkVWSUVXX0RBWV9PRl9NT05USF9GSVJTVBABEiEKHVJFVklFV19EQVlfT0ZfTU9OVEhfRklGVEVFTlRIEA8SHAoYUkVWSUVXX0RBWV9PRl9NT05USF9MQVNUEB8qxgEKEEluZWxpZ2libGVTdGF0dXMSIQodSU5FTElHSUJMRV9TVEFUVVNfVU5TUEVDSUZJRUQQABIeChpJTkVMSUdJQkxFX1NUQVRVU19FTElHSUJMRRABEiQKIElORUxJR0lCTEVfU1RBVFVTX1VTRVJfTk9UX0VYSVNUEAISKgomSU5FTElHSUJMRV9TVEFUVVNfTUlTU0lOR19SRVFVSVJFTUVOVFMQAxIdChlJTkVMSUdJQkxFX1NUQVRVU19FWFBJUkVEEARCWFpWZ2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS9nZW4vcHJvdG8vZ28vdGVsZXBvcnQvYWNjZXNzbGlzdC92MTthY2Nlc3NsaXN0djFiBnByb3RvMw", [file_google_protobuf_duration, file_google_protobuf_timestamp, file_teleport_header_v1_resourceheader, file_teleport_trait_v1_trait]);

/**
 * AccessList describes the basic building block of access grants, which are
 * similar to access requests but for longer lived permissions that need to be
 * regularly audited.
 *
 * @generated from message teleport.accesslist.v1.AccessList
 */
export type AccessList = Message<"teleport.accesslist.v1.AccessList"> & {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListSpec spec = 2;
   */
  spec?: AccessListSpec;

  /**
   * status contains dynamically calculated fields.
   *
   * @generated from field: teleport.accesslist.v1.AccessListStatus status = 3;
   */
  status?: AccessListStatus;
};

/**
 * Describes the message teleport.accesslist.v1.AccessList.
 * Use `create(AccessListSchema)` to create a new message.
 */
export const AccessListSchema: GenMessage<AccessList> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 0);

/**
 * AccessListSpec is the specification for an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListSpec
 */
export type AccessListSpec = Message<"teleport.accesslist.v1.AccessListSpec"> & {
  /**
   * description is an optional plaintext description of the access list.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * owners is a list of owners of the access list.
   *
   * @generated from field: repeated teleport.accesslist.v1.AccessListOwner owners = 2;
   */
  owners: AccessListOwner[];

  /**
   * audit describes the frequency that this access list must be audited.
   *
   * @generated from field: teleport.accesslist.v1.AccessListAudit audit = 3;
   */
  audit?: AccessListAudit;

  /**
   * membership_requires describes the requirements for a user to be a member of
   * the access list. For a membership to an access list to be effective, the
   * user must meet the requirements of Membership_requires and must be in the
   * members list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires membership_requires = 4;
   */
  membershipRequires?: AccessListRequires;

  /**
   * ownership_requires describes the requirements for a user to be an owner of
   * the access list. For ownership of an access list to be effective, the user
   * must meet the requirements of ownership_requires and must be in the owners
   * list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires ownership_requires = 5;
   */
  ownershipRequires?: AccessListRequires;

  /**
   * grants describes the access granted by membership to this access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListGrants grants = 6;
   */
  grants?: AccessListGrants;

  /**
   * title is a plaintext short description of the access list.
   *
   * @generated from field: string title = 8;
   */
  title: string;

  /**
   * owner_grants describes the access granted by owners to this access list.
   *
   * @generated from field: teleport.accesslist.v1.AccessListGrants owner_grants = 11;
   */
  ownerGrants?: AccessListGrants;
};

/**
 * Describes the message teleport.accesslist.v1.AccessListSpec.
 * Use `create(AccessListSpecSchema)` to create a new message.
 */
export const AccessListSpecSchema: GenMessage<AccessListSpec> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 1);

/**
 * AccessListOwner is an owner of an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListOwner
 */
export type AccessListOwner = Message<"teleport.accesslist.v1.AccessListOwner"> & {
  /**
   * name is the username of the owner.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * description is the plaintext description of the owner and why they are an
   * owner.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * ineligible_status describes if this owner is eligible or not
   * and if not, describes how they're lacking eligibility.
   *
   * @generated from field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 3;
   */
  ineligibleStatus: IneligibleStatus;
};

/**
 * Describes the message teleport.accesslist.v1.AccessListOwner.
 * Use `create(AccessListOwnerSchema)` to create a new message.
 */
export const AccessListOwnerSchema: GenMessage<AccessListOwner> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 2);

/**
 * AccessListAudit describes the audit configuration for an access list.
 *
 * @generated from message teleport.accesslist.v1.AccessListAudit
 */
export type AccessListAudit = Message<"teleport.accesslist.v1.AccessListAudit"> & {
  /**
   * next_audit_date is when the next audit date should be done by.
   *
   * @generated from field: google.protobuf.Timestamp next_audit_date = 2;
   */
  nextAuditDate?: Timestamp;

  /**
   * recurrence is the recurrence definition
   *
   * @generated from field: teleport.accesslist.v1.Recurrence recurrence = 3;
   */
  recurrence?: Recurrence;

  /**
   * notifications is the configuration for notifying users.
   *
   * @generated from field: teleport.accesslist.v1.Notifications notifications = 4;
   */
  notifications?: Notifications;
};

/**
 * Describes the message teleport.accesslist.v1.AccessListAudit.
 * Use `create(AccessListAuditSchema)` to create a new message.
 */
export const AccessListAuditSchema: GenMessage<AccessListAudit> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 3);

/**
 * Recurrence is the definition for when reviews will be scheduled.
 *
 * @generated from message teleport.accesslist.v1.Recurrence
 */
export type Recurrence = Message<"teleport.accesslist.v1.Recurrence"> & {
  /**
   * frequency is the frequency of reviews. This represents the period in months
   * between two reviews.
   * Supported values are 0, 1, 3, 6, and 12.
   *
   * @generated from field: teleport.accesslist.v1.ReviewFrequency frequency = 1;
   */
  frequency: ReviewFrequency;

  /**
   * day_of_month is the day of month that reviews will be scheduled on.
   * Supported values are 0, 1, 15, and 31.
   *
   * @generated from field: teleport.accesslist.v1.ReviewDayOfMonth day_of_month = 2;
   */
  dayOfMonth: ReviewDayOfMonth;
};

/**
 * Describes the message teleport.accesslist.v1.Recurrence.
 * Use `create(RecurrenceSchema)` to create a new message.
 */
export const RecurrenceSchema: GenMessage<Recurrence> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 4);

/**
 * Notifications contains the configuration for notifying users of a nearing
 * next audit date.
 *
 * @generated from message teleport.accesslist.v1.Notifications
 */
export type Notifications = Message<"teleport.accesslist.v1.Notifications"> & {
  /**
   * start specifies when to start notifying users that the next audit date is
   * coming up.
   *
   * @generated from field: google.protobuf.Duration start = 1;
   */
  start?: Duration;
};

/**
 * Describes the message teleport.accesslist.v1.Notifications.
 * Use `create(NotificationsSchema)` to create a new message.
 */
export const NotificationsSchema: GenMessage<Notifications> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 5);

/**
 * AccessListRequires describes a requirement section for an access list. A user
 * must meet the following criteria to obtain the specific access to the list.
 *
 * @generated from message teleport.accesslist.v1.AccessListRequires
 */
export type AccessListRequires = Message<"teleport.accesslist.v1.AccessListRequires"> & {
  /**
   * roles are the user roles that must be present for the user to obtain
   * access.
   *
   * @generated from field: repeated string roles = 1;
   */
  roles: string[];

  /**
   * traits are the traits that must be present for the user to obtain access.
   *
   * @generated from field: repeated teleport.trait.v1.Trait traits = 2;
   */
  traits: Trait[];
};

/**
 * Describes the message teleport.accesslist.v1.AccessListRequires.
 * Use `create(AccessListRequiresSchema)` to create a new message.
 */
export const AccessListRequiresSchema: GenMessage<AccessListRequires> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 6);

/**
 * AccessListGrants describes what access is granted by membership to the access
 * list.
 *
 * @generated from message teleport.accesslist.v1.AccessListGrants
 */
export type AccessListGrants = Message<"teleport.accesslist.v1.AccessListGrants"> & {
  /**
   * roles are the roles that are granted to users who are members of the access
   * list.
   *
   * @generated from field: repeated string roles = 1;
   */
  roles: string[];

  /**
   * traits are the traits that are granted to users who are members of the
   * access list.
   *
   * @generated from field: repeated teleport.trait.v1.Trait traits = 2;
   */
  traits: Trait[];
};

/**
 * Describes the message teleport.accesslist.v1.AccessListGrants.
 * Use `create(AccessListGrantsSchema)` to create a new message.
 */
export const AccessListGrantsSchema: GenMessage<AccessListGrants> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 7);

/**
 * Member describes a member of an access list.
 *
 * @generated from message teleport.accesslist.v1.Member
 */
export type Member = Message<"teleport.accesslist.v1.Member"> & {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list member.
   *
   * @generated from field: teleport.accesslist.v1.MemberSpec spec = 2;
   */
  spec?: MemberSpec;
};

/**
 * Describes the message teleport.accesslist.v1.Member.
 * Use `create(MemberSchema)` to create a new message.
 */
export const MemberSchema: GenMessage<Member> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 8);

/**
 * MemberSpec is the specification for an access list member.
 *
 * @generated from message teleport.accesslist.v1.MemberSpec
 */
export type MemberSpec = Message<"teleport.accesslist.v1.MemberSpec"> & {
  /**
   * associated access list
   *
   * @generated from field: string access_list = 1;
   */
  accessList: string;

  /**
   * name is the name of the member of the access list.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * joined is when the user joined the access list.
   *
   * @generated from field: google.protobuf.Timestamp joined = 3;
   */
  joined?: Timestamp;

  /**
   * expires is when the user's membership to the access list expires.
   *
   * @generated from field: google.protobuf.Timestamp expires = 4;
   */
  expires?: Timestamp;

  /**
   * reason is the reason this user was added to the access list.
   *
   * @generated from field: string reason = 5;
   */
  reason: string;

  /**
   * added_by is the user that added this user to the access list.
   *
   * @generated from field: string added_by = 6;
   */
  addedBy: string;

  /**
   * ineligible_status describes if this member is eligible or not
   * and if not, describes how they're lacking eligibility.
   *
   * @generated from field: teleport.accesslist.v1.IneligibleStatus ineligible_status = 7;
   */
  ineligibleStatus: IneligibleStatus;
};

/**
 * Describes the message teleport.accesslist.v1.MemberSpec.
 * Use `create(MemberSpecSchema)` to create a new message.
 */
export const MemberSpecSchema: GenMessage<MemberSpec> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 9);

/**
 * Review is a review of an access list.
 *
 * @generated from message teleport.accesslist.v1.Review
 */
export type Review = Message<"teleport.accesslist.v1.Review"> & {
  /**
   * header is the header for the resource.
   *
   * @generated from field: teleport.header.v1.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * spec is the specification for the access list review.
   *
   * @generated from field: teleport.accesslist.v1.ReviewSpec spec = 2;
   */
  spec?: ReviewSpec;
};

/**
 * Describes the message teleport.accesslist.v1.Review.
 * Use `create(ReviewSchema)` to create a new message.
 */
export const ReviewSchema: GenMessage<Review> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 10);

/**
 * ReviewSpec is the specification for an access list review.
 *
 * @generated from message teleport.accesslist.v1.ReviewSpec
 */
export type ReviewSpec = Message<"teleport.accesslist.v1.ReviewSpec"> & {
  /**
   * access_list is the name of the access list that this review is for.
   *
   * @generated from field: string access_list = 1;
   */
  accessList: string;

  /**
   * reviewers are the users who performed the review.
   *
   * @generated from field: repeated string reviewers = 2;
   */
  reviewers: string[];

  /**
   * review_date is the date that this review was created.
   *
   * @generated from field: google.protobuf.Timestamp review_date = 3;
   */
  reviewDate?: Timestamp;

  /**
   * notes is an optional plaintext attached to the review that can be used by
   * the review for arbitrary note taking on the review.
   *
   * @generated from field: string notes = 4;
   */
  notes: string;

  /**
   * changes are the changes made as part of the review.
   *
   * @generated from field: teleport.accesslist.v1.ReviewChanges changes = 5;
   */
  changes?: ReviewChanges;
};

/**
 * Describes the message teleport.accesslist.v1.ReviewSpec.
 * Use `create(ReviewSpecSchema)` to create a new message.
 */
export const ReviewSpecSchema: GenMessage<ReviewSpec> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 11);

/**
 * ReviewChanges are the changes that were made as part of the review.
 *
 * @generated from message teleport.accesslist.v1.ReviewChanges
 */
export type ReviewChanges = Message<"teleport.accesslist.v1.ReviewChanges"> & {
  /**
   * membership_requirements_changed is populated if the requirements were
   * changed as part of this review.
   *
   * @generated from field: teleport.accesslist.v1.AccessListRequires membership_requirements_changed = 2;
   */
  membershipRequirementsChanged?: AccessListRequires;

  /**
   * removed_members contains the members that were removed as part of this
   * review.
   *
   * @generated from field: repeated string removed_members = 3;
   */
  removedMembers: string[];

  /**
   * review_frequency_changed is populated if the review frequency has changed.
   *
   * @generated from field: teleport.accesslist.v1.ReviewFrequency review_frequency_changed = 4;
   */
  reviewFrequencyChanged: ReviewFrequency;

  /**
   * review_day_of_month_changed is populated if the review day of month has
   * changed.
   *
   * @generated from field: teleport.accesslist.v1.ReviewDayOfMonth review_day_of_month_changed = 5;
   */
  reviewDayOfMonthChanged: ReviewDayOfMonth;
};

/**
 * Describes the message teleport.accesslist.v1.ReviewChanges.
 * Use `create(ReviewChangesSchema)` to create a new message.
 */
export const ReviewChangesSchema: GenMessage<ReviewChanges> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 12);

/**
 * AccessListStatus contains dynamic fields calculated during retrieval.
 *
 * @generated from message teleport.accesslist.v1.AccessListStatus
 */
export type AccessListStatus = Message<"teleport.accesslist.v1.AccessListStatus"> & {
  /**
   * member_count is the number of members in the in the access list.
   *
   * @generated from field: optional uint32 member_count = 1;
   */
  memberCount?: number;
};

/**
 * Describes the message teleport.accesslist.v1.AccessListStatus.
 * Use `create(AccessListStatusSchema)` to create a new message.
 */
export const AccessListStatusSchema: GenMessage<AccessListStatus> = /*@__PURE__*/
  messageDesc(file_teleport_accesslist_v1_accesslist, 13);

/**
 * ReviewFrequency is the frequency of reviews.
 *
 * @generated from enum teleport.accesslist.v1.ReviewFrequency
 */
export enum ReviewFrequency {
  /**
   * @generated from enum value: REVIEW_FREQUENCY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_ONE_MONTH = 1;
   */
  ONE_MONTH = 1,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_THREE_MONTHS = 3;
   */
  THREE_MONTHS = 3,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_SIX_MONTHS = 6;
   */
  SIX_MONTHS = 6,

  /**
   * @generated from enum value: REVIEW_FREQUENCY_ONE_YEAR = 12;
   */
  ONE_YEAR = 12,
}

/**
 * Describes the enum teleport.accesslist.v1.ReviewFrequency.
 */
export const ReviewFrequencySchema: GenEnum<ReviewFrequency> = /*@__PURE__*/
  enumDesc(file_teleport_accesslist_v1_accesslist, 0);

/**
 * ReviewDayOfMonth is the day of month that reviews will repeat on.
 *
 * @generated from enum teleport.accesslist.v1.ReviewDayOfMonth
 */
export enum ReviewDayOfMonth {
  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_FIRST = 1;
   */
  FIRST = 1,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_FIFTEENTH = 15;
   */
  FIFTEENTH = 15,

  /**
   * @generated from enum value: REVIEW_DAY_OF_MONTH_LAST = 31;
   */
  LAST = 31,
}

/**
 * Describes the enum teleport.accesslist.v1.ReviewDayOfMonth.
 */
export const ReviewDayOfMonthSchema: GenEnum<ReviewDayOfMonth> = /*@__PURE__*/
  enumDesc(file_teleport_accesslist_v1_accesslist, 1);

/**
 * IneligibleStatus describes how the user is ineligible.
 *
 * @generated from enum teleport.accesslist.v1.IneligibleStatus
 */
export enum IneligibleStatus {
  /**
   * INELIGIBLE_STATUS_UNSPECIFIED means eligiblity is unknown.
   *
   * @generated from enum value: INELIGIBLE_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * INELIGIBLE_STATUS_ELIGIBLE means checks were done and user met all
   * requirements.
   *
   * @generated from enum value: INELIGIBLE_STATUS_ELIGIBLE = 1;
   */
  ELIGIBLE = 1,

  /**
   * INELIGIBLE_STATUS_USER_NOT_EXIST means user was not found in backend.
   *
   * @generated from enum value: INELIGIBLE_STATUS_USER_NOT_EXIST = 2;
   */
  USER_NOT_EXIST = 2,

  /**
   * INELIGIBLE_STATUS_MISSING_REQUIREMENTS means user is missing some
   * requirements defined by AccessListRequires (fields can be either
   * ownership_requires or membership_requires)
   *
   * @generated from enum value: INELIGIBLE_STATUS_MISSING_REQUIREMENTS = 3;
   */
  MISSING_REQUIREMENTS = 3,

  /**
   * INELIGIBLE_STATUS_EXPIRED means user is expired.
   * Only applicable to members.
   *
   * @generated from enum value: INELIGIBLE_STATUS_EXPIRED = 4;
   */
  EXPIRED = 4,
}

/**
 * Describes the enum teleport.accesslist.v1.IneligibleStatus.
 */
export const IneligibleStatusSchema: GenEnum<IneligibleStatus> = /*@__PURE__*/
  enumDesc(file_teleport_accesslist_v1_accesslist, 2);

