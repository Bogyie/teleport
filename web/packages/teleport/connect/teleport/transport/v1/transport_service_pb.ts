// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/transport/v1/transport_service.proto (package teleport.transport.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/transport/v1/transport_service.proto.
 */
export const file_teleport_transport_v1_transport_service: GenFile = /*@__PURE__*/
  fileDesc("Ci10ZWxlcG9ydC90cmFuc3BvcnQvdjEvdHJhbnNwb3J0X3NlcnZpY2UucHJvdG8SFXRlbGVwb3J0LnRyYW5zcG9ydC52MSKuAQoPUHJveHlTU0hSZXF1ZXN0EjYKC2RpYWxfdGFyZ2V0GAEgASgLMiEudGVsZXBvcnQudHJhbnNwb3J0LnYxLlRhcmdldEhvc3QSKwoDc3NoGAIgASgLMhwudGVsZXBvcnQudHJhbnNwb3J0LnYxLkZyYW1lSAASLQoFYWdlbnQYAyABKAsyHC50ZWxlcG9ydC50cmFuc3BvcnQudjEuRnJhbWVIAEIHCgVmcmFtZSKvAQoQUHJveHlTU0hSZXNwb25zZRI2CgdkZXRhaWxzGAEgASgLMiUudGVsZXBvcnQudHJhbnNwb3J0LnYxLkNsdXN0ZXJEZXRhaWxzEisKA3NzaBgCIAEoCzIcLnRlbGVwb3J0LnRyYW5zcG9ydC52MS5GcmFtZUgAEi0KBWFnZW50GAMgASgLMhwudGVsZXBvcnQudHJhbnNwb3J0LnYxLkZyYW1lSABCBwoFZnJhbWUiUwoTUHJveHlDbHVzdGVyUmVxdWVzdBIPCgdjbHVzdGVyGAEgASgJEisKBWZyYW1lGAIgASgLMhwudGVsZXBvcnQudHJhbnNwb3J0LnYxLkZyYW1lIkMKFFByb3h5Q2x1c3RlclJlc3BvbnNlEisKBWZyYW1lGAEgASgLMhwudGVsZXBvcnQudHJhbnNwb3J0LnYxLkZyYW1lIhgKBUZyYW1lEg8KB3BheWxvYWQYASABKAwiMAoKVGFyZ2V0SG9zdBIRCglob3N0X3BvcnQYASABKAkSDwoHY2x1c3RlchgCIAEoCSIaChhHZXRDbHVzdGVyRGV0YWlsc1JlcXVlc3QiUwoZR2V0Q2x1c3RlckRldGFpbHNSZXNwb25zZRI2CgdkZXRhaWxzGAEgASgLMiUudGVsZXBvcnQudHJhbnNwb3J0LnYxLkNsdXN0ZXJEZXRhaWxzIiYKDkNsdXN0ZXJEZXRhaWxzEhQKDGZpcHNfZW5hYmxlZBgBIAEoCDLYAgoQVHJhbnNwb3J0U2VydmljZRJ2ChFHZXRDbHVzdGVyRGV0YWlscxIvLnRlbGVwb3J0LnRyYW5zcG9ydC52MS5HZXRDbHVzdGVyRGV0YWlsc1JlcXVlc3QaMC50ZWxlcG9ydC50cmFuc3BvcnQudjEuR2V0Q2x1c3RlckRldGFpbHNSZXNwb25zZRJfCghQcm94eVNTSBImLnRlbGVwb3J0LnRyYW5zcG9ydC52MS5Qcm94eVNTSFJlcXVlc3QaJy50ZWxlcG9ydC50cmFuc3BvcnQudjEuUHJveHlTU0hSZXNwb25zZSgBMAESawoMUHJveHlDbHVzdGVyEioudGVsZXBvcnQudHJhbnNwb3J0LnYxLlByb3h5Q2x1c3RlclJlcXVlc3QaKy50ZWxlcG9ydC50cmFuc3BvcnQudjEuUHJveHlDbHVzdGVyUmVzcG9uc2UoATABQlZaVGdpdGh1Yi5jb20vZ3Jhdml0YXRpb25hbC90ZWxlcG9ydC9hcGkvZ2VuL3Byb3RvL2dvL3RlbGVwb3J0L3RyYW5zcG9ydC92MTt0cmFuc3BvcnR2MWIGcHJvdG8z");

/**
 * Request for ProxySSH
 *
 * In order for proxying to begin the client must send a request with the
 * TargetHost populated. Creating the stream doesn't actually open the SSH connection.
 * Any attempts to exchange frames prior to the client sending a TargetHost message will
 * result in the stream being terminated.
 *
 * @generated from message teleport.transport.v1.ProxySSHRequest
 */
export type ProxySSHRequest = Message<"teleport.transport.v1.ProxySSHRequest"> & {
  /**
   * Contains the information required to dial the target.
   * Must be populated on the initial request so that SSH connection can be established.
   *
   * @generated from field: teleport.transport.v1.TargetHost dial_target = 1;
   */
  dialTarget?: TargetHost;

  /**
   * Payload from SSH/SSH Agent Protocols
   *
   * @generated from oneof teleport.transport.v1.ProxySSHRequest.frame
   */
  frame: {
    /**
     * Raw SSH payload
     *
     * @generated from field: teleport.transport.v1.Frame ssh = 2;
     */
    value: Frame;
    case: "ssh";
  } | {
    /**
     * Raw SSH Agent payload, populated for agent forwarding
     *
     * @generated from field: teleport.transport.v1.Frame agent = 3;
     */
    value: Frame;
    case: "agent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.transport.v1.ProxySSHRequest.
 * Use `create(ProxySSHRequestSchema)` to create a new message.
 */
export const ProxySSHRequestSchema: GenMessage<ProxySSHRequest> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 0);

/**
 * Response for ProxySSH
 *
 * The first response from the server will contain ClusterDetails
 * so that clients may get information about a particular cluster
 * without needing to call GetClusterDetails first. All subsequent
 * response will only contain Frames.
 *
 * @generated from message teleport.transport.v1.ProxySSHResponse
 */
export type ProxySSHResponse = Message<"teleport.transport.v1.ProxySSHResponse"> & {
  /**
   * Cluster information returned *ONLY* with the first frame
   *
   * @generated from field: teleport.transport.v1.ClusterDetails details = 1;
   */
  details?: ClusterDetails;

  /**
   * Payload from SSH/SSH Agent Protocols
   *
   * @generated from oneof teleport.transport.v1.ProxySSHResponse.frame
   */
  frame: {
    /**
     * SSH payload
     *
     * @generated from field: teleport.transport.v1.Frame ssh = 2;
     */
    value: Frame;
    case: "ssh";
  } | {
    /**
     * SSH Agent payload, populated for agent forwarding
     *
     * @generated from field: teleport.transport.v1.Frame agent = 3;
     */
    value: Frame;
    case: "agent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.transport.v1.ProxySSHResponse.
 * Use `create(ProxySSHResponseSchema)` to create a new message.
 */
export const ProxySSHResponseSchema: GenMessage<ProxySSHResponse> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 1);

/**
 * Request for ProxyCluster
 *
 * In order for proxying to begin the client must send a request with the
 * cluster name populated. Creating the stream doesn't actually open the connection.
 * Any attempts to exchange frames prior to the client sending a cluster name will
 * result in the stream being terminated. All subsequent messages only need to
 * provide a Frame.
 *
 * @generated from message teleport.transport.v1.ProxyClusterRequest
 */
export type ProxyClusterRequest = Message<"teleport.transport.v1.ProxyClusterRequest"> & {
  /**
   * Name of the cluster to connect to. Must
   * be sent first so the connection can be established.
   *
   * @generated from field: string cluster = 1;
   */
  cluster: string;

  /**
   * Raw payload
   *
   * @generated from field: teleport.transport.v1.Frame frame = 2;
   */
  frame?: Frame;
};

/**
 * Describes the message teleport.transport.v1.ProxyClusterRequest.
 * Use `create(ProxyClusterRequestSchema)` to create a new message.
 */
export const ProxyClusterRequestSchema: GenMessage<ProxyClusterRequest> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 2);

/**
 * Response for ProxyCluster
 *
 * @generated from message teleport.transport.v1.ProxyClusterResponse
 */
export type ProxyClusterResponse = Message<"teleport.transport.v1.ProxyClusterResponse"> & {
  /**
   * Raw payload
   *
   * @generated from field: teleport.transport.v1.Frame frame = 1;
   */
  frame?: Frame;
};

/**
 * Describes the message teleport.transport.v1.ProxyClusterResponse.
 * Use `create(ProxyClusterResponseSchema)` to create a new message.
 */
export const ProxyClusterResponseSchema: GenMessage<ProxyClusterResponse> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 3);

/**
 * Encapsulates protocol specific payloads
 *
 * @generated from message teleport.transport.v1.Frame
 */
export type Frame = Message<"teleport.transport.v1.Frame"> & {
  /**
   * The raw packet of data
   *
   * @generated from field: bytes payload = 1;
   */
  payload: Uint8Array;
};

/**
 * Describes the message teleport.transport.v1.Frame.
 * Use `create(FrameSchema)` to create a new message.
 */
export const FrameSchema: GenMessage<Frame> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 4);

/**
 * TargetHost indicates which server the connection is for
 *
 * @generated from message teleport.transport.v1.TargetHost
 */
export type TargetHost = Message<"teleport.transport.v1.TargetHost"> & {
  /**
   * The hostname/ip/uuid:port of the remote host.
   *
   * @generated from field: string host_port = 1;
   */
  hostPort: string;

  /**
   * The cluster the server is a member of
   *
   * @generated from field: string cluster = 2;
   */
  cluster: string;
};

/**
 * Describes the message teleport.transport.v1.TargetHost.
 * Use `create(TargetHostSchema)` to create a new message.
 */
export const TargetHostSchema: GenMessage<TargetHost> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 5);

/**
 * Request for GetClusterDetails.
 *
 * @generated from message teleport.transport.v1.GetClusterDetailsRequest
 */
export type GetClusterDetailsRequest = Message<"teleport.transport.v1.GetClusterDetailsRequest"> & {
};

/**
 * Describes the message teleport.transport.v1.GetClusterDetailsRequest.
 * Use `create(GetClusterDetailsRequestSchema)` to create a new message.
 */
export const GetClusterDetailsRequestSchema: GenMessage<GetClusterDetailsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 6);

/**
 * Response for GetClusterDetails.
 *
 * @generated from message teleport.transport.v1.GetClusterDetailsResponse
 */
export type GetClusterDetailsResponse = Message<"teleport.transport.v1.GetClusterDetailsResponse"> & {
  /**
   * Cluster configuration details
   *
   * @generated from field: teleport.transport.v1.ClusterDetails details = 1;
   */
  details?: ClusterDetails;
};

/**
 * Describes the message teleport.transport.v1.GetClusterDetailsResponse.
 * Use `create(GetClusterDetailsResponseSchema)` to create a new message.
 */
export const GetClusterDetailsResponseSchema: GenMessage<GetClusterDetailsResponse> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 7);

/**
 * ClusterDetails contains cluster configuration information
 *
 * @generated from message teleport.transport.v1.ClusterDetails
 */
export type ClusterDetails = Message<"teleport.transport.v1.ClusterDetails"> & {
  /**
   * If the cluster is running in FIPS mode
   *
   * @generated from field: bool fips_enabled = 1;
   */
  fipsEnabled: boolean;
};

/**
 * Describes the message teleport.transport.v1.ClusterDetails.
 * Use `create(ClusterDetailsSchema)` to create a new message.
 */
export const ClusterDetailsSchema: GenMessage<ClusterDetails> = /*@__PURE__*/
  messageDesc(file_teleport_transport_v1_transport_service, 8);

/**
 * TransportService provides methods to proxy connections to various Teleport instances.
 *
 * All connections are operate on top of a bidirectional stream which transports
 * raw payloads from higher level protocols (i.e. SSH). Clients must send an initial
 * message on the stream to set up the connections accordingly. After the initial
 * request either side may freely send data in any order until the stream is terminated.
 *
 * @generated from service teleport.transport.v1.TransportService
 */
export const TransportService: GenService<{
  /**
   * GetClusterDetails provides cluster information that may affect how transport
   * should occur.
   *
   * @generated from rpc teleport.transport.v1.TransportService.GetClusterDetails
   */
  getClusterDetails: {
    methodKind: "unary";
    input: typeof GetClusterDetailsRequestSchema;
    output: typeof GetClusterDetailsResponseSchema;
  },
  /**
   * ProxySSH establishes an SSH connection to the target host over a bidirectional stream.
   *
   * The client must first send a DialTarget before the connection is established. Agent frames
   * will be populated if SSH Agent forwarding is enabled for the connection. SSH frames contain
   * raw SSH payload to be processed by an x/crypto/ssh.Client or x/crypto/ssh.Server.
   *
   * @generated from rpc teleport.transport.v1.TransportService.ProxySSH
   */
  proxySSH: {
    methodKind: "bidi_streaming";
    input: typeof ProxySSHRequestSchema;
    output: typeof ProxySSHResponseSchema;
  },
  /**
   * ProxyCluster establishes a connection to the target cluster.
   *
   * The client must first send a ProxyClusterRequest with the desired cluster name before the
   * connection is established. After which the connection can be used to construct a new
   * auth.Client to the tunneled cluster.
   *
   * @generated from rpc teleport.transport.v1.TransportService.ProxyCluster
   */
  proxyCluster: {
    methodKind: "bidi_streaming";
    input: typeof ProxyClusterRequestSchema;
    output: typeof ProxyClusterResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_teleport_transport_v1_transport_service, 0);

