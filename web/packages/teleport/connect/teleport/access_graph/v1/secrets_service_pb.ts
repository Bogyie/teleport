// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/access_graph/v1/secrets_service.proto (package teleport.access_graph.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { AuthorizedKey } from "./authorized_key_pb";
import { file_teleport_access_graph_v1_authorized_key } from "./authorized_key_pb";
import type { PrivateKey } from "./private_key_pb";
import { file_teleport_access_graph_v1_private_key } from "./private_key_pb";
import type { AssertDeviceRequest, AssertDeviceResponse } from "../../devicetrust/v1/assert_pb";
import { file_teleport_devicetrust_v1_assert } from "../../devicetrust/v1/assert_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/access_graph/v1/secrets_service.proto.
 */
export const file_teleport_access_graph_v1_secrets_service: GenFile = /*@__PURE__*/
  fileDesc("Ci50ZWxlcG9ydC9hY2Nlc3NfZ3JhcGgvdjEvc2VjcmV0c19zZXJ2aWNlLnByb3RvEhh0ZWxlcG9ydC5hY2Nlc3NfZ3JhcGgudjEikAEKG1JlcG9ydEF1dGhvcml6ZWRLZXlzUmVxdWVzdBI1CgRrZXlzGAEgAygLMicudGVsZXBvcnQuYWNjZXNzX2dyYXBoLnYxLkF1dGhvcml6ZWRLZXkSOgoJb3BlcmF0aW9uGAIgASgOMicudGVsZXBvcnQuYWNjZXNzX2dyYXBoLnYxLk9wZXJhdGlvblR5cGUiHgocUmVwb3J0QXV0aG9yaXplZEtleXNSZXNwb25zZSKwAQoUUmVwb3J0U2VjcmV0c1JlcXVlc3QSSAoQZGV2aWNlX2Fzc2VydGlvbhgBIAEoCzIsLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkFzc2VydERldmljZVJlcXVlc3RIABJDCgxwcml2YXRlX2tleXMYBCABKAsyKy50ZWxlcG9ydC5hY2Nlc3NfZ3JhcGgudjEuUmVwb3J0UHJpdmF0ZUtleXNIAEIJCgdwYXlsb2FkIkcKEVJlcG9ydFByaXZhdGVLZXlzEjIKBGtleXMYASADKAsyJC50ZWxlcG9ydC5hY2Nlc3NfZ3JhcGgudjEuUHJpdmF0ZUtleSJtChVSZXBvcnRTZWNyZXRzUmVzcG9uc2USSQoQZGV2aWNlX2Fzc2VydGlvbhgBIAEoCzItLnRlbGVwb3J0LmRldmljZXRydXN0LnYxLkFzc2VydERldmljZVJlc3BvbnNlSABCCQoHcGF5bG9hZCpgCg1PcGVyYXRpb25UeXBlEh4KGk9QRVJBVElPTl9UWVBFX1VOU1BFQ0lGSUVEEAASFgoST1BFUkFUSU9OX1RZUEVfQUREEAESFwoTT1BFUkFUSU9OX1RZUEVfU1lOQxACMp0CChVTZWNyZXRzU2Nhbm5lclNlcnZpY2USiwEKFFJlcG9ydEF1dGhvcml6ZWRLZXlzEjUudGVsZXBvcnQuYWNjZXNzX2dyYXBoLnYxLlJlcG9ydEF1dGhvcml6ZWRLZXlzUmVxdWVzdBo2LnRlbGVwb3J0LmFjY2Vzc19ncmFwaC52MS5SZXBvcnRBdXRob3JpemVkS2V5c1Jlc3BvbnNlIgAoATABEnYKDVJlcG9ydFNlY3JldHMSLi50ZWxlcG9ydC5hY2Nlc3NfZ3JhcGgudjEuUmVwb3J0U2VjcmV0c1JlcXVlc3QaLy50ZWxlcG9ydC5hY2Nlc3NfZ3JhcGgudjEuUmVwb3J0U2VjcmV0c1Jlc3BvbnNlIgAoATABQlpaWGdpdGh1Yi5jb20vZ3Jhdml0YXRpb25hbC90ZWxlcG9ydC9hcGkvZ2VuL3Byb3RvL2dvL3RlbGVwb3J0L2FjY2Vzc2dyYXBoL3YxO2FjY2Vzc2dyYXBodjFiBnByb3RvMw", [file_teleport_access_graph_v1_authorized_key, file_teleport_access_graph_v1_private_key, file_teleport_devicetrust_v1_assert]);

/**
 * ReportAuthorizedKeysRequest is used by Teleport nodes to report authorized keys
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportAuthorizedKeysRequest
 */
export type ReportAuthorizedKeysRequest = Message<"teleport.access_graph.v1.ReportAuthorizedKeysRequest"> & {
  /**
   * keys is a list of authorized keys that could be used to bypass Teleport.
   *
   * @generated from field: repeated teleport.access_graph.v1.AuthorizedKey keys = 1;
   */
  keys: AuthorizedKey[];

  /**
   * operation indicates the operation that the client wants to perform.
   *
   * @generated from field: teleport.access_graph.v1.OperationType operation = 2;
   */
  operation: OperationType;
};

/**
 * Describes the message teleport.access_graph.v1.ReportAuthorizedKeysRequest.
 * Use `create(ReportAuthorizedKeysRequestSchema)` to create a new message.
 */
export const ReportAuthorizedKeysRequestSchema: GenMessage<ReportAuthorizedKeysRequest> = /*@__PURE__*/
  messageDesc(file_teleport_access_graph_v1_secrets_service, 0);

/**
 * ReportAuthorizedKeysResponse is the response from ReportAuthorizedKeys
 * RPC method.
 *
 * @generated from message teleport.access_graph.v1.ReportAuthorizedKeysResponse
 */
export type ReportAuthorizedKeysResponse = Message<"teleport.access_graph.v1.ReportAuthorizedKeysResponse"> & {
};

/**
 * Describes the message teleport.access_graph.v1.ReportAuthorizedKeysResponse.
 * Use `create(ReportAuthorizedKeysResponseSchema)` to create a new message.
 */
export const ReportAuthorizedKeysResponseSchema: GenMessage<ReportAuthorizedKeysResponse> = /*@__PURE__*/
  messageDesc(file_teleport_access_graph_v1_secrets_service, 1);

/**
 * ReportSecretsRequest is used by trusted devices to report secrets found on the host
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportSecretsRequest
 */
export type ReportSecretsRequest = Message<"teleport.access_graph.v1.ReportSecretsRequest"> & {
  /**
   * @generated from oneof teleport.access_graph.v1.ReportSecretsRequest.payload
   */
  payload: {
    /**
     * The device should initiate the device assertion ceremony by sending the
     * AssertDeviceRequest. Please refer to the [teleport.devicetrust.v1.AssertDeviceRequest]
     * message for more details.
     *
     * @generated from field: teleport.devicetrust.v1.AssertDeviceRequest device_assertion = 1;
     */
    value: AssertDeviceRequest;
    case: "deviceAssertion";
  } | {
    /**
     * private_keys is a list of private keys that were found on the device.
     *
     * @generated from field: teleport.access_graph.v1.ReportPrivateKeys private_keys = 4;
     */
    value: ReportPrivateKeys;
    case: "privateKeys";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.access_graph.v1.ReportSecretsRequest.
 * Use `create(ReportSecretsRequestSchema)` to create a new message.
 */
export const ReportSecretsRequestSchema: GenMessage<ReportSecretsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_access_graph_v1_secrets_service, 2);

/**
 * ReportPrivateKeys is used by trusted devices to report private keys found on the host
 * that could be used to bypass Teleport.
 *
 * @generated from message teleport.access_graph.v1.ReportPrivateKeys
 */
export type ReportPrivateKeys = Message<"teleport.access_graph.v1.ReportPrivateKeys"> & {
  /**
   * keys is a list of private keys that could be used to bypass Teleport.
   *
   * @generated from field: repeated teleport.access_graph.v1.PrivateKey keys = 1;
   */
  keys: PrivateKey[];
};

/**
 * Describes the message teleport.access_graph.v1.ReportPrivateKeys.
 * Use `create(ReportPrivateKeysSchema)` to create a new message.
 */
export const ReportPrivateKeysSchema: GenMessage<ReportPrivateKeys> = /*@__PURE__*/
  messageDesc(file_teleport_access_graph_v1_secrets_service, 3);

/**
 * ReportSecretsResponse is the response from the ReportSecrets
 * RPC method.
 *
 * @generated from message teleport.access_graph.v1.ReportSecretsResponse
 */
export type ReportSecretsResponse = Message<"teleport.access_graph.v1.ReportSecretsResponse"> & {
  /**
   * @generated from oneof teleport.access_graph.v1.ReportSecretsResponse.payload
   */
  payload: {
    /**
     * device_assertion is the response from the device assertion ceremony.
     * Please refer to the [teleport.devicetrust.v1.AssertDeviceResponse]
     * message for more details
     *
     * @generated from field: teleport.devicetrust.v1.AssertDeviceResponse device_assertion = 1;
     */
    value: AssertDeviceResponse;
    case: "deviceAssertion";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message teleport.access_graph.v1.ReportSecretsResponse.
 * Use `create(ReportSecretsResponseSchema)` to create a new message.
 */
export const ReportSecretsResponseSchema: GenMessage<ReportSecretsResponse> = /*@__PURE__*/
  messageDesc(file_teleport_access_graph_v1_secrets_service, 4);

/**
 * OperationType is an enum that indicates the operation that the client wants to perform.
 *
 * @generated from enum teleport.access_graph.v1.OperationType
 */
export enum OperationType {
  /**
   * OPERATION_TYPE_UNSPECIFIED is an unknown operation.
   *
   * @generated from enum value: OPERATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * OPERATION_TYPE_ADD is an operation that indicates that the client wants to add keys to the list.
   *
   * @generated from enum value: OPERATION_TYPE_ADD = 1;
   */
  ADD = 1,

  /**
   * OPERATION_TYPE_SYNC is an operation that indicates that the client has sent all the keys and
   * the server can proceed with the analysis.
   *
   * @generated from enum value: OPERATION_TYPE_SYNC = 2;
   */
  SYNC = 2,
}

/**
 * Describes the enum teleport.access_graph.v1.OperationType.
 */
export const OperationTypeSchema: GenEnum<OperationType> = /*@__PURE__*/
  enumDesc(file_teleport_access_graph_v1_secrets_service, 0);

/**
 * SecretsScannerService provides methods for Access Graph Secret Scanner functionality.
 *
 * @generated from service teleport.access_graph.v1.SecretsScannerService
 */
export const SecretsScannerService: GenService<{
  /**
   * ReportAuthorizedKeys is used by Teleport SSH nodes to report authorized keys
   * that could be used to bypass Teleport.
   * The client (Teleport SSH Node) should authenticate using the certificate-key pair signed by Teleport HostCA.
   *
   * @generated from rpc teleport.access_graph.v1.SecretsScannerService.ReportAuthorizedKeys
   */
  reportAuthorizedKeys: {
    methodKind: "bidi_streaming";
    input: typeof ReportAuthorizedKeysRequestSchema;
    output: typeof ReportAuthorizedKeysResponseSchema;
  },
  /**
   * ReportSecrets is used by trusted devices to report secrets found on the host that could be used to bypass Teleport.
   * The client (device) should first authenticate using the [ReportSecretsRequest.device_assertion] flow. Please refer to
   * the [teleport.devicetrust.v1.AssertDeviceRequest] and [teleport.devicetrust.v1.AssertDeviceResponse] messages for more details.
   *
   * Once the device is asserted, the client can send the secrets using the [ReportSecretsRequest.private_keys] field
   * and then close the client side of the stream.
   *
   * -> ReportSecrets (client) [1 or more]
   * -> CloseStream (client)
   * <- TerminateStream (server)
   *
   * Any failure in the assertion ceremony will result in the stream being terminated by the server. All secrets
   * reported by the client before the assertion terminates will be ignored and result in the stream being terminated.
   *
   * @generated from rpc teleport.access_graph.v1.SecretsScannerService.ReportSecrets
   */
  reportSecrets: {
    methodKind: "bidi_streaming";
    input: typeof ReportSecretsRequestSchema;
    output: typeof ReportSecretsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_teleport_access_graph_v1_secrets_service, 0);

