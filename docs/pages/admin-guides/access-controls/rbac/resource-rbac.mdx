
---
title: Getting Started With Per-Resource Role-Based Access Control
description: Implementing fine-grained access control with RBAC.
---


## What is per-resource RBAC?

This granular approach allows you to grant more precise management of user permissions.

Unlike broader, traditional role-based permissions, which can apply to all resources within a namespace or across an entire infrastructure, per-resource RBAC enables administrators to control user access on a per-resource basis. 
This feature is especially valuable in complex environments with diverse user groups, where some users need restricted access to sensitive systems while others may require broad access.

## Use cases

### Multi-tenant environments

In a multi-tenant setup, per-resource RBAC can ensure that each client or team has access only to their specific resources, preventing any accidental or intentional cross-tenant access.

### Compliance requirements
For industries with strict regulatory requirements (e.g., finance, healthcare), per-resource RBAC helps in implementing and demonstrating compliance with access control policies.

### Team management
For new team members or roles, per-resource RBAC facilitates a gradual increase in access privileges as users become more familiar with the systems and demonstrate need and competence.
When working with external contractors, per-resource RBAC allows granting temporary, limited access to specific resources without exposing the entire infrastructure.

### DevOps workflows
In CI/CD pipelines, different stages may require different levels of access; per-resource RBAC can be used to grant just-in-time access for specific tasks in the pipeline.

Let's look at some examples of how per-resource RBAC can be implemented:

**SSH access control**

```code
kind: role
version: v3
metadata:
 name: dev-team
spec:
 allow:
    logins: ['ubuntu']
    node_labels:
      environment: ['dev', 'staging']
    rules:
      - resources: ['session']
        verbs: ['read', 'list']
```

This role allows members of the dev team to SSH into nodes labeled as 'dev' or 'staging' environments, using the 'ubuntu' user account. 
They can also read and list session information.

**Kubernetes access control**

```code
kind: role
version: v3
metadata:
  name: k8s-dev
spec:
  allow:
    kubernetes_groups: ['system:developers']
    kubernetes_resources:
      - kind: pod
        namespace: 'dev-*'
        verbs: ['get', 'list', 'create', 'update', 'delete']
      - kind: service
        namespace: 'dev-*'
        verbs: ['get', 'list']
```

This role grants developers access to manage pods in any namespace starting with 'dev-', while only allowing them to view services in those namespaces.

**Database access control**

```code
kind: role
version: v3
metadata:
  name: db-readonly
spec:
  allow:
    db_labels:
      environment: ['production']
      type: ['postgres']
    db_names: ['analytics', 'reporting']
    db_users: ['readonly']
```

This role provides read-only access to production PostgreSQL databases named 'analytics' and 'reporting' using the 'readonly' database user.


## Best practices

- **Regular audits**: 
Periodically review and update RBAC policies to ensure they align with current organizational needs and security best practices.

- **Principle of Least Privilege**: 
Always start with minimal access and gradually increase permissions as needed.

- **Integration with identity providers (IdPs) like Okta and AWS OIDC**:
Leverage existing identity management systems to streamline user management and access control.

- **Monitoring and alerting**:
Set up comprehensive logging and alerting for access events, especially for sensitive resources.

- **User education**:
Ensure that all users understand their access levels and the importance of adhering to security policies.