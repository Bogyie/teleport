// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package teleport.kubeprovision.v1;

import "teleport/header/v1/metadata.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/kubeprovision/v1;kubeprovisionv1";

// KubeProvision represents a Kubernetes resources that can be provisioned on the Kubernetes clusters.
// This includes roles/role bindings and cluster roles/cluster role bindings.
// For rationale behind this type, see the RFD 174.
message KubeProvision {
  // Kind of resource represented.
  string kind = 1;
  // SubKind is not populated for this resource type.
  string sub_kind = 2;
  // Version of the resource being represented.
  string version = 3;
  // Metadata is common metadata that all resources share.
  teleport.header.v1.Metadata metadata = 4;
  // Spec determines the specific properties of kube provision.
  KubeProvisionSpec spec = 5;
}

// KubeProvisionSpec is the spec for the kube provision message.
message KubeProvisionSpec {
  // ClusterRoles is a list of Kubernetes ClusterRoles resources to provision.
  repeated ClusterRole cluster_roles = 1;

  // ClusterRolesBinding is a list of Kubernetes ClusterRoleBinding resources to provision.
  repeated ClusterRoleBinding cluster_role_bindings = 2;

  // Roles is a list of Kubernetes Role resources to provision.
  repeated Role roles = 3;

  // RoleBindings is a list of Kubernetes RoleBinding resources to provision.
  repeated RoleBinding role_bindings = 4;
}

// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
message ClusterRole {
  // Metadata is standard object's metadata.
  KubeObjectMeta metadata = 1;

  // Rules holds all the PolicyRules for this ClusterRole
  repeated PolicyRule rules = 2;

  // AggregationRule describes how to build the Rules for this ClusterRole.
  // If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be
  // stomped by the controller.
  AggregationRule aggregation_rule = 3;
}

// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,
// and adds who information via Subject.
message ClusterRoleBinding {
  // Metadata is standard object's metadata.
  KubeObjectMeta metadata = 1;

  // Subjects holds references to the objects the role applies to.
  repeated Subject subjects = 2;

  // RoleRef references a ClusterRole in the global namespace.
  RoleRef role_ref = 3;
}

// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
message Role {
  // Metadata is standard object's metadata.
  KubeObjectMeta metadata = 1;

  // Rules holds all the PolicyRules for this Role
  repeated PolicyRule rules = 2;
}

// RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
// It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given
// namespace only have effect in that namespace.
message RoleBinding {
  // Metadata is standard object's metadata.
  KubeObjectMeta metadata = 1;

  // Subjects holds references to the objects the role applies to.
  repeated Subject subjects = 2;

  // RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
  RoleRef role_ref = 3;
}

// KubeObjectMeta is metadata for Kubernetes RBAC resources.
message KubeObjectMeta {
  // Name is a unique resource name within a namespace.
  string name = 1;

  // Labels are a map of string keys and values that can be used to organize and categorize
  // (scope and select) objects.
  map<string, string> labels = 2;

  // Namespace defines the space within which each name must be unique.
  string namespace = 3;

  // Annotations is an unstructured key value map stored with a resource that may be
  // set by external tools to store and retrieve arbitrary metadata.
  map<string, string> annotations = 4;
}

// LabelSelector is labels selector.
message LabelSelector {
  // MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
  // map is equivalent to an element of matchExpressions, whose key field is "key", the
  // operator is "In", and the values array contains only "value". The requirements are ANDed.
  map<string, string> match_labels = 1;

  // MatchExpressions is a list of label selector requirements. The requirements are ANDed.
  repeated LabelSelectorRequirement match_expressions = 2;
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
message LabelSelectorRequirement {
  // key is the label key that the selector applies to.
  string key = 1;

  // operator represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists and DoesNotExist.
  string operator = 2;

  // values is an array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty.
  repeated string values = 3;
}

// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
message AggregationRule {
  // ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules.
  // If any of the selectors match, then the ClusterRole's permissions will be added
  repeated LabelSelector cluster_role_selectors = 1;
}

// PolicyRule holds information that describes a policy rule, but does not contain information
// about who the rule applies to or which namespace the rule applies to.
message PolicyRule {
  // Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
  repeated string verbs = 1;

  // APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
  // the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
  repeated string api_groups = 2;

  // Resources is a list of resources this rule applies to. '*' represents all resources.
  repeated string resources = 3;

  // ResourceNames is an optional white list of names that the rule applies to. An empty set means that everything is allowed.
  repeated string resource_names = 4;

  // NonResourceURLs is a set of partial urls that a user should have access to. *s are allowed, but only as the full, final step in the path
  // Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
  // Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"), but not both.
  repeated string non_resource_urls = 5;
}

// RoleRef contains information that points to the role being used
message RoleRef {
  // Kind is the type of resource being referenced
  string kind = 1;

  // APIGroup is the group for the resource being referenced
  string api_group = 2;

  // Name is the name of resource being referenced
  string name = 3;
}

// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
// or a value for non-objects such as user and group names.
message Subject {
  // Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
  string kind = 1;

  // APIGroup holds the API group of the referenced subject.
  string api_group = 2;

  // Name of the object being referenced.
  string name = 3;

  // Namespace of the referenced object.
  string namespace = 4;
}
