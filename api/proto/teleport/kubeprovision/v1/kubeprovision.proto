// Copyright 2024 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package teleport.kubeprovision.v1;

import "teleport/header/v1/metadata.proto";

//import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/kubeprovision/v1;kubeprovisionv1";

// KubeProvision represents a Kubernetes resources that can be provisioned on the Kubernetes clusters.
// This includes roles/role bindings and cluster roles/cluster role bindings.
// For rationale behind this type, see the RFD 174.
message KubeProvision {
  // The kind of resource represented.
  string kind = 1;
  // Not populated for this resource type.
  string sub_kind = 2;
  // The version of the resource being represented.
  string version = 3;
  // Common metadata that all resources share.
  teleport.header.v1.Metadata metadata = 4;
  // The specific properties of kube provision.
  KubeProvisionSpec spec = 5;
}

// KubeProvisionSpec is the spec for the kube provision message.
message KubeProvisionSpec {
  // resources_data is base64 encoded YAML definitions of the Kubernetes resources.
  string resources_data = 1;

  repeated ClusterRole cluster_roles = 2;

  repeated ClusterRoleBinding cluster_role_bindings = 3;

  repeated Role roles = 4;

  repeated RoleBinding role_bindings = 5;
}

// KubeRbacResources is Kubernetes RBAC resources.
message KubeRbacResources {
  repeated ClusterRole cluster_roles = 1;

  repeated ClusterRoleBinding cluster_role_bindings = 2;

  repeated Role roles = 3;

  repeated RoleBinding role_bindings = 4;
}

// KubeRbacMeta is metadata for Kubernetes RBAC resources.
message KubeRbacMeta {
  string kind = 1;

  string api_version = 2;
}

// LabelSelector is labels selector.
message LabelSelector {
  // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
  // map is equivalent to an element of matchExpressions, whose key field is "key", the
  // operator is "In", and the values array contains only "value". The requirements are ANDed.
  // +optional
  map<string, string> match_labels = 1;

  // matchExpressions is a list of label selector requirements. The requirements are ANDed.
  // +optional
  // +listType=atomic
  repeated LabelSelectorRequirement match_expressions = 2;
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
message LabelSelectorRequirement {
  // key is the label key that the selector applies to.
  string key = 1;

  // operator represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists and DoesNotExist.
  string operator = 2;

  // values is an array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. This array is replaced during a strategic
  // merge patch.
  // +optional
  // +listType=atomic
  repeated string values = 3;
}

// AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole
message AggregationRule {
  // ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules.
  // If any of the selectors match, then the ClusterRole's permissions will be added
  // +optional
  // +listType=atomic
  repeated LabelSelector cluster_role_selectors = 1;
}

// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
message ClusterRole {
  string kind = 1;

  string api_version = 2;

  // Standard object's metadata.
  // +optional
  KubeRbacMeta metadata = 3;

  // Rules holds all the PolicyRules for this ClusterRole
  // +optional
  // +listType=atomic
  repeated PolicyRule rules = 4;

  // AggregationRule is an optional field that describes how to build the Rules for this ClusterRole.
  // If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be
  // stomped by the controller.
  // +optional
  AggregationRule aggregation_rule = 5;
}

// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,
// and adds who information via Subject.
message ClusterRoleBinding {
  string kind = 1;

  string api_version = 2;

  // Standard object's metadata.
  // +optional
  KubeRbacMeta metadata = 3;

  // Subjects holds references to the objects the role applies to.
  // +optional
  // +listType=atomic
  repeated Subject subjects = 4;

  // RoleRef can only reference a ClusterRole in the global namespace.
  // If the RoleRef cannot be resolved, the Authorizer must return an error.
  // This field is immutable.
  RoleRef role_ref = 5;
}

// PolicyRule holds information that describes a policy rule, but does not contain information
// about who the rule applies to or which namespace the rule applies to.
message PolicyRule {
  // Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.
  // +listType=atomic
  repeated string verbs = 1;

  // APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
  // the enumerated resources in any API group will be allowed. "" represents the core API group and "*" represents all API groups.
  // +optional
  // +listType=atomic
  repeated string api_groups = 2;

  // Resources is a list of resources this rule applies to. '*' represents all resources.
  // +optional
  // +listType=atomic
  repeated string resources = 3;

  // ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
  // +optional
  // +listType=atomic
  repeated string resource_names = 4;

  // NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
  // Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
  // Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
  // +optional
  // +listType=atomic
  repeated string non_resource_urls = 5;
}

// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
message Role {
  string kind = 1;

  string api_version = 2;

  // Standard object's metadata.
  // +optional
  KubeRbacMeta metadata = 3;

  // Rules holds all the PolicyRules for this Role
  // +optional
  // +listType=atomic
  repeated PolicyRule rules = 4;
}

// RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
// It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given
// namespace only have effect in that namespace.
message RoleBinding {
  string kind = 1;

  string api_version = 2;

  // Standard object's metadata.
  // +optional
  KubeRbacMeta metadata = 3;

  // Subjects holds references to the objects the role applies to.
  // +optional
  // +listType=atomic
  repeated Subject subjects = 4;

  // RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
  // If the RoleRef cannot be resolved, the Authorizer must return an error.
  // This field is immutable.
  RoleRef role_ref = 5;
}

// RoleRef contains information that points to the role being used
// +structType=atomic
message RoleRef {
  // Kind is the type of resource being referenced
  string kind = 1;

  // APIGroup is the group for the resource being referenced
  string api_group = 2;

  // Name is the name of resource being referenced
  string name = 3;
}

// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
// or a value for non-objects such as user and group names.
// +structType=atomic
message Subject {
  // Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
  // If the Authorizer does not recognized the kind value, the Authorizer should report an error.
  string kind = 1;

  // APIGroup holds the API group of the referenced subject.
  // Defaults to "" for ServiceAccount subjects.
  // Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
  // +optional
  string api_group = 2;

  // Name of the object being referenced.
  string name = 3;

  // Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
  // the Authorizer should report an error.
  // +optional
  string namespace = 4;
}
